<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Calculus</title>
    <link href="/2025/02/21/Calculus/"/>
    <url>/2025/02/21/Calculus/</url>
    
    <content type="html"><![CDATA[<h1 id="Calculus"><a href="#Calculus" class="headerlink" title="Calculus"></a>Calculus</h1><p>本篇微积分内容主要回顾一些重要结论的推导证明，全文没有严格上下文关系。</p><blockquote><p>绘图我是实在肝不动了…索性用个草图好了，将个烂就</p></blockquote><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-三角函数"><a href="#1-三角函数" class="headerlink" title="1. 三角函数"></a>1. 三角函数</h2><p>三角函数涉及到三角换元，反函数图像，积化和差公式等等..</p><h3 id="1-1-三角换元"><a href="#1-1-三角换元" class="headerlink" title="1.1 三角换元"></a>1.1 三角换元</h3><ul><li>正割：<br>$$<br>\sec x &#x3D; \frac{1}{\cos x}<br>$$</li><li>余割：</li></ul><p>$$<br>\csc x &#x3D; \frac{1}{\sin x}<br>$$</p><ul><li>常见换元：<br>$$<br>\begin{cases}<br>\sin^2 x + \cos^2 x &#x3D; 1 \\<br>1 + \tan^2 x &#x3D; \sec^2 &#x3D; \frac{1}{\cos^2}<br>\end{cases}<br>$$</li></ul><h3 id="1-2-反三角函数"><a href="#1-2-反三角函数" class="headerlink" title="1.2 反三角函数"></a>1.2 反三角函数</h3><p>这里我觉得认识图像非常重要，当然还有后面的反三角函数求导，这里暂不做讲解。</p><h4 id="1-2-1-反正弦函数（arcsin-x-）"><a href="#1-2-1-反正弦函数（arcsin-x-）" class="headerlink" title="1.2.1 反正弦函数（arcsin(x)）"></a>1.2.1 反正弦函数（arcsin(x)）</h4><p>反正弦函数，记作 $\arcsin(x)$，是正弦函数的反函数。它的定义域为 $[-1, 1]$，值域为 $[-\frac{\pi}{2}, \frac{\pi}{2}]$。即对于任意 $y &#x3D; \arcsin(x)$，有：</p><p>$$<br>\sin(y) &#x3D; x, \quad y \in \left[-\frac{\pi}{2}, \frac{\pi}{2}\right]<br>$$</p><h4 id="1-2-2-反余弦函数（arccos-x-）"><a href="#1-2-2-反余弦函数（arccos-x-）" class="headerlink" title="1.2.2 反余弦函数（arccos(x)）"></a>1.2.2 反余弦函数（arccos(x)）</h4><p>反余弦函数，记作 $\arccos(x)$，是余弦函数的反函数。它的定义域为 $[-1, 1]$，值域为 $[0, \pi]$。即对于任意 $y &#x3D; \arccos(x)$，有：</p><p>$$<br>\cos(y) &#x3D; x, \quad y \in [0, \pi]<br>$$</p><h4 id="1-2-3-反正切函数（arctan-x-）"><a href="#1-2-3-反正切函数（arctan-x-）" class="headerlink" title="1.2.3 反正切函数（arctan(x)）"></a>1.2.3 反正切函数（arctan(x)）</h4><p>反正切函数，记作 $\arctan(x)$，是正切函数的反函数。它的定义域为 $(-\infty, +\infty)$，值域为 $(-\frac{\pi}{2}, \frac{\pi}{2})$。即对于任意 $y &#x3D; \arctan(x)$，有：</p><p>$$<br>\tan(y) &#x3D; x, \quad y \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><img src="/img/Calculus/arcsin.jpg" alt="反三角函数" style="max-width: 100%; height: auto;" /><h3 id="1-3-积化和差公式"><a href="#1-3-积化和差公式" class="headerlink" title="1.3 积化和差公式"></a>1.3 积化和差公式</h3><p>$$<br>\sin(x \pm y) &#x3D; \sin(x)\cos(y) \pm \cos(x)\sin(y)<br>$$</p><p>$$<br>\cos(x \pm y) &#x3D; \cos(x)\cos(y) \mp \sin(x)\sin(y)<br>$$</p><p>$$<br>\tan(x \pm y) &#x3D; \frac{\tan(x) \pm \tan(y)}{1 \mp \tan(x)\tan(y)}<br>$$</p><p>$$<br>\sin(x) \cos(y) &#x3D; \frac{1}{2} \left[ \sin(x + y) + \sin(x - y) \right]<br>$$</p><p>$$<br>\cos(x) \sin(y) &#x3D; \frac{1}{2} \left[ \sin(x + y) - \sin(x - y) \right]<br>$$</p><p>$$<br>\cos(x) \cos(y) &#x3D; \frac{1}{2} \left[ \cos(x + y) + \cos(x - y) \right]<br>$$</p><p>$$<br>\sin(x) \sin(y) &#x3D; \frac{1}{2} \left[ \cos(x - y) - \cos(x + y) \right]<br>$$</p><h3 id="1-4-倍角-半角公式"><a href="#1-4-倍角-半角公式" class="headerlink" title="1.4 倍角&#x2F;半角公式"></a>1.4 倍角&#x2F;半角公式</h3><p>$$<br>\sin(2x) &#x3D; 2 \sin(x) \cos(x)<br>$$</p><p>$$<br>\cos(2x) &#x3D; \cos^2(x) - \sin^2(x) &#x3D; 2\cos^2(x) - 1 &#x3D; 1 - 2\sin^2(x)<br>$$</p><p>$$<br>\tan(2x) &#x3D; \frac{2\tan(x)}{1 - \tan^2(x)}<br>$$</p><p>$$<br>\sin\left(\frac{x}{2}\right) &#x3D; \pm \sqrt{\frac{1 - \cos(x)}{2}}<br>$$</p><p>$$<br>\cos\left(\frac{x}{2}\right) &#x3D; \pm \sqrt{\frac{1 + \cos(x)}{2}}<br>$$</p><p>$$<br>\tan\left(\frac{x}{2}\right) &#x3D; \pm \sqrt{\frac{1 - \cos(x)}{1 + \cos(x)}} &#x3D; \frac{\sin(x)}{1 + \cos(x)} &#x3D; \frac{1 - \cos(x)}{\sin(x)}<br>$$</p><h3 id="1-5-万能公式"><a href="#1-5-万能公式" class="headerlink" title="1.5 万能公式"></a>1.5 万能公式</h3><p>设 $u &#x3D; \tan\left(\frac{x}{2}\right)$，则有：<br>$$<br>\sin x &#x3D; \frac{2u}{1 + u^2}, \quad x \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><p>$$<br>\cos x &#x3D; \frac{1 - u^2}{1 + u^2}, \quad x \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><p>$$<br>\tan x &#x3D; \frac{2u}{1 - u^2}, \quad x \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><h2 id="2-一元二次方程"><a href="#2-一元二次方程" class="headerlink" title="2. 一元二次方程"></a>2. 一元二次方程</h2><p>一元二次方程的标准形式是：</p><p>$$<br>ax^2 + bx + c &#x3D; 0<br>$$</p><p>其中，$a$、$b$ 和 $c$ 是常数，且 $a \neq 0$。</p><p>一元二次方程的解的存在与否可以通过判别式 $\Delta$ 来判断，判别式的表达式是：</p><p>$$<br>\Delta &#x3D; b^2 - 4ac<br>$$</p><p>根据 $\Delta$ 的值，可以判断方程的解的情况：</p><ul><li>如果 $\Delta &gt; 0$，方程有 <strong>两个不相等的实数解</strong>。</li><li>如果 $\Delta &#x3D; 0$，方程有 <strong>一个实数解</strong>，也叫做 <strong>重根</strong>。</li><li>如果 $\Delta &lt; 0$，方程没有实数解，只有 <strong>两个共轭复数解</strong>。</li></ul><p>根据判别式 $\Delta$，方程的解可以通过求根公式来表示：</p><p>$$<br>x &#x3D; \frac{-b \pm \sqrt{\Delta}}{2a}<br>$$</p><p>其中，“$\pm$”表示可以有两个解，分别是：</p><p>$$<br>x_1 &#x3D; \frac{-b + \sqrt{\Delta}}{2a}, \quad x_2 &#x3D; \frac{-b - \sqrt{\Delta}}{2a}<br>$$</p><ol><li>$\Delta &#x3D; b^2 - 4ac$ 是判别式，它决定了方程解的个数和类型。</li><li>根据 $\Delta$ 的值，分别有不同的解的情况。</li></ol><h2 id="3-等差-等比数列"><a href="#3-等差-等比数列" class="headerlink" title="3. 等差&#x2F;等比数列"></a>3. 等差&#x2F;等比数列</h2><h3 id="3-1-等差数列的相关公式"><a href="#3-1-等差数列的相关公式" class="headerlink" title="3.1 等差数列的相关公式"></a>3.1 等差数列的相关公式</h3><p>等差数列是指每一项与前一项的差都相等的数列，常常用符号 $a_n$ 表示。</p><p>假设等差数列的首项为 $a_1$，公差为 $d$，则该数列的第 $n$ 项可以表示为：</p><p>$$<br>a_n &#x3D; a_1 + (n - 1) d<br>$$</p><p><strong>求和公式：</strong> 等差数列前 $n$ 项的和可以通过以下公式计算：</p><p>$$<br>S_n &#x3D; \frac{n}{2} \left(2a_1 + (n - 1) d \right)<br>$$</p><p>或者</p><p>$$<br>S_n &#x3D; \frac{n}{2} \left(a_1 + a_n \right)<br>$$</p><p>其中，$a_n$ 是数列的第 $n$ 项。</p><p><strong>总结：</strong></p><ol><li>等差数列的第 $n$ 项公式：$a_n &#x3D; a_1 + (n - 1)d$</li><li>等差数列前 $n$ 项的和公式：$S_n &#x3D; \frac{n}{2} \left(2a_1 + (n - 1) d \right)$ 或者 $S_n &#x3D; \frac{n}{2} \left(a_1 + a_n \right)$</li></ol><hr><h3 id="3-2-等比数列的相关公式"><a href="#3-2-等比数列的相关公式" class="headerlink" title="3.2 等比数列的相关公式"></a>3.2 等比数列的相关公式</h3><p>等比数列是指每一项与前一项的比都相等的数列，常常用符号 $b_n$ 表示。</p><p>假设等比数列的首项为 $b_1$，公比为 $r$，则该数列的第 $n$ 项可以表示为：</p><p>$$<br>b_n &#x3D; b_1 r^{n-1}<br>$$</p><p><strong>求和公式：</strong> 等比数列前 $n$ 项的和可以通过以下公式计算：</p><ul><li>当 $r \neq 1$ 时，前 $n$ 项的和为：</li></ul><p>$$<br>S_n &#x3D; \frac{b_1 (1 - r^n)}{1 - r}<br>$$</p><ul><li>当 $r &#x3D; 1$ 时，前 $n$ 项的和为：</li></ul><p>$$<br>S_n &#x3D; n \cdot b_1<br>$$</p><p><strong>总结：</strong></p><ol><li>等比数列的第 $n$ 项公式：$b_n &#x3D; b_1 r^{n-1}$</li><li>等比数列前 $n$ 项的和公式（当 $r \neq 1$）：$S_n &#x3D; \frac{b_1 (1 - r^n)}{1 - r}$</li><li>等比数列前 $n$ 项的和公式（当 $r &#x3D; 1$）：$S_n &#x3D; n \cdot b_1$</li></ol><h2 id="4-二项定理-组合数"><a href="#4-二项定理-组合数" class="headerlink" title="4. 二项定理&#x2F;组合数"></a>4. 二项定理&#x2F;组合数</h2><p><strong>二项式定理</strong>是用于展开 $(a + b)^n$ 的一个公式，它可以表示为：</p><p>$$<br>(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k<br>$$</p><p>其中，$\binom{n}{k}$ 是 <strong>组合数</strong>，表示从 $n$ 个不同的元素中选取 $k$ 个元素的方式数。它的公式为：</p><p>$$<br>\binom{n}{k} &#x3D; \frac{n!}{k!(n-k)!}<br>$$</p><p><strong>组合数的性质：</strong></p><ol><li><strong>对称性：</strong></li></ol><p>$$<br>\binom{n}{k} &#x3D; \binom{n}{n-k}<br>$$</p><ol start="2"><li><strong>递推公式：</strong></li></ol><p>$$<br>\binom{n}{k} &#x3D; \binom{n-1}{k-1} + \binom{n-1}{k}<br>$$</p><ol start="3"><li><strong>边界条件：</strong></li></ol><p>$$<br>\binom{n}{0} &#x3D; 1, \quad \binom{n}{n} &#x3D; 1<br>$$</p><ol start="4"><li><strong>与阶乘的关系：</strong></li></ol><p>$$<br>\binom{n}{k} &#x3D; \frac{n!}{k!(n-k)!}<br>$$</p><p><strong>二项式展开公式的应用：</strong><br>二项式定理展开式中的每一项 $\binom{n}{k} a^{n-k} b^k$ 表示的是 $(a + b)^n$ 展开后的第 $k$ 项，其中 $\binom{n}{k}$ 是对应的组合数，它可以用来计算每一项的系数。</p><p><strong>总结：</strong></p><ul><li>二项式定理展开式：$(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k$</li><li>组合数公式：$\binom{n}{k} &#x3D; \frac{n!}{k!(n-k)!}$</li><li>组合数的一些性质：<ul><li>$\binom{n}{k} &#x3D; \binom{n}{n-k}$</li><li>$\binom{n}{k} &#x3D; \binom{n-1}{k-1} + \binom{n-1}{k}$</li><li>$\binom{n}{0} &#x3D; 1, \quad \binom{n}{n} &#x3D; 1$</li></ul></li></ul><hr><h3 id="4-1-二项定理的证明"><a href="#4-1-二项定理的证明" class="headerlink" title="4.1 二项定理的证明"></a>4.1 二项定理的证明</h3><p>二项式定理的证明可以通过<strong>数学归纳法</strong>来进行，下面是详细的证明过程：</p><p><strong>基本步骤：</strong><br>我们希望证明对于任意自然数 $n$，都有：</p><p>$$<br>(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k<br>$$</p><p>其中，$\binom{n}{k}$ 是组合数，表示从 $n$ 个元素中选出 $k$ 个元素的方法数。</p><p>1.<strong>归纳基础：</strong> $n &#x3D; 0$<br>首先，我们验证当 $n &#x3D; 0$ 时，公式是否成立：</p><p>对于 $n &#x3D; 0$：</p><p>$$<br>(a + b)^0 &#x3D; 1<br>$$</p><p>而右边的展开式为：</p><p>$$<br>\sum_{k&#x3D;0}^{0} \binom{0}{k} a^{0-k} b^k &#x3D; \binom{0}{0} a^0 b^0 &#x3D; 1<br>$$</p><p>显然，当 $n &#x3D; 0$ 时，公式成立。</p><p>2.<strong>归纳假设：</strong> 假设对于 $n &#x3D; k$ 时成立<br>假设对于某个自然数 $k$，我们有：</p><p>$$<br>(a + b)^k &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i<br>$$</p><p>我们现在需要证明对于 $n &#x3D; k+1$ 时，公式也成立。</p><p>3.<strong>归纳步骤：</strong> 证明 $n &#x3D; k+1$ 时公式成立<br>考虑 $(a + b)^{k+1}$，我们可以将其分解为：</p><p>$$<br>(a + b)^{k+1} &#x3D; (a + b)(a + b)^k<br>$$</p><p>根据归纳假设，$(a + b)^k$ 可以展开为：</p><p>$$<br>(a + b)^{k+1} &#x3D; (a + b) \left( \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i \right)<br>$$</p><p>接下来，展开右边的乘积：</p><p>$$<br>(a + b) \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i &#x3D; a \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i + b \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i<br>$$</p><p>将每项展开：</p><ol><li>第一项是：</li></ol><p>$$<br>a \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k+1-i} b^i<br>$$</p><ol start="2"><li>第二项是：</li></ol><p>$$<br>b \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^{i+1}<br>$$</p><p>为了便于合并，我们将第二个求和的指标进行变换。令 $j &#x3D; i+1$，则 $i &#x3D; j-1$，且当 $i$ 从 $0$ 到 $k$ 变化时，$j$ 从 $1$ 到 $k+1$ 变化。因此：</p><p>$$<br>\sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^{i+1} &#x3D; \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k-(j-1)} b^j &#x3D; \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k+1-j} b^j<br>$$</p><p>现在我们可以改写为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k+1-i} b^i + \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k+1-j} b^j<br>$$</p><p>为了合并这两个和式，我们将第一个和式的指标也改为 $j$。对于第一个和式，当 $i &#x3D; j$，范围从 $0$ 到 $k$：</p><p>$$<br>(a + b)^{k+1} &#x3D; \sum_{j&#x3D;0}^{k} \binom{k}{j} a^{k+1-j} b^j + \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k+1-j} b^j<br>$$</p><p>注意到：</p><ol><li>在 $j&#x3D;0$ 时，只有第一个和式有贡献，为 $\binom{k}{0}a^{k+1}b^0 &#x3D; a^{k+1}$</li><li>在 $j&#x3D;k+1$ 时，只有第二个和式有贡献，为 $\binom{k}{k}a^0b^{k+1} &#x3D; b^{k+1}$</li><li>对于 $1 \leq j \leq k$，两个和式都有贡献</li></ol><p>因此，我们可以将其重写为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \binom{k}{0}a^{k+1} + \sum_{j&#x3D;1}^{k} \left( \binom{k}{j} + \binom{k}{j-1} \right) a^{k+1-j} b^j + \binom{k}{k}b^{k+1}<br>$$</p><p>根据组合数的<strong>递推关系</strong>(关键结论)：$\binom{k+1}{j} &#x3D; \binom{k}{j-1} + \binom{k}{j}$，上式可以写为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \binom{k+1}{0}a^{k+1} + \sum_{j&#x3D;1}^{k} \binom{k+1}{j} a^{k+1-j} b^j + \binom{k+1}{k+1}b^{k+1}<br>$$</p><p>这可以进一步简化为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \sum_{j&#x3D;0}^{k+1} \binom{k+1}{j} a^{k+1-j} b^j<br>$$</p><p>这正是我们需要的展开式，因此，二项式定理对于 $n &#x3D; k+1$ 也成立。</p><p>4.<strong>结论</strong><br>由归纳法可知，二项式定理对所有自然数 $n$ 都成立：</p><p>$$<br>(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k<br>$$</p><h2 id="5-常见等价无穷小"><a href="#5-常见等价无穷小" class="headerlink" title="5. 常见等价无穷小"></a>5. 常见等价无穷小</h2><p>在 $x \to 0$时，以下等价无穷小成立：</p><h3 id="5-1-基本等价无穷小"><a href="#5-1-基本等价无穷小" class="headerlink" title="5.1. 基本等价无穷小"></a>5.1. 基本等价无穷小</h3><p>$$ \sin x \sim x $$</p><p>$$ \tan x \sim x $$</p><p>$$ \arcsin x \sim x $$</p><p>$$ \arctan x \sim x $$</p><p>$$ 1 - \cos x \sim \frac{x^2}{2} $$</p><p>$$ x - \sin x \sim \frac{x^3}{6} $$</p><p>$$ e^x - 1 \sim x $$</p><p>$$ \ln(1 + x) \sim x $$</p><h3 id="5-2-组合与扩展"><a href="#5-2-组合与扩展" class="headerlink" title="5.2. 组合与扩展"></a>5.2. 组合与扩展</h3><p>$$ \ln(1 - x) \sim -x $$</p><p>$$ a^x - 1 \sim x \ln a \quad (a &gt; 0, a \neq 1) $$</p><p>$$ (1 + x)^a - 1 \sim ax \quad (a \text{ 为常数}) $$</p><h3 id="5-3-其他常见形式"><a href="#5-3-其他常见形式" class="headerlink" title="5.3. 其他常见形式"></a>5.3. 其他常见形式</h3><p>$$ \sqrt{1 + x} - 1 \sim \frac{x}{2} $$</p><p>$$ \frac{1}{1 + x} \sim 1 - x $$</p><h2 id="6-常见重要极限"><a href="#6-常见重要极限" class="headerlink" title="6. 常见重要极限"></a>6. 常见重要极限</h2><p>在 $x \to 0$ 时，以下极限成立：</p><h3 id="6-1-经典初等极限"><a href="#6-1-经典初等极限" class="headerlink" title="6.1. 经典初等极限"></a>6.1. 经典初等极限</h3><p>$$ \lim\limits_{x \to 0} \frac{\sin x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\tan x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\arcsin x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\arctan x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{1 - \cos x}{x^2} &#x3D; \frac{1}{2} $$</p><h3 id="6-2-指数与对数相关极限"><a href="#6-2-指数与对数相关极限" class="headerlink" title="6.2. 指数与对数相关极限"></a>6.2. 指数与对数相关极限</h3><p>$$ \lim\limits_{x \to 0} \frac{e^x - 1}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\ln(1 + x)}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\ln(1 - x)}{x} &#x3D; -1 $$</p><p>$$ \lim\limits_{x \to \infty} \left( 1 + \frac{1}{x} \right)^x &#x3D; e $$</p><p>$$ \lim\limits_{x \to 0} (1 + x)^{\frac{1}{x}} &#x3D; e $$</p><h3 id="6-3-重要无穷小极限"><a href="#6-3-重要无穷小极限" class="headerlink" title="6.3. 重要无穷小极限"></a>6.3. 重要无穷小极限</h3><p>$$ \lim\limits_{x \to 0} \frac{x - \sin x}{x^3} &#x3D; \frac{1}{6} $$</p><p>$$ \lim\limits_{x \to 0} \frac{\tan x - x}{x^3} &#x3D; \frac{1}{3} $$</p><p>$$ \lim\limits_{x \to 0} \frac{e^x - 1 - x}{x^2} &#x3D; \frac{1}{2} $$</p><p>$$ \lim\limits_{x \to 0} \frac{\ln(1 + x) - x}{x^2} &#x3D; -\frac{1}{2} $$</p><h3 id="6-4-其他重要极限"><a href="#6-4-其他重要极限" class="headerlink" title="6.4. 其他重要极限"></a>6.4. 其他重要极限</h3><p>$$ \lim\limits_{x \to 0} \left( 1 + x \right)^{\frac{1}{x}} &#x3D; e $$</p><p>$$ \lim\limits_{n \to \infty} \left( 1 + \frac{k}{n} \right)^n &#x3D; e^k, \quad k \text{ 为常数} $$</p><p>$$ \lim\limits_{x \to 0} \frac{a^x - 1}{x} &#x3D; \ln a, \quad (a &gt; 0, a \neq 1) $$</p><h2 id="7-函数连续性"><a href="#7-函数连续性" class="headerlink" title="7. 函数连续性"></a>7. 函数连续性</h2><h3 id="7-1-极限存在"><a href="#7-1-极限存在" class="headerlink" title="7.1. 极限存在"></a>7.1. 极限存在</h3><p>$$ \lim\limits_{x \to a} f(x) &#x3D; L $$</p><p>极限存在是后续所有概念的基础。当函数 $f(x)$ 在点 $a$ 的邻域内有定义，且当 $x$ 无限接近 $a$ 时，函数值能够无限接近某个确定的常数 $L$，我们称该极限存在。</p><p>极限存在的条件：</p><ul><li>左极限和右极限相等</li><li>极限值不依赖于函数在 $a$ 点的具体定义</li><li>可以通过 $\epsilon-\delta$ 语言严格定义</li></ul><h3 id="7-2-连续"><a href="#7-2-连续" class="headerlink" title="7.2. 连续"></a>7.2. 连续</h3><p>$$ \lim\limits_{x \to a} f(x) &#x3D; f(a) $$</p><p>连续是对极限的进一步要求：</p><ul><li>函数在点 $a$ 处有定义</li><li>极限存在</li><li>极限值等于函数在该点的函数值</li></ul><p>连续的类型：</p><ul><li>点连续</li><li>区间连续</li><li>一致连续</li></ul><h3 id="7-3-可导（derivative）"><a href="#7-3-可导（derivative）" class="headerlink" title="7.3. 可导（derivative）"></a>7.3. 可导（derivative）</h3><p>$$ f’(a) &#x3D; \lim\limits_{x \to a} \frac{f(x) - f(a)}{x - a} $$</p><p>可导是连续的进一步强化条件：</p><ul><li>函数在点 $a$ 处连续</li><li>函数在点 $a$ 处存在唯一的切线</li><li>导数存在，表示函数在该点的瞬时变化率</li></ul><p>可导的充要条件：</p><ul><li>左导数和右导数存在且相等</li></ul><h3 id="7-4-可微（differentiable）"><a href="#7-4-可微（differentiable）" class="headerlink" title="7.4. 可微（differentiable）"></a>7.4. 可微（differentiable）</h3><p>$$ f(x + \Delta x) &#x3D; f(x) + f’(x)\Delta x + o(\Delta x) $$</p><p>可微是可导的更强条件：</p><ul><li>函数可导</li><li>在点 $a$ 处可以用线性函数进行局部近似</li><li>误差项 $o(\Delta x)$ 是高阶无穷小</li></ul><p>可微的特点：</p><ul><li>提供了函数局部线性逼近</li><li>在微积分和泰勒展开中有重要应用</li></ul><h3 id="7-5-可偏导（partially-differentiable）"><a href="#7-5-可偏导（partially-differentiable）" class="headerlink" title="7.5. 可偏导（partially differentiable）"></a>7.5. 可偏导（partially differentiable）</h3><p>$$ \frac{\partial f}{\partial x_i} &#x3D; \lim\limits_{h \to 0} \frac{f(x_1, \ldots, x_i + h, \ldots, x_n) - f(x_1, \ldots, x_n)}{h} $$</p><p>可偏导是多变量函数的导数概念：</p><ul><li>定义在多元函数上</li><li>固定其他变量，对某一变量求导</li><li>每个自变量都存在偏导数</li></ul><p>可偏导的条件：</p><ul><li>每个方向的导数都存在</li><li>不要求所有偏导数连续</li></ul><h3 id="7-6-关系总结"><a href="#7-6-关系总结" class="headerlink" title="7.6 关系总结"></a>7.6 关系总结</h3><ol><li><p>极限存在 $\Rightarrow$ 连续</p><ul><li>极限存在是连续的必要条件</li><li>但极限存在不一定保证连续</li></ul></li><li><p>连续 $\Rightarrow$ 可导</p><ul><li>连续是可导的必要条件</li><li>但连续不一定保证可导</li></ul></li><li><p>可导 $\Rightarrow$ 可微</p><ul><li>可导是可微的必要条件</li><li>可导函数一定可微</li></ul></li><li><p>可导 $\Rightarrow$ 连续</p><ul><li>可导函数一定连续</li><li>连续是可导的必要条件</li></ul></li><li><p>多元函数的可偏导</p><ul><li>要求每个方向的导数存在</li><li>不要求偏导数连续或存在</li></ul></li></ol><p><strong>典型反例</strong></p><ul><li>$f(x) &#x3D; |x|$ 在 $x &#x3D; 0$ 处连续但不可导</li><li>$f(x) &#x3D; x \sin(\frac{1}{x})$（$x \neq 0$）在 $x &#x3D; 0$ 处极限存在但不连续</li></ul><img src="/img/Calculus/relation.svg" alt="关系总结" style="max-width: 100%; height: auto;" /><h2 id="8-常见函数的导数"><a href="#8-常见函数的导数" class="headerlink" title="8. 常见函数的导数"></a>8. 常见函数的导数</h2><h3 id="8-1-基本初等函数的导数"><a href="#8-1-基本初等函数的导数" class="headerlink" title="8.1. 基本初等函数的导数"></a>8.1. 基本初等函数的导数</h3><p>$$ (C)’ &#x3D; 0, \quad C \text{ 为常数} $$</p><p>$$ (x^n)’ &#x3D; nx^{n-1} $$</p><p>$$ (e^x)’ &#x3D; e^x $$</p><p>$$ (\ln x)’ &#x3D; \frac{1}{x} $$</p><p>$$ (\sin x)’ &#x3D; \cos x $$</p><p>$$ (\cos x)’ &#x3D; -\sin x $$</p><p>$$ (\tan x)’ &#x3D; \sec^2 x $$</p><p>$$ (\cot x)’ &#x3D; -\csc^2 x $$</p><p>$$ (\sec x)’ &#x3D; \sec x \tan x $$</p><p>$$ (\csc x)’ &#x3D; -\csc x \cot x $$</p><h3 id="8-2-反三角函数的导数"><a href="#8-2-反三角函数的导数" class="headerlink" title="8.2. 反三角函数的导数"></a>8.2. 反三角函数的导数</h3><p>$$ (\arcsin x)’ &#x3D; \frac{1}{\sqrt{1-x^2}} $$</p><p>$$ (\arccos x)’ &#x3D; -\frac{1}{\sqrt{1-x^2}} $$</p><p>$$ (\arctan x)’ &#x3D; \frac{1}{1+x^2} $$</p><p>$$ (\text{arccot } x)’ &#x3D; -\frac{1}{1+x^2} $$</p><p>$$ (\text{arcsec } x)’ &#x3D; \frac{1}{|x|\sqrt{x^2-1}} $$</p><p>$$ (\text{arccsc } x)’ &#x3D; -\frac{1}{|x|\sqrt{x^2-1}} $$</p><h3 id="8-3-指数与对数函数的导数"><a href="#8-3-指数与对数函数的导数" class="headerlink" title="8.3. 指数与对数函数的导数"></a>8.3. 指数与对数函数的导数</h3><p>$$ (a^x)’ &#x3D; a^x \ln a, \quad (a &gt; 0, a \neq 1) $$</p><p>$$ (\log_a x)’ &#x3D; \frac{1}{x \ln a}, \quad (a &gt; 0, a \neq 1) $$</p><h3 id="8-4-复合函数、积、商的导数"><a href="#8-4-复合函数、积、商的导数" class="headerlink" title="8.4. 复合函数、积、商的导数"></a>8.4. 复合函数、积、商的导数</h3><p>$$ [f(g(x))]’ &#x3D; f’(g(x)) \cdot g’(x) $$</p><p>$$ (u \cdot v)’ &#x3D; u’ \cdot v + u \cdot v’ $$</p><p>$$ \left(\frac{u}{v}\right)’ &#x3D; \frac{u’ \cdot v - u \cdot v’}{v^2} $$</p><h3 id="8-5-双曲函数的导数"><a href="#8-5-双曲函数的导数" class="headerlink" title="8.5. 双曲函数的导数"></a>8.5. 双曲函数的导数</h3><p>$$ (\sinh x)’ &#x3D; \cosh x $$</p><p>$$ (\cosh x)’ &#x3D; \sinh x $$</p><p>$$ (\tanh x)’ &#x3D; \text{sech}^2 x $$</p><p>$$ (\coth x)’ &#x3D; -\text{csch}^2 x $$</p><p>$$ (\text{sech } x)’ &#x3D; -\text{sech } x \tanh x $$</p><p>$$ (\text{csch } x)’ &#x3D; -\text{csch } x \coth x $$</p><h2 id="9-常见不等式"><a href="#9-常见不等式" class="headerlink" title="9. 常见不等式"></a>9. 常见不等式</h2><h3 id="9-1-基本不等式"><a href="#9-1-基本不等式" class="headerlink" title="9.1. 基本不等式"></a>9.1. 基本不等式</h3><p>$$ a \geq b \Rightarrow a^n \geq b^n, \quad (a,b &gt; 0, n &gt; 0) $$</p><p>$$ |a + b| \leq |a| + |b| $$</p><p>$$ |a - b| \geq \left| |a| - |b| \right| $$</p><p>$$ \frac{a+b}{2} \geq \sqrt{ab}, \quad (a,b &gt; 0) $$</p><p>$$ \frac{a_1 + a_2 + \cdots + a_n}{n} \geq \sqrt[n]{a_1 a_2 \cdots a_n}, \quad (a_i &gt; 0) $$</p><h3 id="9-2-三角函数不等式"><a href="#9-2-三角函数不等式" class="headerlink" title="9.2. 三角函数不等式"></a>9.2. 三角函数不等式</h3><p>$$ \sin x &lt; x &lt; \tan x, \quad (0 &lt; x &lt; \frac{\pi}{2}) $$</p><p>$$ \sin x \geq \frac{2x}{\pi}, \quad (0 \leq x \leq \frac{\pi}{2}) $$</p><p>$$ \cos x \geq 1 - \frac{x^2}{2}, \quad (x \in \mathbb{R}) $$</p><p>$$ |\sin x| \leq |x|, \quad (x \in \mathbb{R}) $$</p><p>$$ 1 - \cos x \leq \frac{x^2}{2}, \quad (x \in \mathbb{R}) $$</p><h3 id="9-3-指数与对数不等式"><a href="#9-3-指数与对数不等式" class="headerlink" title="9.3. 指数与对数不等式"></a>9.3. 指数与对数不等式</h3><p>$$ e^x \geq 1 + x, \quad (x \in \mathbb{R}) $$</p><p>$$ e^x \geq 1 + x + \frac{x^2}{2}, \quad (x \geq 0) $$</p><p>$$ \ln(1+x) \leq x, \quad (x &gt; -1) $$</p><p>$$ \ln x \leq x - 1, \quad (x &gt; 0) $$</p><p>$$ x^a &lt; x^b, \quad (0 &lt; x &lt; 1, a &gt; b) $$</p><p>$$ x^a &gt; x^b, \quad (x &gt; 1, a &gt; b) $$</p><h3 id="9-4-柯西不等式与其扩展"><a href="#9-4-柯西不等式与其扩展" class="headerlink" title="9.4. 柯西不等式与其扩展"></a>9.4. 柯西不等式与其扩展</h3><p>$$ \left( \sum_{i&#x3D;1}^{n} a_i b_i \right)^2 \leq \left( \sum_{i&#x3D;1}^{n} a_i^2 \right) \left( \sum_{i&#x3D;1}^{n} b_i^2 \right) $$</p><p>$$ \left( \frac{a_1 + a_2 + \cdots + a_n}{n} \right)^2 \leq \frac{a_1^2 + a_2^2 + \cdots + a_n^2}{n} $$</p><p>$$ \frac{1}{a_1} + \frac{1}{a_2} + \cdots + \frac{1}{a_n} \geq \frac{n^2}{a_1 + a_2 + \cdots + a_n}, \quad (a_i &gt; 0) $$</p><h3 id="9-5-经典不等式"><a href="#9-5-经典不等式" class="headerlink" title="9.5. 经典不等式"></a>9.5. 经典不等式</h3><p>$$ \frac{a^n + b^n}{2} \geq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, n \geq 1) $$</p><p>$$ \frac{a^n + b^n}{2} \leq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, 0 &lt; n &lt; 1) $$</p><p>$$ a^b \cdot b^a \leq a^a \cdot b^b, \quad (a, b &gt; 0) $$</p><p>$$ \sqrt{1+x} &lt; 1 + \frac{x}{2}, \quad (x &gt; 0) $$</p><p>$$ (1+x)^n \geq 1 + nx, \quad (x &gt; -1, n &gt; 1) $$</p><h2 id="10-函数凹凸性"><a href="#10-函数凹凸性" class="headerlink" title="10. 函数凹凸性"></a>10. 函数凹凸性</h2><h3 id="10-1-函数的凹凸性定义"><a href="#10-1-函数的凹凸性定义" class="headerlink" title="10.1. 函数的凹凸性定义"></a><strong>10.1. 函数的凹凸性定义</strong></h3><ul><li><p><strong>凸函数（上凸函数）：</strong> 若函数 $f(x)$ 在区间 $I$ 内满足：</p><p>$$ f(\lambda x_1 + (1 - \lambda)x_2) \leq \lambda f(x_1) + (1 - \lambda) f(x_2), \quad (\lambda \in [0,1]) $$</p><p>则称 $f(x)$ <strong>在 $I$ 上是凸函数（Convex Function）</strong>。</p></li><li><p><strong>凹函数（下凸函数）：</strong> 若函数 $f(x)$ 在区间 $I$ 内满足：</p><p>$$ f(\lambda x_1 + (1 - \lambda)x_2) \geq \lambda f(x_1) + (1 - \lambda) f(x_2), \quad (\lambda \in [0,1]) $$</p><p>则称 $f(x)$ <strong>在 $I$ 上是凹函数（Concave Function）</strong>。</p></li></ul><p>几何上，<strong>凸函数的图像在任意两点之间的弦线之下，凹函数的图像在弦线之上。</strong></p><hr><h3 id="10-2-通过二阶导数判断凹凸性"><a href="#10-2-通过二阶导数判断凹凸性" class="headerlink" title="10.2. 通过二阶导数判断凹凸性"></a><strong>10.2. 通过二阶导数判断凹凸性</strong></h3><p>若 $f(x)$ 在区间 $I$ <strong>二阶可导</strong>，则：</p><ul><li>若 $f’’(x) &gt; 0$，则 $f(x)$ 在 $I$ <strong>上凸（凸函数）</strong>；</li><li>若 $f’’(x) &lt; 0$，则 $f(x)$ 在 $I$ <strong>下凸（凹函数）</strong>；</li><li>若 $f’’(x) &#x3D; 0$，需要进一步分析高阶导数或函数的局部行为。</li></ul><p><strong>示例：</strong></p><ul><li>$f(x) &#x3D; x^2$，二阶导数 $f’’(x) &#x3D; 2 &gt; 0$，是<strong>凸函数</strong>（向上弯曲）。</li><li>$f(x) &#x3D; -x^2$，二阶导数 $f’’(x) &#x3D; -2 &lt; 0$，是<strong>凹函数</strong>（向下弯曲）。</li></ul><img src="/img/Calculus/convex.jpg" alt="凹凸性" style="max-width: 100%; height: auto;" /><div class="note note-success">            <p>⚠️注意国内定义的凹凸性和国际上的凹凸性是反过来的…这里以国际定义为准</p>          </div><hr><h3 id="10-3-拐点（Inflection-Point）"><a href="#10-3-拐点（Inflection-Point）" class="headerlink" title="10.3. 拐点（Inflection Point）"></a><strong>10.3. 拐点（Inflection Point）</strong></h3><p>若 $f(x)$ 的二阶导数在某点 $x &#x3D; c$ 发生符号变化，即满足：</p><p>$$ f’’(c) &#x3D; 0, \quad \text{且} \quad f’’(x) \text{ 在 } c \text{ 处改变符号} $$</p><p>则称 $x &#x3D; c$ 为函数的<strong>拐点</strong>，即函数从凸变凹或从凹变凸的点。</p><p><strong>示例：</strong></p><ul><li>$f(x) &#x3D; x^3$，二阶导数 $f’’(x) &#x3D; 6x$，在 $x &#x3D; 0$ 处由负变正，因此 $x &#x3D; 0$ 是拐点。</li></ul><hr><h3 id="10-4-经典结论"><a href="#10-4-经典结论" class="headerlink" title="10.4. 经典结论"></a><strong>10.4. 经典结论</strong></h3><ol><li><strong>指数函数</strong> $f(x) &#x3D; e^x$，二阶导数 $f’’(x) &#x3D; e^x &gt; 0$，是<strong>凸函数</strong>。</li><li><strong>对数函数</strong> $f(x) &#x3D; \ln x$，二阶导数 $f’’(x) &#x3D; -\frac{1}{x^2} &lt; 0$，是<strong>凹函数</strong>。</li><li><strong>幂函数</strong> $f(x) &#x3D; x^p$：<ul><li>若 $p \geq 1$ 或 $0 &lt; p &lt; 1$，则 $f(x)$ <strong>在 $x &gt; 0$ 上是凸函数</strong>。</li><li>若 $p &lt; 0$，则 $f(x)$ <strong>在 $x &gt; 0$ 上是凹函数</strong>。</li></ul></li></ol><hr><h3 id="10-5-例题解析"><a href="#10-5-例题解析" class="headerlink" title="10.5. 例题解析"></a><strong>10.5. 例题解析</strong></h3><h4 id="例-1：判断函数-f-x-x-4-4x-3-6x-2-的凹凸性及拐点"><a href="#例-1：判断函数-f-x-x-4-4x-3-6x-2-的凹凸性及拐点" class="headerlink" title="例 1：判断函数 $f(x) &#x3D; x^4 - 4x^3 + 6x^2$ 的凹凸性及拐点"></a><strong>例 1：判断函数 $f(x) &#x3D; x^4 - 4x^3 + 6x^2$ 的凹凸性及拐点</strong></h4><p><strong>解：</strong></p><ul><li><p>一阶导数：</p><p>$$ f’(x) &#x3D; 4x^3 - 12x^2 + 12x $$</p></li><li><p>二阶导数：</p><p>$$ f’’(x) &#x3D; 12x^2 - 24x + 12 $$</p></li><li><p>令 $f’’(x) &#x3D; 0$ 求拐点：</p><p>$$ 12(x^2 - 2x + 1) &#x3D; 0 $$</p><p>$$ 12(x - 1)^2 &#x3D; 0 \Rightarrow x &#x3D; 1 $$</p></li><li><p>由于 $f’’(x)$ 在 $x &#x3D; 1$ 两侧符号没有变化，说明<strong>函数在整个定义域内都是凸的</strong>。</p></li></ul><hr><h3 id="10-6-重要不等式"><a href="#10-6-重要不等式" class="headerlink" title="10.6. 重要不等式"></a><strong>10.6. 重要不等式</strong></h3><ul><li><p><strong>Jensen 不等式（对凸函数成立）：</strong></p><p>$$ f\left(\frac{x_1 + x_2}{2}\right) \leq \frac{f(x_1) + f(x_2)}{2} $$</p><p>若 $f(x)$ 是<strong>凹函数</strong>，则不等号方向相反。</p></li><li><p><strong>均值不等式（对幂函数成立）：</strong></p><p>$$ \frac{a^n + b^n}{2} \geq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, n \geq 1) $$</p><p>$$ \frac{a^n + b^n}{2} \leq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, 0 &lt; n &lt; 1) $$</p></li><li><p><strong>指数与对数的不等式（由凹凸性推出）：</strong></p><p>$$ a^b \cdot b^a \leq a^a \cdot b^b, \quad (a, b &gt; 0) $$</p><p>$$ \sqrt{1+x} &lt; 1 + \frac{x}{2}, \quad (x &gt; 0) $$</p><p>$$ (1+x)^n \geq 1 + nx, \quad (x &gt; -1, n &gt; 1) $$</p></li></ul><hr><h3 id="10-7-总结"><a href="#10-7-总结" class="headerlink" title="10.7. 总结"></a><strong>10.7. 总结</strong></h3><ul><li><strong>凸函数</strong>满足 $f’’(x) &gt; 0$，图像向上弯曲。</li><li><strong>凹函数</strong>满足 $f’’(x) &lt; 0$，图像向下弯曲。</li><li><strong>拐点</strong>是函数从凹变凸或从凸变凹的点，满足 $f’’(x) &#x3D; 0$ 且符号发生变化。</li><li><strong>经典结论</strong>：<ul><li>$e^x$ 是凸函数</li><li>$\ln x$ 是凹函数</li><li>$x^p$ 的凹凸性取决于 $p$ 的大小</li></ul></li></ul><hr><h3 id="10-8-Jesen不等式"><a href="#10-8-Jesen不等式" class="headerlink" title="10.8. Jesen不等式"></a>10.8. Jesen不等式</h3><p><strong>Jensen不等式的基本形式</strong></p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) \leq \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为凸函数}) $$</p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) \geq \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为凹函数}) $$</p><p>$$ \text{其中} \sum_{i&#x3D;1}^n \lambda_i &#x3D; 1, \lambda_i \geq 0, i&#x3D;1,2,\ldots,n $$</p><p>等号成立当且仅当满足以下任一条件：</p><ol><li><p>$x_1 &#x3D; x_2 &#x3D; \cdots &#x3D; x_n$</p><p>即所有的 $x_i$ 都相等。</p></li><li><p>$\varphi(x) \text{ 在包含所有 } x_i \text{ 的区间上是线性函数}$ 即 $\varphi(x) &#x3D; ax + b$，其中 $a, b$ 为常数。</p></li></ol><p><strong>这两个条件可以这样理解：</strong></p><p>当所有点 $x_i$ 相同时，无论权重 $\lambda_i$ 如何分配，加权平均值都等于这个公共值，因此等号成立。</p><p>当 $\varphi(x)$ 是线性函数时，它既不是严格凸的也不是严格凹的（$\varphi’’(x) &#x3D; 0$），这种情况下，函数值的加权平均恰好等于函数在加权平均点的值，从而等号成立。</p><p>对于严格凸函数（$\varphi’’(x) &gt; 0$）或严格凹函数（$\varphi’’(x) &lt; 0$），等号成立当且仅当所有 $x_i$ 都相等。</p><hr><p><strong>连续形式的Jensen不等式</strong></p><p>$$ \varphi\left(\int_a^b f(x) g(x) dx\right) \leq \int_a^b \varphi(f(x)) g(x) dx, \quad (\varphi \text{ 为凸函数}) $$</p><p>$$ \varphi\left(\int_a^b f(x) g(x) dx\right) \geq \int_a^b \varphi(f(x)) g(x) dx, \quad (\varphi \text{ 为凹函数}) $$</p><p>$$ \text{其中} \int_a^b g(x) dx &#x3D; 1, g(x) \geq 0 $$</p><hr><p><strong>概率形式的Jensen不等式</strong></p><p>$$ \varphi(E[X]) \leq E[\varphi(X)], \quad (\varphi \text{ 为凸函数}) $$</p><p>$$ \varphi(E[X]) \geq E[\varphi(X)], \quad (\varphi \text{ 为凹函数}) $$</p><p>$$ \text{其中} E[X] \text{ 表示随机变量 } X \text{ 的期望} $$</p><hr><p><strong>典型应用案例</strong></p><p>$$ \left(\frac{a_1 + a_2 + \cdots + a_n}{n}\right)^p \leq \frac{a_1^p + a_2^p + \cdots + a_n^p}{n}, \quad (a_i &gt; 0, p &gt; 1) $$</p><p>$$ \left(\frac{a_1 + a_2 + \cdots + a_n}{n}\right)^p \geq \frac{a_1^p + a_2^p + \cdots + a_n^p}{n}, \quad (a_i &gt; 0, 0 &lt; p &lt; 1) $$</p><p>$$ \ln\left(\frac{a_1 + a_2 + \cdots + a_n}{n}\right) \geq \frac{\ln a_1 + \ln a_2 + \cdots + \ln a_n}{n}, \quad (a_i &gt; 0) $$</p><hr><p><strong>Jensen不等式的几何解释</strong></p><p>$$ \varphi(tx_1 + (1-t)x_2) \leq t\varphi(x_1) + (1-t)\varphi(x_2), \quad (0 \leq t \leq 1, \varphi \text{ 为凸函数}) $$</p><p>$$ \varphi(tx_1 + (1-t)x_2) \geq t\varphi(x_1) + (1-t)\varphi(x_2), \quad (0 \leq t \leq 1, \varphi \text{ 为凹函数}) $$</p><p>$$ \text{即凸函数图像上任意两点的连线位于图像上方，凹函数则位于图像下方} $$</p><hr><p><strong>严格不等式条件</strong></p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) &lt; \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为严格凸函数且不是所有 } x_i \text{ 都相等}) $$</p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) &gt; \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为严格凹函数且不是所有 } x_i \text{ 都相等}) $$</p><h2 id="11-泰勒公式-麦克劳林公式"><a href="#11-泰勒公式-麦克劳林公式" class="headerlink" title="11. 泰勒公式&amp;麦克劳林公式"></a>11. 泰勒公式&amp;麦克劳林公式</h2><h3 id="11-1-泰勒公式"><a href="#11-1-泰勒公式" class="headerlink" title="11.1 泰勒公式"></a>11.1 泰勒公式</h3><p>泰勒公式是一种用多项式函数近似表示光滑函数的方法。它使我们能够在某点附近用幂级数展开函数。</p><p>假设函数 $f(x)$ 在点 $x&#x3D;a$ 的某个邻域内具有 $n+1$ 阶连续导数，那么对于该邻域内的任意点 $x$，函数 $f(x)$ 可以表示为：</p><p>$$ f(x) &#x3D; f(a) + f’(a)(x-a) + \frac{f’’(a)}{2!}(x-a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n + R_n(x) $$</p><p>其中 $R_n(x)$ 是拉格朗日余项，表示为：</p><p>$$ R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-a)^{n+1} $$</p><p>这里 $\xi$ 是介于 $a$ 和 $x$ 之间的某个值。</p><p>泰勒公式的另一种常见形式是带有皮亚诺余项：</p><p>$$ f(x) &#x3D; f(a) + f’(a)(x-a) + \frac{f’’(a)}{2!}(x-a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n + o((x-a)^n) $$</p><h3 id="11-2-麦克劳林公式"><a href="#11-2-麦克劳林公式" class="headerlink" title="11.2 麦克劳林公式"></a>11.2 麦克劳林公式</h3><p>麦克劳林公式是泰勒公式的特殊情况，即在点 $a&#x3D;0$ 处展开：</p><p>$$ f(x) &#x3D; f(0) + f’(0)x + \frac{f’’(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n + R_n(x) $$</p><p>其中余项 $R_n(x)$ 表示为：</p><p>$$ R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!}x^{n+1} $$</p><p>这里 $\xi$ 是介于 $0$ 和 $x$ 之间的某个值。</p><p>让我们看一个例子，计算 $\sin(0.1)$ 的近似值：</p><p>使用麦克劳林公式展开到 $x^5$ 项：<br>$$ \sin(0.1) \approx 0.1 - \frac{(0.1)^3}{3!} + \frac{(0.1)^5}{5!} $$<br>$$ \sin(0.1) \approx 0.1 - \frac{0.001}{6} + \frac{0.00001}{120} $$<br>$$ \sin(0.1) \approx 0.1 - 0.000167 + 0.000000083 \approx 0.099833 $$</p><p>实际值 $\sin(0.1) \approx 0.0998334$，所以这个近似是相当准确的。</p><h3 id="11-3-常见函数的麦克劳林展开"><a href="#11-3-常见函数的麦克劳林展开" class="headerlink" title="11.3 常见函数的麦克劳林展开"></a>11.3 常见函数的麦克劳林展开</h3><p>以下是一些常见函数的麦克劳林展开式：</p><ol><li><p>指数函数：<br>$$ e^x &#x3D; 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{x^n}{n!} $$</p></li><li><p>正弦函数：<br>$$ \sin x &#x3D; x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n+1}}{(2n+1)!} $$</p></li><li><p>余弦函数：<br>$$ \cos x &#x3D; 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n}}{(2n)!} $$</p></li><li><p>自然对数函数：<br>$$ \ln(1+x) &#x3D; x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots &#x3D; \sum_{n&#x3D;1}^{\infty} \frac{(-1)^{n+1}x^n}{n}, \quad |x| &lt; 1 $$</p></li><li><p>反正切函数：<br>$$ \arctan x &#x3D; x - \frac{x^3}{3} + \frac{x^5}{5} - \frac{x^7}{7} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n+1}}{2n+1}, \quad |x| \leq 1 $$</p></li><li><p>双曲正弦函数：<br>$$ \sinh x &#x3D; x + \frac{x^3}{3!} + \frac{x^5}{5!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{x^{2n+1}}{(2n+1)!} $$</p></li><li><p>双曲余弦函数：<br>$$ \cosh x &#x3D; 1 + \frac{x^2}{2!} + \frac{x^4}{4!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{x^{2n}}{(2n)!} $$</p></li><li><p>$(1+x)^{\alpha}$ 的二项式展开（广义二项式定理）：<br>$$ (1+x)^{\alpha} &#x3D; 1 + \alpha x + \frac{\alpha(\alpha-1)}{2!}x^2 + \frac{\alpha(\alpha-1)(\alpha-2)}{3!}x^3 + \cdots, \quad |x| &lt; 1 $$<br>$$ &#x3D; \sum_{n&#x3D;0}^{\infty} \binom{\alpha}{n} x^n, \quad |x| &lt; 1 $$<br>其中 $\binom{\alpha}{n} &#x3D; \frac{\alpha(\alpha-1)(\alpha-2)\cdots(\alpha-n+1)}{n!}$</p></li><li><p>正切函数：<br>$$ \tan x &#x3D; x + \frac{x^3}{3} + \frac{2x^5}{15} + \frac{17x^7}{315} + \cdots, \quad |x| &lt; \frac{\pi}{2} $$</p></li><li><p>反正弦函数：<br>$$ \arcsin x &#x3D; x + \frac{1}{2} \cdot \frac{x^3}{3} + \frac{1 \cdot 3}{2 \cdot 4} \cdot \frac{x^5}{5} + \frac{1 \cdot 3 \cdot 5}{2 \cdot 4 \cdot 6} \cdot \frac{x^7}{7} + \cdots, \quad |x| \leq 1 $$</p></li><li><p>平方根函数：<br>$$ \sqrt{1+x} &#x3D; 1 + \frac{1}{2}x - \frac{1}{8}x^2 + \frac{1}{16}x^3 - \frac{5}{128}x^4 + \cdots, \quad |x| &lt; 1 $$</p></li><li><p>倒数函数：<br>$$ \frac{1}{1-x} &#x3D; 1 + x + x^2 + x^3 + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} x^n, \quad |x| &lt; 1 $$</p></li><li><p>双曲正切函数：<br>$$ \tanh x &#x3D; x - \frac{x^3}{3} + \frac{2x^5}{15} - \frac{17x^7}{315} + \cdots, \quad |x| &lt; \frac{\pi}{2} $$</p></li><li><p>余切函数级数：<br>$$ \cot x &#x3D; \frac{1}{x} - \frac{x}{3} - \frac{x^3}{45} - \frac{2x^5}{945} - \cdots, \quad 0 &lt; |x| &lt; \pi $$</p></li><li><p>正割函数：<br>$$ \sec x &#x3D; 1 + \frac{x^2}{2} + \frac{5x^4}{24} + \frac{61x^6}{720} + \cdots, \quad |x| &lt; \frac{\pi}{2} $$</p></li></ol><h3 id="11-4-复合函数的麦克劳林展开"><a href="#11-4-复合函数的麦克劳林展开" class="headerlink" title="11.4 复合函数的麦克劳林展开"></a>11.4 复合函数的麦克劳林展开</h3><ol start="16"><li><p>$e^{-x^2}$ 的麦克劳林展开：<br>$$ e^{-x^2} &#x3D; 1 - x^2 + \frac{x^4}{2!} - \frac{x^6}{3!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n}}{n!} $$</p></li><li><p>$\ln(1-x)$ 的麦克劳林展开：<br>$$ \ln(1-x) &#x3D; -x - \frac{x^2}{2} - \frac{x^3}{3} - \frac{x^4}{4} - \cdots &#x3D; -\sum_{n&#x3D;1}^{\infty} \frac{x^n}{n}, \quad |x| &lt; 1 $$</p></li><li><p>$\frac{1}{(1-x)^2}$ 的麦克劳林展开：<br>$$ \frac{1}{(1-x)^2} &#x3D; 1 + 2x + 3x^2 + 4x^3 + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} (n+1)x^n, \quad |x| &lt; 1 $$</p></li></ol><h2 id="12-常见积分的基本公式"><a href="#12-常见积分的基本公式" class="headerlink" title="12. 常见积分的基本公式"></a>12. 常见积分的基本公式</h2><h3 id="12-1-基本不定积分公式"><a href="#12-1-基本不定积分公式" class="headerlink" title="12.1. 基本不定积分公式"></a>12.1. 基本不定积分公式</h3><ol><li><p>常数积分：<br>$$ \int k , dx &#x3D; kx + C $$</p></li><li><p>幂函数积分：<br>$$ \int x^n , dx &#x3D; \frac{x^{n+1}}{n+1} + C, \quad (n \neq -1) $$</p></li><li><p>对数函数积分：<br>$$ \int \frac{1}{x} , dx &#x3D; \ln|x| + C $$</p></li><li><p>指数函数积分：<br>$$ \int e^x , dx &#x3D; e^x + C $$<br>$$ \int a^x , dx &#x3D; \frac{a^x}{\ln a} + C, \quad (a &gt; 0, a \neq 1) $$</p></li><li><p>三角函数积分：<br>$$ \int \sin x , dx &#x3D; -\cos x + C $$<br>$$ \int \cos x , dx &#x3D; \sin x + C $$<br>$$ \int \tan x , dx &#x3D; -\ln|\cos x| + C &#x3D; \ln|\sec x| + C $$<br>$$ \int \cot x , dx &#x3D; \ln|\sin x| + C $$<br>$$ \int \sec x , dx &#x3D; \ln|\sec x + \tan x| + C $$<br>$$ \int \csc x , dx &#x3D; \ln|\csc x - \cot x| + C &#x3D; \ln|\tan(x&#x2F;2)| + C $$</p></li><li><p>反三角函数积分：<br>$$ \int \frac{1}{\sqrt{1-x^2}} , dx &#x3D; \arcsin x + C &#x3D; -\arccos x + C $$<br>$$ \int \frac{1}{1+x^2} , dx &#x3D; \arctan x + C $$<br>$$ \int \frac{1}{|x|\sqrt{x^2-1}} , dx &#x3D; \arccos\frac{1}{|x|} + C $$</p></li><li><p>双曲函数积分：<br>$$ \int \sinh x , dx &#x3D; \cosh x + C $$<br>$$ \int \cosh x , dx &#x3D; \sinh x + C $$<br>$$ \int \tanh x , dx &#x3D; \ln(\cosh x) + C $$<br>$$ \int \coth x , dx &#x3D; \ln|\sinh x| + C $$</p></li></ol><h3 id="12-2-特殊形式积分"><a href="#12-2-特殊形式积分" class="headerlink" title="12.2. 特殊形式积分"></a>12.2. 特殊形式积分</h3><ol start="8"><li><p>分式积分：<br>$$ \int \frac{1}{a^2+x^2} , dx &#x3D; \frac{1}{a}\arctan\frac{x}{a} + C, \quad (a &gt; 0) $$<br>$$ \int \frac{1}{a^2-x^2} , dx &#x3D; \frac{1}{2a}\ln\left|\frac{a+x}{a-x}\right| + C, \quad (|x| &lt; a) $$<br>$$ \int \frac{1}{x^2-a^2} , dx &#x3D; \frac{1}{2a}\ln\left|\frac{x-a}{x+a}\right| + C, \quad (|x| &gt; a) $$</p></li><li><p>根式积分：<br>$$ \int \frac{1}{\sqrt{a^2-x^2}} , dx &#x3D; \arcsin\frac{x}{a} + C, \quad (|x| &lt; a, a &gt; 0) $$<br>$$ \int \frac{1}{\sqrt{x^2-a^2}} , dx &#x3D; \ln|x + \sqrt{x^2-a^2}| + C, \quad (x &gt; a &gt; 0) $$<br>$$ \int \frac{1}{\sqrt{x^2+a^2}} , dx &#x3D; \ln|x + \sqrt{x^2+a^2}| + C, \quad (a &gt; 0) $$<br>$$ \int \sqrt{a^2-x^2} , dx &#x3D; \frac{x\sqrt{a^2-x^2}}{2} + \frac{a^2}{2}\arcsin\frac{x}{a} + C, \quad (|x| &lt; a, a &gt; 0) $$<br>$$ \int \sqrt{x^2+a^2} , dx &#x3D; \frac{x\sqrt{x^2+a^2}}{2} + \frac{a^2}{2}\ln|x + \sqrt{x^2+a^2}| + C, \quad (a &gt; 0) $$<br>$$ \int \sqrt{x^2-a^2} , dx &#x3D; \frac{x\sqrt{x^2-a^2}}{2} - \frac{a^2}{2}\ln|x + \sqrt{x^2-a^2}| + C, \quad (x &gt; a &gt; 0) $$</p></li><li><p>特殊乘积结构：<br>$$ \int x\sin x , dx &#x3D; \sin x - x\cos x + C $$<br>$$ \int x\cos x , dx &#x3D; \cos x + x\sin x + C $$<br>$$ \int x^n e^x , dx &#x3D; x^n e^x - n\int x^{n-1}e^x , dx $$<br>$$ \int x^n \ln x , dx &#x3D; \frac{x^{n+1}}{n+1}\ln x - \frac{x^{n+1}}{(n+1)^2} + C, \quad (n \neq -1) $$</p></li><li><p>有理三角函数变形：<br>$$ \int \sin^2 x , dx &#x3D; \frac{x}{2} - \frac{\sin 2x}{4} + C $$<br>$$ \int \cos^2 x , dx &#x3D; \frac{x}{2} + \frac{\sin 2x}{4} + C $$<br>$$ \int \sin^n x , dx &#x3D; -\frac{\sin^{n-1}x \cos x}{n} + \frac{n-1}{n}\int \sin^{n-2}x , dx, \quad (n &gt; 1) $$<br>$$ \int \cos^n x , dx &#x3D; \frac{\cos^{n-1}x \sin x}{n} + \frac{n-1}{n}\int \cos^{n-2}x , dx, \quad (n &gt; 1) $$</p></li><li><p>平方和与差的积分：<br>$$ \int \frac{1}{x^2+a^2} , dx &#x3D; \frac{1}{a}\arctan\frac{x}{a} + C, \quad (a &gt; 0) $$<br>$$ \int \frac{x}{x^2+a^2} , dx &#x3D; \frac{1}{2}\ln(x^2+a^2) + C $$<br>$$ \int \frac{x^2}{x^2+a^2} , dx &#x3D; x - a\arctan\frac{x}{a} + C, \quad (a &gt; 0) $$</p></li></ol><h3 id="12-3-特殊定积分"><a href="#12-3-特殊定积分" class="headerlink" title="12.3. 特殊定积分"></a>12.3. 特殊定积分</h3><ol start="13"><li><p>常见定积分：<br>$$ \int_0^{\pi&#x2F;2} \sin^n x , dx &#x3D; \int_0^{\pi&#x2F;2} \cos^n x , dx &#x3D; \begin{cases}<br>\frac{(n-1)!!}{n!!} \cdot \frac{\pi}{2}, &amp; \text{n 为偶数} \<br>\frac{(n-1)!!}{n!!}, &amp; \text{n 为奇数}<br>\end{cases} $$<br>其中 $n!! &#x3D; n(n-2)(n-4)\cdots$</p></li><li><p>对称区间上的奇偶性质：<br>$$ \int_{-a}^{a} f(x) , dx &#x3D; 2\int_0^a f(x) , dx, \quad \text{当 } f \text{ 为偶函数} $$<br>$$ \int_{-a}^{a} f(x) , dx &#x3D; 0, \quad \text{当 } f \text{ 为奇函数} $$</p></li><li><p>华里士公式：<br>$$ \int_0^{\pi&#x2F;2} \sin^m x \cos^n x , dx &#x3D; \frac{1}{2}B\left(\frac{m+1}{2}, \frac{n+1}{2}\right) &#x3D; \frac{\Gamma\left(\frac{m+1}{2}\right)\Gamma\left(\frac{n+1}{2}\right)}{2\Gamma\left(\frac{m+n+2}{2}\right)} $$<br>其中 $B$ 是贝塔函数，$\Gamma$ 是伽马函数</p></li><li><p>$\Gamma$ 函数相关积分：<br>$$ \int_0^{\infty} x^{n-1}e^{-x} , dx &#x3D; \Gamma(n), \quad (n &gt; 0) $$<br>$$ \int_0^{\infty} e^{-x^2} , dx &#x3D; \frac{\sqrt{\pi}}{2} $$</p></li><li><p>重要极限类型定积分：<br>$$ \lim_{n \to \infty} \int_0^1 (1-x^n)^n , dx &#x3D; \frac{1}{e} $$<br>$$ \lim_{n \to \infty} \int_0^{\infty} \frac{x^n}{n^{n+1}} e^{-x&#x2F;n} , dx &#x3D; 1 $$</p></li></ol><h3 id="12-4-换元积分法的典型例子"><a href="#12-4-换元积分法的典型例子" class="headerlink" title="12.4. 换元积分法的典型例子"></a>12.4. 换元积分法的典型例子</h3><ol start="18"><li><p>三角换元：<br>$$ \int \sqrt{a^2-x^2} , dx &#x3D; \frac{a^2}{2}\arcsin\frac{x}{a} + \frac{x\sqrt{a^2-x^2}}{2} + C, \quad (|x| &lt; a) $$<br>（令 $x &#x3D; a\sin t$）</p></li><li><p>双曲换元：<br>$$ \int \sqrt{x^2+a^2} , dx &#x3D; \frac{x\sqrt{x^2+a^2}}{2} + \frac{a^2}{2}\ln|x + \sqrt{x^2+a^2}| + C $$<br>（令 $x &#x3D; a\sinh t$）</p></li><li><p>有理分式积分：<br>$$ \int \frac{1}{(x-a)(x-b)} , dx &#x3D; \frac{1}{a-b}\ln\left|\frac{x-a}{x-b}\right| + C, \quad (a \neq b) $$<br>$$ \int \frac{1}{(x-a)^2} , dx &#x3D; -\frac{1}{x-a} + C $$</p></li></ol><h2 id="13-Gamma函数"><a href="#13-Gamma函数" class="headerlink" title="13. Gamma函数"></a>13. Gamma函数</h2>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Calculus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS Concepts</title>
    <link href="/2025/02/09/CS-Concepts/"/>
    <url>/2025/02/09/CS-Concepts/</url>
    
    <content type="html"><![CDATA[<h1 id="CS-Concepts"><a href="#CS-Concepts" class="headerlink" title="CS Concepts"></a>CS Concepts</h1><p>本章笔记着重对CS相关专业科目的名词进行解释，在修考问答题和面试八股文场景下适用。这些名词都来源于CS相关学科。本篇笔记内容按科目划分，每个科目下面有对应的常见高频名词解释（中&#x2F;英）。</p><h2 id="1-Data-Stucture-Algorithms"><a href="#1-Data-Stucture-Algorithms" class="headerlink" title="1. Data Stucture &amp; Algorithms"></a>1. Data Stucture &amp; Algorithms</h2><h2 id="2-Operating-System"><a href="#2-Operating-System" class="headerlink" title="2. Operating System"></a>2. Operating System</h2><h2 id="3-Computer-Architecture"><a href="#3-Computer-Architecture" class="headerlink" title="3. Computer Architecture"></a>3. Computer Architecture</h2><h2 id="4-Formal-Language-Automata"><a href="#4-Formal-Language-Automata" class="headerlink" title="4. Formal Language &amp; Automata"></a>4. Formal Language &amp; Automata</h2><h2 id="5-Programming-Language"><a href="#5-Programming-Language" class="headerlink" title="5. Programming Language"></a>5. Programming Language</h2><h2 id="6-Machine-Learning"><a href="#6-Machine-Learning" class="headerlink" title="6. Machine Learning"></a>6. Machine Learning</h2><h2 id="7-Digital-Circuit"><a href="#7-Digital-Circuit" class="headerlink" title="7. Digital Circuit"></a>7. Digital Circuit</h2><h2 id="8-Computer-Networks"><a href="#8-Computer-Networks" class="headerlink" title="8. Computer Networks"></a>8. Computer Networks</h2><h2 id="9-Cryptography"><a href="#9-Cryptography" class="headerlink" title="9. Cryptography"></a>9. Cryptography</h2><h2 id="10-Digital-Signal-Processing"><a href="#10-Digital-Signal-Processing" class="headerlink" title="10. Digital Signal Processing"></a>10. Digital Signal Processing</h2><h2 id="11-Control-Engineering"><a href="#11-Control-Engineering" class="headerlink" title="11. Control Engineering"></a>11. Control Engineering</h2><h2 id="12-Software-Development"><a href="#12-Software-Development" class="headerlink" title="12. Software Development"></a>12. Software Development</h2><h2 id="13-Robotics"><a href="#13-Robotics" class="headerlink" title="13. Robotics"></a>13. Robotics</h2>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>CS Concepts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Networks</title>
    <link href="/2025/02/09/computer-networks/"/>
    <url>/2025/02/09/computer-networks/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Networks"><a href="#Computer-Networks" class="headerlink" title="Computer Networks"></a>Computer Networks</h1><p>本篇笔记主要讲解计算机网络的常见网络模型和常见协议。主要应对面试八股文场景和修考简答题。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Networks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra</title>
    <link href="/2025/02/08/Linear-Algebra/"/>
    <url>/2025/02/08/Linear-Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h1><p>本篇线性代数内容主要讲解一下关键的地方，以及一些重要的二级结论推导。全文没有严格的上下文关系。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="哈密尔顿-凯莱定理（Cayley-Hamilton-Theorem）"><a href="#哈密尔顿-凯莱定理（Cayley-Hamilton-Theorem）" class="headerlink" title="哈密尔顿-凯莱定理（Cayley-Hamilton Theorem）"></a>哈密尔顿-凯莱定理（Cayley-Hamilton Theorem）</h2><p><strong>哈密尔顿-凯莱定理</strong>是线性代数中的一个重要定理，它描述了<strong>每个方阵都满足自己的特征多项式</strong>。</p><p><strong>定理内容</strong>： <strong>设 $A$ 是一个 $n \times n$ 的方阵，其特征多项式为</strong><br>$$<br>p_A(\lambda) &#x3D; \det(\lambda I - A) &#x3D; c_n \lambda^n + c_{n-1} \lambda^{n-1} + \dots + c_1 \lambda + c_0<br>$$<br>其中 $I$ 是 $n$ 阶单位矩阵，$c_i$ 是多项式的系数。</p><p>那么，将矩阵 $A$ 代入它的特征多项式，会得到：<br>$$<br>p_A(A) &#x3D; c_n A^n + c_{n-1} A^{n-1} + \dots + c_1 A + c_0 I &#x3D; 0<br>$$<br>即 <strong>矩阵 $A$ 代入自己的特征多项式后，结果是零矩阵</strong>。</p><hr><p><strong>证明思路（大致想法）</strong> 哈密尔顿-凯莱定理的证明通常有几种方法，最常见的方法基于矩阵的<strong>最小多项式</strong>：</p><ol><li><p><strong>最小多项式法</strong>：  </p><ul><li>设矩阵 $A$ 的最小多项式是 $m_A(\lambda)$，即 $m_A(A) &#x3D; 0$ 且 $m_A(\lambda)$ 是 $A$ 所满足的次数最低的首一多项式。</li><li>由于特征多项式 $p_A(\lambda)$ 是 $A$ 的一个多项式，并且所有矩阵的特征多项式都能被它的最小多项式整除（即 $p_A(\lambda) &#x3D; m_A(\lambda) q(\lambda)$），因此 $p_A(A) &#x3D; 0$ 也成立。</li></ul></li><li><p><strong>利用行列式展开</strong>：</p><ul><li>设 $A$ 的特征多项式 $p_A(\lambda) &#x3D; \det(\lambda I - A)$。</li><li>将 $A$ 代入 $p_A(\lambda)$ 后，利用矩阵的特征向量与特征值的性质，可以证明 $p_A(A) &#x3D; 0$。</li></ul></li><li><p><strong>外代数法（或幂零矩阵分解）</strong>：</p><ul><li>通过矩阵的分块结构，把 $A$ 表示为若尔当标准形的形式，再分别验证哈密尔顿-凯莱定理成立。</li></ul></li></ol><hr><p><strong>示例计算</strong> 假设我们有矩阵：<br>$$<br>A &#x3D; \begin{bmatrix} 2 &amp; 1 \\<br> 0 &amp; 3 \end{bmatrix}<br>$$</p><ol><li><p><strong>计算特征多项式</strong>：<br>$$<br>p_A(\lambda) &#x3D; \det(\lambda I - A) &#x3D; \begin{vmatrix} \lambda - 2 &amp; -1 \\ 0 &amp; \lambda - 3 \end{vmatrix}<br>$$</p><p>计算行列式：<br>$$<br>(\lambda - 2)(\lambda - 3)<br>$$</p><p>所以特征多项式为：</p><p>$$<br>p_A(\lambda) &#x3D; \lambda^2 - 5\lambda + 6<br>$$</p></li><li><p><strong>代入 $A$ 计算</strong>：</p><p>$$<br>A^2 - 5A + 6I &#x3D; \begin{bmatrix} 2 &amp; 1 \\ 0 &amp; 3 \end{bmatrix}^2 - 5 \begin{bmatrix} 2 &amp; 1 \\ 0 &amp; 3 \end{bmatrix} + 6 \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}<br>$$</p><p>计算 $A^2$：</p><p>$$<br>A^2 &#x3D; \begin{bmatrix} 4 &amp; 5 \\ 0 &amp; 9 \end{bmatrix}<br>$$</p><p>计算：</p><p>$$<br>A^2 - 5A + 6I &#x3D; \begin{bmatrix} 4 &amp; 5 \\ 0 &amp; 9 \end{bmatrix} - \begin{bmatrix} 10 &amp; 5 \\ 0 &amp; 15 \end{bmatrix} + \begin{bmatrix} 6 &amp; 0 \\ 0 &amp; 6 \end{bmatrix}<br>$$<br>$$<br>&#x3D; \begin{bmatrix} 0 &amp; 0 \\ 0 &amp; 0 \end{bmatrix}<br>$$</p><p>所以确实满足 $p_A(A) &#x3D; 0$。</p></li></ol><hr><p><strong>应用</strong></p><ol><li><p><strong>计算矩阵的幂</strong>：<br>由于 $p_A(A) &#x3D; 0$，可以将 $A^n$ 表示为 $A$ 的低次幂的线性组合，从而避免直接计算高次矩阵幂。</p></li><li><p><strong>求矩阵的逆</strong>：<br>若 $A$ 可逆，利用哈密尔顿-凯莱定理，可以通过特征多项式表示 $A^{-1}$：<br>$$<br>A^{-1} &#x3D; \frac{1}{c_0}(-c_1 I - c_2 A - \dots - c_{n-1} A^{n-1})<br>$$<br>这样可以避免高维矩阵的直接求逆运算。</p></li><li><p><strong>微分方程的求解</strong>：<br>在常微分方程中，矩阵指数 $e^{At}$ 可以用哈密尔顿-凯莱定理来化简计算。</p></li><li><p><strong>量子力学与物理学</strong>：<br>在量子力学和经典力学的哈密顿系统中，哈密尔顿-凯莱定理常用于求解动力学系统的演化方程。</p></li></ol><hr><p><strong>总结</strong></p><ul><li><strong>核心思想</strong>：每个矩阵都满足自己的特征多项式。</li><li><strong>证明方法</strong>：常用<strong>最小多项式法</strong>、<strong>行列式展开法</strong>、<strong>若尔当标准形法</strong>等。</li><li><strong>应用</strong>：计算矩阵的幂、求逆矩阵、求解微分方程、应用于物理等。</li></ul><h2 id="行列式的-Rank（秩）的几何意义"><a href="#行列式的-Rank（秩）的几何意义" class="headerlink" title="行列式的 Rank（秩）的几何意义"></a>行列式的 Rank（秩）的几何意义</h2><h3 id="1-线性相关性"><a href="#1-线性相关性" class="headerlink" title="1. 线性相关性"></a><strong>1. 线性相关性</strong></h3><p>矩阵的秩表示其行（或列）向量组的<strong>线性无关个数</strong>。如果一个矩阵的秩为 $r$，则意味着其中最多 $r$ 个行（或列）向量是线性无关的，而其余的行（或列）可以由这 $r$ 个向量线性表示。</p><ul><li>如果秩等于矩阵的行数（或列数），那么所有的行（或列）向量都是线性无关的，矩阵是<strong>满秩</strong>的。</li><li>如果秩小于行（或列）数，则矩阵的行（或列）向量是<strong>线性相关</strong>的，意味着其中的某些行（或列）可以用其他行（或列）表示。</li></ul><h3 id="2-维度与子空间"><a href="#2-维度与子空间" class="headerlink" title="2. 维度与子空间"></a><strong>2. 维度与子空间</strong></h3><p>矩阵 $A$ 的秩可以理解为由 $A$ 的列向量张成的<strong>列空间（Column Space）</strong>的维度，也可以理解为由 $A$ 的行向量张成的<strong>行空间（Row Space）</strong>的维度。</p><ul><li><strong>列秩（Column Rank）</strong>：列向量张成的向量空间的维度，表示矩阵映射的目标空间的维度。</li><li><strong>行秩（Row Rank）</strong>：行向量张成的向量空间的维度，表示矩阵映射的定义域的维度。</li></ul><p>根据<strong>基本定理</strong>，列秩和行秩总是相等，因此可以用<strong>矩阵的秩（Rank）</strong>来统一表示。</p><h3 id="3-线性变换的几何意义"><a href="#3-线性变换的几何意义" class="headerlink" title="3. 线性变换的几何意义"></a><strong>3. 线性变换的几何意义</strong></h3><p>在几何上，矩阵可以看作是一个<strong>线性变换</strong>，其秩表示该变换所能映射到的空间的维度。</p><ul><li><strong>满秩矩阵（Full Rank）</strong>：如果一个 $m \times n$ 矩阵 $A$ 的秩等于 $\min(m, n)$，则它表示的线性变换是<strong>最大维度</strong>的，即它能够映射到尽可能大的空间。</li><li><strong>降秩矩阵（Rank Deficient）</strong>：如果 $\operatorname{rank}(A) &lt; \min(m, n)$，说明 $A$ 作为一个线性变换时，会把某些维度“压缩”到更低维的空间，可能导致信息丢失或映射不可逆。</li></ul><h3 id="4-线性方程组解的情况"><a href="#4-线性方程组解的情况" class="headerlink" title="4. 线性方程组解的情况"></a><strong>4. 线性方程组解的情况</strong></h3><p>矩阵秩决定了线性方程组 $Ax &#x3D; b$ 的解的情况：</p><ul><li><strong>如果 $\operatorname{rank}(A) &#x3D; \operatorname{rank}([A | b])$<strong>，则系统</strong>有解</strong>。</li><li><strong>如果 $\operatorname{rank}(A) &lt; \operatorname{rank}([A | b])$<strong>，则系统</strong>无解</strong>（矛盾方程）。</li><li><strong>如果 $\operatorname{rank}(A) &#x3D; \operatorname{rank}([A | b]) &#x3D; n$<strong>（$A$ 是方阵且满秩），则系统有</strong>唯一解</strong>。</li><li><strong>如果 $\operatorname{rank}(A) &lt; n$，则系统有无穷多解</strong>（自由变量存在）。</li></ul><h3 id="5-低秩矩阵的几何解释"><a href="#5-低秩矩阵的几何解释" class="headerlink" title="5. 低秩矩阵的几何解释"></a><strong>5. 低秩矩阵的几何解释</strong></h3><ul><li><strong>秩 1 矩阵</strong>：所有列向量（或行向量）都在同一个方向上，矩阵仅表示一个单一方向的缩放。</li><li><strong>秩 2 矩阵</strong>：表示一个平面（二维空间）上的变换，例如剪切或旋转。</li><li><strong>秩 3 及以上</strong>：随着秩的增加，变换的自由度增加，表示更高维空间的映射。</li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><ol><li>秩表示矩阵的行或列向量的<strong>线性无关个数</strong>。</li><li>秩等于矩阵<strong>列空间（或行空间）的维度</strong>，决定了矩阵的线性变换能映射到的维度。</li><li>在几何上，矩阵的秩决定了它如何变换空间，例如投影、压缩、旋转等。</li><li>在线性方程组中，秩决定了方程组是否有解，以及解的个数。</li><li>低秩矩阵通常表示低维空间的结构，比如秩 1 矩阵对应单一方向的变换，秩 2 矩阵对应二维平面上的变换。</li></ol><h2 id="范德蒙行列式（Vandermonde-Determinant）"><a href="#范德蒙行列式（Vandermonde-Determinant）" class="headerlink" title="范德蒙行列式（Vandermonde Determinant）"></a><strong>范德蒙行列式（Vandermonde Determinant）</strong></h2><p>范德蒙行列式是线性代数中一个重要的行列式，在多项式插值、数值分析、群论和组合数学等领域都有广泛应用。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a><strong>1. 定义</strong></h3><p>范德蒙行列式是一个特殊形式的行列式，其元素由一组数的幂次构成：</p><p>$$<br>V(x_1, x_2, \dots, x_n) &#x3D;<br>\begin{vmatrix}<br>1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{n-1} \\<br>1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{n-1} \\<br>1 &amp; x_3 &amp; x_3^2 &amp; \cdots &amp; x_3^{n-1} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{n-1}<br>\end{vmatrix}<br>$$</p><p>该行列式的值称为<strong>范德蒙行列式</strong>（Vandermonde Determinant）。</p><h3 id="2-计算范德蒙行列式"><a href="#2-计算范德蒙行列式" class="headerlink" title="2. 计算范德蒙行列式"></a><strong>2. 计算范德蒙行列式</strong></h3><p>范德蒙行列式的值有一个标准的封闭表达式：</p><p>$$<br>V(x_1, x_2, \dots, x_n) &#x3D; \prod_{1 \leq i &lt; j \leq n} (x_j - x_i)<br>$$</p><p>即，范德蒙行列式等于所有数 $x_1, x_2, \dots, x_n$ 之间两两之差的乘积。</p><p><strong>示例：计算 $n&#x3D;3$ 的范德蒙行列式</strong><br>$$<br>V(x_1, x_2, x_3) &#x3D;<br>\begin{vmatrix}<br>1 &amp; x_1 &amp; x_1^2 \\<br>1 &amp; x_2 &amp; x_2^2 \\<br>1 &amp; x_3 &amp; x_3^2<br>\end{vmatrix}<br>$$</p><p>按照行列式的展开计算：<br>$$<br>V(x_1, x_2, x_3) &#x3D; (x_2 - x_1)(x_3 - x_1)(x_3 - x_2)<br>$$</p><p>与一般公式一致！</p><hr><h3 id="3-范德蒙行列式的性质"><a href="#3-范德蒙行列式的性质" class="headerlink" title="3. 范德蒙行列式的性质"></a><strong>3. 范德蒙行列式的性质</strong></h3><h4 id="1-反对称性"><a href="#1-反对称性" class="headerlink" title="(1) 反对称性"></a><strong>(1) 反对称性</strong></h4><p>范德蒙行列式的值对任意两行（或两列）交换后变号：<br>$$<br>V(\dots, x_i, x_j, \dots) &#x3D; -V(\dots, x_j, x_i, \dots)<br>$$<br>因此，如果有两个相同的 $x_i &#x3D; x_j$，则 $(x_j - x_i) &#x3D; 0$，导致整个行列式为零。这说明<strong>范德蒙行列式在变量相等时退化为零</strong>。</p><h4 id="2-递归性质"><a href="#2-递归性质" class="headerlink" title="(2) 递归性质"></a><strong>(2) 递归性质</strong></h4><p>$$<br>V(x_1, x_2, \dots, x_n) &#x3D;<br>V(x_1, x_2, \dots, x_{n-1}) \prod_{j&#x3D;1}^{n-1} (x_n - x_j)<br>$$<br>即，可以通过 $n-1$ 阶范德蒙行列式逐步计算出 $n$ 阶的结果。</p><h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a><strong>4. 应用</strong></h3><h4 id="1-多项式插值"><a href="#1-多项式插值" class="headerlink" title="(1) 多项式插值"></a><strong>(1) 多项式插值</strong></h4><p>在拉格朗日插值法中，范德蒙矩阵用于构造一组线性方程来求解插值系数。如果 $x_1, x_2, \dots, x_n$ 互不相同，则范德蒙矩阵是满秩的，因此该线性系统有唯一解。</p><h4 id="2-线性无关性"><a href="#2-线性无关性" class="headerlink" title="(2) 线性无关性"></a><strong>(2) 线性无关性</strong></h4><p>范德蒙矩阵的行（或列）是线性无关的，当且仅当 $x_i$ 互不相同。这一性质用于多项式插值和数值分析中判断点集是否能构成唯一的插值多项式。</p><h4 id="3-代数和组合数学"><a href="#3-代数和组合数学" class="headerlink" title="(3) 代数和组合数学"></a><strong>(3) 代数和组合数学</strong></h4><p>范德蒙行列式与<strong>牛顿插值公式</strong>、<strong>伽罗瓦理论</strong>、<strong>排列和置换的计数问题</strong>密切相关。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ul><li><strong>定义</strong>：范德蒙行列式是一个特殊的行列式，其元素由一组变量的幂构成。</li><li><strong>计算公式</strong>：<br>$$<br>V(x_1, x_2, \dots, x_n) &#x3D; \prod_{1 \leq i &lt; j \leq n} (x_j - x_i)<br>$$</li><li><strong>性质</strong>：<ul><li>反对称性：交换两行（或两列）后变号。</li><li>若存在 $x_i &#x3D; x_j$，则范德蒙行列式为 0。</li><li>可以递归计算。</li></ul></li><li><strong>应用</strong>：<ul><li><strong>多项式插值</strong>（如拉格朗日插值）</li><li><strong>线性无关性判断</strong></li><li><strong>代数与组合数学中的应用</strong></li></ul></li></ul><p>范德蒙行列式在数学和计算中扮演着重要角色，尤其在数值分析和代数结构中具有广泛的应用！</p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>三角函数&#x2F;反三角函数</p><h2 id="常见等价无穷小"><a href="#常见等价无穷小" class="headerlink" title="常见等价无穷小"></a>常见等价无穷小</h2>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Linear Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Top Interview 150</title>
    <link href="/2025/02/06/Leetcode-Hot-150/"/>
    <url>/2025/02/06/Leetcode-Hot-150/</url>
    
    <content type="html"><![CDATA[<p>Source: <a href="https://leetcode.com/studyplan/top-interview-150/">Top Interview 150</a></p><h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">88. Merge Sorted Array</a></h2><p>画蛇添足的做法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> que<span class="token punctuation">;</span>    <span class="token comment">// 使用一个最小堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 清空nums1中的元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 逐个弹出最小堆中的元素</span>            nums1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>暴力直接但能A过的做法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">+</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最希望看到的做法：#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 指向：排序后放入的位置</span>        <span class="token keyword">int</span> idx1 <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 指向：待排序的nums1的元素</span>        <span class="token keyword">int</span> idx2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 指向：待排序的nums2的元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>idx1 <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> idx2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 存在比较的情况</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token operator">></span> nums1<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span><span class="token punctuation">;</span>                idx2<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                                    nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">;</span>                idx1<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 剩下没放完nums2的情况</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>idx2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span><span class="token punctuation">;</span>            idx2<span class="token operator">--</span><span class="token punctuation">;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化过更好的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// nums1中还有元素能“挪动”的情况</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> nums1<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// nums1中没有元素能“挪动”的情况，因此不断放入nums2的元素</span>            <span class="token keyword">else</span> nums1<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150">27. Remove Element</a></h2><p>方法：#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 指向：不被移除的元素</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* i用来遍历一遍数组 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">26. Remove Duplicates from Sorted Array</a></h2><p>方法：#Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 指向需要放入的元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">++</span>k<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150">80. Remove Duplicates from Sorted Array II</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 指向放入的位置</span>        <span class="token keyword">int</span> duplicates_count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 记录重复元素个数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 元素相同的情况</span>                duplicates_count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>duplicates_count <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 重复个数超过2，跳过</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 不超过2，则放入指定位置</span>                    nums<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 不相同的情况，放入指定位置，重制重复元素个数</span>                duplicates_count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更简洁的代码:</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// 指向应该放入的位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 直接与前面第二个元素进行比较</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a><a href="https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150">169. Majority Element</a></h2><p>Solution: #Math</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Map</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>second <span class="token operator">></span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> it<span class="token punctuation">.</span>first<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Boyer-Moore 多数投票算法</p><ol><li>初始化：</li></ol><ul><li><code>candidate</code>：候选元素，初始为 0。</li><li><code>count</code>：计数器，初始为 0。</li></ul><ol start="2"><li>遍历数组：</li></ol><ul><li>如果 <code>count == 0</code>，则将当前元素设为候选元素 <code>candidate</code>。</li><li>如果当前元素等于 <code>candidate</code>，则 <code>count</code> 增加 1。</li><li>如果当前元素不等于 <code>candidate</code>，则 count 减少 1。</li></ul><ol start="3"><li>返回结果：</li></ol><ul><li>遍历结束后，<code>candidate</code> 就是多数元素。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> candidate <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> candidate <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> candidate<span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> candidate<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a><a href="https://leetcode.com/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150">189. Rotate Array</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>  <span class="token comment">// 用来拷贝原数组 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Math</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        k <span class="token operator">%=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>reverse</code>是<code>algorithm</code> 头文件中的一个标准函数,调用方式为:<code>reverse(起始迭代器, 结束迭代器);</code></p><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150">121. Best Time to Buy and Sell Stock</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> gap <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur_profit <span class="token operator">+</span> gap <span class="token operator">&lt;</span> gap<span class="token punctuation">)</span> cur_profit <span class="token operator">=</span> gap<span class="token punctuation">;</span>            <span class="token keyword">else</span> cur_profit <span class="token operator">+=</span> gap<span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> cur_profit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 0, -6, 4, -2, 3, -2</span><span class="token comment">// 0, -1, -2, -1, -2 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150">122. Best Time to Buy and Sell Stock II</a></h2><p>Solution: #DP<br>这里的DP数组含义<code>截止到i天，不持有/持有 股票时拥有的最大利润</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 第i天有股票的情况：i-1天无股票在i天买 or i-1天有股票在i天继续持有</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 第i天无股票的情况：i-1天无股票在i天不买 or i-1天有股票在i天卖</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 在n-1天没有股票是最好情况</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更加优化的方法：#Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 第i天贪心选择：卖 or 不卖 利润最大的情况</span>            profit <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>profit<span class="token punctuation">,</span> profit <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> profit<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.com/problems/jump-game/?envType=study-plan-v2&envId=top-interview-150">55. Jump Game</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> edge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 最大边界</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>edge <span class="token operator">&lt;</span> i<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 够不着下一个Index的情况</span>            <span class="token comment">/** 贪心维护最大边界 **/</span>            edge <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: 将上面的过程进行反推</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> goal <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/** 不断放缩可以达到边界的起点 **/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> goal<span class="token punctuation">)</span> goal <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> goal <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 判断最后放缩到的起点是否index = 0；</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150">45. Jump Game II</a></h2><p>这道题真的蛮有意思的，之前手撕出来了，时隔一段时间又来做又A不出来了…还是贪心的思路，贪心的选择最大边界，不过要维护一个当前边界和跳跃次数</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 计数</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 当前边界</span>        <span class="token keyword">int</span> farthest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 下一步可以达到的最远位置</span>        <span class="token keyword">int</span> goal <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 目标位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            farthest <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>farthest<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 计算当前能跳到的最大位置</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 到达当前边界，必须增加跳跃次数</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>                end <span class="token operator">=</span> farthest<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>end <span class="token operator">>=</span> goal<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 当前边界</span>        <span class="token keyword">int</span> next_end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 接下来的边界</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            next_end <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>next_end<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 贪心选择接下来的边界</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> cur_end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 循环到当前边界，需要更新接下来的边界</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>                cur_end <span class="token operator">=</span> next_end<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274. H-Index"></a><a href="https://leetcode.com/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150">274. H-Index</a></h2><p>Solution: #Brute Force</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">hIndex</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> citations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> citations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> nominate <span class="token operator">=</span> citations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前参照的元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nominate <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 跳过引用次数为0的元素</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 记录大于等于参照元素引用的个数</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> citations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>citations<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> nominate<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cnt <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nominate<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 取最小值</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 取最大值</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">hIndex</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> citations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从小到大排列</span>        <span class="token function">sort</span><span class="token punctuation">(</span>citations<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> citations<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> citations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 遍历找h-index</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>citations<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="380-Insert-Delete-GetRandom-O-1"><a href="#380-Insert-Delete-GetRandom-O-1" class="headerlink" title="380. Insert Delete GetRandom O(1)"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150">380. Insert Delete GetRandom O(1)</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RandomizedSet</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>  <span class="token comment">// 元素 : 放入位置</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>       <span class="token comment">// 存放元素</span>    <span class="token function">RandomizedSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vec<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 已放入的情况</span>        vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 放入的index</span>        mp<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>   <span class="token comment">// 记录位置</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 没放入的情况</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> mp<span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 获取放入的位置</span>        <span class="token keyword">int</span> last_element <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取最后一个元素</span>        vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> last_element<span class="token punctuation">;</span>  <span class="token comment">// 覆盖要删除的元素</span>        vec<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mp<span class="token punctuation">[</span>last_element<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>  <span class="token comment">// 记录调整的元素位置</span>        mp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 消除记录的位置</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 随机获取下标</span>        <span class="token keyword">return</span> vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj->insert(val); * bool param_2 = obj->remove(val); * int param_3 = obj->getRandom(); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238. Product of Array Except Self"></a><a href="https://leetcode.com/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150">238. Product of Array Except Self</a></h2><p> Solution: #前缀数组和后缀数组<br> <figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pre_product</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 前缀积</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            start <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            pre_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nxt_product</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 后缀积</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            end <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nxt_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> end<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ans</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pre_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nxt_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>优化后的代码如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ans</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a><a href="https://leetcode.com/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150">134. Gas Station</a></h2><p>纯暴力爆超时的做法(33&#x2F;39)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> gas<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> gas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">buff</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            buff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> candidates<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>buff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> candidates<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> candidates<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> idx<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> buff<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                sum <span class="token operator">+=</span> buff<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> idx<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Greedy</p><ul><li>遍历每个加油站：<ul><li>对于每个加油站，计算出从当前加油站到下一个加油站所需的油量：<code>curGas += (gas[i] - cost[i])</code>。</li><li>如果 <code>curGas</code> 变成了负值，意味着从当前加油站开始无法继续前进，因此将当前的起点更新为 <code>i + 1</code>，并且重置 <code>curGas</code> 为 0，尝试从下一个加油站作为起点重新开始。</li></ul></li></ul><p>这段代码的精妙之处在于：如果某一段的油量不足，前面的加油站不可能成为起点（因为从前一个加油站开始也不可能成功），所以可以跳过一段，直接从下一个加油站开始尝试。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> gas<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> gasSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> costSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            gasSum <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            costSum <span class="token operator">+=</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>gasSum <span class="token operator">&lt;</span> costSum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curGas <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            curGas <span class="token operator">+=</span> <span class="token punctuation">(</span>gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*如果累加起来的gas总量小于0，那么这一段都不能作为起点*/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curGas <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                  curGas <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 重新从当前点出发</span>                start <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 这里非常有数学意味</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> start<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode.com/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150">135. Candy</a></h2><p>Solution: #Greedy，从左到右遍历局部最优，从右到左局部最优</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">allo</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 每个元素的糖果分配情况</span>        allo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 从左到右分配</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> allo<span class="token punctuation">[</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 从右到左分配</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> allo<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> allo<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> allo<span class="token punctuation">)</span> sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-interview-150">42. Trapping Rain Water</a></h2><p>Solution: #Monotonic Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>   <span class="token comment">// 递增单调递减,存放index</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> mid<span class="token punctuation">;</span>                    <span class="token keyword">int</span> w <span class="token operator">=</span> i <span class="token operator">-</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                    sum <span class="token operator">+=</span> h <span class="token operator">*</span> w<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左右指针初始化</span>        <span class="token keyword">int</span> left_max <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> right_max <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化左右最大高度</span>        <span class="token keyword">int</span> water <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用来累积水量</span>                <span class="token comment">// 双指针遍历，直到左右指针相遇</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 更新左右最大值</span>            left_max <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>left_max<span class="token punctuation">,</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            right_max <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>right_max<span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 根据左右最大值的大小来决定移动哪一边的指针</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left_max <span class="token operator">&lt;</span> right_max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前位置的水量 = 左侧最大值 - 当前柱子高度</span>                water <span class="token operator">+=</span> left_max <span class="token operator">-</span> height<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前位置的水量 = 右侧最大值 - 当前柱子高度</span>                water <span class="token operator">+=</span> right_max <span class="token operator">-</span> height<span class="token punctuation">[</span>r<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> water<span class="token punctuation">;</span> <span class="token comment">// 返回总的水量</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a><a href="https://leetcode.com/problems/roman-to-integer/description/?envType=study-plan-v2&envId=top-interview-150">13. Roman to Integer</a></h2><p>Solution: 暴力的做法，直接打表</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token char">'I'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'V'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'X'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'L'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'D'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'M'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dmp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token string">"IV"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"IX"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"XL"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"XC"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"CD"</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"CM"</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> c1 <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">char</span> c2 <span class="token operator">=</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            string tmp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dmp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> dmp<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">;</span>                i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> mp<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化一下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>m<span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'I'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'V'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'X'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'L'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'C'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'D'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'M'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              ans<span class="token operator">-=</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">else</span><span class="token punctuation">&#123;</span>              ans<span class="token operator">+=</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a><a href="https://leetcode.com/problems/integer-to-roman/description/?envType=study-plan-v2&envId=top-interview-150">12. Integer to Roman</a></h2><p>Solution: #Hash Map, #Math</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">intToRoman</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        string s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"M"</span><span class="token punctuation">,</span> <span class="token string">"CM"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"CD"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"XC"</span><span class="token punctuation">,</span> <span class="token string">"L"</span><span class="token punctuation">,</span> <span class="token string">"XL"</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"IX"</span><span class="token punctuation">,</span> <span class="token string">"V"</span><span class="token punctuation">,</span> <span class="token string">"IV"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">>=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                num <span class="token operator">-=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                ans <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a><a href="https://leetcode.com/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150">58. Length of Last Word</a></h2><p>Solution: #STL</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        istringstream <span class="token function">iss</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        string words<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> vec<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iss <span class="token operator">>></span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> vec<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: 移动尾指针</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/*定位到最后一个单词末尾*/</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/*计算最后一个单词长度*/</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Flag</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> counting <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 开始计数的标志</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                counting <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                length<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>counting<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 停止计数</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a><a href="https://leetcode.com/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150">14. Longest Common Prefix</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> end <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 比对结束的标志</span>        <span class="token comment">/*暴力枚举第一个字符串的所有前缀*/</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*对每个字符串进行暴力比对*/</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    end <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> ans <span class="token operator">+=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Sort, #Double Pointers</p><ul><li>如果这些两个字符串有共同前缀，那么整个数组中的所有字符串也会有相同的前缀。因此，只需要比较数组中最小和最大字符串的前缀即可。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string firstStr <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        string lastStr <span class="token operator">=</span> strs<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">min</span><span class="token punctuation">(</span>firstStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lastStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>firstStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> lastStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> firstStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150">151. Reverse Words in a String</a></h2><p>Solution: #STL</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string word<span class="token punctuation">;</span>        istringstream <span class="token function">iss</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> vec<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iss <span class="token operator">>></span> word<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 遍历完单词的情况</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ans<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> tmp <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> ans<span class="token punctuation">;</span> <span class="token comment">// 不是第一个单词的情况</span>                    <span class="token keyword">else</span> ans <span class="token operator">=</span> tmp<span class="token punctuation">;</span>   <span class="token comment">// 是第一个单词的情况</span>                    tmp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> tmp <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 还剩下最后一个单词</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ans<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> tmp <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> ans<span class="token punctuation">;</span>  <span class="token comment">// 不是第一个单词的情况</span>            <span class="token keyword">else</span> ans <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token comment">// 第一个单词的情况</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一步：整体反转字符串</span>        <span class="token keyword">bool</span> wordStart <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 标记是否正在处理一个单词</span>        <span class="token comment">// 使用 fast 指针遍历字符串</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 找到一个单词的开始</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>wordStart <span class="token operator">&amp;&amp;</span> slow <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span>  <span class="token comment">// 如果已经找到一个单词，且不是字符串开头，加空格分隔单词</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> start <span class="token operator">=</span> fast<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>fast<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 把当前单词复制到新的位置</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 反转单词：把已复制的单词部分反转回来</span>                <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> slow <span class="token operator">-</span> <span class="token punctuation">(</span>fast <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span>                wordStart <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 标记已经找到了一个单词</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 调整字符串的大小，去掉多余的部分</span>        s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="6-Zigzag-Conversion"><a href="#6-Zigzag-Conversion" class="headerlink" title="6. Zigzag Conversion"></a><a href="https://leetcode.com/problems/zigzag-conversion/description/?envType=study-plan-v2&envId=top-interview-150">6. Zigzag Conversion</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>numRows <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> mp<span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> flop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 控制反转。初始化为false</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*到达边界的时候，则需要反转*/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> r <span class="token operator">==</span> numRows <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> flop <span class="token operator">=</span> <span class="token operator">!</span>flop<span class="token punctuation">;</span>            mp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flop<span class="token punctuation">)</span> r<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans<span class="token punctuation">;</span>          vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">temp</span><span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*模拟从上到下的遍历过程*/</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numRows <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/*模拟从下到上的过程*/</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> numRows <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="28-Find-the-Index-of-the-First-Occurrence-in-a-String"><a href="#28-Find-the-Index-of-the-First-Occurrence-in-a-String" class="headerlink" title="28. Find the Index of the First Occurrence in a String"></a><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150">28. Find the Index of the First Occurrence in a String</a></h2><p>Solution: <code>string</code>类成员函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> haystack<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正规的做法：#Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token keyword">else</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：枚举子串进行比较</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> needle<span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68. Text Justification"></a><a href="https://leetcode.com/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150">68. Text Justification</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">fullJustify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">,</span> <span class="token keyword">int</span> maxWidth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> result<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> currentLine<span class="token punctuation">;</span>  <span class="token comment">// 用来存储当前行的单词，直到该行的长度超过 maxWidth。</span>        <span class="token keyword">int</span> currentLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前行中所有单词的总长度（不包括空格）</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> word <span class="token operator">:</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/* 判断当前行加上当前单词是否会超出 maxWidth */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>currentLength <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> maxWidth<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">/* 计算当前行需要的空格*/</span>                <span class="token keyword">int</span> spaces <span class="token operator">=</span> maxWidth <span class="token operator">-</span> currentLength<span class="token punctuation">;</span>                <span class="token comment">/* 如果当前行只有一个单词，直接左对齐，空格填充右侧 */</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>currentLine<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>spaces<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token comment">/* 均匀分配空格 */</span>                    <span class="token keyword">int</span> evenSpace <span class="token operator">=</span> spaces <span class="token operator">/</span> <span class="token punctuation">(</span>currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 每个空格应该有的基本数量</span>                    <span class="token keyword">int</span> extraSpace <span class="token operator">=</span> spaces <span class="token operator">%</span> <span class="token punctuation">(</span>currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 剩余空格数量</span>                    string line <span class="token operator">=</span> currentLine<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">/* 分配空格 */</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> extraSpace<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            line <span class="token operator">+=</span> <span class="token function">string</span><span class="token punctuation">(</span>evenSpace <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">+</span> currentLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                            line <span class="token operator">+=</span> <span class="token function">string</span><span class="token punctuation">(</span>evenSpace<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">+</span> currentLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">/* 清空当前行的单词和长度，准备下一行 */</span>                currentLine<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                currentLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 将当前单词加入到当前行 */</span>            currentLine<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            currentLength <span class="token operator">+=</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 处理最后一行，左对齐 */</span>        string lastLine <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            lastLine <span class="token operator">+=</span> currentLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                lastLine <span class="token operator">+=</span> <span class="token string">" "</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        lastLine <span class="token operator">+=</span> <span class="token function">string</span><span class="token punctuation">(</span>maxWidth <span class="token operator">-</span> lastLine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lastLine<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a><a href="https://leetcode.com/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150">125. Valid Palindrome</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">converString</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 清楚标点和大小写转换</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token char">'A'</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token char">'A'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> gap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token char">'a'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'z'</span> <span class="token operator">||</span> <span class="token char">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ss <span class="token operator">=</span> <span class="token function">converString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> ss<span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> tmp <span class="token operator">==</span> ss<span class="token punctuation">;</span>  <span class="token comment">// 反转后的字符串和反转前字符串比较</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：#Tow Pointers, 使用双指针和类成员函数优化后的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isalnum</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isalnum</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392. Is Subsequence"></a><a href="https://leetcode.com/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150">392. Is Subsequence</a></h2><p>Solution: #Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的双指针写法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>sptr <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tptr <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>sptr<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>tptr<span class="token punctuation">]</span><span class="token punctuation">)</span> sptr<span class="token operator">++</span><span class="token punctuation">;</span>            tptr<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sptr <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：#DP，也可以强行用动态规划来做</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* dp数组：当前两个字符串的子串所匹配的最大长度 */</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> n<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/?envType=study-plan-v2&envId=top-interview-150">167. Two Sum II - Input Array Is Sorted</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/* 由小到大的index顺序 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>target <span class="token operator">-</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mp<span class="token punctuation">[</span>target <span class="token operator">-</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>target <span class="token operator">-</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 没找到匹配才建立映射，顺序不能在if执行之前*/</span>            mp<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更精简的写法：#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-interview-150">11. Container With Most Water</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> r <span class="token operator">-</span> l<span class="token punctuation">;</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> w <span class="token operator">*</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 优先移动高最小的边界 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><a href="https://leetcode.com/problems/3sum/description/?envType=study-plan-v2&envId=top-interview-150">15. 3Sum</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*对目标元素进行去重*/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/*对左右指针去重*/</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>                    l<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>r <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>                    r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. Minimum Size Subarray Sum</a></h2><p>Solution: #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">/* 当前和大于target则移动窗口左边界 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>sum <span class="token operator">>=</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> subLength <span class="token operator">=</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> subLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150">3. Longest Substring Without Repeating Characters</a></h2><p>Solution: #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/* 果字符已存在于集合中，移动左边界 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            length <span class="token operator">=</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30. Substring with Concatenation of All Words"></a><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&envId=top-interview-150">30. Substring with Concatenation of All Words</a></h2><p>Solution: #Brute Force, #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">checkSubstring</span><span class="token punctuation">(</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> wordCount<span class="token punctuation">,</span> string s<span class="token punctuation">,</span> <span class="token keyword">int</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> wordLen <span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 确保不会越界</span>            string w <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>wordCount<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">!=</span> wordCount<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>wordCount<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>                unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> wordCount<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> words<span class="token punctuation">)</span> wordCount<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> wordLen <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> subLen <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> wordLen<span class="token punctuation">;</span>                <span class="token comment">// 如果子串长度超过原字符串长度，直接返回空结果</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>subLen <span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> subLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">checkSubstring</span><span class="token punctuation">(</span>wordCount<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> subLen<span class="token punctuation">)</span><span class="token punctuation">,</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：#Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> words<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token keyword">int</span> wordLength <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> wordCount <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> totalLength <span class="token operator">=</span> wordLength <span class="token operator">*</span> wordCount<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>totalLength <span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token comment">// 统计words中每个单词出现的次数</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> wordFreq<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> word <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            wordFreq<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 对每个可能的起始位置进行处理（由于单词长度可能大于1，需要考虑不同的偏移）</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">&lt;</span> wordLength<span class="token punctuation">;</span> offset<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 对于每个偏移量，使用滑动窗口</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> offset<span class="token punctuation">;</span>            unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> currentFreq<span class="token punctuation">;</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 窗口内有效单词数量</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> offset<span class="token punctuation">;</span> right <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> wordLength<span class="token punctuation">;</span> right <span class="token operator">+=</span> wordLength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                string currentWord <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> wordLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 如果当前单词不在words中，重置窗口</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>wordFreq<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>currentWord<span class="token punctuation">)</span> <span class="token operator">==</span> wordFreq<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    currentFreq<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    left <span class="token operator">=</span> right <span class="token operator">+</span> wordLength<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                                <span class="token comment">// 增加当前单词的计数</span>                currentFreq<span class="token punctuation">[</span>currentWord<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                                <span class="token comment">// 如果当前单词出现次数过多，缩小窗口直到匹配</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>currentFreq<span class="token punctuation">[</span>currentWord<span class="token punctuation">]</span> <span class="token operator">></span> wordFreq<span class="token punctuation">[</span>currentWord<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    string leftWord <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> wordLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                    currentFreq<span class="token punctuation">[</span>leftWord<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    left <span class="token operator">+=</span> wordLength<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                                <span class="token comment">// 如果窗口大小正好等于所有单词的总数，找到一个匹配</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> wordCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        <span class="token comment">// 移动窗口左边界，继续寻找下一个匹配</span>                    string leftWord <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> wordLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                    currentFreq<span class="token punctuation">[</span>leftWord<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    left <span class="token operator">+=</span> wordLength<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-interview-150">76. Minimum Window Substring</a></h2><p>Solution: #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">minWindow</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> charCount<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> t<span class="token punctuation">)</span> charCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 记录t中字符出现的次数</span>        <span class="token keyword">int</span> required <span class="token operator">=</span> charCount<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需要匹配的字符种类</span>        <span class="token keyword">int</span> formed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 已匹配成功的字符种类</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minLen <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// Start index of minimum window</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> windowCount<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>charCount<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> charCount<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> charCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                formed<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 成功匹配完一类字符</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 尝试缩小滑动窗口 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> formed <span class="token operator">==</span> required<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                c <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> minLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    minLen <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    start <span class="token operator">=</span> left<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>charCount<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> charCount<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> charCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    formed<span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token comment">// 匹配次数减少，导致匹配字符类型数-1</span>                <span class="token punctuation">&#125;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> minLen <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> minLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a><a href="https://leetcode.com/problems/valid-sudoku/description/?envType=study-plan-v2&envId=top-interview-150">36. Valid Sudoku</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">/* 判断当前字符是否是1～9 */</span>    <span class="token keyword">bool</span> <span class="token function">isValidChar</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token char">'1'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 检查 3x3 的格子是否有重复数字 */</span>    <span class="token keyword">bool</span> <span class="token function">checkBox</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> y<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> y <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> c <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValidChar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> row<span class="token punctuation">;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> col<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 检查行</span>            row<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> c <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValidChar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>row<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> row<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    row<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 检查列</span>            col<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> c <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValidChar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>col<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> col<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    col<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 检查3x3的小格子</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">checkBox</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table, 更加优化的方法，只用遍历一次数组，采用打表记录的方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用3个9x9的布尔数组，分别记录行、列和方格中数字的出现情况</span>        <span class="token keyword">bool</span> row<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// row[i][j]表示第i行是否出现数字j+1</span>        <span class="token keyword">bool</span> col<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// col[i][j]表示第i列是否出现数字j+1</span>        <span class="token keyword">bool</span> box<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// box[i][j]表示第i个方格是否出现数字j+1</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'.'</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                                <span class="token keyword">int</span> num <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'1'</span><span class="token punctuation">;</span>  <span class="token comment">// 将字符转为0-8的索引</span>                <span class="token keyword">int</span> box_index <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> j <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// 计算当前位置属于哪个3x3方格</span>                                <span class="token comment">// 检查当前数字在行、列、方格中是否已经出现过</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">||</span> col<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">||</span> box<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                                <span class="token comment">// 标记数字已出现</span>                row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                col<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                box<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a><a href="https://leetcode.com/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150">54. Spiral Matrix</a></h2><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 设置边界</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 从右到左（需要检查top &lt;= bottom）</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span> j <span class="token operator">>=</span> left<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                bottom<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 从下到上（需要检查left &lt;= right）</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">>=</span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// line</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// column</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">&lt;</span> bottom <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">></span> left<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">></span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            bottom<span class="token operator">--</span><span class="token punctuation">;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a><a href="https://leetcode.com/problems/rotate-image/description/?envType=study-plan-v2&envId=top-interview-150">48. Rotate Image</a></h2><p>Solution: #Queue，开一个队列把所有数装进来…</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方案，不用开辟新的空间。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 先转置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 再反转</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">reverse</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a><a href="https://leetcode.com/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-interview-150">73. Set Matrix Zeroes</a></h2><p>Solution: #Brute Force</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setZeroes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> row<span class="token punctuation">;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> col<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    row<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    col<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> row<span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> j <span class="token operator">:</span> col<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setZeroes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> firstRowZero <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> firstColZero <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 记录第一列是否有0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> firstColZero <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 记录第一行是否有0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> firstRowZero <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 遍历整个矩阵，用第一行和第一列记录 0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>firstRowZero<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>firstColZero<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="289-Game-of-Life"><a href="#289-Game-of-Life" class="headerlink" title="289. Game of Life"></a><a href="https://leetcode.com/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150">289. Game of Life</a></h2><p>Solution: #Brute Force，对每一个点逐一检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">Alive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> bottom <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> bottom <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> curAlive <span class="token operator">=</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>curAlive <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>curAlive <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>curAlive <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>curAlive <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> tmp <span class="token operator">=</span> board<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Alive</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        board <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：</p><ul><li><code>-1</code> 表示 活细胞变死（即原本是 <code>1</code>，但根据规则变成<code>0</code>）</li><li><code>2</code> 表示 死细胞变活（即原本是 <code>0</code>，但根据规则变成<code>1</code>）。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> directions <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 方向数组，表示相邻八个方向的移动</span>        <span class="token comment">// 遍历计算每个细胞的状态</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> liveNeighbors <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dx <span class="token operator">:</span> directions<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dy <span class="token operator">:</span> directions<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>dx <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 跳过自身</span>                        <span class="token keyword">int</span> ni <span class="token operator">=</span> i <span class="token operator">+</span> dx<span class="token punctuation">,</span> nj <span class="token operator">=</span> j <span class="token operator">+</span> dy<span class="token punctuation">;</span>                        <span class="token comment">// 原地修改，注意找活细胞要用绝对值</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>ni <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ni <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> nj <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nj <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token function">abs</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>ni<span class="token punctuation">]</span><span class="token punctuation">[</span>nj<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            liveNeighbors<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>liveNeighbors <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> liveNeighbors <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 1 -> 0</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> liveNeighbors <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 0 -> 1</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.com/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150">383. Ransom Note</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span>string ransomNote<span class="token punctuation">,</span> string magazine<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>  <span class="token comment">// 统计magazine中字符出现次数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> magazine<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> ransomNote<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 字符不存在</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 字符不够用</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205. Isomorphic Strings"></a><a href="https://leetcode.com/problems/isomorphic-strings/description/?envType=study-plan-v2&envId=top-interview-150">205. Isomorphic Strings</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isIsomorphic</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>              <span class="token comment">// 记录已经被map的字符</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 如果有记录</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 没有记录的情况</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化过的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isIsomorphic</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> sc <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">char</span> tc <span class="token operator">=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>sc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 映射不正确</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">!=</span> tc<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> pair <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 检查是否映射冲突</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>pair<span class="token punctuation">.</span>second <span class="token operator">==</span> tc<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                mp<span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">=</span> tc<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="290. Word Pattern"></a><a href="https://leetcode.com/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150">290. Word Pattern</a></h2><p>Solution:# Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">wordPattern</span><span class="token punctuation">(</span>string pattern<span class="token punctuation">,</span> string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> string<span class="token operator">></span> mp<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> words<span class="token punctuation">;</span>        string tmp<span class="token punctuation">;</span>        istringstream <span class="token function">iss</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iss <span class="token operator">>></span> tmp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            words<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token comment">// 比对数量不对等</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> pc <span class="token operator">=</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>pc<span class="token punctuation">]</span> <span class="token operator">!=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>pair str <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 检查是否有冲突映射</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>second <span class="token operator">==</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                mp<span class="token punctuation">[</span>pc<span class="token punctuation">]</span> <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.com/problems/valid-anagram/description/?envType=study-plan-v2&envId=top-interview-150">242. Valid Anagram</a></h2><p>Solution: #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s <span class="token operator">==</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">int</span> kinds <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 记录字符种类</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                kinds<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> kinds<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 匹配完一种字符</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> kinds <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table，优化后的映射</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            count<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            count<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> num <span class="token operator">:</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a><a href="https://leetcode.com/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-interview-150">49. Group Anagrams</a></h2><p>Solution: #Hash Table, #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ump<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string tmp <span class="token operator">=</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// sort调整顺序</span>            ump<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> ump<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vector<span class="token operator">&lt;</span>string<span class="token operator">></span> vec<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> idx <span class="token operator">:</span> it<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> s <span class="token operator">:</span> strs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string t <span class="token operator">=</span> s<span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>手搓哈希映射的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> s <span class="token operator">:</span> strs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token operator">></span> count <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                count<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            string key<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                key <span class="token operator">+=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"#"</span><span class="token punctuation">;</span>  <span class="token comment">// 避免哈希冲突</span>            <span class="token punctuation">&#125;</span>            ans<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> result<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> entry <span class="token operator">:</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/description/?envType=study-plan-v2&envId=top-interview-150">1. Two Sum</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>   <span class="token comment">// value : index</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>mp<span class="token punctuation">[</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> v<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 记录初始位置</span>        <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 双指针初始化</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">+</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">,</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">+</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">></span> target<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.com/problems/happy-number/description/?envType=study-plan-v2&envId=top-interview-150">202. Happy Number</a></h2><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 计算每个digit的平方和</span>        string tmp <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tmp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>   <span class="token comment">// 检查是否有loop出现</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                n <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法，使用快慢指针。#Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 更优质的计算</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>                    <span class="token comment">// 快慢指针</span>            slow <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>fast<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219. Contains Duplicate II"></a><a href="https://leetcode.com/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150">219. Contains Duplicate II</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">containsNearbyDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>   <span class="token comment">// value : 最近一次出现的index</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化的解法#Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">containsNearbyDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> window<span class="token punctuation">;</span>   <span class="token comment">// 维护滑动窗口内的元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            window<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> window<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 维护窗口大小</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-interview-150">128. Longest Consecutive Sequence</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 去重</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token operator">*</span>st<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 取第一个元素</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 向左寻找连续序列</span>                st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 向右寻找连续序列</span>                st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            result <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">st</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用 HashSet 存储去重后的元素</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> st<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 没有向左连续的情况，那么直接向右找连续元素</span>                <span class="token keyword">int</span> currNum <span class="token operator">=</span> x<span class="token punctuation">;</span>                <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>currNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    currNum<span class="token operator">++</span><span class="token punctuation">;</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                result <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228. Summary Ranges"></a><a href="https://leetcode.com/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150">228. Summary Ranges</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">summaryRanges</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 找出连续区间的结束位置</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"->"</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a href="https://leetcode.com/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-interview-150">56. Merge Intervals</a></h2><p>Solution: #Greedy, #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 不合并区间</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 合并区间的情况</span>                ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以稍微优化一下</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 使用lambda表达式简化排序</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 只需按起始点排序即可</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>                result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 检查是否可以合并</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 合并区间</span>                result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 添加新区间</span>                result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/description/?envType=study-plan-v2&envId=top-interview-150">57. Insert Interval</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">insert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> newInterval<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：#Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">insert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> newInterval<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&envId=top-interview-150">452. Minimum Number of Arrows to Burst Balloons</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> points<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                end <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                end <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-interview-150">20. Valid Parentheses</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'['</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'&#123;'</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'&#125;'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'&#123;'</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">']'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'['</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span> mp <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token char">'('</span><span class="token punctuation">,</span> <span class="token char">')'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token char">'&#123;'</span><span class="token punctuation">,</span> <span class="token char">'&#125;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token char">'['</span><span class="token punctuation">,</span> <span class="token char">']'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mp<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a><a href="https://leetcode.com/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150">71. Simplify Path</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">simplifyPath</span><span class="token punctuation">(</span>string path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span>string<span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            string word<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                word <span class="token operator">+=</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        string ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ans<span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">simplifyPath</span><span class="token punctuation">(</span>string path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 跳过 '/'</span>            string word<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span> word <span class="token operator">+=</span> path<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">"."</span> <span class="token operator">||</span> word<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">".."</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        string ans <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> st<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/description/?envType=study-plan-v2&envId=top-interview-150">155. Min Stack</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>    <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vec<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vec<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> vec<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minn <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> vec<span class="token punctuation">)</span> minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minn<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> minn<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> st<span class="token punctuation">;</span>  <span class="token comment">// 放入元素 ： 当前栈的最小元素</span>    <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>val<span class="token punctuation">,</span> val<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>val<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 维护栈顶的最小值</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&envId=top-interview-150">150. Evaluate Reverse Polish Notation</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stNum<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> s <span class="token operator">:</span> tokens<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'-'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stNum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    b <span class="token operator">=</span> stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stNum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    a <span class="token operator">=</span> stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>string c <span class="token operator">:</span> tokens<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"+"</span><span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">"-"</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> nums2 <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> nums1 <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">+</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">-</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">*</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">/</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">stoi</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="224-Basic-Calculator"><a href="#224-Basic-Calculator" class="headerlink" title="224. Basic Calculator"></a><a href="https://leetcode.com/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150">224. Basic Calculator</a></h2><p>Solution: #Stack, #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// 结果变量，存储当前计算的总和</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// 记录当前解析的数字</span>        <span class="token keyword">int</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 记录当前的符号，初始为正（1 代表正，-1 代表负）</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>     <span class="token comment">// 栈用于存储括号内的符号作用</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化栈，默认作用域符号为 1（正号）</span>        <span class="token comment">// 遍历字符串中的每个字符</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 如果是数字，构造当前数字（支持多位数）</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 遇到左括号 '('，表示进入新的作用域，将当前作用域的 sign 存入栈</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 遇到右括号 ')'，表示离开当前作用域，弹出栈顶的 sign</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 遇到加号 '+' 或减号 '-'，进行计算</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>  <span class="token comment">// 先计算前面解析的数字并累加到 ans</span>                sign <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新当前符号，受括号作用域影响</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 归零，准备解析下一个数字</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 处理最后一个数字</span>        <span class="token keyword">return</span> ans <span class="token operator">+</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用两个栈的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> numStack<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> opStack<span class="token punctuation">;</span> <span class="token comment">// 1 代表 '+', -1 代表 '-'</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span> <span class="token comment">// 计算当前数字</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                sign <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                numStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                opStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span> <span class="token comment">// 计算括号内的最后一个数</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                ans <span class="token operator">*=</span> opStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> opStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理括号前的符号</span>                ans <span class="token operator">+=</span> numStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> numStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 叠加之前的计算结果</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans <span class="token operator">+</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span> <span class="token comment">// 计算最后一个数</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-interview-150">141. Linked List Cycle</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token operator">!=</span> st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a><a href="https://leetcode.com/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150">2. Add Two Numbers</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 递归获取链表长度</span>    <span class="token keyword">int</span> <span class="token function">listLength</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">listLength</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> size1 <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size2 <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size1 <span class="token operator">&lt;</span> size2<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 保证l1是最长的链表;</span>        ListNode<span class="token operator">*</span> cur1 <span class="token operator">=</span> l1<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cursum<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> last <span class="token operator">=</span> l1<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cursum <span class="token operator">=</span> cur1<span class="token operator">-></span>val <span class="token operator">+</span> cur2<span class="token operator">-></span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>            cur1<span class="token operator">-></span>val <span class="token operator">=</span> cursum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            carry <span class="token operator">=</span> cursum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> cur1<span class="token punctuation">;</span>            cur1 <span class="token operator">=</span> cur1<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur2 <span class="token operator">=</span> cur2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cursum <span class="token operator">=</span> cur1<span class="token operator">-></span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>            cur1<span class="token operator">-></span>val <span class="token operator">=</span> cursum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            carry <span class="token operator">=</span> cursum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> cur1<span class="token punctuation">;</span>            cur1 <span class="token operator">=</span> cur1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>carry <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> last<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：使用虚拟头节点</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> p1 <span class="token operator">=</span> l1<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> p2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">?</span> p1<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>p2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">?</span> p2<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span>            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> p1 <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> p2 <span class="token operator">=</span> p2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Formal Language and Automata</title>
    <link href="/2025/01/08/automata/"/>
    <url>/2025/01/08/automata/</url>
    
    <content type="html"><![CDATA[<h1 id="Formal-Language-and-Automata"><a href="#Formal-Language-and-Automata" class="headerlink" title="Formal Language and Automata"></a>Formal Language and Automata</h1><p>关于形式语言与自动机技术这门课我认为内容非常的少，考生只需要掌握正则语言，上下文无关语言以及其对应的自动机模型就可以了。自动机里面的状态转移图和数字电路中的时序电路设计有异曲同工之妙。我觉得这门课是一门很需要脑筋急转弯的课程…To learn this course, you have to preview <code>Data Structure &amp; Algorithm</code></p><p><strong>Reference：</strong></p><ol><li>哈工大Mooc by 王春雨</li><li>MIT Sisper</li></ol><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>形式语言与自动机技术这门课的内容包括：</p><ul><li>形式语言：定义计算语言的方式（正则语言、上下文无关语言等）。</li><li>自动机：描述语言识别的数学模型（有限自动机、下推自动机等）。</li><li>计算理论：讨论问题是否可以通过算法解决（可计算性）以及解决问题的资源消耗（复杂性）。</li></ul><p>首先在学习这门课，我们需要认识一些自动机所需要的一些表示方法。这些表示方法在我们的有穷自动机和下推自动机同样适用。</p><h3 id="1-1-字母表（Alphabet）"><a href="#1-1-字母表（Alphabet）" class="headerlink" title="1.1 字母表（Alphabet）"></a>1.1 字母表（Alphabet）</h3><p>在形式语言与自动机中，<strong>字母表（Alphabet）</strong> 是一个基本的概念，它是用于构造语言的最小组成单位。字母表（通常记为 $\Sigma$）是一个<strong>有限的符号集合</strong>，其中的每个符号称为一个<strong>字母</strong>。</p><p>例如：</p><ul><li>$\Sigma &#x3D; \{a, b\}$ 表示一个字母表，包含两个字母 $a$ 和 $b$。</li><li>$\Sigma &#x3D; \{0, 1\}$ 表示一个二进制字母表。</li><li>$\Sigma &#x3D; \{x, y, z\}$ 表示一个包含三个符号的字母表。</li></ul><p>字母表是<strong>字符串</strong>和<strong>语言</strong>的基础：</p><ol><li><p><strong>字符串</strong>：是由字母表中的符号按一定顺序排列而成的有限序列。</p><ul><li>例如：对 $\Sigma &#x3D; \{a, b\}$，字符串可以是 $a$, $b$, $ab$, $bba$ 等。</li><li>空字符串用 $\epsilon$ 表示，表示长度为 0 的字符串。</li></ul></li><li><p><strong>语言</strong>：是字母表上所有字符串的某个子集。</p><ul><li>例如：对于 $\Sigma &#x3D; \{a, b\}$，语言可以是所有以 $a$ 开头的字符串 $\{a, ab, abb, \dots\}$。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li>字母表是有限的，但基于字母表生成的字符串集合可能是<strong>无限的</strong>。</li><li>字母表的大小和定义取决于具体问题的需求。</li></ul><h3 id="1-2-字符串（String）"><a href="#1-2-字符串（String）" class="headerlink" title="1.2 字符串（String）"></a>1.2 字符串（String）</h3><p>在形式语言与自动机中，<strong>字符串（String）</strong> 是一个由字母表中符号按一定顺序排列而成的<strong>有限序列</strong>。字符串的定义如下</p><ol><li><p>给定字母表 $\Sigma$（一个有限符号集合），字符串是由 $\Sigma$ 中的符号组成的一个<strong>有限长度序列</strong>。</p><ul><li>例如：若 $\Sigma &#x3D; \{a, b\}$，字符串可以是 $a$, $b$, $ab$, $bba$ 等。</li></ul></li><li><p>字符串的<strong>长度</strong>是序列中符号的个数，记为 $|w|$，其中 $w$ 是字符串。</p><ul><li>例如：若 $w &#x3D; abba$，则 $|w| &#x3D; 4$。</li></ul></li><li><p>特殊情况：<strong>空字符串</strong>表示长度为 $0$ 的字符串，用符号 $\epsilon$ 表示。</p><ul><li>$\epsilon$ 是唯一的长度为 $0$ 的字符串，即 $|\epsilon| &#x3D; 0$。</li><li>注意，$\epsilon \notin \Sigma$ ，下面简单辨析一下<ul><li>字母表 $\Sigma$ 是一个有限符号的集合，表示语言构造的基本单位。它仅包含单个符号，不包括空字符串。</li><li>空字符串 $\epsilon$ 是字符串的概念，它表示一个长度为 $0$ 的特殊字符串，而不是字母表中的符号。</li></ul></li></ul></li></ol><p><strong>常见的字符串的操作:</strong></p><ol><li><p><strong>连接</strong>：将两个字符串首尾相接形成新字符串。</p><ul><li>若 $w_1 &#x3D; ab$ 且 $w_2 &#x3D; ba$，则 $w_1w_2 &#x3D; abba$。</li></ul></li><li><p><strong>幂运算</strong>：将字符串自身重复多次，记为 $w^n$（$n \geq 0$）。</p><ul><li>例如：若 $w &#x3D; ab$，则 $w^0 &#x3D; \epsilon$，$w^1 &#x3D; ab$，$w^2 &#x3D; abab$。</li></ul></li><li><p><strong>反转</strong>：将字符串的符号顺序倒置。</p><ul><li>例如：若 $w &#x3D; abba$，则 $w^R &#x3D; abba$。</li></ul></li></ol><p>下文会对常见的字符串操作进行详细推导。</p><p><strong>字符串与语言的区别</strong></p><ul><li>字符串是语言的基本组成单位。</li><li><strong>语言（Language）</strong> 是字母表上所有可能字符串的某个子集。</li></ul><p>示例</p><ul><li>若 $\Sigma &#x3D; \{0, 1\}$，可能的字符串包括：$0$, $1$, $01$, $10$, $001$, 等。</li><li>空字符串 $\epsilon$ 始终是 $\Sigma^*$  的成员（ $\Sigma^*$  是所有字符串的集合）。</li></ul><hr><h4 id="1-2-1-字符串长度的定义"><a href="#1-2-1-字符串长度的定义" class="headerlink" title="1.2.1 字符串长度的定义"></a>1.2.1 字符串长度的定义</h4><p>在形式语言与自动机理论中，字符串长度是指字符串中所包含的字符个数。设 $\Sigma$ 是一个字母表（字符的有限集合），一个字符串 $w$ 是由字母表中字符的有限序列。字符串的长度用 $|w|$ 表示，其含义是 $w$ 中字符的个数：</p><ul><li><strong>空字符串</strong> $\varepsilon$：长度为 $0$，即 $|\varepsilon| &#x3D; 0$。</li><li><strong>非空字符串</strong>：长度为字符串中所有字符的个数。</li></ul><p>例如：</p><ul><li>$w &#x3D; \text{abc}$，则 $|w| &#x3D; 3$；</li><li>$w &#x3D; \varepsilon$，则 $|w| &#x3D; 0$。</li></ul><p>字符串长度 $|w|$ 可以通过<strong>递归方式</strong>定义如下：</p><ol><li><p><strong>基例</strong>（Base case）：<br>如果 $w &#x3D; \varepsilon$（空字符串），那么 $|w| &#x3D; 0$。</p></li><li><p><strong>递归关系</strong>（Recursive case）：<br>如果 $w &#x3D; xa$，其中 $x \in \Sigma^*$（是字母表 $\Sigma$ 的某个字符串）且 $a \in \Sigma$（是字母表中的一个字符），那么：<br>$$<br>|w| &#x3D; |x| + 1<br>$$</p></li></ol><hr><p><strong>推导过程示例</strong>：以字符串 $w &#x3D; \text{abc}$ 为例，设字母表 $\Sigma &#x3D; \{a, b, c\}$：</p><ol><li><p>$w &#x3D; \text{abc}$，将其视为 $x &#x3D; \text{ab}$ 和 $a &#x3D; \text{c}$，则：<br>$$<br>|w| &#x3D; |\text{ab}| + 1<br>$$</p></li><li><p>对 $|\text{ab}|$ 递归分解：<br>$$<br>|\text{ab}| &#x3D; |\text{a}| + 1<br>$$</p></li><li><p>对 $|\text{a}|$ 再递归分解：<br>$$<br>|\text{a}| &#x3D; |\varepsilon| + 1 &#x3D; 0 + 1 &#x3D; 1<br>$$</p></li><li><p>反向合并计算：<br>$$<br>|\text{ab}| &#x3D; 1 + 1 &#x3D; 2<br>$$<br>$$<br>|\text{abc}| &#x3D; 2 + 1 &#x3D; 3<br>$$</p></li></ol><p>字符串长度的递归定义可以表示为：</p><p>$$<br>|w| &#x3D;<br>\begin{cases}<br>0 &amp; \text{if } w &#x3D; \varepsilon \\<br>|x| + 1 &amp; \text{if } w &#x3D; xa, x \in \Sigma^*,  a \in \Sigma<br>\end{cases}<br>$$</p><hr><h4 id="1-2-2-字符串连接的定义"><a href="#1-2-2-字符串连接的定义" class="headerlink" title="1.2.2 字符串连接的定义"></a>1.2.2 字符串连接的定义</h4><p>在形式语言与自动机理论中，<strong>字符串连接</strong>（String Concatenation）是指将两个字符串按顺序组合在一起，形成一个新的字符串。连接操作是形式语言中一个非常重要的基本操作，通常用符号 “$\cdot$” 或直接用空格来表示。</p><p>给定两个字符串 $w_1$ 和 $w_2$，它们分别属于字母表 $\Sigma$ 上的语言 $\Sigma^*$，则它们的连接 $w_1 \cdot w_2$（或写作 $w_1 w_2$）是一个新的字符串，表示将 $w_1$ 和 $w_2$ 顺序连接在一起，形成一个新字符串。</p><p>形式上，假设：</p><ul><li>$w_1 &#x3D; x_1 x_2 \dots x_m$，其中 $x_1, x_2, \dots, x_m \in \Sigma$，是一个长度为 $m$ 的字符串；</li><li>$w_2 &#x3D; y_1 y_2 \dots y_n$，其中 $y_1, y_2, \dots, y_n \in \Sigma$，是一个长度为 $n$ 的字符串。</li></ul><p>那么，$w_1 \cdot w_2 &#x3D; x_1 x_2 \dots x_m y_1 y_2 \dots y_n$，是一个长度为 $m+n$ 的新字符串。</p><p><strong>字符串连接操作的基本性质：</strong></p><ol><li><p><strong>结合律</strong>（Associativity）：  字符串连接满足结合律，即对于任意三个字符串 $w_1, w_2, w_3 \in \Sigma^*$，都有：<br>$$<br>(w_1 \cdot w_2) \cdot w_3 &#x3D; w_1 \cdot (w_2 \cdot w_3)<br>$$</p></li><li><p><strong>单位元</strong>（Identity element）：  空字符串 $\varepsilon$ 是连接操作的单位元，即对于任何字符串 $w \in \Sigma^*$，都有：<br>$$<br>w \cdot \varepsilon &#x3D; \varepsilon \cdot w &#x3D; w<br>$$</p></li></ol><p>字符串连接示例：假设字母表 $\Sigma &#x3D; {a, b}$，考虑以下字符串：</p><ul><li>$w_1 &#x3D; \text{ab}$，</li><li>$w_2 &#x3D; \text{ba}$。</li></ul><p>它们的连接 $w_1 \cdot w_2$ 为：<br>$$<br>w_1 \cdot w_2 &#x3D; \text{ab} \cdot \text{ba} &#x3D; \text{abba}<br>$$</p><hr><p>字符串连接的递归表达式可以通过分段函数的方式来定义。假设 $w_1$ 和 $w_2$ 是两个字符串，递归地定义它们的连接操作 $w_1 \cdot w_2$ 如下：</p><p>$$<br>w_1 \cdot w_2 &#x3D;<br>\begin{cases}<br>w_2, &amp; \text{if } w_1 &#x3D; \varepsilon \\<br>x_1 \cdot (x_2 \cdot \dots \cdot (x_m \cdot w_2)), &amp; \text{if } w_1 &#x3D; x_1 x_2 \dots x_m \text{ and } m &gt; 0<br>\end{cases}<br>$$</p><ol><li><p><strong>基例</strong>（Base case）：  如果 $w_1 &#x3D; \varepsilon$（空字符串），则有：<br>$$<br>\varepsilon \cdot w_2 &#x3D; w_2<br>$$</p></li><li><p><strong>递归关系</strong>（Recursive case）：  如果 $w_1 &#x3D; x_1 x_2 \dots x_m$，其中 $x_1, x_2, \dots, x_m \in \Sigma$，则递归地将 $w_1$ 分解成 $x_1$ 和剩下的部分 $x_2 \dots x_m$，然后将 $x_1$ 与递归结果 $x_2 \dots x_m \cdot w_2$ 连接：<br>$$<br>w_1 \cdot w_2 &#x3D; x_1 \cdot (x_2 \cdot \dots \cdot (x_m \cdot w_2))<br>$$</p></li></ol><p>假设我们有两个字符串 $w_1 &#x3D; \text{abc}$ 和 $w_2 &#x3D; \text{def}$，我们来逐步推导它们的连接过程。</p><ol><li><p>首先，$w_1 &#x3D; \text{abc}$，将其分解为 $w_1 &#x3D; x_1 x_2 x_3$，其中 $x_1 &#x3D; \text{a}$，$x_2 &#x3D; \text{b}$，$x_3 &#x3D; \text{c}$。</p></li><li><p>根据递归关系：<br>$$<br>w_1 \cdot w_2 &#x3D; \text{a} \cdot (\text{b} \cdot (\text{c} \cdot \text{def}))<br>$$</p><p>继续递归下去：<br>$$<br>\text{b} \cdot (\text{c} \cdot \text{def}) &#x3D; \text{b} \cdot \text{cdef}<br>$$</p><p>最终得到：<br>$$<br>\text{a} \cdot (\text{b} \cdot (\text{c} \cdot \text{def})) &#x3D; \text{abcdef}<br>$$</p><p>  因此，$w_1 \cdot w_2 &#x3D; \text{abcdef}$。</p></li></ol><hr><h4 id="1-2-3-字符串幂运算的定义"><a href="#1-2-3-字符串幂运算的定义" class="headerlink" title="1.2.3 字符串幂运算的定义"></a>1.2.3 字符串幂运算的定义</h4><p>在形式语言与自动机理论中，<strong>字符串的幂运算</strong>（String Power）是指将一个字符串自我连接若干次的操作。具体地，对于一个字符串 $w$ 和一个非负整数 $n$，$w^n$ 表示将字符串 $w$ 自我连接 $n$ 次。</p><p><strong>定义：</strong> 设 $w$ 是一个字符串，$n$ 是一个非负整数。字符串 $w$ 的幂 $w^n$ 的定义如下：</p><ul><li><p><strong>基例</strong>：当 $n &#x3D; 0$ 时，$w^0$ 被定义为空字符串 $\varepsilon$：<br>$$<br>w^0 &#x3D; \varepsilon<br>$$</p></li><li><p><strong>递归关系</strong>：当 $n &gt; 0$ 时，$w^n$ 被定义为将字符串 $w$ 连接 $n$ 次，即：<br>$$<br>w^n &#x3D; w \cdot w^{n-1} \quad \text{for } n &gt; 0<br>$$</p><p>这里，$\cdot$ 表示字符串连接操作。</p></li></ul><p><strong>字符串幂运算的性质：</strong></p><ol><li><p><strong>空字符串的幂</strong>：对于任意字符串 $w$，空字符串 $\varepsilon$ 的幂总是为空字符串：<br>$$<br>\varepsilon^n &#x3D;<br>\begin{cases}<br>\varepsilon, &amp; \text{if } n &#x3D; 0 \\<br>\text{undefined}, &amp; \text{if } n &gt; 0<br>\end{cases}<br>$$</p></li><li><p><strong>单位元素</strong>：对于任意字符串 $w$，有：<br>$$<br>w^0 &#x3D; \varepsilon \quad \text{(空字符串)}<br>$$<br>且对于任意正整数 $n$：<br>$$<br>w^1 &#x3D; w<br>$$</p></li><li><p><strong>结合律</strong>：字符串幂运算具有结合律。例如，对于任意字符串 $w$ 和非负整数 $n$、$m$，有：<br>$$<br>w^{n+m} &#x3D; w^n \cdot w^m<br>$$</p></li><li><p><strong>易错点辨析</strong>：对于任意字符串 $w_1$ 和 $w_2$，以及非负整数 $n$，字符串连接的幂运算并不满足分配律。具体地，<strong>字符串连接的幂</strong>遵循以下规律：<br>$$<br>(w_1 \cdot w_2)^n &#x3D; (w_1 w_2) \cdot (w_1 w_2) \cdot \dots \cdot (w_1 w_2) \quad \text{(总共 $n$ 次连接)}<br>$$</p><p>而不是将幂分配到每个字符串上：<br>$$<br>(w_1 \cdot w_2)^n \neq w_1^n \cdot w_2^n<br>$$</p><p><em>这是一个常见的误解。字符串连接的幂是按整体连接的，而不是按每个字符串的幂分别计算。</em></p></li></ol><hr><p><strong>示例：</strong> 假设字母表 $\Sigma &#x3D; {a, b}$，并且考虑字符串 $w &#x3D; \text{ab}$。</p><ol><li><p><strong>当 $n &#x3D; 0$</strong> 时：<br>$$<br>w^0 &#x3D; \varepsilon<br>$$</p></li><li><p><strong>当 $n &#x3D; 1$</strong> 时：<br>$$<br>w^1 &#x3D; \text{ab}<br>$$</p></li><li><p><strong>当 $n &#x3D; 2$</strong> 时：<br>$$<br>w^2 &#x3D; \text{ab} \cdot \text{ab} &#x3D; \text{abab}<br>$$</p></li><li><p><strong>当 $n &#x3D; 3$</strong> 时：<br>$$<br>w^3 &#x3D; \text{ab} \cdot \text{abab} &#x3D; \text{ababab}<br>$$</p></li></ol><p>通过这些示例，可以看出字符串的幂运算是将字符串 $w$ 自我连接多次，产生新的更长的字符串。</p><hr><p><strong>递推关系推导</strong>：假设字符串 $w &#x3D; x_1 x_2 \dots x_m$，其中 $x_1, x_2, \dots, x_m$ 是 $w$ 的各个字符。若 $w^n$ 表示字符串 $w$ 自我连接 $n$ 次，则递归定义如下：</p><ol><li><p><strong>基例</strong>：  当 $n &#x3D; 0$ 时，$w^0 &#x3D; \varepsilon$。</p></li><li><p><strong>递归关系</strong>：  当 $n &gt; 0$ 时：<br>$$<br>w^n &#x3D; w \cdot w^{n-1}<br>$$</p></li><li><p>因此我们可以写出递推表达式：</p></li></ol><p>$$<br>w&#x3D;<br>\begin{cases}<br>\epsilon,\quad n &#x3D; 0 \\<br>w \cdot w^{n-1}, \quad x&gt;0<br>\end{cases}<br>$$</p><hr><h4 id="1-2-4-字符串集合的定义"><a href="#1-2-4-字符串集合的定义" class="headerlink" title="1.2.4 字符串集合的定义"></a>1.2.4 字符串集合的定义</h4><p> 一个字符串是字母表中字符的有限序列，字符串的集合是字母表中所有可能字符串的集合。例如，字母表 $\Sigma &#x3D; \{a, b\}$ 中的所有可能的长度为 2 的字符串集合是：</p><p>$$<br>\{aa, ab, ba, bb\}<br>$$</p><p>在形式语言中，我们可以对字符串集合执行运算，常见的操作包括：</p><ol><li><p><strong>串联（Concatenation）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的串联 $L_1 \cdot L_2$ 是所有可能的通过将 $L_1$ 中的元素与 $L_2$ 中的元素连接而成的字符串集合。例如：</p><ul><li>若 $L_1 &#x3D; \{a, b\}$ 和 $L_2 &#x3D; \{c, d\}$，则：<br>$$<br>L_1 \cdot L_2 &#x3D; \{ac, ad, bc, bd\}<br>$$</li></ul></li><li><p><strong>闭包（Kleene Star）</strong>：给定一个语言 $L$，它的 <strong>Kleene 闭包</strong> $L^*$ 是所有 $L$ 中零个或多个字符串的串联集合，即：<br>$$<br>L^* &#x3D; \{\varepsilon\} \cup L \cup L^2 \cup L^3 \cup \dots<br>$$<br>其中，$\varepsilon$ 表示空字符串，$L^n$ 表示所有长度为 $n$ 的字符串的集合，$n \geq 0$。  </p><p>例如，假设 $L &#x3D; \{a, b\}$，则：<br>$$<br>L^* &#x3D; \{\varepsilon, a, b, aa, ab, ba, bb, aaa, aab, \dots \}<br>$$</p><ul><li><strong>正闭包（Positive Closure）</strong>：正闭包 $L^+$ 是由 $L$ 中一个或多个字符串的串联组成的集合。即：<br>$$<br>L^+ &#x3D; L \cup L^2 \cup L^3 \cup \dots<br>$$<br>正闭包可以看作是 Kleene 闭包去除空字符串部分。例如，如果 $L &#x3D; {a, b}$，则：<br>$$<br>L^+ &#x3D; \{a, b, aa, ab, ba, bb, aaa, aab, \dots\}<br>$$</li></ul></li><li><p><strong>并集（Union）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的并集 $L_1 \cup L_2$ 是包含 $L_1$ 和 $L_2$ 中所有字符串的语言集合。例如：</p><ul><li>若 $L_1 &#x3D; \{a, b\}$ 和 $L_2 &#x3D; \{c, d\}$，则：<br>$$<br>L_1 \cup L_2 &#x3D; \{a, b, c, d\}<br>$$</li></ul></li><li><p><strong>差集（Difference）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的差集 $L_1 \setminus L_2$ 是包含所有属于 $L_1$ 但不属于 $L_2$ 的字符串的语言集合。例如：</p><ul><li>若 $L_1 &#x3D; \{a, b, c\}$ 和 $L_2 &#x3D; \{b, c, d\}$，则：<br>$$<br>L_1 \setminus L_2 &#x3D; \{a\}<br>$$</li></ul></li><li><p><strong>集合的 n 次幂运算（n-th Power of a Set）</strong>：给定一个语言 $L$ 和一个非负整数 $n$，语言 $L$ 的 <strong>n 次幂</strong> $L^n$ 是由 $L$ 中所有长度为 $n$ 的字符串组成的集合。具体定义如下：</p><ul><li>当 $n &#x3D; 0$ 时，$L^0 &#x3D; \{\varepsilon\}$，即仅包含空字符串。</li><li>当 $n &gt; 0$ 时，$L^n$ 包含所有由 $L$ 中的字符串串联组成的长度为 $n$ 的字符串。例如：<ul><li>若 $L &#x3D; \{a, b\}$，则：<ul><li>$L^1 &#x3D; \{a, b\}$</li><li>$L^2 &#x3D; \{aa, ab, ba, bb\}$</li><li>$L^3 &#x3D; \{aaa, aab, aba, abb, baa, bab, bba, bbb\}$</li></ul></li></ul></li></ul><p>通过定义 $L^n$，我们可以理解语言中不同长度的字符串是如何通过多个字符串的串联来生成的。</p></li></ol><h3 id="1-3-语言（Language）"><a href="#1-3-语言（Language）" class="headerlink" title="1.3 语言（Language）"></a>1.3 语言（Language）</h3><p>语言（Language）是一个由字母表上的字符串组成的集合，字符串是字母表上符号的有限序列。形式语言通常是根据某种特定的规则或语法定义的字符串集合。形式语言广泛应用于计算机科学中的编程语言设计、编译原理、人工智能、自然语言处理等领域。</p><p>给定一个字母表 $\Sigma$，语言 $L$ 是 $\Sigma$ 上所有合法字符串的集合。我们可以使用集合表示语言，记作：<br>$$<br>L \subseteq \Sigma^*<br>$$<br>其中，$\Sigma^*$ 是字母表 $\Sigma$ 上所有可能的字符串的集合，包括空字符串 $\varepsilon$。</p><p><strong>字母表（Alphabet）</strong> 是构成语言中所有字符串的基本单位，是一个有限的符号集合，通常用 $\Sigma$ 表示。字母表的元素可以是任何字符、符号或数字。例如：</p><ul><li>二进制字母表：$\Sigma &#x3D; \{0, 1\}$</li><li>字母表：$\Sigma &#x3D; \{a, b, c, \dots\}$</li><li>十进制字母表：$\Sigma &#x3D; \{0, 1, 2, \dots, 9\}$</li></ul><p><strong>字符串</strong>是由字母表 $\Sigma$ 中的符号按照一定顺序排列组成的有限序列。字符串的长度是有限的，通常用 $w$ 表示一个字符串。常见的符号包括：</p><ul><li>空字符串 $\varepsilon$，表示一个不含任何符号的字符串。</li><li>字符串 $w$ 是字母表 $\Sigma$ 中的符号按顺序排列形成的一个有序序列。例如：<ul><li>如果 $\Sigma &#x3D; \{a, b\}$，则字符串 $w &#x3D; \text{ab}$ 是字母表 $\Sigma$ 中字符的一个序列。</li></ul></li></ul><p>字符串的长度是字符串中符号的数量，记作 $|w|$。例如：</p><ul><li>$|\varepsilon| &#x3D; 0$（空字符串的长度为零）</li><li>$|w| &#x3D; 3$，如果 $w &#x3D; \text{abc}$</li></ul><p>根据其生成规则或接受条件，语言可以分为以下几类：</p><ol><li><p><strong>正规语言（Regular Language）</strong>：正规语言是最简单的一类语言，可以由有限自动机（DFA&#x2F;NFA）接受或通过正规表达式表示。正规语言可以通过正规文法生成，并且有许多应用，如文本搜索、词法分析等。</p><ul><li>A language is called a regular language if some infinite automaton recognizes it</li></ul></li><li><p><strong>上下文无关语言（Context-Free Language）</strong>：上下文无关语言是由上下文无关文法（CFG）生成的语言。它们通常可以由推理自动机（如下推自动机）接受，广泛用于编程语言的语法分析。</p></li><li><p><strong>上下文相关语言（Context-Sensitive Language）</strong>：上下文相关语言是由上下文相关文法（CSG）生成的语言，通常由线性有界自动机接受。它们比上下文无关语言更强，但也更复杂。</p></li><li><p><strong>递归可枚举语言（Recursively Enumerable Language）</strong>：递归可枚举语言是可以通过图灵机接受的语言。它们可以包含一些不能有效计算的语言，是计算理论中的最广泛类。</p></li></ol><p><strong>特殊语言类型：</strong></p><ol><li><p><strong>空语言（Empty Language）</strong>：空语言是一个不包含任何字符串的集合，记作 $\emptyset$。例如，对于字母表 $\Sigma &#x3D; \{a, b\}$，如果定义的规则不允许任何字符串出现，那么该语言就是空语言：</p><p>$$<br>L &#x3D; \emptyset<br>$$</p><p>这里需要辨析下面的一个结论： $\emptyset$ 不包含任何元素，即：$|\emptyset| &#x3D; 0$（集合的大小为 0），而 $\{\varepsilon\}$ 包含一个具体的元素（空字符串）。</p><p>$$<br>\emptyset \neq \{\varepsilon\}<br>$$</p></li><li><p><strong>全集语言（Universal Language）</strong>：全集语言是包含字母表 $\Sigma$ 上所有可能字符串的语言，通常记作 $\Sigma^*$。它包含所有长度为任意数目的字符串，包括空字符串。例如：<br>$$<br>L &#x3D; \Sigma^* &#x3D; \{\varepsilon, a, b, ab, aa, ba, \dots \}<br>$$</p></li><li><p><strong>单一元素语言（Singleton Language）</strong>：单一元素语言是只包含一个字符串的语言。例如，若字母表为 $\Sigma &#x3D; \{a, b\}$，语言 $L &#x3D; \{ab\}$ 只有一个字符串元素：<br>$$<br>L &#x3D; \{ab\}<br>$$</p></li></ol><p><strong>语言的运算包括：</strong></p><ol><li><p><strong>串联（Concatenation）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的串联 $L_1 \cdot L_2$ 是所有可能通过将 $L_1$ 中的字符串与 $L_2$ 中的字符串连接起来得到的字符串的集合。</p></li><li><p><strong>并集（Union）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的并集 $L_1 \cup L_2$ 是包含所有属于 $L_1$ 或 $L_2$ 的字符串的集合。</p></li><li><p><strong>差集（Difference）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的差集 $L_1 \setminus L_2$ 是包含所有属于 $L_1$ 但不属于 $L_2$ 的字符串的集合。</p></li><li><p><strong>闭包（Closure）</strong>：</p><ul><li><strong>Kleene 闭包（Kleene Star）</strong>：语言 $L$ 的 Kleene 闭包 $L^*$ 是包含所有 $L$ 中零个或多个字符串串联的语言。</li><li><strong>正闭包（Positive Closure）</strong>：语言 $L$ 的正闭包 $L^+$ 是包含所有 $L$ 中一个或多个字符串串联的语言。</li></ul></li></ol><h2 id="2-Finite-Automata"><a href="#2-Finite-Automata" class="headerlink" title="2. Finite Automata"></a>2. Finite Automata</h2><p>有限自动机 (Finite Automaton, FA) 是一种理论模型，用来描述和识别形式语言中的某些类型的语言。它是自动机理论中的基础之一，广泛应用于计算机科学、编译原理、正则表达式等领域。本章内容我们需要熟悉并且掌握确定性有限自动机（DFA）和非确定性有限自动机 （NFA）</p><h3 id="2-1-DFA"><a href="#2-1-DFA" class="headerlink" title="2.1 DFA"></a>2.1 DFA</h3><p><strong>确定性有限自动机（DFA，Deterministic Finite Automaton）</strong> 是一种计算模型，用于识别正则语言。它由一个有限的状态集合组成，每次在一个特定的输入符号下，从某一状态转换到唯一的另一个状态，因此被称为“确定性”。</p><p>DFA 可以通过<strong>五元组</strong>来定义：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li><p><strong>Q</strong>：状态集，表示所有可能的状态。$ Q &#x3D; \{q_0, q_1, q_2, \dots, q_n\} $ 是有限的。</p></li><li><p><strong>Σ</strong>：输入字母表，是一个有限的符号集合，表示自动机可以接受的输入字符。通常 $ \Sigma &#x3D; \{a, b, \dots\} $。</p></li><li><p><strong>δ</strong>：转移函数，定义了每个状态在给定输入符号时的转移情况。对于任何状态 $ q_i \in Q $ 和输入符号 $ a \in \Sigma $，转移函数 δ 给出了唯一的下一状态 $ q_j \in Q $。即：<br>$$<br>\delta : Q \times \Sigma \to Q<br>$$</p></li><li><p><strong>q₀</strong>：初始状态，表示自动机开始时所处的状态。它是状态集 $ Q $ 中的一个元素，即 $ q_0 \in Q $。</p></li><li><p><strong>F</strong>：接受状态集，表示自动机在接受输入并成功识别一个字符串时所处的状态集合。$ F \subseteq Q $，是状态集 $ Q $ 的一个子集。</p></li></ul><p>DFA 是通过一个<strong>确定的过程</strong>来处理输入字符串的。它从初始状态 $ q_0 $ 开始，逐个读取输入字符串中的符号，并根据当前状态和输入符号，按照转移函数 $ \delta $ 进行状态转移。每次读取一个符号后，自动机都会进入一个新的状态。最终，输入串处理完毕后，如果自动机处于一个接受状态，则该输入字符串被接受；否则，它被拒绝。</p><p>DFA有如下性质：</p><ul><li><strong>确定性</strong>：在每个状态下，对于每一个输入符号，DFA都有一个唯一的转移状态。即不存在多个可能的状态转移。</li><li><strong>有限性</strong>：DFA有一个有限的状态集合，因此它只能识别有限的状态。</li></ul><hr><p>假设我们设计一个DFA来识别所有包含 <strong>偶数个0</strong> 的二进制字符串。这个语言的正则表达式是 $ (1^\ast 0 1^\ast 0)^\ast $。</p><ul><li><p>状态集 $ Q &#x3D; \{q_0, q_1\} $，其中：</p><ul><li>$ q_0 $ 表示当前读取的 0 的个数是偶数个（接受状态）。</li><li>$ q_1 $ 表示当前读取的 0 的个数是奇数个。</li></ul></li><li><p>输入字母表 $ \Sigma &#x3D; \{0, 1\} $。</p></li><li><p>转移函数 $ \delta $ 可以这样定义：</p><ul><li>$ \delta(q_0, 0) &#x3D; q_1 $（如果当前状态是 $ q_0 $，读取到 0 后转到 $ q_1 $）。</li><li>$ \delta(q_0, 1) &#x3D; q_0 $（如果当前状态是 $ q_0 $，读取到 1 后保持在 $ q_0 $）。</li><li>$ \delta(q_1, 0) &#x3D; q_0 $（如果当前状态是 $ q_1 $，读取到 0 后转到 $ q_0 $）。</li><li>$ \delta(q_1, 1) &#x3D; q_1 $（如果当前状态是 $ q_1 $，读取到 1 后保持在 $ q_1 $）。</li></ul></li><li><p>初始状态 $ q_0 $，因为一开始是偶数个 0。</p></li><li><p>接受状态集 $ F &#x3D; \{q_0\} $，即只有在状态 $ q_0 $ 时，DFA 才接受输入。</p></li></ul><p>DFA的状态转换示意图如下：</p><center><img src="/img/FL/dfa1.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><p>我们可以画一个状态转移表：</p><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$\text{*}q_0$</td><td>$q_1$</td><td>$q_0$</td></tr><tr><td>$q_1$</td><td>$q_0$</td><td>$q_1$</td></tr></tbody></table><ul><li><strong>初始状态</strong>：$q_0$</li><li><strong>接受状态</strong>：$q_0$（用 <code>*</code> 表示）</li></ul><p>假设输入字符串是 <code>1010</code>，我们来分析 DFA 的运行过程：</p><ul><li>初始状态 $q_0$。</li><li>读取第一个字符 ‘1’，根据转移函数 $ \delta(q_0, 1) &#x3D; q_0 $，仍然处于状态 $q_0$。</li><li>读取第二个字符 ‘0’，根据转移函数 $ \delta(q_0, 0) &#x3D; q_1 $，转到状态 $q_1$。</li><li>读取第三个字符 ‘1’，根据转移函数 $ \delta(q_1, 1) &#x3D; q_1 $，仍然处于状态 $q_1$。</li><li>读取第四个字符 ‘0’，根据转移函数 $ \delta(q_1, 0) &#x3D; q_0 $，转回状态 $q_0$。</li></ul><p>最终，自动机处于接受状态 $q_0$，因此输入字符串 “1010” 被接受。</p><hr><h4 id="2-1-1-DFA的扩展转移函数"><a href="#2-1-1-DFA的扩展转移函数" class="headerlink" title="2.1.1 DFA的扩展转移函数"></a>2.1.1 DFA的扩展转移函数</h4><p>在形式语言与自动机理论中，DFA的<strong>扩展转移函数</strong>（Extended Transition Function）是指在原始转移函数的基础上，对DFA的状态转移进行扩展，使其能够处理整个输入字符串，而不仅仅是单个符号。这个扩展函数通常表示为 $ \delta^* $，它允许我们对一个输入字符串进行逐个字符的状态转移。</p><p> <strong>扩展转移函数的定义</strong>：设定</p><ul><li><p>$\delta$ 是原始的转移函数，它是一个从状态和输入符号到下一个状态的映射：<br>$$<br>\delta : Q \times \Sigma \to Q<br>$$<br>其中，$Q$ 是状态集，$\Sigma$ 是输入字母表。</p></li><li><p><strong>扩展转移函数</strong>  $\delta^* : Q \times \Sigma^* \to Q$ ，它扩展了原始转移函数，使其能够接受任意长度的输入串，并返回最终的状态。</p></li></ul><p>形式化地，扩展转移函数定义为：</p><p>$$<br>\delta^*(q, \epsilon) &#x3D; q<br>$$</p><p>这里，$\epsilon$ 表示空串，表示在没有任何输入时，自动机保持在原状态 $q$。</p><p>对于一个非空的输入串 $w &#x3D; a_1 a_2 \dots a_n \in \Sigma^*$，扩展转移函数满足以下递归关系：</p><p>$$<br>\delta^*(q, a_1 a_2 \dots a_n) &#x3D; \delta(\delta^*(q, a_1 a_2 \dots a_{n-1}), a_n)<br>$$</p><p>即，扩展转移函数首先对前 $n-1$ 个符号计算转移，并最终得到最后一个符号的转移。</p><p>扩展转移函数允许我们一次性地处理整个输入串，而不是每次只处理一个符号。通过使用这个扩展函数，我们可以计算在输入串的每一个字符都被处理后的最终状态。这在计算是否接受某个字符串时非常有用，因为我们只需要检查自动机最终是否处于接受状态。</p><p>还是用上面的状态转移图举个例子</p><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$\text{*}q_0$</td><td>$q_1$</td><td>$q_0$</td></tr><tr><td>$q_1$</td><td>$q_0$</td><td>$q_1$</td></tr></tbody></table><p>初始状态是 $q_0$，接受状态是 $q_0$。</p><p>我们可以使用扩展转移函数来处理整个输入串。假设输入字符串是 $w &#x3D; 1010$。</p><ol><li>计算 $\delta^*(q_0, \epsilon) &#x3D; q_0$，即没有输入时，自动机仍然处于初始状态 $q_0$。</li><li>计算 $\delta^*(q_0, 1) &#x3D; \delta(q_0, 1) &#x3D; q_0$，读取第一个字符 ‘1’ 后，仍然处于状态 $q_0$。</li><li>计算 $\delta^*(q_0, 10) &#x3D; \delta(\delta^*(q_0, 1), 0) &#x3D; \delta(q_0, 0) &#x3D; q_1$，读取字符 ‘0’ 后，自动机转到状态 $q_1$。</li><li>计算 $\delta^*(q_1, 101) &#x3D; \delta(\delta^*(q_1, 10), 1) &#x3D; \delta(q_1, 1) &#x3D; q_1$，读取字符 ‘1’ 后，仍然处于状态 $q_1$。</li><li>计算 $\delta^*(q_1, 1010) &#x3D; \delta(\delta^*(q_1, 101), 0) &#x3D; \delta(q_1, 0) &#x3D; q_0$，读取最后一个字符 ‘0’ 后，自动机转回状态 $q_0$。</li></ol><p>最终，$\delta^*(q_0, 1010) &#x3D; q_0$，因为最终状态 $q_0$ 是接受状态，因此输入字符串 <code>1010</code>被接受。</p><p>最终总结一下，我们可以得出，DFA的扩展转移函数为：</p><p>$$<br>\delta^*(q, w) &#x3D;<br>\begin{cases}<br>q, &amp; \text{if } w &#x3D; \epsilon \\<br>\delta(\delta^*(q, w_1 w_2 \dots w_{n-1}), w_n), &amp; \text{if } w &#x3D; w_1 w_2 \dots w_n \text{ and } n &gt; 0<br>\end{cases}<br>$$</p><hr><h3 id="2-2-NFA"><a href="#2-2-NFA" class="headerlink" title="2.2 NFA"></a>2.2 NFA</h3><p><strong>非确定性有限自动机（NFA，Nondeterministic Finite Automaton）</strong> 是另一种计算模型，与DFA类似，NFA也用于识别正则语言。与DFA不同的是，NFA在每个状态下，给定某个输入符号时，可能存在多个不同的转移路径，或者在某些情况下甚至可以不进行任何状态转移。这就是它的“非确定性”特性。</p><p>NFA同样可以通过<strong>五元组</strong>来定义：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li><p><strong>Q</strong>：状态集，表示所有可能的状态。$ Q &#x3D; \{q_0, q_1, q_2, \dots, q_n\} $ 是有限的。</p></li><li><p><strong>Σ</strong>：输入字母表，是一个有限的符号集合，表示自动机可以接受的输入字符。通常 $\Sigma &#x3D; \{a, b, \dots\}$。</p></li><li><p><strong>δ</strong>：转移函数，定义了每个状态在给定输入符号时的转移情况。与DFA不同，NFA的转移函数允许多个可能的下一状态，或者在某些状态下，输入符号可能不产生任何转移（即允许空转移）。因此，转移函数 $\delta$ 是从状态集到状态集的映射：<br>$$<br>\delta : Q \times \Sigma \to 2^Q<br>$$<br>其中 $2^Q$ 表示状态集的幂集，表示可能的多个目标状态。</p></li><li><p><strong>q₀</strong>：初始状态，表示自动机开始时所处的状态。它是状态集 $Q$ 中的一个元素，即 $q_0 \in Q$。</p></li><li><p><strong>F</strong>：接受状态集，表示自动机在接受输入并成功识别一个字符串时所处的状态集合。$F \subseteq Q$，是状态集 $Q$ 的一个子集。</p></li></ul><p>NFA处理输入字符串的方式与DFA相似，但是在每个步骤中，NFA可以选择不同的状态转移，或者在某些输入符号下可能没有任何状态转移。NFA并不是沿着一个确定的路径处理输入，而是沿着所有可能的路径并行地进行状态转移。最终，NFA接受输入字符串当且仅当存在至少一条路径能够让它停留在接受状态。</p><p>NFA与DFA的<strong>主要区别：</strong></p><ul><li><strong>非确定性</strong>：在每个状态下，对于每一个输入符号，NFA可以有多个可能的转移状态，或者根本没有转移（空转移）。</li><li><strong>空转移（ε-转移）</strong>：NFA可以有空转移，即在没有任何输入符号的情况下，从一个状态转移到另一个状态。下文会讲解ε-NFA和NFA等价。</li></ul><hr><p>假设我们设计一个NFA来识别所有包含 <strong>至少一个1</strong> 的二进制字符串。这个语言的正则表达式是 $(0|1)^* 1(0|1)^*$。</p><ul><li><p>状态集 $Q &#x3D; \{q_0, q_1\}$，其中：</p><ul><li>$q_0$ 是我们尚未看到任何1的状态</li><li>$q_1$ 是我们已经至少看到一个1的状态</li></ul></li><li><p>输入字母表 $\Sigma &#x3D; \{0, 1\}$</p></li><li><p>转移函数 $\delta$ 定义如下：</p><ul><li>$\delta(q_0, 0) &#x3D; \{q_0\}$（在初始状态读到0，继续等待1的出现）</li><li>$\delta(q_0, 1) &#x3D; \{q_1\}$（在初始状态读到1，转移到接受状态）</li><li>$\delta(q_1, 0) &#x3D; \{q_1\}$（已经看到1后，读到0保持在接受状态）</li><li>$\delta(q_1, 1) &#x3D; \{q_1\}$（已经看到1后，读到1保持在接受状态）</li></ul></li><li><p>初始状态 $q_0$（自然从未读取到1的状态开始）</p></li><li><p>接受状态集 $F &#x3D; \{q_1\}$（只要曾经读取到1，就应该接受）</p></li></ul><p>我们可以用状态转移表来更清晰地展示：</p><center><img src="/img/FL/nfa1.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$q_0$</td><td>${q_0}$</td><td>${q_1}$</td></tr><tr><td>$\text{*}q_1$</td><td>${q_1}$</td><td>${q_1}$</td></tr></tbody></table><ul><li><strong>初始状态</strong>：$q_0$</li><li><strong>接受状态</strong>：$q_1$（用 <code>*</code> 表示）</li></ul><p>让我们分析当输入字符串为 “0110” 时NFA的运行过程：</p><ol><li>从初始状态 $q_0$ 开始</li><li>读取第一个字符 ‘0’：$\delta(q_0, 0) &#x3D; \{q_0\}$，保持在状态 $q_0$</li><li>读取第二个字符 ‘1’：$\delta(q_0, 1) &#x3D; \{q_1\}$，转移到状态 $q_1$</li><li>读取第三个字符 ‘1’：$\delta(q_1, 1) &#x3D; \{q_1\}$，保持在状态 $q_1$</li><li>读取第四个字符 ‘0’：$\delta(q_1, 0) &#x3D; \{q_1\}$，保持在状态 $q_1$</li></ol><p>由于最终停在接受状态 $q_1$，因此字符串 <code>0110</code> 被接受。这符合我们的预期，因为它确实包含至少一个1（实际上包含两个1）。</p><hr><p>再来看一个例子。设计接受全部<strong>以<code>01</code>结尾的串</strong>的NFA。</p><p>首先，自动机需要能够识别所有以 <code>01</code> 结尾的字符串，而不关注字符串前面的部分。我们需要理解这个语言接受什么样的字符串：</p><ul><li>“01” 应该被接受</li><li>“101” 应该被接受</li><li>“1101” 应该被接受</li><li>“11101” 应该被接受</li><li>但 “011” 不应该被接受（因为中间有0）</li><li>“10” 不应该被接受（没有以01结尾）</li></ul><p>接下来是我们的解题步骤</p><ol><li><p><strong>定义状态集 Q</strong>：</p><ul><li>我们需要设计的 NFA 至少有三个状态：<ul><li>$q_0$：初始状态，表示当前没有识别到“01”结尾。</li><li>$q_1$：表示已经读取了一个 <code>0</code>，即我们已经识别到了 <code>0</code>，等待接收 <code>1</code> 作为结束符。</li><li>$q_2$：接受状态，表示已经识别到 <code>01</code> 结尾，自动机接受字符串。</li></ul></li></ul></li><li><p><strong>定义输入字母表 Σ</strong>：</p><ul><li>由于字符串只由字符 <code>0</code> 和 <code>1</code> 构成，字母表为：$ \Sigma &#x3D; \{0, 1\} $。</li></ul></li><li><p><strong>定义转移函数 δ</strong>：</p><ul><li>$ \delta(q_0, 1) &#x3D; \{q_0\} $：如果当前状态是 $q_0$，输入 <code>1</code> 后仍然处于 $q_0$，表示读取 <code>1</code> 不影响结尾是否为 <code>01</code>。</li><li>$ \delta(q_0, 0) &#x3D; \{q_1\} $：如果当前状态是 $q_0$，输入 <code>0</code> 后转移到 $q_1$，表示遇到了一个 <code>0</code>，准备接受接下来的 <code>1</code>；还有一种情况是当前输入的<code>0</code>并不是倒数第二个字符，因此停留在$q_0$</li><li>$ \delta(q_1, 1) &#x3D; \{q_2\} $：如果当前状态是 $q_1$，输入 <code>1</code> 后转移到 $q_2$，表示成功识别到了以 <code>01</code> 结尾；</li><li>$ \delta(q_1, 0) &#x3D; \{q_1\} $：如果当前状态是 $q_1$，输入 <code>0</code> 后走到了未定义的状态，因此走到$\emptyset$</li><li>$ \delta(q_2, 1) &#x3D; \{q_2\} $：没出现我们定义的状态，走到 $\emptyset$</li><li>$ \delta(q_2, 0) &#x3D; \{q_1\} $：没出现我们定义的状态，走到 $\emptyset$</li></ul></li><li><p><strong>定义初始状态$q_0$ :</strong> </p><ul><li>初始状态是 $q_0$，表示开始时尚未识别到 <code>01</code> 结尾。</li></ul></li><li><p><strong>定义接受状态集 F :</strong></p><ul><li>接受状态是 $q_2$，表示已经识别到以 <code>01</code> 结尾的字符串。</li></ul></li></ol><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$q_0$</td><td>$\{q_0,q_1\}$</td><td>$\{q_0\}$</td></tr><tr><td>$q_1$</td><td>$\emptyset$</td><td>$\{q_2\}$</td></tr><tr><td>$\text{*}q_2$</td><td>$\emptyset$</td><td>$\emptyset$</td></tr></tbody></table><ul><li><strong>初始状态</strong>：$q_0$</li><li><strong>接受状态</strong>：$q_2$（用 <code>*</code> 表示）</li></ul><center><img src="/img/FL/nfa2.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><p>假设输入字符串是 <code>1101</code>，我们来分析 NFA 的运行过程：</p><ol><li>初始状态 $q_0$。</li><li>读取第一个字符 ‘1’，根据转移函数 $ \delta(q_0, 1) &#x3D; \{q_0\} $，保持在状态 $q_0$。</li><li>读取第二个字符 ‘1’，根据转移函数 $ \delta(q_0, 1) &#x3D; \{q_0\} $，保持在状态 $q_0$。</li><li>读取第三个字符 ‘0’，根据转移函数 $ \delta(q_0, 0) &#x3D; \{q_1\} $，转移到状态 $\{q_0,q_1\}$。</li><li>读取第四个字符 ‘1’，对于$q_0$，根据转移函数  $ \delta(q_0, 0) &#x3D; \{q_0,q_1\} $ 。对于$q_1$，$ \delta(q_1, 1) &#x3D; \{q_2\} $ 。这时候可能出现三种状态，存在一种状态$q_2$能被NFA接受</li></ol><p>最终，NFA停在接受状态 $q_2$，因此输入字符串 <code>1101</code> 被接受。</p><hr><h4 id="2-2-1-NFA的扩展转移函数"><a href="#2-2-1-NFA的扩展转移函数" class="headerlink" title="2.2.1 NFA的扩展转移函数"></a>2.2.1 NFA的扩展转移函数</h4><p>在非确定性有限自动机（NFA）中，<strong>扩展转移函数</strong>是对传统转移函数的扩展。它允许我们从一个状态开始，处理整个输入字符串，而不仅仅是处理单个字符。扩展转移函数定义了 NFA 如何从一个状态开始，读取整个输入字符串后，到达的状态集。</p><p>假设我们有一个NFA，定义为 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta$ 是转移函数。</li><li>$q_0$ 是初始状态。</li><li>$F$ 是接受状态集。</li></ul><p>扩展转移函数 $ \delta^* $ 是从状态到<strong>状态集</strong>的映射，定义如下：</p><p>$$<br>\delta^*(q, w) &#x3D; \delta^*(q, w_1 w_2 \dots w_n)<br>$$</p><p>其中，$w &#x3D; w_1 w_2 \dots w_n$ 是输入字符串，$w_1, w_2, \dots, w_n$ 是字符串 $w$ 中的各个字符。扩展转移函数遵循以下递归定义：</p><p><strong>Step1:</strong> 空串的处理</p><p>对于空串（即 $w &#x3D; \epsilon$），扩展转移函数返回包含当前状态的状态集，即：</p><p>$$<br>\delta^*(q, \epsilon) &#x3D; {q}<br>$$</p><p>这意味着，当输入为空时，NFA 仍然停留在当前状态。</p><p><strong>Step2:</strong> 递归处理非空字符串</p><p>如果输入字符串 $w &#x3D; w_1 w_2 \dots w_n$ 非空，扩展转移函数 $\delta^*$ 会递归地调用自身来处理子串 $w_1 w_2 \dots w_{n-1}$，然后再根据当前状态和最后一个字符 $w_n$ 进行状态转移。具体的递归形式如下：</p><p>$$<br>\delta^*(q, w) &#x3D; \bigcup_{r \in \delta(q, w_1)} \delta^*(r, w_2 \dots w_n)<br>$$</p><p>这意味着，对于每个可能的目标状态 $r$（从当前状态 $q$ 通过字符 $w_1$ 转移得到的状态），我们递归地求出从状态 $r$ 开始，处理剩余字符串 $w_2 \dots w_n$ 后的状态集，并将这些状态集进行并集运算。</p><p>总结一下，我们可以得出NFA的状态转移函数如下：</p><p>$$<br>\delta^*(q, w) &#x3D;<br>\begin{cases}<br>{q}, &amp; \text{if } w &#x3D; \epsilon \\<br>\bigcup_{r \in \delta(q, w_1)} \delta^*(r, w_2 \dots w_n), &amp; \text{if } w &#x3D; w_1 w_2 \dots w_n \text{ and } n &gt; 0<br>\end{cases}<br>$$</p><hr><p>举个例子: 假设我们有一个简单的 NFA，其中状态集 $Q &#x3D; \{q_0, q_1\}$，输入字母表 $\Sigma &#x3D; \{0, 1\}$，转移函数 $\delta$ 如下：</p><ul><li>$ \delta(q_0, 0) &#x3D; \{q_0, q_1\} $</li><li>$ \delta(q_0, 1) &#x3D; \{q_0\} $</li><li>$ \delta(q_1, 1) &#x3D; \{q_0\} $</li></ul><p>假设我们要计算 $\delta^*(q_0, 01)$，也就是从状态 $q_0$ 开始，处理字符串 <code>01</code> 后最终到达的状态集。</p><ol><li>首先，考虑空串情况：</li></ol><p>$$<br>\delta^*(q_0, \epsilon) &#x3D; \{q_0\}<br>$$</p><ol start="2"><li>然后，处理第一个字符 <code>0</code>：</li></ol><p>$$<br>\delta(q_0, 0) &#x3D; \{q_0, q_1\}<br>$$</p><ol start="3"><li><p>接着，处理剩余的字符串 <code>1</code>。我们需要从上一步得到的所有状态（即 $q_0$ 和 $q_1$）继续进行状态转移：</p><ul><li>对于状态 $q_0$，$ \delta(q_0, 1) &#x3D; \{q_0\} $。</li><li>对于状态 $q_1$，$ \delta(q_1, 1) &#x3D; \{q_0\} $。</li></ul></li><li><p>将这两次转移的结果合并：</p></li></ol><p>$$<br>\delta^*(q_0, 01) &#x3D; \{q_0\} \cup \{q_0\} &#x3D; \{q_0\}<br>$$</p><p>因此，从状态 $q_0$ 开始处理字符串 <code>01</code> 后，最终到达的状态是 $q_0$。</p><p>总结一下NFA的扩展函数有如下特点：</p><ul><li><strong>空串</strong>的扩展转移函数 $\delta^*(q, \epsilon)$ 使得当前状态保持不变。</li><li><strong>递归计算</strong>扩展转移函数是通过逐步处理输入字符串，并根据每个字符的转移结果来更新状态集。</li><li>扩展转移函数允许我们处理整个字符串的转移，而不仅仅是一个字符，这对 NFA 的运行至关重要，因为 NFA 可以在多个状态间“并行”进行状态转移。</li></ul><hr><h4 id="2-2-2-epsilon-NFA"><a href="#2-2-2-epsilon-NFA" class="headerlink" title="2.2.2 $\epsilon$-NFA"></a>2.2.2 $\epsilon$-NFA</h4><p><strong>$\epsilon$-NFA（Epsilon-Non-deterministic Finite Automaton）</strong> 是一种特殊的非确定性有限自动机（NFA）。与普通的 NFA 相比，$\epsilon$-NFA 允许使用 $\epsilon$ 转移（即<strong>空转移</strong>）。$\epsilon$ 转移意味着在没有读取任何输入字符的情况下，自动机可以从一个状态跳转到另一个状态。</p><p>一个 $\epsilon$-NFA 通常用以下五元组表示：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li>$Q$：状态集（有限集合）。</li><li>$\Sigma$：输入字母表（有限集合）。</li><li>$\delta$：状态转移函数，$\delta: Q \times (\Sigma \cup {\epsilon}) \to 2^Q$。注意，这里 $\delta$ 可以包含 $\epsilon$ 转移。</li><li>$q_0$：初始状态，$q_0 \in Q$。</li><li>$F$：接受状态集，$F \subseteq Q$。</li></ul><p>$\epsilon$-NFA 具有<em>以下特性：</em></p><ol><li><p><strong>$\epsilon$ 转移</strong>：</p><ul><li>自动机可以通过 $\epsilon$ 转移从一个状态跳转到另一个状态，而无需消耗任何输入字符。</li><li>例如，如果 $\delta(q_1, \epsilon) &#x3D; \{q_2, q_3\}$，自动机可以从状态 $q_1$ 转移到 $q_2$ 或 $q_3$，而不需要读取输入字符。</li></ul></li><li><p><strong>非确定性</strong>：</p><ul><li>和普通 NFA 一样，$\epsilon$-NFA 也具有非确定性：对于相同的输入字符，自动机可能有多个可能的转移路径。</li></ul></li><li><p><strong>接受条件</strong>：</p><ul><li>一个字符串 $w$ 被 $\epsilon$-NFA 接受，当且仅当：<ul><li>从初始状态 $q_0$ 开始，沿着可能的路径（包括 $\epsilon$ 转移），读取完字符串 $w$ 后，最终能到达某个接受状态 $f \in F$。</li></ul></li></ul></li></ol><p><strong>$\epsilon$ 闭包</strong>是 $\epsilon$-NFA 的一个关键概念。它描述了从某个状态 $q$ 开始，通过任意多次 $\epsilon$ 转移可以到达的状态集合。</p><p>记 $\epsilon$ 闭包为 $\text{E-closure}(q)$，定义如下：</p><p>$$<br>\text{E-closure}(q) &#x3D; \{ p \in Q \mid p \text{ 是从 } q \text{ 经 $\epsilon$ 转移可到达的状态} \}<br>$$</p><p>如果从状态 $q$ 开始经过若干次 $\epsilon$ 转移可以到达状态 $p$，则 $p \in \text{E-closure}(q)$。</p><hr><p>考虑一个简单的 $\epsilon$-NFA，定义如下：</p><ul><li>状态集：$Q &#x3D; \{q_0, q_1, q_2\}$。</li><li>输入字母表：$\Sigma &#x3D; \{a, b\}$。</li><li>初始状态：$q_0$。</li><li>接受状态集：$F &#x3D; \{q_2\}$。</li><li>转移函数 $\delta$：<ul><li>$\delta(q_0, \epsilon) &#x3D; \{q_1\}$。</li><li>$\delta(q_1, a) &#x3D; \{q_1, q_2\}$。</li><li>$\delta(q_2, b) &#x3D; \{q_2\}$。</li></ul></li></ul><p>我们可以用状态转移图表示这个 $\epsilon$-NFA：</p><center><img src="/img/FL/nfa3.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><p><strong>$\epsilon$ 闭包计算</strong></p><ul><li>$\text{E-closure}(q_0) &#x3D; \{q_0, q_1\}$ （$q_1$ 是通过 $\epsilon$ 转移从 $q_0$ 可达）。</li><li>$\text{E-closure}(q_1) &#x3D; \{q_1\}$。</li><li>$\text{E-closure}(q_2) &#x3D; \{q_2\}$。</li></ul><p>假设输入字符串是 “a”，分析其是否被接受：</p><ol><li>初始状态 $q_0$，根据 $\epsilon$ 闭包，$\text{E-closure}(q_0) &#x3D; \{q_0, q_1\}$。</li><li>读取第一个字符 “a”：<ul><li>从 $q_1$ 读取 “a” 后，可以到达状态 $q_1$ 和 $q_2$。</li><li>从 $q_0$ 无法直接读取 “a”。</li></ul></li><li>计算 $\epsilon$ 闭包：<ul><li>$\text{E-closure}(\{q_1, q_2\}) &#x3D; \{q_1, q_2\}$。</li></ul></li><li>最终状态集包含 $q_2$，它是一个接受状态。</li></ol><p>因此，字符串 “a” 被该 $\epsilon$-NFA 接受。</p><p>上面的$\epsilon$-NFA接受的语言是以一个或多个 ‘a’ 结束，并且可以在后面跟上零个或多个 ‘b’。即正则表达式为 $a^+ b^*$。</p><hr><h4 id="2-2-3-epsilon-NFA的扩展转移函数"><a href="#2-2-3-epsilon-NFA的扩展转移函数" class="headerlink" title="2.2.3 $\epsilon$-NFA的扩展转移函数"></a>2.2.3 $\epsilon$-NFA的扩展转移函数</h4><p>一个非确定性有限自动机（NFA）由五元组 $(Q, \Sigma, \delta, q_0, F)$ 组成，其中：</p><ul><li>$Q$ 是状态集，</li><li>$\Sigma$ 是输入字母表，</li><li>$\delta: Q \times \Sigma \to \mathcal{P}(Q)$ 是转移函数（映射一个状态和输入符号到可能的状态集合），</li><li>$q_0 \in Q$ 是初始状态，</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>在 $\epsilon$-NFA 中，除了常规的转移外，还允许存在 $\epsilon$（空字符串）转移，意味着自动机可以在没有任何输入的情况下从一个状态转移到另一个状态。</p><p>$\epsilon$-NFA的扩展转移函数 $\delta^*(q, w)$ 用于计算从状态 $q$ 开始，处理输入字符串 $w$ 后可能到达的所有状态。这个函数需要分别考虑两种情况：当输入字符串为空（$w &#x3D; \epsilon$）时，以及输入字符串非空（$w \neq \epsilon$）时。可以定义为如下的分段函数：</p><p>$$<br>\delta^*(q, w) &#x3D;<br>\begin{cases}<br>E\text{-closure}(q), &amp; \text{if } w &#x3D; \epsilon \\<br>\bigcup_{q’ \in \delta(q, a)} \delta^*(q’, w’), &amp; \text{if } w &#x3D; a w’ \text{ and } a \in \Sigma<br>\end{cases}<br>$$</p><p>其中：</p><ul><li>如果 $w &#x3D; \epsilon$，表示输入字符串为空，那么扩展转移函数的值是从状态 $q$ 开始，所有通过 $\epsilon$ 转移能够到达的状态集合，即 $E$-closure($q$)。</li><li>如果 $w &#x3D; a w’$，表示输入字符串非空，且可以分解为第一个符号 $a$ 和剩余部分 $w’$，那么扩展转移函数的值是所有从状态 $q$ 通过符号 $a$ 转移后，再继续处理 $w’$ 后可能到达的状态的集合。这些状态是通过递归计算 $\delta^*(q’, w’)$ 来得到的，其中 $q’$ 是状态 $q$ 经过符号 $a$ 转移后到达的状态。</li></ul><p>假设有一个简单的 $\epsilon$-NFA，其状态集为 $Q &#x3D; \{q_0, q_1, q_2\}$，字母表为 $\Sigma &#x3D; \{a, b\}$，初始状态为 $q_0$，接受状态为 $F &#x3D; \{q_1\}$，且转移函数如下：</p><ul><li>$\delta(q_0, a) &#x3D; \{q_1\}$</li><li>$\delta(q_1, b) &#x3D; \{q_2\}$</li><li>$\delta(q_0, \epsilon) &#x3D; \{q_2\}$</li></ul><p>则其空转移闭包为：</p><p>$$<br>E\text{-closure}(q_0) &#x3D; \{q_0, q_2\}<br>$$</p><p>扩展转移函数计算为：</p><ul><li>对于输入字符串 $a$，从状态 $q_0$ 开始，$E$-closure 包含 $q_0$ 和 $q_2$，因此扩展转移将考虑状态 $q_0$ 和 $q_2$ 的转移。<ul><li>从 $q_0$，转移到 $q_1$。</li><li>从 $q_2$，没有输入符号 $a$ 的转移。</li></ul></li></ul><p>所以，扩展转移函数为：</p><p>$$<br>\delta^*(q_0, a) &#x3D; \{q_1, q_2\}<br>$$</p><ul><li>对于输入字符串 $ab$，我们首先从状态 $q_0$ 处理 $a$，然后再从 $q_1$ 处理 $b$。<ul><li>从 $q_0$ 处理 $a$ 后，到达状态 $q_1$。</li><li>从 $q_1$ 处理 $b$ 后，到达状态 $q_2$。</li></ul></li></ul><p>所以，扩展转移函数为：</p><p>$$<br>\delta^*(q_0, ab) &#x3D; \{q_2\}<br>$$</p><hr><h4 id="2-2-4-epsilon-NFA与NFA等价性证明"><a href="#2-2-4-epsilon-NFA与NFA等价性证明" class="headerlink" title="2.2.4 $\epsilon$-NFA与NFA等价性证明"></a>2.2.4 $\epsilon$-NFA与NFA等价性证明</h4><p>为了证明 <strong>$\epsilon$-NFA</strong> 和 <strong>NFA</strong> 之间的等价性，即任何一个 <strong>$\epsilon$-NFA</strong> 都可以转换为一个等价的 <strong>NFA</strong>，我们将使用数学归纳法来推导和证明。</p><p><strong>定义：</strong></p><ul><li><strong>$\epsilon$-NFA</strong>（Epsilon-Non-deterministic Finite Automaton）：与普通的 NFA 不同，$\epsilon$-NFA 允许在没有消耗任何输入字符的情况下，通过 $\epsilon$ 转移从一个状态跳转到另一个状态。</li><li><strong>NFA</strong>（Non-deterministic Finite Automaton）：普通的非确定性有限自动机，在每个状态下对每个输入符号至多有一个转移。</li></ul><p><strong>证明目标：</strong> 对于每个 <strong>$\epsilon$-NFA</strong>，存在一个等价的 <strong>NFA</strong>，可以接受相同的语言。</p><p><strong>证明思路：</strong> 我们将采用归纳法来证明，即：任何 <strong>$\epsilon$-NFA</strong> 都可以通过一个构造转换为一个等价的 <strong>NFA</strong>。</p><p><strong>Step 1：基础情况</strong></p><p>假设我们有一个最简单的 <strong>$\epsilon$-NFA</strong>，它没有任何 $\epsilon$ 转移。即这个 <strong>$\epsilon$-NFA</strong> 实际上是一个普通的 <strong>NFA</strong>，因此显然是等价的。</p><ul><li><strong>$\epsilon$-NFA</strong> 就是一个普通的 <strong>NFA</strong>。</li><li>因此，这种情况我们已经证明了等价性。</li></ul><p><strong>Step 2：归纳假设</strong></p><p>假设对于所有状态数目小于 $n$ 的 <strong>$\epsilon$-NFA</strong>，我们已经证明它们与相应的 <strong>NFA</strong> 等价。即：对所有状态数目小于 $n$ 的 <strong>$\epsilon$-NFA</strong>，我们都能构造一个等价的 <strong>NFA</strong>。</p><p><strong>Step 3：归纳步骤</strong></p><p>现在考虑一个有 $n$ 个状态的 <strong>$\epsilon$-NFA</strong>。我们需要通过构造一个 <strong>NFA</strong> 来证明它与 <strong>NFA</strong> 等价。</p><p>假设我们的 <strong>$\epsilon$-NFA</strong> 定义为：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li>$Q &#x3D; \{q_0, q_1, q_2, \dots, q_{n-1}\}$ 是状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta$ 是转移函数，$\delta: Q \times (\Sigma \cup {\epsilon}) \to 2^Q$，表示从状态到状态的转移。</li><li>$q_0$ 是初始状态。</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>我们的任务是构造一个等价的 <strong>NFA</strong>，用来接受相同的语言。</p><hr><p><strong>构造过程:</strong></p><ol><li><p><strong>扩展状态集</strong>：</p><ul><li>对于给定的 <strong>$\epsilon$-NFA</strong>，我们构造一个新的 <strong>NFA</strong>，将其状态集 $Q$ 扩展为 $\tilde{Q}$，其中 $\tilde{Q}$ 表示每个状态的 <strong>$\epsilon$ 闭包</strong>。也就是说，$\tilde{Q}$ 中的每个元素是 <strong>$\epsilon$ 闭包</strong> 集合，表示从原状态集的每个状态出发，经过若干个 $\epsilon$ 转移后可能到达的所有状态。</li></ul></li><li><p><strong>定义新的转移函数</strong>：</p><ul><li>对于每一个 $\tilde{q} \in \tilde{Q}$ 和输入符号 $a \in \Sigma$，新的转移函数 $\tilde{\delta}$ 将定义为：<br>$$<br>\tilde{\delta}(\tilde{q}, a) &#x3D; \bigcup_{q \in \tilde{q}} \delta(q, a)<br>$$<br>其中 $\tilde{q}$ 是一个 <strong>$\epsilon$ 闭包</strong> 集合，而 $\delta(q, a)$ 是普通的 NFA 转移。</li><li>注意，$\tilde{q}$ 代表的是从状态集合中通过 $\epsilon$ 转移到达的所有状态，因此 $\tilde{\delta}(\tilde{q}, a)$ 是所有从该集合内的状态通过输入字符 $a$ 能到达的状态的并集。</li></ul></li><li><p><strong>定义初始状态和接受状态</strong>：</p><ul><li>新的初始状态是 $\tilde{q_0} &#x3D; \text{E-closure}(q_0)$，即初始状态 $q_0$ 经过 $\epsilon$ 闭包后到达的状态集合。</li><li>接受状态集 $F’ &#x3D; \{\tilde{q} \mid \tilde{q} \cap F \neq \emptyset\}$，即任何包含原接受状态 $F$ 中某个状态的状态集合都作为新的接受状态。</li></ul></li></ol><hr><p><strong>证明等价性</strong></p><p>我们要证明，通过上述构造的 <strong>NFA</strong> 能够接受与原 <strong>$\epsilon$-NFA</strong> 相同的语言。我们使用归纳法步骤中的假设和构造的转换来证明这一点。</p><ol><li><p><strong>$\epsilon$ 闭包和转移函数</strong>：</p><ul><li>在 <strong>$\epsilon$-NFA</strong> 中，任何通过 $\epsilon$ 转移到达的状态都能被纳入 <strong>NFA</strong> 的转移函数中。由于 $\epsilon$ 转移没有消耗输入字符，因此 <strong>NFA</strong> 的转移函数扩展了对 $\epsilon$ 转移的处理。</li><li>每个 <strong>$\epsilon$-NFA</strong> 的 $\epsilon$ 闭包都被映射为 <strong>NFA</strong> 的状态集合，而输入字符会在这个集合内传播。</li></ul></li><li><p><strong>接受条件</strong>：</p><ul><li><strong>NFA</strong> 通过判断是否可以到达一个包含原接受状态的集合来确定是否接受字符串。这与 <strong>$\epsilon$-NFA</strong> 的接受条件一致，即只要从初始状态出发经过输入串到达某个接受状态，就被接受。</li></ul></li><li><p><strong>语言相等性</strong>：</p><ul><li>由于 <strong>$\epsilon$-NFA</strong> 的每一步转移都在 <strong>NFA</strong> 中得到了精确的映射，并且接受状态的条件也被正确保留，因此构造的 <strong>NFA</strong> 接受的语言与原 <strong>$\epsilon$-NFA</strong> 接受的语言是相同的。</li></ul></li></ol><p>通过以上构造和证明，我们可以得出结论：<strong>任何一个 $\epsilon$-NFA 都可以转换为一个等价的 NFA</strong>，即 $\epsilon$-NFA$ \equiv$ NFA。</p><div class="note note-success">            <p>此后不再明确区分$\epsilon$-NFA和NFA，因为它们都是NFA</p>          </div><hr><h3 id="2-3-DFA和NFA等价性证明"><a href="#2-3-DFA和NFA等价性证明" class="headerlink" title="2.3 DFA和NFA等价性证明"></a>2.3 DFA和NFA等价性证明</h3><p>在形式语言与自动机理论中，<strong>确定性有限自动机</strong>（DFA）和<strong>非确定性有限自动机</strong>（NFA）是两种常见的自动机模型。它们用于识别正则语言，并且<strong>DFA</strong> 和 <strong>NFA</strong> 是<strong>等价的</strong>，即它们识别的语言是完全一样的。具体来说，任何一个 NFA 都可以转换成一个等价的 DFA，反之亦然。以下是 DFA 和 NFA 等价性的证明过程。</p><p>DFA 是一个五元组 $(Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是有限状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta: Q \times \Sigma \to Q$ 是状态转移函数，给定当前状态和输入符号，确定唯一的下一个状态。</li><li>$q_0 \in Q$ 是初始状态。</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>NFA 是一个五元组 $(Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是有限状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta: Q \times \Sigma \to \mathcal{P}(Q)$ 是状态转移函数，给定当前状态和输入符号，可以转移到多个状态（即可以是空的或多个状态的集合）。</li><li>$q_0 \in Q$ 是初始状态。</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>我们要证明的是，<strong>每个 NFA 都可以转化为一个等价的 DFA</strong>。为此，我们将通过构造来展示如何从 NFA 构造 DFA，使得它们识别的语言是一样的。</p><p>分析：从 NFA 转换到 DFA</p><p>假设有一个 NFA $N &#x3D; (Q, \Sigma, \delta, q_0, F)$，我们想构造一个等价的 DFA $D &#x3D; (Q’, \Sigma, \delta’, q_0’, F’)$。</p><ol><li><p><strong>状态集</strong>：DFA 的状态集 $Q’$ 由 NFA 的状态集的子集组成。更具体地，DFA 的状态对应于 NFA 的状态集合的一个子集。即 $Q’ \subseteq 2^Q$（所有 NFA 状态的集合的幂集）。</p></li><li><p><strong>初始状态</strong>：DFA 的初始状态 $q_0’$ 是 NFA 初始状态的 $\epsilon$-闭包。记 $E\text{-closure}(q_0)$ 为 NFA 状态 $q_0$ 的空转移闭包。于是，DFA 的初始状态是 $q_0’ &#x3D; E\text{-closure}(q_0)$。</p></li><li><p><strong>转移函数</strong>：对于 DFA 中的每个状态（它是 NFA 状态的一个子集），DFA 的转移函数 $\delta’(S, a)$ 被定义为所有 NFA 状态在读取符号 $a$ 后所能到达的状态的 $\epsilon$-闭包：</p><p>$$ \delta’(S, a) &#x3D; E\text{-closure} \left( \bigcup_{q \in S} \delta(q, a) \right) $$</p><p>也就是说，DFA 的转移函数是 NFA 中所有可能的状态集合的组合。</p></li><li><p><strong>接受状态集</strong>：DFA 的接受状态集 $F’$ 由 NFA 中的所有包含接受状态的状态集合组成。即：</p><p>$$ F’ &#x3D; \{ S \subseteq Q \mid S \cap F \neq \emptyset \} $$</p><p>也就是说，DFA 中只要某个状态子集包含 NFA 的某个接受状态，它就被认为是接受状态。</p></li></ol><p><strong>证明：</strong></p><p>为了证明从 NFA 到 DFA 的转换是有效的，即两者识别的语言是一样的，我们可以分为以下几步：</p><ol><li><p><strong>从 NFA 接受的语言到 DFA</strong>：</p><ul><li>NFA 对输入字符串 $w$ 执行多个路径，并在路径中存在至少一条接受状态时就接受字符串。</li><li>对于 DFA，它基于一个状态子集来模拟所有这些路径。由于每个状态子集都包括了 NFA 的多个状态，DFA 必定能够找到 NFA 中的一个路径来接受字符串。</li></ul><p>因此，如果一个字符串被 NFA 接受，它也会被通过构造的 DFA 接受。</p></li><li><p><strong>从 DFA 接受的语言到 NFA</strong>：</p><ul><li>DFA 在每一步都有唯一的转移，因此它只能遵循一个路径。这个路径可以直接对应于 NFA 的多个可能路径。</li><li>因此，如果 DFA 接受一个字符串，那么这个字符串也会被 NFA 接受（尽管 NFA 可能有多个路径，但至少有一条与 DFA 的唯一路径相同）。</li></ul></li></ol><p>由于这两个方向的转换都成立，因此 <strong>DFA 和 NFA 是等价的</strong>。</p><p>假设我们有一个简单的 NFA，其状态集为 $Q &#x3D; \{q_0, q_1\}$，字母表为 $\Sigma &#x3D; \{a, b\}$，初始状态为 $q_0$，接受状态为 $F &#x3D; \{q_1\}$，转移函数如下：</p><ul><li>$\delta(q_0, a) &#x3D; \{q_0, q_1\}$</li><li>$\delta(q_0, b) &#x3D; \{q_0\}$</li><li>$\delta(q_1, a) &#x3D; \{q_1\}$</li><li>$\delta(q_1, b) &#x3D; \{q_1\}$</li></ul><p>可以看到，NFA 在状态 $q_0$ 时，对于输入 $a$ 可以转移到 $q_0$ 或 $q_1$。我们可以按照上述方法将此 NFA 转换为一个等价的 DFA。</p><p>这里我们简单总结一下：</p><ul><li><strong>DFA 和 NFA 是等价的</strong>，它们可以识别相同的正则语言。</li><li><strong>NFA 到 DFA 的转换</strong>是通过将 NFA 状态的所有子集映射到 DFA 状态的过程来实现的。</li><li><strong>从 NFA 到 DFA 的转换</strong>能够保留语言不变，并且可以通过递归地计算状态的 $\epsilon$-闭包和转移来实现。</li></ul><p>这个等价性证明展示了尽管 DFA 和 NFA 在结构上有所不同，但它们的能力是等同的，都能够识别正则语言(Regular Language)。</p><hr><h3 id="2-4-State-Elimination-Method"><a href="#2-4-State-Elimination-Method" class="headerlink" title="2.4 State Elimination Method"></a>2.4 State Elimination Method</h3><p><strong>状态消除法（State Elimination Method）</strong> 是一种常用于将有限状态机（Finite State Machine, FSM）或确定性有限自动机（Deterministic Finite Automaton, DFA）转换为正则表达式的技术。在形式语言与自动机的学习中，这一方法是将有限状态机的转移图简化为一个相应的正则表达式的有效工具。</p><p><strong>基本步骤</strong></p><ol><li><p><strong>构造状态转移图：</strong><br>开始时，首先需要有一个确定的有限状态机（DFA）或者非确定的有限状态机（NFA），其状态转移图应包括：</p><ul><li>各状态</li><li>状态之间的转移（可能是输入字符）</li><li>初态与终态的标定</li></ul></li><li><p><strong>从图中删除状态：</strong><br>在每一步中，选择一个非终态进行删除。删除一个状态时，需考虑：</p><ul><li>状态间的所有可能的转移路径。</li><li>通过删除该状态，可能会导致一些新路径的产生。</li></ul></li><li><p><strong>更新转移关系：</strong><br>删除某一状态后，所有从该状态出发的转移关系必须通过其它状态来代替。具体地：</p><ul><li>如果有从状态 <code>A</code> 到状态 <code>B</code> 的路径 <code>a</code> 和从状态 <code>B</code> 到状态 <code>C</code> 的路径 <code>b</code>，那么删除状态 <code>B</code> 后，可以通过路径 <code>a</code> 和 <code>b</code> 连接成新的路径 <code>ab</code>。</li><li>对于状态 <code>B</code> 本身的自环路径（比如 <code>B</code> 到 <code>B</code> 的路径），要通过循环自环的组合形成新的路径。</li></ul></li><li><p><strong>重复删除直到只剩下起始状态和终止状态：</strong><br>继续删除其他非终态，逐步简化自动机的结构，直到只剩下一个起始状态和一个或多个终止状态。这时可以从起始状态到终止状态的路径表示为一个正则表达式。</p></li><li><p><strong>得到正则表达式：</strong><br>一旦删除所有状态，只剩下两个状态（起始状态和终止状态），从起始状态到终止状态的所有路径就是自动机的正则表达式。</p></li></ol><img src="/img/FL/state_elimation.svg" alt="状态消除法" style="max-width: 100%; height: auto;" /><h2 id="3-Regular-Language"><a href="#3-Regular-Language" class="headerlink" title="3. Regular Language"></a>3. Regular Language</h2><p><strong>正则语言 (Regular Language)</strong> 是形式语言理论中的一个重要概念，通常与有限自动机（Finite Automata, FA）和正则表达式（Regular Expressions, RE）相关联。正则语言是可以被有限自动机识别或由正则表达式描述的语言。它们的特点是相对简单，能够用有限的计算资源进行识别或生成。</p><p>形式化地，正则语言是一个语言集合，满足以下条件之一：</p><ul><li>它可以被一个<strong>有限自动机</strong>识别。</li><li>它可以通过<strong>正则表达式</strong>来描述。</li><li>它可以通过正则文法生成。</li></ul><p>这些语言可以被归类为<strong>正规语言</strong>，它们的生成和识别过程是有限的，不需要无限的计算资源。</p><p>正则语言可以通过 DFA 或 NFA 来识别。尽管 DFA 和 NFA 之间在形式上有所不同，实际上它们是等价的，因为每一个 NFA 都可以被转换成一个等效的 DFA。</p><blockquote><p>有限自动机与正则表达式的等价性证明留到后面</p></blockquote><div class="note note-primary">            <p><strong>有限自动机 (Finite Automaton)</strong> 是一种计算模型，它由一组状态、一个输入字母表、一个转换函数、一个初始状态和一些接受状态组成。有限自动机有两种类型：</p><ul><li><strong>确定性有限自动机 (DFA)</strong> ：对于每个状态和输入符号，都有唯一的转移。</li><li><strong>非确定性有限自动机 (NFA)</strong> ：对于某些状态和输入符号，可能有多个转移或者没有转移。</li></ul>          </div><p>正则语言具有一些有用的性质，包括：</p><ul><li><p><strong>闭包性质</strong>：正则语言在以下操作下保持闭合，即操作结果仍然是正则语言。</p><ul><li><strong>并运算</strong>：如果 $L_1$ 和 $L_2$ 是正则语言，则 $L_1 \cup L_2$ 也是正则语言。</li><li><strong>连接运算</strong>：如果 $L_1$ 和 $L_2$ 是正则语言，则 $L_1 \cdot L_2$ 也是正则语言。</li><li><strong>星号闭包（Kleene闭包）</strong>：如果 $L$ 是正则语言，则 $L^*$ 也是正则语言。</li><li><strong>补运算</strong>：正则语言对于补集操作是封闭的，假设 $L$ 是正则语言，则 $\overline{L}$ 也是正则语言。</li></ul></li><li><p><strong>可表示性</strong>：正则语言可以用正则表达式来描述。每个正则表达式都定义了一个正则语言。</p></li></ul><blockquote><p>后面内容对这里的正确性进行证明</p></blockquote><p>尽管正则语言非常有用，它们也有一些限制：</p><ul><li>正则语言无法描述<strong>上下文相关语言</strong>或<strong>上下文无关语言</strong>中一些更复杂的结构。例如，正则语言不能识别平衡的括号或相互嵌套的结构。</li><li>正则语言只能识别相对简单的模式（如重复模式、选择模式），对于更复杂的结构，它们的<strong>表达能力有限。</strong></li></ul><p>正则语言和正则表达式在计算机科学中有广泛应用，尤其是在文本处理领域，如：</p><ul><li><strong>文本搜索</strong>：正则表达式广泛用于字符串匹配和文本搜索。</li><li><strong>编译器设计</strong>：在编译器中，正则语言用于词法分析阶段，识别输入的词法单位（如关键字、标识符、操作符等）。</li><li><strong>数据验证</strong>：在输入数据验证中，正则表达式被用于检查输入是否符合特定模式（如电子邮件地址、电话号码等）。</li></ul><hr><ol><li><p><strong>正则语言的简单示例</strong>：</p><ul><li>语言 $L &#x3D; {a, b}$，即由字符 ‘a’ 或 ‘b’ 组成的语言，可以由正则表达式 $a|b$ 来表示。</li></ul></li><li><p><strong>使用 Kleene 星号操作</strong>：</p><ul><li>语言 $L &#x3D; {a^n \mid n \geq 0}$，即包含任意数量的字符 ‘a’ 的语言，可以用正则表达式 $a^*$ 来表示。</li></ul></li><li><p><strong>连接操作</strong>：</p><ul><li>语言 $L &#x3D; {ab, abc}$，即包含字符串 ‘ab’ 和 ‘abc’ 的语言，可以通过正则表达式 $ab|abc$ 来表示。</li></ul></li></ol><hr><h3 id="3-1-Regular-Expression"><a href="#3-1-Regular-Expression" class="headerlink" title="3.1 Regular Expression"></a>3.1 Regular Expression</h3><p><strong>正则表达式 (Regular Expression, RE)</strong> 是一种用于描述字符串模式的形式化语言，广泛应用于文本搜索、数据匹配、编译器的词法分析等领域。在形式语言与自动机的理论中，正则表达式用于定义<strong>正则语言</strong>，它们能够描述可以被<strong>有限自动机</strong>识别的语言。</p><p>正则表达式是一种通过特定规则组合字母、符号和运算符来表示字符串集合的工具。它由字母表（通常为有限的字符集）中的符号以及以下几种运算符组合而成：</p><ul><li><strong>字面量字符</strong>：如字符 <code>a</code>、<code>b</code>、<code>1</code> 等，它们直接表示一个特定的字符。</li><li><strong>连接 (Concatenation)</strong> ：将两个正则表达式拼接在一起，表示这两个模式依次出现。例如，<code>ab</code> 表示第一个字符是 <code>a</code>，第二个字符是 <code>b</code>。(也可以用<code>·</code>来表示)</li><li><strong>并运算 (Union)</strong> ：表示选择操作，表示两个模式的并集。用竖线 <code>|</code> 表示，如 <code>a|b</code> 表示匹配 <code>a</code> 或 <code>b</code>。（也可以用<code>+</code>来表示并运算）</li><li><strong>Kleene 星号 (Kleene Star)</strong> ：表示零次或多次重复某个模式。用星号 <code>*</code> 表示，如 <code>a*</code> 表示匹配零次或多次字符 <code>a</code>。</li><li><strong>括号 (Parentheses)</strong> ：用于分组操作，将多个元素或子表达式组合成一个单位。例如，<code>(ab)*</code> 表示零次或多次重复 <code>ab</code>。</li><li><strong>字符集 (Character Class)</strong> ：用于匹配一组字符中的任意一个。用方括号 <code>[]</code> 表示，如 <code>[a-z]</code> 表示匹配小写字母中的任何一个。</li><li><strong>取反 (Negation)</strong> ：表示匹配不在指定字符集中的字符。用 <code>^</code> 在字符集的开头表示，如 <code>[^0-9]</code> 表示匹配任意非数字字符。</li></ul><hr><p>下面列举一些简单的例子：</p><ol><li><p><strong>匹配一个单一字符：</strong></p><ul><li><code>a</code>：匹配字符 <code>a</code>。</li></ul></li><li><p><strong>匹配字符的选择：</strong></p><ul><li><code>a|b</code>：匹配字符 <code>a</code> 或字符 <code>b</code>。</li></ul></li><li><p><strong>匹配多个字符：</strong></p><ul><li><code>abc</code>：匹配字符串 <code>abc</code>。</li></ul></li><li><p><strong>匹配字符重复：</strong></p><ul><li><code>a*</code>：匹配零次或多次字符 <code>a</code>，即可以匹配空字符串、<code>a</code>、<code>aa</code>、<code>aaa</code> 等。</li><li><code>(ab)*</code>：匹配零次或多次 <code>ab</code>，即可以匹配空字符串、<code>ab</code>、<code>abab</code> 等。</li></ul></li><li><p><strong>匹配字符集合：</strong></p><ul><li><code>[0-9]</code>：匹配任意一个数字字符。</li><li><code>[a-zA-Z]</code>：匹配任意一个英文字母（不区分大小写）。</li></ul></li><li><p><strong>匹配任意字符：</strong></p><ul><li><code>.</code>：表示匹配任意单个字符（除了换行符）。</li></ul></li></ol><hr><p>正则表达式广泛应用于多个领域，主要包括：</p><ul><li><strong>文本搜索与替换</strong>：可以在文本中查找匹配特定模式的字符串，或对匹配的部分进行替换。</li><li><strong>数据验证</strong>：验证用户输入是否符合特定模式，如电子邮件、电话号码等。</li><li><strong>编译器与解释器</strong>：在编译器的词法分析阶段，正则表达式用于识别源代码中的词法单元（tokens），如关键字、标识符、常数等。</li><li><strong>日志分析与处理</strong>：从大量的日志文件中提取出符合特定模式的数据，进行后续分析。</li></ul><p>尽管正则表达式非常强大，但它也有一些限制，主要体现在以下方面：</p><ul><li>正则表达式无法处理<strong>上下文依赖</strong>的结构，比如匹配平衡的括号或递归模式。</li><li>对于复杂的语言结构，正则表达式的表达能力是有限的。对于需要更复杂模式匹配的任务，可能需要更高级的解析技术，如上下文无关文法或上下文相关文法。</li></ul><blockquote><p>这里就引入了后面章节的下推自动机和上下文无关文法</p></blockquote><hr><p>正则表达式中的运算符有一定的优先级，决定了它们在表达式中组合的顺序。理解这些优先级对于正确解析和构建正则表达式至关重要。</p><p><strong>运算优先级总结：</strong></p><ol><li><strong><code>()</code></strong> ：分组，最高优先级。</li><li><strong>量词 <code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;n,m&#125;</code></strong> ：应用于前面的字符或表达式。</li><li><strong><code>[]</code></strong> 和 <strong><code>[^]</code></strong> ：字符集和取反。</li><li><strong><code>|</code></strong> ：选择，最低优先级。</li></ol><p><strong>示例：</strong></p><ul><li><strong><code>a(b|c)*d</code></strong> ：匹配 <code>a</code> 后跟 <code>b</code> 或 <code>c</code> 任意次（包括零次）再跟 <code>d</code>。这里，<code>(b|c)</code> 优先于 <code>*</code>。</li><li><strong><code>a|b*</code></strong> ：先匹配 <code>b*</code>，然后匹配 <code>a</code>，因为 <code>*</code> 的优先级高于 <code>|</code>。</li></ul><div class="note note-success">            <p>修考题目中会有许多正则表达式的考点，我就放在修考真题里来讲解吧…</p>          </div><hr><h3 id="3-2-有限自动机与正则表达式的等价性证明"><a href="#3-2-有限自动机与正则表达式的等价性证明" class="headerlink" title="3.2 有限自动机与正则表达式的等价性证明"></a>3.2 有限自动机与正则表达式的等价性证明</h3><p><em>第一部分：基本定义</em></p><p>一个确定性有限自动机(DFA) $M$ 是一个五元组 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是有限的状态集</li><li>$\Sigma$ 是有限的输入字母表</li><li>$\delta: Q \times \Sigma \rightarrow Q$ 是转移函数</li><li>$q_0 \in Q$ 是初始状态</li><li>$F \subseteq Q$ 是接受状态集合</li></ul><p>一个非确定性有限自动机(NFA) $M$ 是一个五元组 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$\delta: Q \times (\Sigma \cup {\varepsilon}) \rightarrow \mathcal{P}(Q)$ 是转移函数，$\mathcal{P}(Q)$表示$Q$的幂集</li><li>其他组件与DFA定义相同</li></ul><p>正则表达式归纳定义如下：</p><ol><li>$\emptyset$ 是正则表达式</li><li>$\varepsilon$ 是正则表达式</li><li>对于任何 $a \in \Sigma$，$a$ 是正则表达式</li><li>如果 $r$ 和 $s$ 是正则表达式，则：<ul><li>$(r \cdot s)$ 是正则表达式（连接）</li><li>$(r|s)$ 是正则表达式（选择）</li><li>$(r*)$ 是正则表达式（Kleene闭包）</li></ul></li></ol><p>正则表达式表示的语言: $L(r)$ 表示正则表达式 $r$ 表示的语言，归纳定义如下：</p><ol><li>$L(\emptyset) &#x3D; \emptyset$</li><li>$L(\varepsilon) &#x3D; \{\varepsilon\}$</li><li>$L(a) &#x3D; \{a\}$, $a \in \Sigma$</li><li>$L(r \cdot s) &#x3D; L(r) \cdot L(s)$</li><li>$L(r|s) &#x3D; L(r) \cup L(s)$</li><li>$L(r^*) &#x3D; L(r)* &#x3D; \bigcup_{i \geq 0} L(r)^i$</li></ol><p><em>第二部分：正则表达式到有限自动机的转换</em></p><p><strong>定理:Thompson构造</strong>:</p><ul><li>对于任意正则表达式 $r$，存在一个接受 $L(r)$ 的$\varepsilon$-NFA。</li></ul><p>我们用结构归纳法证明。</p><p>基础情况：</p><ol><li><p>$r &#x3D; \emptyset$：<br>构造 $M &#x3D; (\{q_0\}, \Sigma, \delta, q_0, \emptyset)$，其中$\delta$为空函数</p></li><li><p>$r &#x3D; \varepsilon$：<br>构造 $M &#x3D; (\{q_0\}, \Sigma, \delta, q_0, \{q_0\})$，其中$\delta$为空函数</p></li><li><p>$r &#x3D; a$，$a \in \Sigma$：<br>构造 $M &#x3D; (\{q_0, q_1\}, \Sigma, \delta, q_0, \{q_1\})$，其中<br>$\delta(q_0, a) &#x3D; \{q_1\}$</p></li></ol><p>归纳步骤：<br>假设对于正则表达式 $r_1$ 和 $r_2$，已经构造出接受 $L(r_1)$ 和 $L(r_2)$ 的NFA $M_1 &#x3D; (Q_1, \Sigma, \delta_1, s_1, F_1)$ 和 $M_2 &#x3D; (Q_2, \Sigma, \delta_2, s_2, F_2)$。</p><ol><li><p>连接 $r &#x3D; r_1 \cdot r_2$：<br>构造 $M &#x3D; (Q_1 \cup Q_2, \Sigma, \delta, s_1, F_2)$，其中</p><ul><li>$\delta(q, a) &#x3D; \delta_1(q, a)$ 对于 $q \in Q_1, a \in \Sigma$</li><li>$\delta(q, a) &#x3D; \delta_2(q, a)$ 对于 $q \in Q_2, a \in \Sigma$</li><li>$\delta(f, \varepsilon) &#x3D; {s_2}$ 对于所有 $f \in F_1$</li></ul></li><li><p>选择 $r &#x3D; r_1|r_2$：<br>构造 $M &#x3D; (Q_1 \cup Q_2 \cup \{q_0\}, \Sigma, \delta, q_0, F_1 \cup F_2)$，其中</p><ul><li>$\delta(q_0, \varepsilon) &#x3D; {s_1, s_2}$</li><li>其他转移同上</li></ul></li><li><p>Kleene闭包 $r &#x3D; r_1*$：<br>构造 $M &#x3D; (Q_1 \cup \{q_0\}, \Sigma, \delta, q_0, \{q_0\} \cup F_1)$，其中</p><ul><li>$\delta(q_0, \varepsilon) &#x3D; \{s_1\}$</li><li>$\delta(f, \varepsilon) &#x3D; \{s_1, q_0\}$ 对于所有 $f \in F_1$</li></ul></li></ol><p><em>第三部分：有限自动机到正则表达式的转换</em></p><p><em>广义化的Kleene定理:</em> 对于任意NFA $M$，存在一个正则表达式 $r$，使得 $L(M) &#x3D; L(r)$。</p><p><strong>证明：</strong></p><p>给定NFA $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，令 $Q &#x3D; \{1, 2, …, n\}$。</p><ol><li><p>定义生成式 $R_{ij}^k$，表示从状态$i$到状态$j$的路径，其中中间状态编号不超过$k$。</p></li><li><p>基础情况 $(k &#x3D; 0)$：$R_{ij}^0 &#x3D; \{a | j \in \delta(i, a)\} \cup \{\varepsilon | i &#x3D; j\}$</p></li><li><p>归纳步骤：$R_{ij}^k &#x3D; R_{ij}^{k-1} \cup R_{ik}^{k-1}(R_{kk}^{k-1})^*R_{kj}^{k-1}$</p></li><li><p>最终表达式：$r &#x3D; \bigcup\{R_{0j}^n | j \in F\}$</p></li></ol><p><em>第四部分：等价性证明的完成</em></p><p>Kleene定理: 一个语言是正则的，当且仅当它能被某个有限自动机识别。</p><blockquote><p>The language is regular if and only if it can be recognized by some finite automaton.</p></blockquote><p><strong>证明：</strong></p><ol><li>$(\Rightarrow)$ 由定理2.1，每个正则表达式都可以转换为等价的NFA</li><li>$(\Leftarrow)$ 由定理3.1，每个NFA都可以转换为等价的正则表达式</li></ol><p>补充定理：对于任意正则表达式 $r$，如果 $M$ 是通过Thompson构造得到的NFA，那么：<br>$L(M) &#x3D; L(r)$</p><p><strong>证明：</strong> 用归纳法证明，对应每个构造步骤，证明：<br>$w \in L(r) \Leftrightarrow w \in L(M)$</p><blockquote><p>这里的等价性证明非常繁琐…我们只需要知道有限自动机和正则表达式在表示语言的能力上等价即可。直接记结论。</p></blockquote><hr><h3 id="3-3-正则表达式的代数定律"><a href="#3-3-正则表达式的代数定律" class="headerlink" title="3.3 正则表达式的代数定律"></a>3.3 正则表达式的代数定律</h3><p>正则表达式的代数定律是形式语言与自动机理论中的重要内容，它描述了正则表达式在运算过程中具有的一些代数性质。这些定律可以帮助简化和推导正则表达式，进而用于分析和构造自动机。以下是常见的正则表达式代数定律：</p><p><strong>1.交换律 (Commutative Law)</strong></p><ul><li>对于两种运算，正则表达式的并运算是满足交换律的，但是<em>连接运算是不满足的。</em></li><li><strong>并运算：</strong><br>$$<br>A + B &#x3D; B + A<br>$$<br>意思是，两个正则表达式的并运算可以交换顺序。</li><li><strong>连接运算：</strong><br>$$<br>A \cdot B \neq B \cdot A<br>$$</li></ul><p><strong>2.结合律 (Associative Law)</strong></p><ul><li><strong>并运算：</strong><br>$$<br>(A + B) + C &#x3D; A + (B + C)<br>$$</li><li><strong>连接运算：</strong><br>$$<br>(A \cdot B) \cdot C &#x3D; A \cdot (B \cdot C)<br>$$</li></ul><p><strong>3.分配律 (Distributive Law)</strong></p><ul><li><strong>连接对并的分配律：</strong><br>$$<br>A \cdot (B + C) &#x3D; (A \cdot B) + (A \cdot C)<br>$$</li><li><strong>并对连接的分配律：</strong><br>$$<br>(A + B) \cdot C &#x3D; (A \cdot C) + (B \cdot C)<br>$$</li></ul><p><strong>4.单位元律 (Identity Law)</strong></p><ul><li>正则表达式中有“单位元”概念，通常用空集和空字符串表示。<ul><li>空集 $∅$ 与并运算：<br>$$<br>A + \emptyset &#x3D; A<br>$$</li><li>空字符串 $ε$ 与连接运算：<br>$$<br>A \cdot \varepsilon &#x3D; A<br>$$</li></ul></li></ul><p><strong>5.幂集运算 (Kleene Star)</strong></p><ul><li>Kleene星（表示零次或多次重复）有一些特殊的性质：<ul><li><strong>结合律：</strong><br>$$<br>(A^*)^* &#x3D; A^*<br>$$</li><li><strong>吸收律：</strong><br>$$<br>A \cdot A^* &#x3D; A^*<br>$$<br>$$<br>A^* \cdot A &#x3D; A^*<br>$$</li><li><strong>与空集结合：</strong><br>$$<br>\emptyset^* &#x3D; \varepsilon<br>$$</li><li><strong>空字符串的 Kleene 星：</strong><br>$$<br>\varepsilon^* &#x3D; \varepsilon<br>$$</li></ul></li></ul><hr><h3 id="3-4-Pumping-Lemma"><a href="#3-4-Pumping-Lemma" class="headerlink" title="3.4 Pumping Lemma"></a>3.4 Pumping Lemma</h3><p>正则语言的泵引理（<strong>Pumping Lemma</strong>）是形式语言与自动机理论中的一个重要工具，用于证明某个语言不是正则语言。泵引理提供了一种“泵”的性质，即正则语言中的某些字符串可以在一定条件下重复（或“泵”）而不改变该字符串是否属于语言。</p><p>泵引理主要适用于正则语言，它指出：如果一个语言是正则的，那么存在一个常数 $p$（泵长度），对于任何长度大于或等于 $p$ 的字符串 $s \in L$（该字符串属于语言 $L$），都可以将 $s$ 分解成以下三部分：</p><ul><li>$s &#x3D; xyz$，其中：<ul><li>$x$ 是 $s$ 的前缀（可能为空）。</li><li>$y$ 是可以被“泵”的部分，且 $|y| &gt; 0$。</li><li>$z$ 是 $s$ 的后缀（可能为空）。</li></ul></li></ul><p>并且，对于任意 $i \geq 0$，字符串 $xy^i z$ 都应该属于语言 $L$，也就是说，$y$ 可以重复任意次数而不影响 $s$ 是否在语言 $L$ 中。</p><hr><h4 id="3-4-1-正则语言的泵引理证明"><a href="#3-4-1-正则语言的泵引理证明" class="headerlink" title="3.4.1 正则语言的泵引理证明"></a>3.4.1 正则语言的泵引理证明</h4><p>泵引理是正则语言的一个重要性质，它指出：如果一个语言是正则的，那么存在一个常数 $p$（泵长度），对于任何长度大于或等于 $p$ 的字符串 $s \in L$（该字符串属于语言 $L$），都可以将 $s$ 分解成以下三部分：</p><ul><li>$s &#x3D; xyz$，其中：<ul><li>$x$ 是 $s$ 的前缀（可能为空）。</li><li>$y$ 是可以被“泵”的部分，且 $|y| &gt; 0$。</li><li>$z$ 是 $s$ 的后缀（可能为空）。</li></ul></li></ul><p>并且，对于任意 $i \geq 0$，字符串 $xy^i z$ 都应该属于语言 $L$，也就是说，$y$ 可以重复任意次数而不影响 $s$ 是否在语言 $L$ 中。</p><p><strong>证明思路:</strong></p><ol><li><p><strong>假设语言是正则的</strong>：假设语言 $L$ 是正则的，那么存在一个有限状态自动机（DFA）能够接受语言 $L$。我们称该自动机为 $M$，其状态数为 $q$（即 $M$ 的状态集大小）。设 $p &#x3D; q$，这是泵引理中的泵长度。</p></li><li><p><strong>选择适当的字符串$s$</strong> ：选择一个字符串 $s \in L$，且 $|s| \geq p$。由于 $s$ 的长度大于或等于 $p$，它会经过 DFA $M$ 的多个状态，并且会在某些状态之间重复。</p></li><li><p><strong>应用鸽巢原理(Pigeonhole principle)</strong> ：根据鸽巢原理，若一个物体放入有限多个箱子中，且物体数量超过箱子数量，那么至少有一个箱子中必须放入超过一个物体。</p><p>在这里，DFA $M$ 有 $p$ 个状态（箱子），而字符串 $s$ 长度至少为 $p$，因此在 $s$ 从起始状态到终止状态的过程中，至少有两个不同的位置会经过相同的状态。具体地，假设 $s &#x3D; a_1 a_2 \dots a_n$，其中 $n \geq p$，我们可以表示 $s$ 的执行过程中的状态序列为：<br>$$<br>q_0, q_1, q_2, \dots, q_n<br>$$<br>其中 $q_0$ 是初始状态，$q_1, q_2, \dots, q_n$ 是字符串 $s$ 中每个字符对应的状态转换。</p><p>由于状态总共有 $p$ 个，因此，根据鸽巢原理，在这 $n$ 步转换中，必然存在一个状态 $q_i$（在 $1 \leq i \leq n$）至少重复一次。假设 $q_i &#x3D; q_j$ 且 $i &lt; j$，那么在 $s$ 中，$a_i, a_{i+1}, \dots, a_j$ 这部分的输入字符会使自动机回到同一个状态。这就为我们提供了分解字符串 $s$ 的依据。</p></li><li><p><strong>分解字符串$s$</strong> ：假设字符串 $s$ 被分解为：<br>$$<br>s &#x3D; x , y , z<br>$$<br>其中：</p><ul><li>$x &#x3D; a_1 a_2 \dots a_{i-1}$（从起始位置到重复状态之前的部分），</li><li>$y &#x3D; a_i a_{i+1} \dots a_{j-1}$（从第一个重复状态到第二个重复状态之间的部分），</li><li>$z &#x3D; a_j a_{j+1} \dots a_n$（从第二个重复状态之后的部分）。</li></ul><p>注意到 $y$ 至少包含一个字符，因为 $i &lt; j$，所以 $|y| &gt; 0$。</p></li><li><p><strong>验证泵操作</strong> ：现在我们需要验证，对于任意 $i \geq 0$，字符串 $xy^i z$ 仍然属于语言 $L$。</p><ul><li>由于 $y$ 的重复仅仅是使自动机在状态空间中来回循环，但没有改变接受状态，因此可以通过重复 $y$ 来构造新的字符串 $xy^i z$，使得新的字符串也能被自动机接受。即：<br>$$<br>xy^i z \in L \quad \text{对于任意} \quad i \geq 0<br>$$<br>这就完成了对泵引理的证明。</li></ul></li></ol><img src="/img/FL/pumping_lemma.svg" alt="泵引理证明" style="max-width: 100%; height: auto;" /><p>通过鸽巢原理，我们证明了正则语言的泵引理。我们假设语言是正则的，构造一个长度大于等于泵长度 $p$ 的字符串，并应用鸽巢原理来确定字符串中的某些部分是重复的。然后，通过分解字符串并使用状态重复性（即“泵”）来证明任意重复的部分都不会改变字符串是否属于语言，从而完成了泵引理的证明。</p><hr><h4 id="3-4-2-泵引理的形式化描述"><a href="#3-4-2-泵引理的形式化描述" class="headerlink" title="3.4.2 泵引理的形式化描述"></a>3.4.2 泵引理的形式化描述</h4><p>假设 $L$ 是一个正则语言，那么存在一个常数 $p$，满足：</p><ol><li><p>对于任意的字符串 $s \in L$，如果 $|s| \geq p$，那么 $s$ 可以被分解为 $s &#x3D; xyz$，且满足：</p><ul><li>$|xy| \leq p$，</li><li>$|y| &gt; 0$。</li></ul></li><li><p>对于任意 $i \geq 0$，字符串 $xy^i z \in L$。</p></li></ol><p>泵引理的作用是帮助我们<strong>证明某个语言不是正则的</strong>。具体来说，如果我们能够找到一个语言中的某个字符串，并且我们无法将它分解成符合上述条件的三部分（即无法“泵”），那么就可以证明该语言不是正则的。</p><p><em>如何使用泵引理证明语言不是正则的?</em></p><ol><li><p><strong>假设语言是正则的</strong>：首先假设语言 $L$ 是正则的，那么根据泵引理，必定存在一个泵长度 $p$。</p></li><li><p><strong>选择一个适当的字符串</strong>：从语言 $L$ 中选择一个特定的字符串 $s$，使得 $|s| \geq p$。</p></li><li><p><strong>尝试分解字符串</strong>：尝试将该字符串 $s$ 分解为 $s &#x3D; xyz$，并确保满足上述条件。特别注意，$y$ 部分必须满足 $|y| &gt; 0$。</p></li><li><p><strong>尝试泵操作</strong>：通过不同的 $i$ 值（即对 $y$ 进行不同次数的重复），构造新的字符串 $xy^i z$。</p></li><li><p><strong>找出矛盾</strong>：如果在某些情况下，$xy^i z$ 不再属于语言 $L$，那么就说明假设语言 $L$ 是正则的错误，从而得出结论，$L$ 不是正则语言。</p></li></ol><hr><p><strong>例子 1：</strong> 语言 $L &#x3D; \{ a^n b^n \mid n \geq 0 \}$</p><p>我们来尝试使用泵引理证明这个语言不是正则的。</p><ol><li><p>假设 $L$ 是正则的，那么根据泵引理，存在一个常数 $p$，对于任意 $s \in L$ 且 $|s| \geq p$，都可以分解为 $s &#x3D; xyz$，并且满足：</p><ul><li>$|xy| \leq p$，</li><li>$|y| &gt; 0$。</li></ul></li><li><p>选择 $s &#x3D; a^p b^p$ 作为字符串。显然，$|s| &#x3D; 2p \geq p$，所以 $s$ 必须符合泵引理。</p></li><li><p>根据泵引理，$s &#x3D; xyz$ 且 $|xy| \leq p$，这意味着 $x$ 和 $y$ 只能包含字符 $a$，而 $z$ 中包含的字符则包含 $b$。</p></li><li><p>由于 $y$ 至少包含一个 $a$（因为 $|y| &gt; 0$），我们可以通过泵操作，选择 $i &#x3D; 2$ 生成字符串 $xy^2z$，即将 $y$ 中的 $a$ 重复一次。结果是一个包含 $p+1$ 个 $a$ 和 $p$ 个 $b$ 的字符串，显然它不属于语言 $L$，因为 $L$ 中的字符串必须有相同数量的 $a$ 和 $b$。</p></li><li><p>由于构造的字符串不属于 $L$，这与我们假设 $L$ 是正则语言相矛盾。因此，语言 $L &#x3D; { a^n b^n \mid n \geq 0 }$ 不是正则的。</p></li></ol><p><strong>例子 2：</strong> 语言 $L &#x3D; \{ ww \mid w \in {a, b}^* \}$</p><ol><li><p>假设 $L$ 是正则的，那么根据泵引理，存在一个泵长度 $p$。</p></li><li><p>选择 $s &#x3D; a^p b^p a^p b^p$ 作为字符串，显然，$|s| &#x3D; 4p \geq p$，所以 $s$ 必须符合泵引理。</p></li><li><p>根据泵引理，$s &#x3D; xyz$ 且 $|xy| \leq p$，这意味着 $x$ 和 $y$ 只能包含字符 $a$，而 $z$ 中包含的字符包含 $b$ 和后面的部分。</p></li><li><p>通过泵操作，选择 $i &#x3D; 2$ 生成字符串 $xy^2z$。由于 $y$ 部分仅包含 $a$，所以将 $y$ 重复后，得到的字符串是 $a^{p+k} b^p a^p b^p$（其中 $k &gt; 0$）。显然，这个字符串不能保持原始形式 $ww$，因为它不再符合形式 $ww$（即左右两部分必须完全相同）。</p></li><li><p>因此，语言 $L$ 不是正则的。</p></li></ol><p>泵引理是用来<strong>证明某个语言不是正则语言</strong>的重要工具。通过假设某个语言是正则的，并利用泵引理来分析该语言的字符串，若能找到无法满足泵引理条件的字符串，就能证明该语言不是正则语言。它为我们提供了一个有效的手段来排除正则性，尤其在证明一些较为复杂的语言不是正则语言时非常有用。</p><hr><h3 id="3-5-正则语言的封闭性"><a href="#3-5-正则语言的封闭性" class="headerlink" title="3.5 正则语言的封闭性"></a>3.5 正则语言的封闭性</h3><p>正则语言的封闭性（Closure Property）是指正则语言在某些操作下的结果仍然是正则语言。也就是说，如果我们对正则语言进行某些运算操作，那么得到的语言仍然是正则的。我们要证明正则语言在以下几种情况下是封闭的：</p><ul><li>并（Union）</li><li>交（Intersection）</li><li>连接（Concatenation）</li><li>闭包（Kleene Closure）</li><li>补（Complement）</li><li>差（Difference）</li><li>反转（Reversal）</li><li>同态（Homomorphism）</li><li>逆同态（Inverse Homomorphism）</li></ul><div class="note note-success">            <p>修考题经常考前面6个封闭性性质的证明,重点掌握</p>          </div><hr><h4 id="3-5-1-并运算的封闭性"><a href="#3-5-1-并运算的封闭性" class="headerlink" title="3.5.1 并运算的封闭性"></a>3.5.1 并运算的封闭性</h4><p><strong>并运算</strong>（Union）指的是将两个语言中的所有字符串合并在一起，构成一个新的语言。具体来说，给定两个语言 $L_1$ 和 $L_2$，它们的并集定义为：</p><p>$$<br>L_1 \cup L_2 &#x3D; \{ w \mid w \in L_1 \text{ 或者 } w \in L_2 \}<br>$$</p><p>这意味着，任何一个属于 $L_1$ 或者 $L_2$ 的字符串都将属于 $L_1 \cup L_2$。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 是正则语言，那么 $L_1 \cup L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于并运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的并集 $L_1 \cup L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对并运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若我们有两个 DFA 分别接受 $L_1$ 和 $L_2$，我们将构造一个新的自动机来接受它们的并集。</p><p><strong>Step 1：</strong>  <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设我们有两个正则语言 $L_1$ 和 $L_2$，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们的目标是构造一个新的 DFA $M$，使得它接受 $L_1 \cup L_2$。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M$ 来接受 $L_1 \cup L_2$</em></p><p>我们将使用一个新的起始状态，并通过非确定性选择进入 $M_1$ 或 $M_2$ 来模拟两个原始的 DFA。这种方法是基于非确定性有限自动机（NFA）的构造，最后我们将转换为一个 DFA。</p><ol><li><p><strong>状态集</strong>：新的自动机 $M$ 的状态集是 $Q_1 \cup Q_2$。也就是说，$M$ 的状态集合包括 $M_1$ 和 $M_2$ 的所有状态。</p></li><li><p><strong>起始状态</strong>：$M$ 的起始状态 $q_0$ 是一个新的状态，表示新的起始状态。我们通过 $\epsilon$-转换从 $q_0$ 转移到 $q_1^0$（$M_1$ 的起始状态）或者 $q_2^0$（$M_2$ 的起始状态）。这表示新的自动机可以选择进入 $M_1$ 或 $M_2$ 来继续执行。</p></li><li><p><strong>接受状态</strong>：$M$ 的接受状态是 $M_1$ 和 $M_2$ 的接受状态集合的并集，即 $F &#x3D; F_1 \cup F_2$。这意味着，只要 $M$ 到达 $M_1$ 或 $M_2$ 中的任何接受状态，就接受该字符串。</p></li><li><p><strong>转移函数</strong>：新的转移函数 $\delta$ 是如下定义的：</p><ul><li>如果在状态 $q_1$ 上，按照 $M_1$ 的转移函数进行转移；</li><li>如果在状态 $q_2$ 上，按照 $M_2$ 的转移函数进行转移；</li><li>从新的起始状态 $q_0$ 可以通过 $\epsilon$-转换分别转移到 $M_1$ 和 $M_2$ 的起始状态。</li></ul></li></ol><p>这样，我们通过构造一个新的 NFA 来接受 $L_1 \cup L_2$。由于 NFA 和 DFA 等价，最终我们可以将 NFA 转换为一个等价的 DFA，因此我们得出结论，$L_1 \cup L_2$ 是正则语言。</p><p>通过构造一个新的 NFA，我们证明了正则语言对于并运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 是正则语言，则它们的并集 $L_1 \cup L_2$ 也是正则语言。因为 NFA 和 DFA 等价，最终我们可以将 NFA 转换为 DFA，从而证明 $L_1 \cup L_2$ 是正则语言。</p><hr><p><strong>举个例子：</strong> 假设我们有两个正则语言：</p><ol><li>$L_1 &#x3D; \{ a^n \mid n \geq 1 \}$，由 DFA $M_1$ 接受。</li><li>$L_2 &#x3D; \{ b^n \mid n \geq 1 \}$，由 DFA $M_2$ 接受。</li></ol><p>我们希望构造一个 DFA 来接受 $L_1 \cup L_2$，即接受所有形式为 $a^n$ 或 $b^n$ 的字符串。通过上面的方法，构造出的 DFA 会有以下状态：</p><ul><li>起始状态 $q_0$，可以通过 $\epsilon$-转换进入 $M_1$ 或 $M_2$ 的起始状态。</li><li>接受状态为 $M_1$ 和 $M_2$ 的所有接受状态的并集。</li><li>转移规则根据 $M_1$ 和 $M_2$ 的转移规则构造。</li></ul><p>该 DFA 将正确接受 $a^n$ 或 $b^n$ 形式的字符串，因此它能够接受 $L_1 \cup L_2$。</p><p>通过构造一个新的 NFA 来接受并集 $L_1 \cup L_2$，并利用 NFA 和 DFA 等价的性质，我们证明了正则语言对于并运算是封闭的。即：如果 $L_1$ 和 $L_2$ 都是正则语言，那么它们的并集 $L_1 \cup L_2$ 也是正则语言。</p><hr><h4 id="3-5-2-交运算的封闭性"><a href="#3-5-2-交运算的封闭性" class="headerlink" title="3.5.2 交运算的封闭性"></a>3.5.2 交运算的封闭性</h4><p><strong>交运算</strong>（Intersection）用于表示两个语言中的共同部分。给定两个语言 $L_1$ 和 $L_2$，它们的交运算定义为：</p><p>$$<br>L_1 \cap L_2 &#x3D; \{ w \mid w \in L_1 \text{ and } w \in L_2 \}<br>$$</p><p>这意味着 $L_1 \cap L_2$ 包含所有同时属于 $L_1$ 和 $L_2$ 的字符串。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 都是正则语言，那么 $L_1 \cap L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于交运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的交运算 $L_1 \cap L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对交运算封闭，我们将利用有限状态自动机（DFA）来表示正则语言。具体来说，若 $L_1$ 和 $L_2$ 分别由 DFA $M_1$ 和 DFA $M_2$ 接受，我们将通过构造一个新的自动机来接受 $L_1 \cap L_2$。</p><p><strong>Step 1：</strong> <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设 $L_1$ 和 $L_2$ 都是正则语言，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们的目标是构造一个新的 DFA $M$ 来接受 $L_1 \cap L_2$，即所有同时属于 $L_1$ 和 $L_2$ 的字符串。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M$ 来接受 $L_1 \cap L_2$</em></p><p>为了构造接受交集 $L_1 \cap L_2$ 的 DFA，我们可以使用两个 DFA 的 <strong>直积自动机</strong>（product automaton）。直积自动机的状态集是由两个原始自动机的状态对组成，并且状态转移是由两个 DFA 的转移规则共同决定的。</p><ol><li><p><strong>状态集</strong>：$M$ 的状态集是 $Q_1 \times Q_2$，即每个状态由 $M_1$ 和 $M_2$ 的一个状态对组成。</p></li><li><p><strong>起始状态</strong>：$M$ 的起始状态是 $(q_1^0, q_2^0)$，即 $M_1$ 和 $M_2$ 的起始状态的组合。</p></li><li><p><strong>接受状态</strong>：$M$ 的接受状态集是 $F_1 \times F_2$，即 $M_1$ 和 $M_2$ 的接受状态的组合。这意味着只有当 $M_1$ 和 $M_2$ 都到达各自的接受状态时，$M$ 才会接受该字符串。</p></li><li><p><strong>转移函数</strong>：$M$ 的转移函数是通过 $M_1$ 和 $M_2$ 的转移函数组合得到的。具体来说，如果 $M_1$ 在状态 $q_1$ 接收输入符号 $a$ 并转移到状态 $q_1’$，同时 $M_2$ 在状态 $q_2$ 接收输入符号 $a$ 并转移到状态 $q_2’$，那么 $M$ 在状态 $(q_1, q_2)$ 接收输入符号 $a$ 后将转移到状态 $(q_1’, q_2’)$。</p></li></ol><p>通过这种构造，$M$ 就可以接受所有同时属于 $L_1$ 和 $L_2$ 的字符串，即接受交集 $L_1 \cap L_2$。</p><p>通过构造一个新的 DFA 来接受交集 $L_1 \cap L_2$，我们证明了正则语言对于交运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 都是正则语言，则它们的交运算 $L_1 \cap L_2$ 也是正则语言。</p><hr><p>假设我们有两个正则语言：</p><ol><li>$L_1 &#x3D; { a^n b^m \mid n \geq 1 \text{ and } m \geq 1 }$，即由一个或多个 ‘a’ 后跟一个或多个 ‘b’ 构成的字符串。</li><li>$L_2 &#x3D; { a^n b^n \mid n \geq 1 }$，即由相同数量的 ‘a’ 和 ‘b’ 构成的字符串。</li></ol><p>为了构造一个 DFA 来接受交集 $L_1 \cap L_2$，我们需要利用两个 DFA：</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA。</li><li>$M_2$ 是接受 $L_2$ 的 DFA。</li></ul><p>我们将通过<strong>直积构造法</strong>（product construction）来构造一个新的 DFA，它接受 $L_1 \cap L_2$。</p><p><strong>步骤 1：构造直积自动机</strong></p><ol><li><p><strong>状态集</strong>：</p><ul><li>$M_1$ 的状态集为 $Q_1$，$M_2$ 的状态集为 $Q_2$，因此交集自动机 $M$ 的状态集是 $Q_1 \times Q_2$，即每个状态是由 $M_1$ 和 $M_2$ 的状态对组成。</li></ul></li><li><p><strong>起始状态</strong>：</p><ul><li>$M_1$ 的起始状态是 $q_1^0$，$M_2$ 的起始状态是 $q_2^0$，因此交集自动机的起始状态是 $(q_1^0, q_2^0)$。</li></ul></li><li><p><strong>接受状态</strong>：</p><ul><li>$M_1$ 的接受状态集为 $F_1$，$M_2$ 的接受状态集为 $F_2$。因此，交集自动机的接受状态集为 $F_1 \times F_2$，即所有 $M_1$ 和 $M_2$ 都接受的状态对。</li></ul></li><li><p><strong>转移函数</strong>：</p><ul><li>假设 $M_1$ 在状态 $q_1$ 接收符号 $a$ 后转移到状态 $q_1’$，同时 $M_2$ 在状态 $q_2$ 接收符号 $a$ 后转移到状态 $q_2’$，那么交集自动机 $M$ 在状态 $(q_1, q_2)$ 接收符号 $a$ 后将转移到状态 $(q_1’, q_2’)$。</li></ul></li></ol><p>交集 DFA 的转移函数是通过两个原始 DFA 的转移函数组合而成的。</p><p><strong>步骤 2：构造过程的分析</strong></p><p>我们需要考虑交集 DFA 的工作过程：</p><ul><li><p><strong>对于输入字符串的处理</strong>：</p><ol><li>交集自动机将逐步处理输入字符串，状态转移遵循 $M_1$ 和 $M_2$ 的转移规则。</li><li>当读取到字符 ‘a’ 时，$M_1$ 继续在它的状态上移动，而 $M_2$ 也继续在它的状态上移动。</li><li>当读取到字符 ‘b’ 时，$M_1$ 和 $M_2$ 分别继续处理接下来的字符，保持状态的变化。</li></ol></li><li><p><strong>接受条件</strong>：</p><ul><li>字符串必须同时满足两个条件：它属于 $L_1$（即形如 $a^n b^m$），并且它属于 $L_2$（即形如 $a^n b^n$）。因此，交集自动机接受的字符串必须是形如 $a^n b^n$，且 $n \geq 1$。</li></ul></li></ul><p>通过这个构造，交集自动机能够接受所有形如 $a^n b^n$ 的字符串，其中 $n \geq 1$，即 $L_1 \cap L_2 &#x3D; \{ a^n b^n \mid n \geq 1 \}$。</p><p>通过直积构造法，最终我们得到一个新的 DFA，它接受所有形如 $a^n b^n$ 的字符串。</p><p>通过构造一个新的 DFA 来接受交集运算 $L_1 \cap L_2$，我们证明了正则语言对于交运算是封闭的。即：如果 $L_1$ 和 $L_2$ 都是正则语言，那么它们的交运算 $L_1 \cap L_2$ 也是正则语言。</p><hr><h4 id="3-5-3-连接运算的封闭性"><a href="#3-5-3-连接运算的封闭性" class="headerlink" title="3.5.3 连接运算的封闭性"></a>3.5.3 连接运算的封闭性</h4><p><strong>连接运算</strong>（Concatenation）是另一种常见的运算。连接运算指的是将两个语言中的所有字符串拼接在一起，构成一个新的语言。具体来说，给定两个语言 $L_1$ 和 $L_2$，它们的连接运算定义为：</p><p>$$<br>L_1 \cdot L_2 &#x3D; \{ w_1w_2 \mid w_1 \in L_1, w_2 \in L_2 \}<br>$$</p><p>这意味着，任何一个由 $L_1$ 中的字符串 $w_1$ 和 $L_2$ 中的字符串 $w_2$ 拼接而成的字符串都属于 $L_1 \cdot L_2$。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 是正则语言，那么 $L_1 \cdot L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于连接运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的连接运算 $L_1 \cdot L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对连接运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若我们有两个 DFA 分别接受 $L_1$ 和 $L_2$，我们将构造一个新的自动机来接受它们的连接。</p><p><strong>Step 1：</strong> <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设我们有两个正则语言 $L_1$ 和 $L_2$，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们的目标是构造一个新的 DFA $M$，使得它接受 $L_1 \cdot L_2$。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M$ 来接受 $L_1 \cdot L_2$</em></p><p>我们可以通过在 $M_1$ 的接受状态添加 $\epsilon$-转换，来将 $M_1$ 和 $M_2$ 连接起来，从而构造一个新的 DFA 来接受 $L_1 \cdot L_2$。</p><ol><li><p><strong>状态集</strong>：新的自动机 $M$ 的状态集是 $Q_1 \cup Q_2$，即包含 $M_1$ 和 $M_2$ 的所有状态。</p></li><li><p><strong>起始状态</strong>：$M$ 的起始状态是 $q_1^0$（即 $M_1$ 的起始状态）。从 $q_1^0$ 开始执行。</p></li><li><p><strong>接受状态</strong>：$M$ 的接受状态是 $F_2$，即 $M_2$ 的接受状态集。表示当 $M_2$ 达到接受状态时，接受该字符串。</p></li><li><p><strong>转移函数</strong>：</p><ul><li>如果在 $M_1$ 的状态中，按照 $M_1$ 的转移函数 $\delta_1$ 进行转移；</li><li>如果在 $M_2$ 的状态中，按照 $M_2$ 的转移函数 $\delta_2$ 进行转移；</li><li>当 $M_1$ 进入接受状态时，增加从 $M_1$ 的接受状态到 $M_2$ 的起始状态 $q_2^0$ 的 $\epsilon$-转换。</li></ul></li></ol><p>通过这种方式，新的自动机可以先接受 $L_1$ 中的字符串，然后接着接受 $L_2$ 中的字符串，最终接受整个字符串。</p><p>通过构造一个新的 DFA 来接受连接 $L_1 \cdot L_2$，我们证明了正则语言对于连接运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 是正则语言，则它们的连接 $L_1 \cdot L_2$ 也是正则语言。</p><hr><p>举个例子：假设我们有两个正则语言：</p><ol><li>$L_1 &#x3D; \{ a^n \mid n \geq 1 \}$，由 DFA $M_1$ 接受。</li><li>$L_2 &#x3D; \{ b^m \mid m \geq 1 \}$，由 DFA $M_2$ 接受。</li></ol><p>我们希望构造一个 DFA 来接受 $L_1 \cdot L_2$，即接受所有形式为 $a^n b^m$（$n, m \geq 1$）的字符串。通过上面的构造方法，得到的 DFA 将有以下状态：</p><ul><li>起始状态 $q_1^0$，接受 $L_1$ 中的 $a^n$ 字符串。</li><li>一旦 $M_1$ 接受完 $a^n$，它会通过 $\epsilon$-转换跳转到 $M_2$，然后接受 $b^m$ 字符串。</li><li>接受状态为 $M_2$ 的接受状态集。</li></ul><p>该 DFA 将正确接受所有形如 $a^n b^m$ 的字符串，因此它能够接受 $L_1 \cdot L_2$。</p><p>通过构造一个新的 DFA 来接受连接运算 $L_1 \cdot L_2$，我们证明了正则语言对于连接运算是封闭的。即：如果 $L_1$ 和 $L_2$ 都是正则语言，那么它们的连接 $L_1 \cdot L_2$ 也是正则语言。</p><hr><h4 id="3-5-4-闭包运算的封闭性"><a href="#3-5-4-闭包运算的封闭性" class="headerlink" title="3.5.4 闭包运算的封闭性"></a>3.5.4 闭包运算的封闭性</h4><p><strong>闭包运算</strong>（Kleene closure）用于表示一个语言中所有可能的字符串的任意次重复（包括空字符串）。给定一个语言 $L$，其 Kleene 闭包表示为：</p><p>$$<br>L^* &#x3D; \{ w_1 w_2 \cdots w_k \mid k \geq 0, w_i \in L \text{ for all } i \}<br>$$</p><p>这意味着 $L^*$ 包含所有由 $L$ 中的字符串组成的串，且可以重复零次或多次。换句话说，$L^*$ 包括空字符串 $\epsilon$ 以及 $L$ 中字符串的任意数量的串联。</p><p><strong>问题：</strong> 如果 $L$ 是正则语言，那么 $L^*$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于 Kleene 闭包运算是封闭的</strong>。也就是说，若 $L$ 是正则语言，那么它的 Kleene 闭包 $L^*$ 也是正则语言。</p><hr><p>为了证明正则语言对闭包运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若 $L$ 是由某个 DFA $M$ 接受的正则语言，那么我们将构造一个新的自动机来接受 $L^*$。</p><p><strong>Step 1：</strong> <em>假设 $L$ 是正则语言</em></p><p>假设 $L$ 是一个正则语言，并且由 DFA $M$ 接受。$M$ 的状态集为 $Q$，起始状态为 $q_0$，接受状态集为 $F$，以及转移函数为 $\delta$。</p><p>我们的目标是构造一个新的 DFA $M^*$ 来接受 $L^*$，即接受所有在 $L$ 中的字符串的任意次重复（包括空字符串）。</p><p><strong>Step 2：</strong>  构造一个新的自动机 $M^*$ 来接受 $L^*$</p><p>我们通过对原始 DFA $M$ 进行修改来构造一个新的 DFA $M^*$，使其能够接受 $L^*$。</p><ol><li><p><strong>状态集</strong>：$M^*$ 的状态集仍然是 $Q$，即与 $M$ 相同。</p></li><li><p><strong>起始状态</strong>：$M^*$ 的起始状态是原来的起始状态 $q_0$，并且我们将 $q_0$ 设置为一个额外的接受状态，因为空字符串 $\epsilon$ 也属于 $L^*$。</p></li><li><p><strong>接受状态</strong>：$M^*$ 的接受状态集是 $F \cup \{q_0\}$，即包括 $M$ 的接受状态以及起始状态 $q_0$（空字符串的情况）。</p></li><li><p><strong>转移函数</strong>：对于 $M^*$ 的转移函数：</p><ul><li>如果 $M$ 在某个状态 $q$ 上接收到输入符号 $a$，并转移到状态 $q’$，那么 $M^*$ 在状态 $q$ 上接收到 $a$ 后也转移到状态 $q’$。</li><li>另外，在 $M^*$ 中，当它到达某个接受状态时，它可以通过一个 $\epsilon$-转换回到原来的起始状态 $q_0$，以实现对重复的字符串的处理。</li></ul></li></ol><p>通过这种方式，$M^*$ 可以接受 $L$ 中所有字符串的任意次重复，并且包括空字符串。</p><p>通过对原始 DFA $M$ 进行修改，我们证明了正则语言对于闭包运算是封闭的。具体地说，若 $L$ 是正则语言，则它的 Kleene 闭包 $L^*$ 也是正则语言。</p><hr><p><strong>举个例子：</strong> 假设我们有一个正则语言：</p><ol><li>$L &#x3D; \{ a^n \mid n \geq 1 \}$，由 DFA $M$ 接受。</li></ol><p>我们希望构造一个 DFA 来接受 $L^*$，即接受所有形式为 $a^n$（$n \geq 1$）的字符串的任意次重复。这将包括像 $\epsilon$（空字符串）、$a$, $aa$, $aaa$ 等等的所有可能组合。</p><p>通过上面的构造方法，得到的 DFA 将有以下状态：</p><ul><li>起始状态 $q_0$，既是接受状态也是新的起始状态，因为我们需要接受空字符串。</li><li>从 $q_0$ 出发，如果接收到 $a$，则转移到 $q_1$（即接受 $a$）。</li><li>一旦到达 $q_1$，它可以继续接收更多的 $a$ 字符串。</li><li>在每次接收完一个字符串后，我们都可以通过 $\epsilon$-转换返回到起始状态 $q_0$，从而实现对多个 $a$ 字符串的重复。</li></ul><p>该 DFA 将正确接受 $a^n$ 的任意次重复形式，因此它能够接受 $L^*$。</p><p>通过构造一个新的 DFA 来接受 Kleene 闭包 $L^*$，我们证明了正则语言对于闭包运算是封闭的。即：如果 $L$ 是正则语言，那么它的 Kleene 闭包 $L^*$ 也是正则语言。</p><hr><h4 id="3-5-5-补运算的封闭性"><a href="#3-5-5-补运算的封闭性" class="headerlink" title="3.5.5 补运算的封闭性"></a>3.5.5 补运算的封闭性</h4><p><strong>补运算</strong>（Complement）用于表示一个语言中不包含的所有字符串。给定一个语言 $L$，它的补语言 $\overline{L}$ 定义为：</p><p>$$<br>\overline{L} &#x3D; \Sigma^* \setminus L<br>$$</p><p>其中，$\Sigma^*$ 表示所有可能的字符串的集合，$L$ 是一个语言，$\overline{L}$ 就是包含所有不属于 $L$ 的字符串的语言。</p><p><strong>问题：</strong> 如果 $L$ 是正则语言，那么 $\overline{L}$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于补运算是封闭的</strong>。也就是说，若 $L$ 是正则语言，那么它的补语言 $\overline{L}$ 也是正则语言。</p><hr><p>为了证明正则语言对补运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若 $L$ 是由某个 DFA $M$ 接受的正则语言，那么我们将通过改变 $M$ 来构造一个新的 DFA 来接受 $\overline{L}$。</p><p><strong>Step 1：</strong> <em>假设 $L$ 是正则语言</em></p><p>假设 $L$ 是一个正则语言，并且由 DFA $M$ 接受。$M$ 的状态集为 $Q$，起始状态为 $q_0$，接受状态集为 $F$，以及转移函数为 $\delta$。</p><p>我们的目标是构造一个新的 DFA $M’$ 来接受 $\overline{L}$，即接受所有不属于 $L$ 的字符串。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M’$ 来接受 $\overline{L}$</em></p><p>我们可以通过改变 $M$ 中接受状态的定义来构造一个新的 DFA 来接受 $\overline{L}$。</p><ol><li><p><strong>状态集</strong>：$M’$ 的状态集与 $M$ 相同，即 $Q$。</p></li><li><p><strong>起始状态</strong>：$M’$ 的起始状态与 $M$ 相同，即 $q_0$。</p></li><li><p><strong>接受状态</strong>：$M’$ 的接受状态集是 $M$ 中所有非接受状态的集合。也就是说，如果 $M$ 中的接受状态集是 $F$，那么 $M’$ 中的接受状态集就是 $Q \setminus F$，即所有不属于 $F$ 的状态。</p></li><li><p><strong>转移函数</strong>：$M’$ 的转移函数与 $M$ 的转移函数完全相同。也就是说，$M’$ 仍然按照 $M$ 中的转移规则进行状态转换。</p></li></ol><p>通过这种方式，$M’$ 会接受所有不属于 $L$ 的字符串，即它接受的语言是 $\overline{L}$。</p><hr><h4 id="3-5-6-差运算的封闭性"><a href="#3-5-6-差运算的封闭性" class="headerlink" title="3.5.6 差运算的封闭性"></a>3.5.6 差运算的封闭性</h4><p><strong>差运算</strong>（Difference）用于表示一个语言中的所有字符串减去另一个语言中的字符串。给定两个语言 $L_1$ 和 $L_2$，它们的差运算定义为：</p><p>$$<br>L_1 - L_2 &#x3D; \{ w \mid w \in L_1 \text{ and } w \notin L_2 \}<br>$$</p><p>这意味着 $L_1 - L_2$ 包含所有属于 $L_1$ 但不属于 $L_2$ 的字符串。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 都是正则语言，那么 $L_1 - L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于差运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的差运算 $L_1 - L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对差运算封闭，我们将利用正则语言的补运算封闭性以及交运算封闭性来完成证明。具体来说，若 $L_1$ 和 $L_2$ 都是正则语言，那么 $L_1 - L_2$ 可以表示为 $L_1 \cap \overline{L_2}$，即 $L_1$ 与 $L_2$ 的补语言 $\overline{L_2}$ 的交集。</p><p><strong>Step 1：</strong> <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设 $L_1$ 和 $L_2$ 都是正则语言，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们想要构造一个新的 DFA 来接受 $L_1 - L_2$，即所有属于 $L_1$ 但不属于 $L_2$ 的字符串。</p><p><strong>Step 2：</strong> <em>利用补运算和交运算构造新自动机</em></p><p>首先，利用正则语言对补运算的封闭性，我们知道，如果 $L_2$ 是正则语言，那么它的补语言 $\overline{L_2}$ 也是正则语言。然后，利用正则语言对交运算的封闭性，我们知道 $L_1 \cap \overline{L_2}$ 也是正则语言。</p><ol><li><p><strong>构造 $M_1$ 和 $M_2$ 的补自动机：</strong> 假设 $M_1$ 和 $M_2$ 是接受 $L_1$ 和 $L_2$ 的 DFA。我们可以通过对 $M_2$ 进行修改，构造一个新的 DFA 来接受 $L_2$ 的补语言 $\overline{L_2}$，方法与补运算的证明相同。</p></li><li><p><strong>构造 $L_1 \cap \overline{L_2}$ 的交集自动机：</strong> 利用正则语言对交运算的封闭性，我们可以构造一个新的 DFA 来接受 $L_1 \cap \overline{L_2}$。这可以通过构造两个 DFA 的直积自动机（product automaton）来实现：每个状态对包含 $M_1$ 和 $M_2$ 的状态对，转移规则通过两者的转移函数组合来确定。（状态是两个自动机状态的笛卡尔积）</p></li></ol><p>通过这样的构造，新的自动机可以接受所有属于 $L_1$ 但不属于 $L_2$ 的字符串，即接受差语言 $L_1 - L_2$。</p><p>通过利用正则语言对补运算和交运算的封闭性，我们证明了正则语言对于差运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 都是正则语言，则它们的差运算 $L_1 - L_2$ 也是正则语言。</p><hr><h4 id="3-5-7-反转运算的封闭性"><a href="#3-5-7-反转运算的封闭性" class="headerlink" title="3.5.7 反转运算的封闭性"></a>3.5.7 反转运算的封闭性</h4><p>我们来探讨正则语言在<strong>反转运算</strong>下的封闭性。即，如果一个语言是正则的，那么它的反转语言也是正则的。</p><p><strong>定义：</strong> 给定一个语言 $L$，我们定义其<strong>反转语言</strong> $L^R$ 为：</p><p>$$<br>L^R &#x3D; \{ w^R \mid w \in L \}<br>$$</p><p>其中，$w^R$ 是字符串 $w$ 的反转。例如，如果 $w &#x3D; \text{abc}$，则 $w^R &#x3D; \text{cba}$。</p><p>正则语言的封闭性意味着，如果 $L$ 是一个正则语言，那么 $L^R$ 也一定是正则语言。</p><p>我们通过以下步骤来证明正则语言对反转运算是封闭的：</p><ol><li><p><strong>假设 $L$ 是一个正则语言</strong>，那么存在一个确定性有限自动机（DFA） $M$ 来接受 $L$。我们的目标是构造一个 DFA 来接受 $L^R$。</p></li><li><p><strong>构造反转的非确定性有限自动机（NFA）</strong>：</p><ul><li>假设 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 是接受语言 $L$ 的 DFA，其中：<ul><li>$Q$ 是状态集，</li><li>$\Sigma$ 是输入字母表，</li><li>$\delta$ 是转移函数，</li><li>$q_0$ 是起始状态，</li><li>$F$ 是接受状态集。</li></ul></li></ul><p>我们需要构造一个 NFA $M^R &#x3D; (Q, \Sigma, \delta^R, q_0^R, F^R)$ 来接受语言 $L^R$。</p></li><li><p><strong>反转过程的步骤</strong>：</p><ul><li><strong>反转接受状态</strong>：NFA 的接受状态集 $F^R$ 应该是原 DFA $M$ 的起始状态 $q_0$。</li><li><strong>反转转移函数</strong>：在 $M$ 中，每个状态到另一个状态的转移是由 $\delta$ 定义的。在 $M^R$ 中，我们将这些转移反向，即如果在 $M$ 中有一个转移 $\delta(q, a) &#x3D; p$，那么在 $M^R$ 中，$p$ 到 $q$ 也应有一个转移，记作 $\delta^R(p, a) &#x3D; q$。</li><li><strong>起始状态</strong>：NFA $M^R$ 的起始状态是 $M$ 的接受状态集 $F$ 中的所有状态。这是因为我们希望通过反转路径从接受状态回到起始状态。</li></ul></li><li><p><strong>从 NFA 到 DFA</strong>：</p><ul><li>由于正则语言是通过 DFA 接受的，因此我们可以通过<strong>子集构造法</strong>将 NFA 转换为一个等价的 DFA。这个 DFA 将接受语言 $L^R$。</li></ul></li><li><p><strong>结论</strong>：</p><ul><li>通过构造 NFA 和将其转换为 DFA，我们证明了反转运算对于正则语言是封闭的。</li></ul></li></ol><p>正则语言对反转运算是封闭的，即如果一个语言是正则的，那么它的反转语言也是正则的。通过构造 NFA 来接受反转语言，并利用子集构造法将其转化为 DFA，我们证明了这一点。</p><hr><h4 id="3-5-8-同态运算的封闭性"><a href="#3-5-8-同态运算的封闭性" class="headerlink" title="3.5.8 同态运算的封闭性"></a>3.5.8 同态运算的封闭性</h4><p>在形式语言理论中，<strong>同态</strong>（Homomorphism）是指将一个语言中的字母按某种规则替换为另一个字母或字母串的操作。我们来探讨正则语言在<strong>同态运算</strong>下的封闭性。即，如果一个语言是正则的，那么它的同态映射后的语言也是正则的。</p><p><strong>定义：</strong></p><p>给定一个字母表 $\Sigma$ 和一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，其中 $\Gamma$ 是另一个字母表，$\varphi$ 是将字符串从 $\Sigma$ 字母表映射到 $\Gamma$ 字母表的映射。</p><p>假设我们有一个语言 $L \subseteq \Sigma^*$，则语言 $L^\varphi$ 是通过对语言 $L$ 中的每个字符串应用同态映射 $\varphi$ 得到的语言：</p><p>$$<br>L^\varphi &#x3D; { \varphi(w) \mid w \in L }<br>$$</p><p>其中，$\varphi(w)$ 是字符串 $w$ 在同态映射下的结果。我们的目标是证明正则语言在同态下是封闭的，即如果 $L$ 是正则语言，那么 $L^\varphi$ 也是正则语言。</p><p>我们通过以下步骤来证明正则语言对同态运算是封闭的：</p><ol><li><p><strong>假设 $L$ 是一个正则语言</strong>：</p><ul><li>如果 $L$ 是正则语言，那么存在一个 DFA（确定性有限自动机）$M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 来接受 $L$。</li></ul></li><li><p><strong>定义同态映射</strong>：</p><ul><li>给定一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，它将字母表 $\Sigma$ 上的每个符号映射到 $\Gamma$ 上的字符串。</li><li>例如，假设 $\varphi$ 将 $\Sigma &#x3D; {a, b}$ 映射到 $\Gamma &#x3D; {0, 1}$，其中 $\varphi(a) &#x3D; 0$，$\varphi(b) &#x3D; 11$。对于字符串 $w &#x3D; ab$, $\varphi(w) &#x3D; 011$。</li></ul></li><li><p><strong>构造接受 $L^\varphi$ 的 NFA</strong>：</p><ul><li>给定 DFA $M$ 接受语言 $L$，我们将构造一个新的 NFA 来接受语言 $L^\varphi$。</li><li>对于 $M$ 中的每个状态转移 $\delta(q, a) &#x3D; p$，我们将新的 NFA 中的转移改为 $\delta’(q, \varphi(a)) &#x3D; p$，即每次读取字母 $a$ 时，我们在新自动机中读取 $\varphi(a)$。</li></ul></li><li><p><strong>从 NFA 到 DFA</strong>：</p><ul><li>由于正则语言是通过 DFA 接受的，因此我们可以通过<strong>子集构造法</strong>（subset construction）将这个新的 NFA 转换为一个等价的 DFA。</li></ul></li><li><p><strong>结论</strong>：</p><ul><li>通过上述构造过程，我们证明了正则语言在同态下是封闭的，即如果 $L$ 是正则语言，那么 $L^\varphi$ 也是正则语言。</li></ul></li></ol><hr><p><strong>子集构造法</strong>是将一个 NFA 转换为等价的 DFA 的经典方法。具体过程如下：</p><ol><li><p><strong>NFA 的状态集</strong>：</p><ul><li>假设我们已经构造了一个 NFA $M^\varphi &#x3D; (Q, \Gamma, \delta’, q_0, F)$ 来接受语言 $L^\varphi$，其中：<ul><li>$Q$ 是 NFA 的状态集，</li><li>$\Gamma$ 是新的字母表（经过同态映射后），</li><li>$\delta’$ 是新的转移函数，</li><li>$q_0$ 是起始状态，</li><li>$F$ 是接受状态集。</li></ul></li><li>在这个 NFA 中，状态的转移是非确定性的，因此多个状态可能会同时被激活。</li></ul></li><li><p><strong>DFA 的状态集</strong>：</p><ul><li>对应的 DFA 状态集是 NFA 状态集的<strong>子集</strong>。具体来说，DFA 中的每个状态都表示 NFA 中某些状态的集合。这些集合是 NFA 在某个状态和输入符号下可能到达的状态的集合。</li></ul></li><li><p><strong>DFA 状态转移</strong>：</p><ul><li>假设 DFA 的当前状态是 $S \subseteq Q$（即 NFA 中某些状态的集合），而当前输入符号是 $a \in \Gamma$。DFA 的下一状态是由 NFA 对每个状态集合的转移决定的：<br>$$<br>\delta_{\text{DFA}}(S, a) &#x3D; \bigcup_{q \in S} \delta’(q, a)<br>$$<br>也就是说，DFA 状态转移函数根据当前的输入符号 $a$，将所有处于集合 $S$ 中的 NFA 状态的转移结果联合起来，得到新的状态集合。</li></ul></li><li><p><strong>DFA 的起始状态</strong>：</p><ul><li>DFA 的起始状态对应于 NFA 起始状态的集合。假设 NFA 的起始状态是 $q_0$，那么 DFA 的起始状态是包含 $q_0$ 的集合：${q_0}$。</li></ul></li><li><p><strong>DFA 的接受状态</strong>：</p><ul><li>DFA 中的接受状态集合是 NFA 中任何包含接受状态的集合。具体来说，DFA 的状态 $S$ 是接受状态，如果 $S$ 包含 NFA 的某个接受状态。</li></ul></li><li><p><strong>结束</strong>：</p><ul><li>通过这些步骤，我们就能够构造一个 DFA，它的状态集由 NFA 的状态集的子集组成，转移函数由 NFA 的转移函数导出，起始状态和接受状态也对应了 NFA 中的起始状态和接受状态。</li></ul></li></ol><p><strong>例子</strong>：假设我们有一个简单的 NFA 和同态映射：</p><ul><li><p><strong>NFA</strong> $M^\varphi$ 接受语言 $L^\varphi$，其中 $\Sigma &#x3D; {a, b}$ 和 $\Gamma &#x3D; {0, 1}$，并且同态映射 $\varphi$ 如下：</p><ul><li>$\varphi(a) &#x3D; 0$</li><li>$\varphi(b) &#x3D; 11$</li></ul></li><li><p>假设 $L &#x3D; {ab, aa, abba}$，我们想要计算 $L^\varphi$，即应用同态映射后得到的语言：</p><ul><li>$\varphi(ab) &#x3D; 011$</li><li>$\varphi(aa) &#x3D; 00$</li><li>$\varphi(abba) &#x3D; 0111$</li></ul></li></ul><p>根据这些映射，我们可以构造一个 NFA 来接受 $L^\varphi &#x3D; {011, 00, 0111}$。接下来，我们使用子集构造法将 NFA 转换为一个 DFA。</p><hr><h4 id="3-5-9-逆同态运算的封闭性"><a href="#3-5-9-逆同态运算的封闭性" class="headerlink" title="3.5.9 逆同态运算的封闭性"></a>3.5.9 逆同态运算的封闭性</h4><p>在形式语言理论中，<strong>逆同态</strong>（Inverse Homomorphism）是指将一个语言中的字符串的各个字母按某种规则反向映射到字母表中的操作。我们来探讨正则语言在<strong>逆同态运算</strong>下的封闭性。即，如果一个语言是正则的，那么它的逆同态映射后的语言也是正则的。</p><p><strong>定义</strong>：给定一个字母表 $\Sigma$ 和一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，其中 $\Gamma$ 是另一个字母表，$\varphi$ 是将字符串从 $\Sigma$ 字母表映射到 $\Gamma$ 字母表的映射。</p><p>逆同态映射是一个将一个字符串从 $\Gamma^*$ 映射到 $\Sigma^*$ 的操作，记作 $\varphi^{-1}$. 对于任意的字符串 $w \in \Gamma^*$，$\varphi^{-1}(w)$ 表示所有可能的字符串，它们在同态映射 $\varphi$ 下可以映射到 $w$。</p><p>逆同态语言 $L^{\varphi^{-1}}$ 是对语言 $L$ 应用逆同态映射 $\varphi^{-1}$ 后得到的语言：</p><p>$$<br>L^{\varphi^{-1}} &#x3D; \{ w \in \Sigma^* \mid \varphi(w) \in L \}<br>$$</p><p>即，语言 $L^{\varphi^{-1}}$ 包含所有可以通过同态映射 $\varphi$ 映射到语言 $L$ 中的字符串。</p><p>我们要证明的是：<strong>如果 $L$ 是正则语言，那么 $L^{\varphi^{-1}}$ 也是正则语言</strong>。</p><p>我们通过以下步骤来证明正则语言在逆同态运算下是封闭的：</p><ol><li><p><strong>假设 $L$ 是正则语言</strong>：</p><ul><li>如果 $L$ 是正则语言，那么存在一个 DFA（确定性有限自动机）$M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 来接受 $L$。</li></ul></li><li><p><strong>定义逆同态映射</strong>：</p><ul><li>给定一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，我们定义其逆同态映射为 $\varphi^{-1}$，即对于每个字符串 $w \in \Gamma^*$，$\varphi^{-1}(w)$ 是所有可以被映射到 $w$ 的字符串。</li></ul></li><li><p><strong>构造逆同态的 NFA</strong>：</p><ul><li>假设我们已经有一个 DFA $M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 来接受语言 $L$。我们要构造一个接受语言 $L^{\varphi^{-1}}$ 的 NFA。</li><li><strong>逆同态的状态转移</strong>：对于每个输入符号 $a \in \Gamma$，如果在 DFA 中有转移 $\delta(q, \varphi(a)) &#x3D; p$，则在逆同态的 NFA 中，我们可以反向将转移为从 $p$ 到 $q$ 的转移。</li><li>这个反向的过程类似于同态的构造，只不过是在反向应用同态映射的结果。</li></ul></li><li><p><strong>从 NFA 到 DFA</strong>：</p><ul><li>由于正则语言是通过 DFA 接受的，因此我们可以通过<strong>子集构造法</strong>（subset construction）将这个新的 NFA 转换为一个等价的 DFA。</li></ul></li><li><p><strong>结论</strong>：</p><ul><li>通过构造逆同态的 NFA，并通过子集构造法将其转化为 DFA，我们证明了正则语言在逆同态运算下是封闭的。</li></ul></li></ol><p>正则语言对逆同态运算是封闭的。也就是说，如果一个语言是正则的，那么它经过逆同态映射后的语言也是正则语言。我们通过将 DFA 中的转移规则反向应用于 NFA，进而通过子集构造法将其转化为 DFA，证明了这一点。</p><hr><h3 id="3-6-自动机最小化"><a href="#3-6-自动机最小化" class="headerlink" title="3.6 自动机最小化"></a>3.6 自动机最小化</h3><p>自动机最小化是形式语言与自动机理论中的一个重要主题，其目的是将一个确定有限自动机（DFA）转化为一个状态数量最少的等价自动机。最小化的目的是减少状态数量，进而减少计算复杂度和存储需求。</p><p>最小化的目标是通过合并一些等价的状态来简化自动机。两个状态被称为等价的，如果它们在自动机中的行为相同，即对于任何输入串，它们的转移和接受状态是一样的。</p><hr><h4 id="3-6-1-状态的等价性"><a href="#3-6-1-状态的等价性" class="headerlink" title="3.6.1 状态的等价性"></a>3.6.1 状态的等价性</h4><p>在自动机理论中，两个状态 $q_1$ 和 $q_2$ 被称为 <strong>等价状态</strong>，如果它们在给定的输入下，能够产生相同的行为。具体来说，两个状态 $q_1$ 和 $q_2$ 是等价的，意味着对于每一个输入串 $w$，从状态 $q_1$ 和 $q_2$ 出发，最终是否接受该串的结果是相同的。</p><p>形式化地讲，状态 $q_1$ 和 $q_2$ 等价，若满足以下条件：</p><ol><li>对于每个输入串 $w$，从 $q_1$ 和 $q_2$ 出发，最终的接受状态是否一致。即：<br>$$<br>\delta(q_1, w) \in F \iff \delta(q_2, w) \in F<br>$$<br>其中，$\delta(q, w)$ 表示从状态 $q$ 出发读取输入串 $w$ 后到达的状态，$F$ 是接受状态的集合。</li></ol><p>等价状态的数学证明：假设我们有一个确定有限自动机（DFA） $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是状态集合；</li><li>$\Sigma$ 是输入字母表；</li><li>$\delta$ 是状态转移函数；</li><li>$q_0$ 是初始状态；</li><li>$F$ 是接受状态集合。</li></ul><p>我们要证明两个状态 $q_1$ 和 $q_2$ 等价，即：<br>$$<br>\delta(q_1, w) \in F \iff \delta(q_2, w) \in F \quad \text{对所有输入串 } w \text{ 成立}.<br>$$</p><p><strong>证明过程：</strong></p><ol><li><p><strong>定义等价关系：</strong><br>定义一个等价关系 $\sim$ 在状态集 $Q$ 上。对于任意两个状态 $q_1$ 和 $q_2$：</p><p>$$<br>q_1 \sim q_2 \iff \forall w \in \Sigma^*, \delta(q_1, w) \in F \iff \delta(q_2, w) \in F<br>$$<br>即 $q_1$ 和 $q_2$ 等价当且仅当，对于任意的输入串 $w$，从 $q_1$ 和 $q_2$ 出发，最终是否接受该串的结果是相同的。</p></li><li><p><strong>划分状态集：</strong><br>通过上述等价关系 $\sim$，将状态集 $Q$ 划分为若干个等价类，每个等价类中的状态对于所有输入串具有相同的接受行为。</p></li><li><p><strong>构造最小化自动机：</strong><br>在自动机最小化过程中，合并那些属于同一个等价类的状态。这些状态在任何输入下的行为完全一致，因此可以作为一个状态来表示，从而得到最小化的自动机。</p></li></ol><p><strong>反证法证明：</strong></p><p>假设 $q_1$ 和 $q_2$ 是两个状态，它们在行为上是等价的，即：<br>$$<br>\delta(q_1, w) \in F \iff \delta(q_2, w) \in F \quad \text{对于所有的输入串 } w.<br>$$</p><p>接下来我们证明：如果 $q_1 \sim q_2$，那么它们的转移关系完全一致。</p><ol><li><p>假设我们有一个输入字母 $a \in \Sigma$ 和状态 $q_1$, $q_2$，即考虑从 $q_1$ 和 $q_2$ 出发，分别读取输入字母 $a$ 后转移到新的状态。</p></li><li><p>由于 $q_1 \sim q_2$，对于任意的输入串 $w$，从 $q_1$ 和 $q_2$ 出发，最终的接受状态是相同的。因此，考虑输入串 $w &#x3D; a$ 时，从 $q_1$ 和 $q_2$ 出发，都会进入同一个接受状态或非接受状态。</p></li><li><p>从这个反推，我们可以得出：从状态 $q_1$ 和 $q_2$ 读取输入字母 $a$ 后，必须转移到相同的状态。因此，状态转移关系 $\delta(q_1, a) &#x3D; \delta(q_2, a)$ 必然成立。</p></li><li><p>由于 $q_1 \sim q_2$ 对于所有输入串 $w$ 都成立，因此可以逐步推断出它们的转移关系一致。</p></li></ol><p>通过上述过程，我们证明了两个状态 $q_1$ 和 $q_2$ 的等价性意味着它们的转移函数在所有输入下都一致，从而可以被合并为一个状态。在自动机最小化过程中，等价的状态可以被合并，从而简化自动机的结构，减少状态数量。</p><hr><h4 id="3-6-2-填表算法"><a href="#3-6-2-填表算法" class="headerlink" title="3.6.2 填表算法"></a>3.6.2 填表算法</h4><p>对于任意一个DFA，我们都可以找到一个等价的、状态数最少的DFA。两个状态如果对于任何输入串都产生相同的接受&#x2F;拒绝行为，我们就说它们是等价的。</p><p>让我们通过一个具体的例子来理解这个过程。考虑一个识别所有以”ab”结尾的二进制串的DFA：</p><p>形式化定义如下：</p><ul><li>状态集合 $Q &#x3D; \{q_0, q_1, q_2, q_3, q_4\}$</li><li>字母表 $\Sigma &#x3D; \{a, b\}$</li><li>初始状态 &#x3D; $q_0$</li><li>接受状态 $F &#x3D; \{q_4\}$</li></ul><p>转移函数 $\delta$ 可以表示为：</p><table><thead><tr><th>状态</th><th>$a$</th><th>$b$</th></tr></thead><tbody><tr><td>$q_0$</td><td>$q_1$</td><td>$q_3$</td></tr><tr><td>$q_1$</td><td>$q_1$</td><td>$q_2$</td></tr><tr><td>$q_2$</td><td>$q_1$</td><td>$q_4$</td></tr><tr><td>$q_3$</td><td>$q_1$</td><td>$q_3$</td></tr><tr><td>$q_4$</td><td>$q_1$</td><td>$q_3$</td></tr></tbody></table><p>填表算法步骤如下：</p><p><strong>Step 1</strong> :初始区分</p><p>首先，我们将所有状态分为两组：</p><ul><li>接受状态：$\{q_4\}$</li><li>非接受状态：$\{q_0, q_1, q_2, q_3\}$</li></ul><p><strong>Step 2</strong> :构建初始表格</p><p>我们创建一个对角表格，标记明显不等价的状态对（一个是接受状态，一个是非接受状态）：</p><table><thead><tr><th></th><th>$q_1$</th><th>$q_2$</th><th>$q_3$</th><th>$q_4$</th></tr></thead><tbody><tr><td>$q_0$</td><td>-</td><td>-</td><td>-</td><td>X</td></tr><tr><td>$q_1$</td><td></td><td>-</td><td>-</td><td>X</td></tr><tr><td>$q_2$</td><td></td><td></td><td>-</td><td>X</td></tr><tr><td>$q_3$</td><td></td><td></td><td></td><td>X</td></tr></tbody></table><p>其中 X 表示这对状态明显不等价。</p><p>补充一下什么是等价：</p><ul><li>如果 $q_i \in F$ 且 $q_j \notin F$，则 $(q_i, q_j)$ 不等价。</li><li>如果 $q_i \notin F$ 且 $q_j \in F$，则 $(q_i, q_j)$ 不等价。</li><li>否则，将 $(q_i, q_j)$ 标记为等价。</li></ul><p><strong>Step 3</strong> :迭代区分过程</p><p>对于每对状态 $p,q$，我们需要检查：</p><ul><li>在每个输入符号 $a \in \Sigma$ 下</li><li>如果 $\delta(p,a)$ 和 $\delta(q,a)$ 已被标记为不等价</li><li>则 $p$ 和 $q$ 也应被标记为不等价</li></ul><p>例如，检查 $(q_0,q_1)$：</p><ul><li>输入 $a$：$\delta(q_0,a)&#x3D;q_1$, $\delta(q_1,a)&#x3D;q_1$ （转向相同状态）</li><li>输入 $b$：$\delta(q_0,b)&#x3D;q_3$, $\delta(q_1,b)&#x3D;q_2$ </li><li>由于 $q_2$ 和 $q_3$ 在到达接受状态 $q_4$ 的能力上不同，所以 $q_0$ 和 $q_1$ 是不等价的</li></ul><p>最终的表格变为：</p><table><thead><tr><th></th><th>$q_1$</th><th>$q_2$</th><th>$q_3$</th><th>$q_4$</th></tr></thead><tbody><tr><td>$q_0$</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>$q_1$</td><td></td><td>X</td><td>X</td><td>X</td></tr><tr><td>$q_2$</td><td></td><td></td><td>X</td><td>X</td></tr><tr><td>$q_3$</td><td></td><td></td><td></td><td>X</td></tr></tbody></table><p><strong>Step 4</strong> : 合并等价状态</p><p>根据最终表格，我们可以看到所有状态对都被标记为不等价，因此这个自动机已经是最小的了。</p><p>如果有未被标记的状态对 $(p,q)$，则：</p><ul><li>创建一个新状态 $[p]$ 代表 $p$ 和 $q$ 的等价类</li><li>新状态的转移函数：$\delta([p],a) &#x3D; [\delta(p,a)]$</li><li>如果 $p$ 或 $q$ 是接受状态，则 $[p]$ 也是接受状态</li><li>如果 $p$ 或 $q$ 是初始状态，则 $[p]$ 也是初始状态</li></ul><p>填表算法基于以下重要概念：</p><ol><li><p>Myhill-Nerode 定理：两个状态等价当且仅当它们对于任何输入串都有相同的接受性</p></li><li><p>等价关系的传递性：如果状态 $p$ 等价于 $q$，且 $q$ 等价于 $r$，则 $p$ 等价于 $r$</p></li><li><p>不等价的传递性：如果输入 $w$ 能区分状态 $p$ 和 $q$，则 $w$ 也能区分所有等价于 $p$ 的状态和所有等价于 $q$ 的状态</p></li></ol><p>这个算法的时间复杂度为 $O(n^2)$，其中 $n$ 是状态数。它是求解DFA最小化问题的一个经典且高效的算法。</p><h2 id="4-Context-Free-Language"><a href="#4-Context-Free-Language" class="headerlink" title="4. Context-Free Language"></a>4. Context-Free Language</h2><p>上下文无关文法（Context-free grammar，CFG）是一种形式化的文法，用于生成语言。它由一个包含以下四个部分的四元组组成：</p><p>$$<br>G &#x3D; (V, \Sigma, R, S)<br>$$</p><ul><li>$V$：变量（非终结符）的集合。</li><li>$\Sigma$：终结符的集合，即语言中的字母表。</li><li>$R$：产生式规则的集合，每个规则的形态为 $A \rightarrow \alpha$，其中 $A \in V$ 是一个非终结符，$\alpha$ 是由终结符和非终结符组成的字符串（可以为空，表示空串）。</li><li>$S$：开始符号，是一个特殊的非终结符，表示语言的开始。</li></ul><p>上下文无关文法的关键在于其产生式规则的结构：每个产生式的左边是一个单一的非终结符（例如 $A$），右边是一个由终结符和非终结符组成的字符串（例如 $\alpha$）。这一点与<strong>上下文相关文法</strong>不同，后者的产生式规则的左边可以是多个符号的组合（非终结符或终结符）。</p><hr><h3 id="4-1-上下文无关语言的定义"><a href="#4-1-上下文无关语言的定义" class="headerlink" title="4.1 上下文无关语言的定义"></a>4.1 上下文无关语言的定义</h3><p>上下文无关语言（CFL）是由上下文无关文法（CFG）生成的语言。换句话说，如果一个语言可以通过某个上下文无关文法的规则从开始符号 $S$ 推导出一个字符串，那么这个字符串就属于上下文无关语言。</p><div class="note note-primary">            <p>上下文无关语言是一种形式语言，其生成规则由上下文无关文法（CFG）定义，不依赖于符号周围的上下文。</p>          </div><p>例如，考虑如下文法：$aSb \rightarrow aYb \mid \epsilon$</p><p>这个文法的符号串<code>Y</code>是根据<code>S</code>的派生式产生的，不依赖<code>S</code>的上下文<code>a</code>和<code>b</code>。</p><p><strong>上下文无关语言有如下特性：</strong></p><ul><li><strong>递归结构</strong>：上下文无关语言能够表示递归结构。它能够处理很多具有递归特征的语言，例如编程语言中的嵌套结构（如括号匹配、表达式求值等）。</li><li><strong>构造性强</strong>：上下文无关语言不仅可以描述自然语言中的一些结构，还能表达很多编程语言的语法。</li><li><strong>推导和归约</strong>：上下文无关语言的推导过程是基于替换规则的应用，直到生成一个由终结符组成的字符串。这个过程通常是“递归下降”的。</li></ul><p>上下文无关语言与 <strong>下推自动机（Pushdown Automaton，PDA）</strong> 密切相关。下推自动机是能够识别上下文无关语言的一种自动机模型。下推自动机与有限自动机的主要区别在于它有一个栈，可以用来存储额外的信息，从而实现对递归结构的处理。</p><p>例如，对于文法 $S \rightarrow aSb \mid \epsilon$</p><p>下推自动机可以使用栈来存储“a”并在遇到“b”时逐一弹出栈顶的“a”，从而保证字符串中的“a”和“b”的数量相等。</p><p>上下文无关语言的例子：</p><ul><li>$\{ a^n b^n \mid n \geq 0 \}$（例如 $aabbb$）</li><li>$\{ w \mid w \text{ 是一个合法的括号序列} \}$，比如 $(())$、(())、(()()() )等。</li><li>编程语言中的语法，如 C 语言中的函数定义、条件表达式等。</li></ul><p>尽管上下文无关语言在很多实际应用中都非常重要，但它们并不是万能的。上下文无关语言不能处理所有类型的语言，例如，语言</p><p>$$<br>\{ a^n b^n c^n \mid n \geq 0 \}<br>$$</p><p>就不是上下文无关的，因为它需要同时确保 $a$、$b$、$c$ 的数量相等，这超出了上下文无关文法的能力。</p><p>上下文无关语言（CFL）是一类可以由上下文无关文法生成的语言，具有非常广泛的应用，尤其在编程语言的语法分析中。它们能够表示许多递归结构，但并不具备表达所有形式语言的能力。上下文无关语言可以通过下推自动机进行识别，其计算能力介于有限自动机和图灵机之间。</p><p>接下来的内容我们就仔细探讨上下文无关语言的特点和识别它的PDA的特点</p><hr><h3 id="4-2-Derivation-Reduction"><a href="#4-2-Derivation-Reduction" class="headerlink" title="4.2 Derivation &amp; Reduction"></a>4.2 Derivation &amp; Reduction</h3><ul><li><strong>派生</strong>是从开始符号出发，一步步通过应用文法规则，直到得到一个终结符的串。</li><li><strong>规约</strong>是从终结符串开始，一步步逆向应用文法规则，将其简化为开始符号。</li></ul><p>派生和规约是语法分析的两个核心过程，在编译器的语法分析阶段起着至关重要的作用。</p><ul><li><strong>最左派生</strong>和<strong>最右派生</strong>是两种不同的推导方式，它们规定了在派生过程中每一步替换的顺序：最左派生总是替换最左边的非终结符，最右派生总是替换最右边的非终结符。</li><li><strong>规约</strong>是派生过程的逆过程，通过逆向应用产生式规则，将终结符串简化回开始符号。</li></ul><p>这两者在语法分析和推导中各有重要作用，理解它们对于学习上下文无关语言的解析非常关键。</p><hr><h4 id="4-2-1-派生（Derivation）"><a href="#4-2-1-派生（Derivation）" class="headerlink" title="4.2.1 派生（Derivation）"></a>4.2.1 派生（Derivation）</h4><p>派生是根据文法规则从开始符号 $S$ 开始，逐步替换非终结符，直到得到一个仅由终结符组成的字符串的过程。派生有两种常见的形式：<strong>最左派生</strong>和<strong>最右派生</strong>。</p><p><strong>最左派生（Left Derivation）</strong></p><p>最左派生指的是在派生过程中，每一步都选择最左边的非终结符进行替换。换句话说，在每一步推导中，总是选择最左边的非终结符来进行替换，直到最终只剩下终结符。</p><p><strong>最右派生（Right Derivation）</strong></p><p>最右派生指的是在派生过程中，每一步都选择最右边的非终结符进行替换。也就是说，在每一步推导中，总是选择最右边的非终结符来进行替换，直到最终只剩下终结符。</p><p>举个简单的例子辨别一下最左派生和最右派生：</p><p>$<br>E \rightarrow E + T \mid T \<br>$</p><p>$<br>T \rightarrow T * F \mid F <br>$</p><p>$<br>F \rightarrow (E) \mid id<br>$</p><p>让我们用这个文法来推导表达式 <code>id + id * id</code>。</p><p>在<strong>最左派生</strong>中,我们每次都选择最左边的非终结符来替换:</p><p>从起始符号开始：$E$</p><p>使用 $E \rightarrow E + T$ 替换最左边的 $E$：$E \Rightarrow E + T$</p><p>使用 $E \rightarrow T$ 替换最左边的 $E$：$E \Rightarrow T + T$</p><p>使用 $T \rightarrow F$ 替换最左边的 $T$：$E \Rightarrow F + T$</p><p>使用 $F \rightarrow id$ 替换 $F$：$E \Rightarrow id + T$</p><p>使用 $T \rightarrow T * F$ 替换 $T$：$E \Rightarrow id + T * F$</p><p>使用 $T \rightarrow F$ 替换 $T$：$E \Rightarrow id + F * F$</p><p>使用 $F \rightarrow id$ 替换第一个 $F$：$E \Rightarrow id + id * F$</p><p>使用 $F \rightarrow id$ 替换最后的 $F$：$E \Rightarrow id + id * id$</p><hr><p>在<strong>最右派生</strong>中,我们每次都选择最右边的非终结符来替换:</p><p>从起始符号开始：$E$</p><p>使用 $E \rightarrow E + T$ 替换 $E$：$E \Rightarrow E + T$</p><p>使用 $T \rightarrow T * F$ 替换最右边的 $T$：$E \Rightarrow E + T * F$</p><p>使用 $T \rightarrow F$ 替换 $T$：$E \Rightarrow E + F * F$</p><p>使用 $F \rightarrow id$ 替换最右边的 $F$：$E \Rightarrow E + F * id$</p><p>使用 $F \rightarrow id$ 替换剩下的 $F$：$E \Rightarrow E + id * id$</p><p>使用 $E \rightarrow T$ 替换 $E$：$E \Rightarrow T + id * id$</p><p>使用 $T \rightarrow F$ 替换 $T$：$E \Rightarrow F + id * id$</p><p>使用 $F \rightarrow id$ 替换 $F$：$E \Rightarrow id + id * id$</p><hr><h4 id="4-2-2-规约（Reduction）"><a href="#4-2-2-规约（Reduction）" class="headerlink" title="4.2.2 规约（Reduction）"></a>4.2.2 规约（Reduction）</h4><p>规约是派生的反过程，即从一个终结符字符串开始，逐步通过逆向应用文法规则，将字符串中的终结符和非终结符替换回更高层次的非终结符，直到恢复到开始符号 $S$ 为止。规约和派生是上下文无关文法中解析过程的两个主要组成部分。</p><p>在规约过程中，每一步都是根据文法的产生式规则来“逆向”推导。例如，如果有一个产生式 $A \rightarrow \alpha$，并且我们当前的字符串中包含 $\alpha$，则我们可以用 $A$ 来替代 $\alpha$。</p><p>假设我们已经得到了一个字符串（比如终结符的串），然后通过逆推规则一步一步将其还原为开始符号 $S$：</p><ol><li>如果字符串中包含某个产生式的右边部分（例如 $A \rightarrow \alpha$），我们可以用左边的非终结符 $A$ 替换掉右边的部分 $\alpha$。</li><li>继续这个过程，直到字符串被简化为开始符号 $S$。</li></ol><p>规约通常是在语法分析过程中进行的，尤其是<strong>自顶向下</strong>或<strong>自底向上</strong>的语法分析方法。</p><hr><p>假设我们有输入字符串 $id + id * id$，我们将展示如何将其规约回开始符号 $E$。规约过程实际上是最右派生的逆过程，我们需要从右向左观察并应用合适的产生式规则。<br>详细规约步骤</p><ul><li><p>第一步规约：观察最右端的 $id$，应用规则 $F \rightarrow id$<br>$$id + id * id \Rightarrow id + id * F$$</p></li><li><p>第二步规约：继续向左，遇到另一个 $id$，同样应用规则 $F \rightarrow id$<br>$$id + id * F \Rightarrow id + F * F$$</p></li><li><p>第三步规约：现在我们看到 $ F * F $ 的形式，这符合规则 $<br>T \rightarrow T*F$</p></li></ul><p>$$id + F * F \Rightarrow id + T$$</p><ul><li><p>第四步规约：处理最左边的 $id$，应用规则 $F \rightarrow id$<br>$$id + T \Rightarrow F + T$$</p></li><li><p>最后一步规约：应用规则 $E \rightarrow E + T$，将 $F + T$ 规约为 $E$<br>$$F + T \Rightarrow E$$</p></li></ul><hr><h3 id="4-3-文法等价性"><a href="#4-3-文法等价性" class="headerlink" title="4.3 文法等价性"></a>4.3 文法等价性</h3><p>在上下文无关文法（Context-Free Grammar, CFG）中，<strong>文法等价性</strong>指的是两个文法生成相同语言，即它们能够产生相同的所有字符串。换句话说，若两个文法 $G_1$ 和 $G_2$ 对于任意输入串 $w$ 都能通过各自的推导产生这个字符串 $w$，则我们称这两个文法是等价的。</p><p><strong>文法等价性的常见方式：</strong></p><ol><li><p><strong>语言等价</strong>：<br>如果两个文法生成相同的语言，即它们能够生成相同的所有字符串，那么我们说这两个文法是<strong>语言等价</strong>的。</p><p>对于文法 $G_1$ 和 $G_2$，如果 $\mathcal{L}(G_1) &#x3D; \mathcal{L}(G_2)$（其中 $\mathcal{L}(G)$ 表示文法 $G$ 生成的语言），那么它们是语言等价的。</p></li><li><p><strong>推导等价</strong>：<br>两个文法可能有不同的推导方式，但如果它们生成相同的语言，且能够通过等价的推导步骤将一个文法的推导转换为另一个文法的推导，我们也可以认为这两个文法在某种程度上是等价的。通常来说，如果文法 $G_1$ 和 $G_2$ 通过推导能够互相转换，它们也可以被视为等价的。</p></li></ol><p><strong>判断文法是否等价：</strong></p><ul><li><strong>直接比较语言</strong>：通过生成的语言是否相同来判断两个文法是否等价。</li><li><strong>转换法</strong>：通过将一个文法转换为另一个文法的等价形式（例如，转换为简化文法、正规文法等）来判断它们是否等价。</li></ul><p>让我举一个正确的语言等价的文法例子:</p><p>$G_1$:</p><p>$$<br>S \rightarrow aA<br>$$</p><p>$$<br>A \rightarrow aA \mid b<br>$$</p><p>$G_2$:</p><p>$$<br>S \rightarrow a a^* b<br>$$</p><p>这两个文法都生成语言 $L &#x3D; \{a^nb | n \geq 1\}$,即至少包含一个 $a$ 后面跟着一个 $b$ 的所有字符串。<br>我们可以验证:</p><p>$G_1$ 中,第一步必须生成一个 $a$,然后 $A$ 可以生成任意多个 $a$ 最后生成一个 $b$<br>$G_2$ 直接表达了这个语言的形式:一个 $a$ 后面跟着任意多个 $a$ (包括零个),最后是一个 $b$</p><p>这两个文法虽然写法不同,但生成的语言完全相同,所以它们是语言等价的。</p><p>文法等价性通常是通过比较两个文法生成的语言是否相同来判断的。如果两个文法生成的语言相同，则我们认为它们是等价的。</p><hr><h3 id="4-4-Parse-Tree"><a href="#4-4-Parse-Tree" class="headerlink" title="4.4 Parse Tree"></a>4.4 Parse Tree</h3><p>在形式语言与自动机的学习中，<strong>语法分析树（Parse Tree）</strong> 是一个非常重要的概念。它通常用于表示一个输入字符串在某个特定文法下的语法结构，反映了该字符串如何由文法规则生成。语法分析树可以帮助我们理解输入字符串是如何符合某种文法的，并且它是编译器中的一个核心组件，特别是在编译过程的语法分析阶段。</p><h4 id="4-4-1-语法分析树定义"><a href="#4-4-1-语法分析树定义" class="headerlink" title="4.4.1 语法分析树定义"></a>4.4.1 语法分析树定义</h4><p>语法分析树是一棵树形结构，其特点如下：</p><ul><li><strong>根节点</strong>：树的根通常代表语言的开始符号（Start Symbol），例如 $S$（常见于上下文无关文法）。</li><li><strong>内部节点</strong>：每个内部节点表示文法中的某个非终结符，或者在某些情况下可能是终结符的组合。</li><li><strong>叶节点</strong>：树的叶子节点表示文法中的终结符，也就是输入字符串的实际字符或符号。</li></ul><p>构建语法分析树的过程实际上是推导过程的可视化。对于一个给定的输入字符串，通过应用文法规则逐步替代非终结符，直到最终替换成终结符。具体的过程包括：</p><ol><li><strong>选择开始符号</strong>，例如 $S$。</li><li>使用文法规则（例如 $S \to aSb \mid \epsilon$）将开始符号逐步展开，生成新的非终结符。</li><li>每次展开都会在树中添加一个新的节点，并继续扩展，直到输入字符串完全匹配到叶节点为止。</li><li>最终生成的树形结构就是该输入字符串的语法分析树。</li></ol><p>假设我们有一个简单的上下文无关文法：</p><p>$$<br>S \to aSb \mid \epsilon<br>$$</p><p>我们想分析字符串 <code>&quot;aabb&quot;</code> 是否符合这个文法。</p><ul><li><strong>步骤 1</strong>：从根节点开始，$S$。</li><li><strong>步骤 2</strong>：使用 $S \to aSb$ 规则，得到 $S \to aSb$。</li><li><strong>步骤 3</strong>：继续展开 $S \to aSb$，得到 $S \to aaSbb$。</li><li><strong>步骤 4</strong>：再次应用 $S \to \epsilon$，得到 $S \to aa\epsilon bb$，结果是 <code>&quot;aabb&quot;</code>。</li></ul><p>对应的语法分析树如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\a S b   /|\  a S b     |     ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="4-4-2-语法分析树与派生"><a href="#4-4-2-语法分析树与派生" class="headerlink" title="4.4.2 语法分析树与派生"></a>4.4.2 语法分析树与派生</h4><p>语法分析树是派生过程的图形化表示。每一次应用文法规则都对应语法分析树中的一个分支或一个节点的展开。具体来说：</p><ul><li>根节点：表示开始符号。</li><li>内部节点：表示一个非终结符，并且这些非终结符是通过相应的文法规则展开的。</li><li>叶子节点：表示终结符，通常是输入字符串的实际字符。</li></ul><p><strong>从派生到语法分析树：</strong></p><ul><li>给定一个派生过程，我们可以通过每一步推导生成一个节点，并将其按顺序组织成一棵树。</li><li>每个非终结符的应用对应语法分析树中的一个内节点，每次替代操作都创建树的分支。</li></ul><p><strong>从语法分析树到派生：</strong></p><ul><li>通过语法分析树，我们可以逆向得到派生过程。从根节点开始，逐层向下，按照每个节点的子节点选择合适的文法规则，逆推出每一步派生。</li></ul><p>根据上面例子的语法分析树</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\a S b   /|\  a S b     |     ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到：</p><ul><li>每一步派生都对应树中的每一层节点展开，每一层都是一个文法规则的应用。</li><li>从语法分析树回推派生：从根到叶的路径，可以通过每个非终结符的替换规则反推出派生过程。</li></ul><h4 id="4-4-3-Grammar-Ambiguity"><a href="#4-4-3-Grammar-Ambiguity" class="headerlink" title="4.4.3 Grammar Ambiguity"></a>4.4.3 Grammar Ambiguity</h4><p><strong>文法的歧义性（ Grammar Ambiguity）</strong>指的是一种情况：对于某个文法，它可以通过多种不同的方式生成同一个字符串，导致该字符串存在多个不同的<strong>语法分析树（Parse Tree）</strong>或<strong>推导（Derivations）</strong>。这种属性使得文法具有歧义性。</p><p>如果一个文法 $G$ 存在某个字符串 $w$（属于该文法生成的语言 $L(G)$），使得 $w$ 有<strong>两种或更多不同的最左推导（Leftmost Derivations）</strong>、最右推导或语法分析树，则称该文法 $G$ 是<strong>歧义文法</strong>。</p><p>换句话说：</p><ul><li>该文法中的某些规则允许通过多种不同的方式从开始符号 $S$ 推导出字符串 $w$。</li><li>歧义产生的原因是文法的结构无法唯一确定字符串的生成方式。</li></ul><hr><p><strong>歧义文法的例子</strong>：考虑以下文法 $G$：</p><p>$$<br>S \to S + S \mid S \times S \mid a<br>$$</p><ul><li>终结符 $a$ 表示一个变量或操作数。</li><li>非终结符 $S$ 表示一个表达式。</li></ul><p>该文法可以生成字符串 $a + a \times a$，但这个字符串有<strong>两种不同的语法分析树</strong>：</p><ol><li>如果优先处理“+”操作：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\S  + S|    /|\a   S  x S    |    |    a    a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ol><li>如果优先处理“×”操作：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\S  x S|    |a   S    /|\   S  + S   |    |   a    a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这两棵语法分析树对应相同的字符串 $a + a \times a$，但它们表示的结构和含义不同（例如，不同的操作符优先级会导致计算结果不同）。</p><p><strong>文法歧义性的影响</strong></p><ul><li><strong>语义不明确</strong>：文法的歧义性使得字符串的含义变得不明确。例如，在编程语言中，歧义文法可能会导致相同的表达式得出不同的结果。</li><li><strong>解析困难</strong>：歧义文法更难解析，因为解析器可能无法唯一确定语法分析树。</li><li><strong>编译器设计问题</strong>：大多数编程语言都要求文法是无歧义的，以确保代码的解析和执行是确定性的。</li></ul><p>遗憾的是，对于一个任意上下文无关文法（CFG），<strong>无法通过算法判断文法是否是歧义的</strong>。这是形式语言理论中的一个已知的不可判定问题（Undecidable Problem）。<br>不过，对于简单的情况，可以通过手动检查某些字符串是否有多种推导方式来发现歧义。</p><hr><p><strong>如何消除歧义:</strong> 如果一个文法是歧义的，有时可以将其重写为一个等价的<strong>无歧义文法</strong>。例如，上述的算术表达式文法可以通过引入操作符优先级和结合性规则来消除歧义：</p><ul><li>定义<strong>优先级</strong>：乘法（$\times$）的优先级高于加法（$+$）。</li><li>定义<strong>结合性</strong>：加法和乘法均为左结合。</li></ul><p>重写后的文法如下：</p><p>$$<br>E \to E + T \mid T<br>$$<br>$$<br>T \to T \times F \mid F<br>$$<br>$$<br>F \to a<br>$$</p><p>在这个文法中，字符串 $a + a \times a$ 的语法分析树唯一，结构如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  E /|\E  + T|    |F    T|    |a    F     |     a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这棵语法分析树清楚地表示了“$\times$”比“$+$”具有更高的优先级，从而消除了歧义。</p><p>文法的歧义性不仅存在于编程语言或形式语言中，也经常出现在<strong>自然语言</strong>中。例如：</p><p><code>I saw the man with a telescope</code></p><p>这句话有两种解释：</p><ol><li><strong>我用望远镜看到了这个人。</strong></li><li><strong>我看到了一个拿着望远镜的人。</strong></li></ol><p>这种歧义也可以用两棵不同的语法分析树表示，与形式语言中的歧义类似。</p><h3 id="4-5-文法化简与范式"><a href="#4-5-文法化简与范式" class="headerlink" title="4.5 文法化简与范式"></a>4.5 文法化简与范式</h3><p>文法化简是形式语言与自动机理论中的重要内容，用于简化上下文无关文法（CFG），使其更易于分析或实现。文法化简的目标是通过一系列步骤，移除冗余规则和符号，同时保持生成语言不变。主要包括以下三步：</p><p><strong>Step 1:</strong> 消除无用符号</p><p>无用符号是指在文法中不可能被用来生成任何字符串的非终结符，分为两种情况：</p><ul><li><strong>不可达符号</strong>：从起始符号出发，无法到达的非终结符。</li><li><strong>非生成符号</strong>：无法推导出终结符串的非终结符。</li></ul><p><strong>处理方法</strong>：</p><ol><li>找出能够推导出终结符串的非终结符（生成符号）。</li><li>找出从起始符号可以到达的符号（可达符号）。</li><li>移除所有既非生成又不可达的符号及相关产生式。</li></ol><p><strong>Step 2:</strong> 消除 $\epsilon$-产生式</p><p>$\epsilon$-产生式是指形如 $A \to \epsilon$ 的规则（$\epsilon$ 表示空串）。除非文法描述的语言中包含空串，应尽量消除这些规则。</p><p><strong>处理方法</strong>：</p><ol><li>找出所有可以直接或间接推导出空串的非终结符（称为 $\epsilon$-可导符号）。</li><li>对于每个包含 $\epsilon$-可导符号的产生式，生成所有可能的替代产生式（通过省略这些符号）。</li><li>如果起始符号可以推导出空串，需增加新的起始符号：<br>$$<br>S’ \to S \ | \ \epsilon<br>$$</li></ol><p><strong>Step 3:</strong> 消除单一产生式</p><p>单一产生式是指形如 $A \to B$ 的规则，其中 $A$ 和 $B$ 都是非终结符。它们会增加文法复杂性但不会增加语言的表达能力。</p><p><strong>处理方法</strong>：</p><ol><li>找出所有的单一产生式。</li><li>替换单一产生式 $A \to B$ 为 $A$ 直接生成 $B$ 的所有右部。</li></ol><p><strong>Step 4:</strong> 化简为规范形式（可选）</p><p>如果需要进一步化简，可将文法转化为以下特定的规范形式：</p><ul><li><strong>格雷巴赫范式（GNF）</strong>：每个产生式的右部以一个终结符开头，后跟若干非终结符。</li><li><strong>乔姆斯基范式（CNF）</strong>：每个产生式要么是两个非终结符，要么是一个终结符。</li></ul><p>$$<br>A \to BC<br>$$</p><p>$$<br>A \to a<br>$$</p><p>下面我们先了解一下文法化简的规范形式。</p><hr><h4 id="4-5-1-Chomsky-Normal-Form-CNF"><a href="#4-5-1-Chomsky-Normal-Form-CNF" class="headerlink" title="4.5.1 Chomsky Normal Form (CNF)"></a>4.5.1 Chomsky Normal Form (CNF)</h4><p>在形式语言与自动机理论中，<strong>Chomsky Normal Form（CNF）</strong> 是一种用于上下文无关文法（Context-Free Grammar，CFG）标准化的形式。通过将文法转换为 Chomsky 正常形式，很多算法（如 CYK 算法）可以变得更加高效。</p><p><strong>Chomsky Normal Form 的定义:</strong></p><p>一个上下文无关文法 $G &#x3D; (V, \Sigma, R, S)$，其中 $V$ 是非终结符的集合，$\Sigma$ 是终结符的集合，$R$ 是产生式规则的集合，$S$ 是起始符号。若该文法满足以下条件，则称其为 Chomsky Normal Form：</p><ol><li><p>每个产生式 $A \rightarrow \alpha$ 满足以下之一：</p><ul><li>$\alpha$ 是一个终结符，形式为 $A \rightarrow a$，其中 $a \in \Sigma$。</li><li>$\alpha$ 是两个非终结符的串，形式为 $A \rightarrow BC$，其中 $B, C \in V$，并且 $B$ 和 $C$ 不能是起始符号 $S$。</li></ul></li><li><p>如果文法包含空产生式（即 $S \rightarrow \epsilon$），则 $S$ 必须是唯一的起始符号，并且不能出现在右侧的产生式中。</p></li><li><p>如果文法包含单位产生式（即 $A \rightarrow B$），则可以用合适的规则进行替换，消除单位产生式。</p></li></ol><p>假设我们有一个上下文无关文法 $G$，想要将其转换为 Chomsky Normal Form，通常的步骤如下：</p><p><strong>Step 1:</strong> 移除空产生式<br>首先，移除所有的空产生式（即产生式 $A \rightarrow \epsilon$）。如果文法包含这样的产生式，需要适当调整其他产生式，将空产生式的影响消除。</p><p><strong>Step 2:</strong> 移除单位产生式<br>移除所有的单位产生式（即 $A \rightarrow B$ 形式的产生式）。这一步需要通过替换和合并产生式来完成。</p><p><strong>Step 3:</strong> 替换长右边的产生式<br>将所有右边有两个以上符号的产生式替换为符合 CNF 的形式。如果存在一个产生式 $A \rightarrow X_1 X_2 \dots X_n$，其中 $n &gt; 2$，则通过引入新的非终结符逐步将其拆分成二元产生式。</p><p><strong>Step 4:</strong> 替换终结符的混合产生式<br>如果在某个产生式中，右边含有终结符和非终结符混合的情况（例如 $A \rightarrow aB$，其中 $a \in \Sigma$ 且 $B \in V$），则通过引入新的非终结符来替换终结符。</p><p>假设我们有以下文法：</p><ul><li>$S \rightarrow AB \mid a$</li><li>$A \rightarrow SA \mid \epsilon$</li><li>$B \rightarrow b$</li></ul><p>我们将其转换为 Chomsky Normal Form：</p><ol><li><p><strong>移除空产生式</strong>：由于 $A \rightarrow \epsilon$，我们需要将文法中可能依赖 $A$ 的规则调整为不包含 $A$ 的形式。</p><ul><li>$S \rightarrow AB \mid a$ -&gt; $S \rightarrow AB \mid a \mid B$</li><li>$A \rightarrow SA$ -&gt; $A \rightarrow SA \mid S$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>移除单位产生式</strong>：从 $A \rightarrow S$ 和 $S \rightarrow B$ 可以看出我们有单位产生式。我们将 $A \rightarrow S$ 和 $S \rightarrow B$ 替换成等效的产生式。</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow AB \mid a$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>替换长右边的产生式</strong>：没有长右边的产生式，所有产生式都已经是符合 CNF 的。</p></li></ol><p>最终结果可能会是：</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow AB \mid a$</li><li>$B \rightarrow b$</li></ul><hr><h4 id="4-5-2-Greibach-Normal-Form-GNF"><a href="#4-5-2-Greibach-Normal-Form-GNF" class="headerlink" title="4.5.2 Greibach Normal Form (GNF)"></a>4.5.2 Greibach Normal Form (GNF)</h4><p><strong>Greibach Normal Form（GNF）</strong> 是另一种上下文无关文法（Context-Free Grammar，CFG）的标准形式。与 Chomsky Normal Form 不同，GNF 强调了产生式的结构形式。特别是，每个产生式的右侧必须以一个终结符开始，其后跟随零个或多个非终结符。</p><p><strong>Greibach Normal Form 的定义:</strong></p><p>一个上下文无关文法 $G &#x3D; (V, \Sigma, R, S)$，其中 $V$ 是非终结符的集合，$\Sigma$ 是终结符的集合，$R$ 是产生式规则的集合，$S$ 是起始符号。若该文法满足以下条件，则称其为 Greibach Normal Form：</p><ol><li><p>每个产生式 $A \rightarrow \alpha$ 都是以下形式之一：</p><ul><li>$\alpha$ 以一个终结符开始，形式为 $A \rightarrow a \gamma$，其中 $a \in \Sigma$，且 $\gamma$ 是非终结符的串（包括空串）。</li></ul></li><li><p>文法中的每个产生式右边必须以一个终结符开头，后面可以跟任意数量的非终结符。</p></li></ol><p>与 Chomsky Normal Form 不同，GNF 不要求右边的产生式是二元的，而是要求右边的第一个符号是终结符。</p><p>假设我们有一个上下文无关文法 $G$，想要将其转换为 Greibach Normal Form，通常的步骤如下：</p><p><strong>Step 1:</strong> 移除空产生式<br>首先，移除所有的空产生式（即产生式 $A \rightarrow \epsilon$）。如果文法包含这样的产生式，需要调整文法中的其他产生式，以消除空产生式的影响。</p><p><strong>Step 2:</strong> 移除单位产生式<br>移除所有的单位产生式（即 $A \rightarrow B$ 形式的产生式）。这一步需要通过替换单位产生式来完成。</p><p><strong>Step 3:</strong> 替换长右边的产生式<br>如果产生式的右边有多个符号，则需要通过引入新的非终结符逐步将其转换为以终结符开始的形式。</p><ul><li>例如，如果你有一个产生式 $A \rightarrow X_1 X_2 \dots X_n$，其中 $n &gt; 1$，你需要分解该产生式，使其右边以终结符开始，并且后面跟着非终结符。</li></ul><p><strong>Step 4:</strong> 替换终结符的混合产生式<br>如果产生式的右边包含终结符与非终结符的混合（例如 $A \rightarrow aB$），则需要将终结符与非终结符分离，确保右边的产生式以终结符开头，后面跟随零个或多个非终结符。</p><p>假设我们有以下文法：</p><ul><li>$S \rightarrow AB \mid a$</li><li>$A \rightarrow SA \mid \epsilon$</li><li>$B \rightarrow b$</li></ul><p>我们将其转换为 Greibach Normal Form：</p><ol><li><p><strong>移除空产生式</strong>：首先，移除空产生式 $A \rightarrow \epsilon$，并调整其他规则。</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow SA \mid S$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>移除单位产生式</strong>：从 $A \rightarrow S$ 和 $S \rightarrow B$ 可以看出我们有单位产生式。我们将其替换成等效的产生式。</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow AB \mid a$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>替换长右边的产生式</strong>：没有长右边的产生式，所有产生式的右边已经以终结符开头。</p></li></ol><p>最终文法可能是：</p><ul><li>$S \rightarrow a \mid b$</li><li>$A \rightarrow aB \mid b$</li><li>$B \rightarrow b$</li></ul><hr><h4 id="4-5-3-CYK算法（Cocke-Younger-Kasami-Algorithm）"><a href="#4-5-3-CYK算法（Cocke-Younger-Kasami-Algorithm）" class="headerlink" title="4.5.3 CYK算法（Cocke-Younger-Kasami Algorithm）"></a>4.5.3 CYK算法（Cocke-Younger-Kasami Algorithm）</h4><p>CYK算法是一种用于上下文无关文法（CFG，Context-Free Grammar）分析的算法，主要用于确定一个给定的字符串是否能被某个上下文无关文法生成。CYK算法基于动态规划思想，通过构造一个三维表格来高效地判断一个字符串是否属于某个上下文无关文法所生成的语言。</p><p>假设我们有一个上下文无关文法 $G &#x3D; (N, \Sigma, P, S)$，其中：</p><ul><li>$N$ 是非终结符的集合，</li><li>$\Sigma$ 是终结符的集合，</li><li>$P$ 是文法规则的集合，</li><li>$S$ 是起始符号。</li></ul><p>给定一个字符串 $w &#x3D; w_1 w_2 \dots w_n$（长度为 $n$），我们通过 CYK 算法来判断 $w$ 是否能通过文法 $G$ 生成。</p><p><strong>具体步骤如下：</strong></p><ol><li><p><strong>构造三维表格：</strong>  创建一个三维表格 $T$，其中 $T[i,j]$ 表示字符串 $w_i, w_{i+1}, \dots, w_j$（从第 $i$ 个字符到第 $j$ 个字符）是否可以由某个非终结符生成。表格的大小为 $n \times n$，其中 $n$ 是输入字符串的长度。每个表格项 $T[i,j]$ 都会包含一些非终结符，表示该子字符串可以由哪些非终结符生成。</p></li><li><p><strong>初始化：</strong>  对于长度为 1 的子串（即单个字符），检查该字符是否是文法中的终结符。如果是，填充对应的非终结符。</p></li></ol><ul><li>比如，对于每个 $w_i \in \Sigma$，我们查找规则 $A \to w_i$，如果存在，将 $A$ 加入到 $T[i,i]$ 中。</li></ul><ol start="3"><li><p><strong>填充表格：</strong>  对于长度大于 1 的子串，遍历所有可能的分割点 $k$（从 1 到 $n-1$），并检查是否可以通过文法规则将其分割为两个子串。对于每一对非终结符 $A \to BC$，如果 $B$ 能生成左边的子串（即 $T[i,k]$），$C$ 能生成右边的子串（即 $T[k+1,j]$），则将 $A$ 加入 $T[i,j]$。</p></li><li><p><strong>终止条件：</strong>  最终，检查起始符号 $S$ 是否在 $T[1,n]$ 中。如果是，说明字符串 $w$ 可以由文法 $G$ 生成；否则不能。</p></li></ol><p>CYK算法的时间复杂度为 $O(n^3 \cdot |G|)$，其中：</p><ul><li>$n$ 是输入字符串的长度，</li><li>$|G|$ 是文法规则的数量。</li></ul><hr><p>举个例子，给定一个乔姆斯基范式的上下文无关文法：</p><p>$$G &#x3D; ({S, A, B, C}, {a, b}, S, P)$$</p><p>其中规则 $P$ 如下：</p><p>$S \to AB \mid BC$</p><p>$A \to BA \mid a$</p><p>$B \to CC \mid b$</p><p>$C \to AB \mid a$</p><p>问题：字符串 <code>bbabaa</code> 能不能通过该文法产生？</p><p>我们使用 CYK 算法来解决这个问题，CYK 算法通过构建一个表格来判断每个子串能由哪些非终结符生成。表格的第 $i$ 列和第 $j$ 行表示由哪些非终结符可以生成字字符串 $\sigma_i \dots \sigma_j$。</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><strong>i</strong></td><td>a</td><td>b</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td><strong>j&#x3D;1</strong></td><td>{$B$}</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>j&#x3D;2</strong></td><td></td><td>{$B$}</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>j&#x3D;3</strong></td><td>{$A$}</td><td>{$S, A$}</td><td>{$A, C$}</td><td></td><td></td><td></td></tr><tr><td><strong>j&#x3D;4</strong></td><td>{$S, C$}</td><td>{$S, C$}</td><td>{$S, C$}</td><td>{$B$}</td><td></td><td></td></tr><tr><td><strong>j&#x3D;5</strong></td><td>{$B$}</td><td>{$B$}</td><td>{$B$}</td><td>{$A, S$}</td><td>{$A, C$}</td><td></td></tr><tr><td><strong>j&#x3D;6</strong></td><td>{$A, S$}</td><td>{$A, S$}</td><td>{$A, S$}</td><td></td><td>{$B$}</td><td>{$A, C$}</td></tr></tbody></table><p><strong>判断过程如下：</strong></p><ul><li><p><strong>初始化</strong>：对于每个字符 $w_i$（即 $a$, $b$ 等），填充对应的非终结符。</p><ul><li>对于 $w_1 &#x3D; b$，由规则 $B \to b$，填充 $T[1, 1] &#x3D; \{B\}$。</li><li>对于 $w_2 &#x3D; b$，同理填充 $T[2, 2] &#x3D; \{B\}$。</li><li>以此类推，对于其他字符填充。</li></ul></li><li><p><strong>递推填充</strong>：根据文法规则检查可能的组合，填充表格中的其他位置。例如：</p><ul><li>$T[3, 3]$ 可以通过 $A \to a$ 填充为 $\{A\}$。</li><li>$T[2, 3]$ 可以通过 $S \to BC$ 或 $A \to BA$ 填充为 $\{S, A\}$ </li><li>如此继续填充整个表格。(比如生成<code>bba</code>这样的子串，那么就要考虑<code>b + ba</code> 或者<code>bb+a</code>这样的派生)</li></ul></li><li><p><strong>终止条件</strong>：最终检查 $T[1, 6]$ 是否包含文法的起始符号 $S$。如果包含，则说明该字符串可以由该文法生成。</p></li></ul><p>由于 $T[1, 6]$ 中包含了文法的起始符号 $S$，我们可以得出结论：<strong>字符串 <code>bbabaa</code> 能由文法 $G$ 生成</strong>。</p><hr><h3 id="4-6-Pumping-Lemma-for-CFLs"><a href="#4-6-Pumping-Lemma-for-CFLs" class="headerlink" title="4.6 Pumping Lemma for CFLs"></a>4.6 Pumping Lemma for CFLs</h3><p>上下文无关语言（CFL）的泵引理指出，对于任何上下文无关语言 $L$，如果 $L$ 是无限的，那么存在一个常数 $p$（泵长），使得对于所有长度大于等于 $p$ 的字符串 $s \in L$，$s$ 可以分解为五个部分 $s &#x3D; uvwxy$，满足以下条件：</p><ol><li>对于所有 $i \geq 0$，$uv^i w x^i y \in L$。</li><li>$|v| + |x| &gt; 0$ （也就是说，$v$ 和 $x$ 不全为空）。</li><li>$|vwx| \leq p$ （即 $v$ 和 $x$ 的长度加起来不能超过泵长 $p$）。</li></ol><p>我们假设 $L$ 是一个无限的上下文无关语言。由于 $L$ 是上下文无关语言，根据上下文无关文法的结构特性，它对应着一个下推自动机（PDA）。这个 PDA 需要满足一个条件：它可以“泵”字符串，即通过重复某些部分的字符串仍然保持在语言 $L$ 中。</p><p>根据泵引理的假设，存在一个泵长 $p$，使得对于所有长度大于等于 $p$ 的字符串 $s \in L$，该字符串 $s$ 可以分解为 $s &#x3D; uvwxy$，且满足以下条件：</p><ul><li>$|vwx| \leq p$。</li><li>$|v| + |x| &gt; 0$。</li></ul><p>上下文无关语言可以通过上下文无关文法（CFG）生成，也可以通过下推自动机（PDA）来接受。我们利用这些结构来展示泵引理。</p><ul><li>对于一个长度大于等于 $p$ 的字符串 $s \in L$，它一定可以通过上下文无关文法的推导生成。</li><li>由于 $L$ 是无限的，存在某些部分的推导树，可以分解成五个部分 $uvwxy$，其中：<ul><li>$v$ 和 $x$ 是可以被“泵”重复的部分。</li><li>$v$ 和 $x$ 的长度总和不超过 $p$。</li><li>这意味着，对于某些合适的 $i$，$v$ 和 $x$ 可以重复而不破坏语言的结构。</li></ul></li></ul><blockquote><p>这里的证明也会用到Pigeonhole Principal，就不细讲了</p></blockquote><p>根据上下文无关语言的结构，字符串 $s$ 可以分解为 $s &#x3D; uvwxy$，且满足以下条件：</p><ul><li>$|vwx| \leq p$，这意味着 $v$ 和 $x$ 的总长度不会超过泵长 $p$，它们的长度是有限的。</li><li>$|v| + |x| &gt; 0$，这表示 $v$ 和 $x$ 不能同时为空。</li></ul><p>通过泵引理，我们知道，如果我们“泵”字符串 $s$ 中的部分 $v$ 和 $x$，即重复它们的次数，则得到的新字符串 $uv^i w x^i y$ 仍然属于语言 $L$，对于所有 $i \geq 0$。</p><p>根据泵引理的假设，对于所有 $i \geq 0$，$uv^i w x^i y \in L$。这意味着，通过增加 $v$ 和 $x$ 部分的数量，字符串依然保持在语言 $L$ 中。</p><p>该过程的关键在于，通过适当的分解和“泵”操作，语言的结构保持不变，因此可以通过上下文无关文法或下推自动机接受。</p><p>通过泵引理，我们可以证明某些语言不是上下文无关语言。例如，反证法通常用于证明一个语言不符合上下文无关语言的要求。通过选择一个合适的字符串，并假设它满足泵引理的条件，我们可以展示某些操作导致字符串不再属于该语言，从而得出该语言不是上下文无关语言的结论。</p><hr><p>通过泵引理，我们可以用反证法证明某些语言不是上下文无关语言。假设我们要证明某个语言 $L$ 不是上下文无关语言，通常通过以下步骤：</p><ol><li>假设 $L$ 是上下文无关语言，并假设它满足泵引理。</li><li>选择一个字符串 $s \in L$，其长度大于等于泵长 $p$，然后将其分解为 $s &#x3D; uvwxy$，并使用泵引理。</li><li>展开 $uv^i w x^i y$ 并证明对于某些值的 $i$，$uv^i w x^i y$ 不属于 $L$，从而得出矛盾。</li><li>由此得出结论，$L$ 不是上下文无关语言。</li></ol><p>例子：证明 $L &#x3D; \{ a^n b^n c^n \mid n \geq 0 \}$ 不是上下文无关语言</p><p>我们使用上下文无关语言的泵引理来证明 $L &#x3D; \{ a^n b^n c^n \mid n \geq 0 \}$ 不是上下文无关语言。</p><ol><li><p><strong>假设 $L$ 是上下文无关语言：</strong><br>假设 $L$ 是上下文无关语言，且存在泵长 $p$。根据泵引理，任何长度大于或等于 $p$ 的字符串 $s$ 都可以分解为 $s &#x3D; uvwxy$，其中 $|vwx| \leq p$ 且 $|v| + |x| &gt; 0$。</p></li><li><p><strong>选择字符串 $s &#x3D; a^p b^p c^p$：</strong><br>选择字符串 $s &#x3D; a^p b^p c^p$，它显然属于语言 $L$，并且 $|s| &#x3D; 3p \geq p$。</p></li><li><p><strong>分解字符串 $s$：</strong><br>根据泵引理，$s &#x3D; uvwxy$，其中 $|vwx| \leq p$，并且 $|v| + |x| &gt; 0$。由于 $|vwx| \leq p$，它只能覆盖字符串中的某一部分（即 $a^n$、$b^n$ 或 $c^n$）。而且，由于 $|v| + |x| &gt; 0$，$v$ 和 $x$ 必定包含某些重复的字符。</p></li><li><p><strong>泵引理的应用：</strong><br>根据泵引理，对于所有的 $i \geq 0$，$uv^i w x^i y$ 应该仍然属于 $L$。但是，如果我们选择 $i &gt; 1$，则会得到不匹配的字符串，如 $uv^2 w x^2 y$，这个字符串在 $a^n b^n c^n$ 结构中就无法保持相同数量的 <code>a</code>、<code>b</code> 和 <code>c</code>，从而不再属于 $L$。</p></li><li><p><strong>得出矛盾：</strong><br>因此，我们得出结论，$L$ 不可能是上下文无关语言，因为泵引理得出的结论与 $L$ 的定义矛盾。</p></li></ol><p>上下文无关语言的泵引理是通过对语言字符串的分解和重复来证明语言的一些特性。它为我们提供了一个方法，可以通过反证法证明某些语言不是上下文无关语言。</p><hr><h3 id="4-7-上下文无关语言的封闭性"><a href="#4-7-上下文无关语言的封闭性" class="headerlink" title="4.7 上下文无关语言的封闭性"></a>4.7 上下文无关语言的封闭性</h3><p>CFL（上下文无关语言，Context-Free Languages）的运算封闭性是指当对CFL进行一些特定的语言运算时，运算结果是否仍然是CFL。这里先给出结论：</p><ul><li><strong>封闭性</strong>的运算有：<ul><li>代换（Substitution）</li><li>并（Union）</li><li>连接（Concatenation）</li><li>闭包（Kleene Star</li><li>同态（Homomorphism）</li><li>逆同态（Inverse Homomorphism）</li><li>反转（Reversal）</li></ul></li><li><strong>不封闭</strong>的运算有：<ul><li>交（Intersection）</li><li>补（Complement）</li></ul></li></ul><blockquote><p>这里的证明也是修考的常考点，必须掌握得滚瓜烂熟</p></blockquote><hr><h4 id="4-7-1-代换（Substitution）封闭"><a href="#4-7-1-代换（Substitution）封闭" class="headerlink" title="4.7.1 代换（Substitution）封闭"></a>4.7.1 代换（Substitution）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），并且每个符号$x$在$L$中都被替换成一个CFL语言$A_x$，那么代换后的语言也是CFL。</p><p>证明过程如下：</p><ol><li><p><strong>定义代换运算</strong>：<br>假设$L$是一个上下文无关语言，并且对于$L$中的每个符号$x$，我们定义一个CFL语言$A_x$。代换运算的结果$L’$是通过将$L$中的每个符号$x$替换为相应的语言$A_x$得到的，即<br>$$ L’ &#x3D; \{ w_1w_2 \cdots w_n \mid w_i \in A_{x_i} \text{，且} x_1x_2 \cdots x_n \in L \} $$<br>其中$w_i$是符号$x_i$在语言$A_{x_i}$中的一个字符串。</p></li><li><p><strong>构造文法</strong>：<br>由于$L$是一个CFL，假设$L$的文法是$G &#x3D; (V, \Sigma, R, S)$，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。</p><p>对于每个符号$x$，我们有一个CFL语言$A_x$，假设$A_x$的文法是$G_x &#x3D; (V_x, \Sigma_x, R_x, S_x)$。</p></li><li><p><strong>构造代换后的文法</strong>：<br>我们可以构造一个新文法$G’$来生成$L’$。文法$G’$的非终结符集合包括所有$G$中的非终结符以及所有$A_x$的非终结符。文法规则由以下部分构成：</p><ul><li><p>对于$G$中的每个产生式$A \to \alpha$，我们将其替换为：<br>$$ A \to \alpha’ $$<br>其中$\alpha’$是通过将$\alpha$中的每个符号$x_i$替换为$A_{x_i}$的开始符号$S_{x_i}$得到的。</p></li><li><p>对于每个$A_x$中的产生式$S_x \to w$，我们加入产生式$S_x \to w$到$G’$中。</p></li></ul><p>通过这些规则，$G’$可以生成代换后的语言$L’$。</p></li><li><p><strong>结论</strong>：<br>我们通过构造一个新的文法$G’$，使得$G’$生成代换后的语言$L’$。由于文法$G’$是上下文无关的（它是由上下文无关文法$G$和$A_x$的文法组合而成的），因此$L’$也是一个上下文无关语言。</p></li></ol><p>因此，CFL对于代换运算是封闭的。</p><hr><h4 id="4-7-2-并（Union）封闭"><a href="#4-7-2-并（Union）封闭" class="headerlink" title="4.7.2 并（Union）封闭"></a>4.7.2 并（Union）封闭</h4><p>我们需要证明：如果$L_1$和$L_2$都是上下文无关语言（CFL），那么$L_1 \cup L_2$也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L_1$和$L_2$都是上下文无关语言。根据定义，$L_1$和$L_2$分别可以由上下文无关文法$G_1 &#x3D; (V_1, \Sigma, R_1, S_1)$和$G_2 &#x3D; (V_2, \Sigma, R_2, S_2)$生成，其中$V_1$和$V_2$是非终结符集，$\Sigma$是终结符集，$R_1$和$R_2$是产生式规则，$S_1$和$S_2$是开始符号。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G &#x3D; (V, \Sigma, R, S)$，用来生成$L_1 \cup L_2$。新的文法$G$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V &#x3D; V_1 \cup V_2 \cup \{S\}$，其中$S$是$L_1 \cup L_2$的开始符号。</p></li><li><p><strong>终结符集</strong>：$\Sigma$与$L_1$和$L_2$的终结符集相同，都是$\Sigma$。</p></li><li><p><strong>产生式规则集</strong>：$R$包括以下规则：</p><ol><li>$S \to S_1 \mid S_2$，其中$S_1$是$L_1$的开始符号，$S_2$是$L_2$的开始符号。</li><li>对于$G_1$中的每个产生式$A \to \alpha$，将其直接加入$R$。</li><li>对于$G_2$中的每个产生式$B \to \beta$，将其直接加入$R$。</li></ol></li><li><p><strong>开始符号</strong>：$S$是新的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L_1 \cup L_2$：<br>通过新的文法$G$，我们可以生成任意一个$L_1$中的字符串或$L_2$中的字符串。具体来说：</p><ul><li>如果$w \in L_1$，则$w$可以通过$S \to S_1$产生，然后根据$G_1$中的产生式生成$w$。</li><li>如果$w \in L_2$，则$w$可以通过$S \to S_2$产生，然后根据$G_2$中的产生式生成$w$。</li></ul><p>因此，$L_1 \cup L_2$中的任意字符串都可以通过文法$G$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G$来生成$L_1 \cup L_2$，并且文法$G$是上下文无关的（由$G_1$和$G_2$组合而成），因此$L_1 \cup L_2$也是上下文无关语言。</p></li></ol><p>因此，CFL对于并运算是封闭的。</p><hr><h4 id="4-7-3-连接（Concatenation）封闭"><a href="#4-7-3-连接（Concatenation）封闭" class="headerlink" title="4.7.3 连接（Concatenation）封闭"></a>4.7.3 连接（Concatenation）封闭</h4><p>我们需要证明：如果$L_1$和$L_2$都是上下文无关语言（CFL），那么$L_1 \cdot L_2$（即$L_1$和$L_2$的连接）也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L_1$和$L_2$都是上下文无关语言。根据定义，$L_1$和$L_2$分别可以由上下文无关文法$G_1 &#x3D; (V_1, \Sigma, R_1, S_1)$和$G_2 &#x3D; (V_2, \Sigma, R_2, S_2)$生成，其中$V_1$和$V_2$是非终结符集，$\Sigma$是终结符集，$R_1$和$R_2$是产生式规则，$S_1$和$S_2$是开始符号。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G &#x3D; (V, \Sigma, R, S)$，用来生成$L_1 \cdot L_2$。新的文法$G$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V &#x3D; V_1 \cup V_2 \cup {S}$，其中$S$是$L_1 \cdot L_2$的开始符号。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与$L_1$和$L_2$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R$包括以下规则：</p><ol><li>$S \to S_1 S_2$，其中$S_1$是$L_1$的开始符号，$S_2$是$L_2$的开始符号。</li><li>对于$G_1$中的每个产生式$A \to \alpha$，将其直接加入$R$。</li><li>对于$G_2$中的每个产生式$B \to \beta$，将其直接加入$R$。</li></ol></li><li><p><strong>开始符号</strong>：$S$是新的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L_1 \cdot L_2$：<br>通过新的文法$G$，我们可以生成$L_1 \cdot L_2$中的任意字符串。具体来说：</p><ul><li>如果$w &#x3D; w_1w_2$，其中$w_1 \in L_1$且$w_2 \in L_2$，那么：<ul><li>首先通过$S \to S_1 S_2$产生$w_1w_2$。</li><li>然后，$w_1$可以通过$S_1$的产生式根据$G_1$中的规则生成，$w_2$可以通过$S_2$的产生式根据$G_2$中的规则生成。</li></ul></li></ul><p>因此，$L_1 \cdot L_2$中的每个字符串都可以通过文法$G$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G$来生成$L_1 \cdot L_2$，并且文法$G$是上下文无关的（由$G_1$和$G_2$组合而成），因此$L_1 \cdot L_2$也是上下文无关语言。</p></li></ol><p>因此，CFL对于连接运算是封闭的。</p><hr><h4 id="4-7-4-闭包（Kleene-Star）封闭"><a href="#4-7-4-闭包（Kleene-Star）封闭" class="headerlink" title="4.7.4 闭包（Kleene Star）封闭"></a>4.7.4 闭包（Kleene Star）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），那么$L^*$（即$L$的闭包）也是上下文无关语言。</p><p>证明：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言。根据定义，$L$可以由一个上下文无关文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G^* &#x3D; (V^*, \Sigma, R^*, S^*)$，用来生成$L^*$。新的文法$G^*$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V^* &#x3D; V \cup \{S^* \}$，其中$S^*$是新的开始符号。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与$L$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R^*$包括以下规则：</p><ol><li>$S^* \to \epsilon \mid S S^*$，这里$\epsilon$表示空串，$S$是$L$的开始符号。</li><li>对于$G$中的每个产生式$A \to \alpha$，将其直接加入$R^*$。</li></ol></li><li><p><strong>开始符号</strong>：$S^*$是新的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L^*$：<br>通过新的文法$G^*$，我们可以生成$L^*$中的任意字符串。具体来说：</p><ul><li>如果$w \in L^*$，那么$w$可以分解为若干个$L$中字符串的串联，假设$w &#x3D; w_1w_2\cdots w_n$，其中每个$w_i \in L$。</li><li>首先通过$S^* \to S S^*$规则生成前缀$w_1w_2 \cdots w_{n-1}$。</li><li>然后通过$S^* \to \epsilon$规则生成空串，结束生成过程。</li><li>对于每个$w_i \in L$，根据$G$中的产生式生成$w_i$。</li></ul><p>因此，$L^*$中的每个字符串都可以通过文法$G^*$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G^*$来生成$L^*$，并且文法$G^*$是上下文无关的（由$G$和$S^*$的规则组合而成），因此$L^*$也是上下文无关语言。</p></li></ol><p>因此，CFL对于Kleene闭包运算是封闭的。</p><hr><h4 id="4-7-5-同态（Homomorphism）封闭"><a href="#4-7-5-同态（Homomorphism）封闭" class="headerlink" title="4.7.5 同态（Homomorphism）封闭"></a>4.7.5 同态（Homomorphism）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），并且$h$是一个同态映射，那么$h(L)$也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言，且$L$由文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。$h$是一个同态映射，它将语言$\Sigma$中的每个符号映射到语言$\Sigma’$中的某个字符串。</p></li><li><p><strong>定义同态映射</strong>：<br>同态映射$h$是一个函数，它将$\Sigma$中的每个符号映射为一个字符串，即对于每个符号$a \in \Sigma$，$h(a)$是一个字符串。为了简便起见，我们假设$h$将$\Sigma$中的每个符号映射为$\Sigma’$中的一个子串。</p></li><li><p><strong>构造新的文法</strong>：<br>我们将构造一个新的文法$G_h &#x3D; (V, \Sigma’, R_h, S_h)$来生成$h(L)$。新的文法$G_h$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V$，即与$L$相同的非终结符集。</p></li><li><p><strong>终结符集</strong>：$\Sigma’$，这是映射$h$后得到的新的终结符集。</p></li><li><p><strong>产生式规则集</strong>：$R_h$包括以下规则：</p><ol><li>对于$G$中的每个产生式$A \to \alpha$，我们将其替换为$A \to h(\alpha)$，其中$h(\alpha)$表示将$\alpha$中的每个符号通过$h$映射到新的符号串上。</li><li>如果$A \to a_1 a_2 \cdots a_n$是$G$中的某个产生式，则$A \to h(a_1) h(a_2) \cdots h(a_n)$是$G_h$中的相应产生式。</li></ol></li><li><p><strong>开始符号</strong>：$S_h &#x3D; S$，即$L$的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$h(L)$：<br>通过新的文法$G_h$，我们可以生成$h(L)$中的每个字符串。具体来说：</p><ul><li>假设$w &#x3D; w_1 w_2 \cdots w_n \in L$，其中每个$w_i \in \Sigma$。</li><li>通过$G$中的产生式规则，我们可以生成$w$。</li><li>在$G_h$中，$w$会被映射为$h(w_1) h(w_2) \cdots h(w_n)$，这正是$h(L)$中的一个字符串。</li></ul><p>因此，$h(L)$中的每个字符串都可以通过文法$G_h$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G_h$来生成$h(L)$，并且文法$G_h$是上下文无关的（它仅仅是对$G$进行符号替换），因此$h(L)$也是上下文无关语言。</p></li></ol><p>因此，CFL对于同态运算是封闭的。</p><hr><h4 id="4-7-6-逆同态（Inverse-Homomorphism）封闭"><a href="#4-7-6-逆同态（Inverse-Homomorphism）封闭" class="headerlink" title="4.7.6 逆同态（Inverse Homomorphism）封闭"></a>4.7.6 逆同态（Inverse Homomorphism）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），并且$h$是一个同态映射，那么$h^{-1}(L)$（即$L$的逆同态映射）也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言，且$L$由文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。$h$是一个同态映射，它将语言$\Sigma$中的每个符号映射到语言$\Sigma’$中的某个字符串。</p></li><li><p><strong>定义逆同态映射</strong>：<br>同态映射$h$将$\Sigma$中的每个符号映射为一个字符串，而逆同态映射$h^{-1}$将$\Sigma’$中的每个字符串反向映射到$\Sigma$中的符号集合。对于每个符号$a \in \Sigma$，$h(a)$是一个字符串，那么$h^{-1}(w)$将字符串$w$映射回其对应的符号集合。例如，如果$h(a) &#x3D; w$，那么$h^{-1}(w) &#x3D; a$。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G_{h^{-1}} &#x3D; (V, \Sigma, R_{h^{-1}}, S_{h^{-1}})$，用来生成$h^{-1}(L)$。新的文法$G_{h^{-1}}$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V$，即与$L$相同的非终结符集。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与原语言$L$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R_{h^{-1}}$包括以下规则：</p><ol><li>对于$G$中的每个产生式$A \to \alpha$，我们将其替换为$A \to h^{-1}(\alpha)$，其中$h^{-1}(\alpha)$表示将$\alpha$中的每个符号通过$h^{-1}$映射回符号集上的串。</li><li>对于$G$中的每个产生式$A \to a_1 a_2 \cdots a_n$，我们加入产生式$A \to h^{-1}(a_1) h^{-1}(a_2) \cdots h^{-1}(a_n)$。</li></ol></li><li><p><strong>开始符号</strong>：$S_{h^{-1}} &#x3D; S$，即$L$的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$h^{-1}(L)$：<br>通过新的文法$G_{h^{-1}}$，我们可以生成$h^{-1}(L)$中的每个字符串。具体来说：</p><ul><li>假设$w &#x3D; w_1 w_2 \cdots w_n \in L$，其中每个$w_i \in \Sigma$。</li><li>在$G$中，$w$可以通过产生式规则生成。</li><li>在$G_{h^{-1}}$中，通过将$w$中的每个符号$w_i$映射回原始符号，我们可以生成对应的字符串$h^{-1}(w_1) h^{-1}(w_2) \cdots h^{-1}(w_n)$。</li></ul><p>因此，$h^{-1}(L)$中的每个字符串都可以通过文法$G_{h^{-1}}$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G_{h^{-1}}$来生成$h^{-1}(L)$，并且文法$G_{h^{-1}}$是上下文无关的（它仅仅是对$G$进行符号替换），因此$h^{-1}(L)$也是上下文无关语言。</p></li></ol><p>因此，CFL对于逆同态运算是封闭的。</p><hr><h4 id="4-7-7-反转（Reversal）封闭"><a href="#4-7-7-反转（Reversal）封闭" class="headerlink" title="4.7.7 反转（Reversal）封闭"></a>4.7.7 反转（Reversal）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），那么$L^R$（即$L$的反转）也是上下文无关语言。</p><p>证明：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言，且$L$由文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。我们需要证明$L^R$（即$L$中所有字符串的反转）也是上下文无关语言。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G^R &#x3D; (V, \Sigma, R^R, S^R)$，用来生成$L^R$。新的文法$G^R$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V$，即与$L$相同的非终结符集。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与$L$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R^R$包括以下规则：</p><ol><li>对于$G$中的每个产生式$A \to \alpha$，将其替换为$A \to \alpha^R$，其中$\alpha^R$表示字符串$\alpha$的反转。</li><li>例如，如果$A \to a_1 a_2 \cdots a_n$是$G$中的产生式，那么$A \to a_n a_{n-1} \cdots a_1$是$G^R$中的对应产生式。</li></ol></li><li><p><strong>开始符号</strong>：$S^R &#x3D; S$，即$L$的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L^R$：<br>通过新的文法$G^R$，我们可以生成$L^R$中的每个字符串。具体来说：</p><ul><li>假设$w &#x3D; w_1 w_2 \cdots w_n \in L$，其中每个$w_i \in \Sigma$。</li><li>在$G$中，$w$可以通过产生式规则生成。</li><li>在$G^R$中，$w$将被反转为$w_n w_{n-1} \cdots w_1$，即$w$中的每个符号都会在生成过程中被反转。</li></ul><p>因此，$L^R$中的每个字符串都可以通过文法$G^R$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G^R$来生成$L^R$，并且文法$G^R$是上下文无关的（它仅仅是对$G$中的产生式规则进行了反转），因此$L^R$也是上下文无关语言。</p></li></ol><p>因此，CFL对于反转运算是封闭的。</p><h4 id="4-7-8-交（Intersection）不封闭"><a href="#4-7-8-交（Intersection）不封闭" class="headerlink" title="4.7.8 交（Intersection）不封闭"></a>4.7.8 交（Intersection）不封闭</h4><p>我们需要证明：上下文无关语言（CFL）对于交运算<strong>不封闭</strong>，即存在两个上下文无关语言$L_1$和$L_2$，使得它们的交集$L_1 \cap L_2$不是上下文无关语言。</p><p>证明：</p><ol><li><p>构造两个上下文无关语言$L_1$和$L_2$：<br>我们选择以下两个上下文无关语言：</p><ul><li>$L_1 &#x3D; \{a^n b^n c^n \mid n \geq 0\}$，这是一个标准的上下文无关语言，它表示由$a$、$b$、$c$组成的字符串，其中每种字符的数量相同。</li><li>$L_2 &#x3D; \{a^n b^m c^m \mid n \geq 0, m \geq 0\}$，这个语言包含任意数量的$a$，后面跟着相同数量的$b$，再后面跟着相同数量的$c$。</li></ul></li><li><p>求交集$L_1 \cap L_2$：<br>现在，我们来求$L_1$和$L_2$的交集：</p><ul><li>$L_1 \cap L_2 &#x3D; \{a^n b^n c^n \mid n \geq 0\} \cap \{a^n b^m c^m \mid n \geq 0, m \geq 0\}$。</li><li>交集的结果是$L_1 \cap L_2 &#x3D; \{a^n b^n c^n \mid n \geq 0\}$，即所有$ a $、$ b $和$ c $的数量都相同的字符串。</li></ul><p>这个语言$L_1 \cap L_2$其实就是$L_1$，即$\{a^n b^n c^n \mid n \geq 0\}$。</p></li><li><p><strong>$L_1 \cap L_2$是否是上下文无关语言</strong>：<br>我们知道，语言$L_1 &#x3D; {a^n b^n c^n \mid n \geq 0}$是<strong>非上下文无关</strong>的。原因是存在一个推理，可以证明使用上下文无关文法无法生成此语言：此问题可以通过泵引理等方法证明。</p><p>因此，$L_1 \cap L_2$并不是上下文无关语言。</p></li><li><p><strong>结论</strong>：<br>虽然$L_1$和$L_2$都是上下文无关语言，但它们的交集$L_1 \cap L_2 &#x3D; \{a^n b^n c^n \mid n \geq 0\}$不是上下文无关语言。因此，CFL对于交运算是不封闭的。</p></li></ol><h4 id="4-7-9-补（Complement）不封闭"><a href="#4-7-9-补（Complement）不封闭" class="headerlink" title="4.7.9 补（Complement）不封闭"></a>4.7.9 补（Complement）不封闭</h4><p>我们需要证明：上下文无关语言（CFL）对于补运算<strong>不封闭</strong>，即存在一个上下文无关语言$L$，使得$L$的补集$\overline{L}$不是上下文无关语言。</p><p>证明：</p><ol><li><p>构造上下文无关语言$L$：<br>我们选择一个已知的上下文无关语言$L$：</p><ul><li>$L &#x3D; \{a^n b^n c^n \mid n \geq 0\}$，这是一个标准的上下文无关语言，它表示由$a$、$b$、$c$组成的字符串，其中每种字符的数量相同。</li></ul></li><li><p>构造$L$的补集$\overline{L}$：<br>我们来求$L$的补集$\overline{L}$，即所有不属于$L$的字符串集合：</p><ul><li>$L &#x3D; \{a^n b^n c^n \mid n \geq 0\}$。</li><li>$\overline{L}$包含所有不是形如$a^n b^n c^n$的字符串。这意味着$\overline{L}$包含所有字符数量不相等或字符顺序不符合$a^n b^n c^n$模式的字符串。</li></ul></li><li><p><strong>证明$\overline{L}$不是上下文无关语言</strong>：<br>我们要证明$\overline{L}$不是上下文无关语言。考虑语言$L$中的字符串形态，它要求字符的数量严格匹配：$a$的数量、$b$的数量、$c$的数量相同。</p><ul><li><p>由于上下文无关文法无法在具有多个计数条件的语言中做出有效的限制（即无法处理像$a^n b^n c^n$这样的结构），$L$本身并不具备简单的反转特性。</p></li><li><p>如果我们通过推理$L$的补集，会发现它的复杂度远远超过了上下文无关文法能够处理的范围。换句话说，$\overline{L}$包含了非常多的字符串，其中一些字符串无法用上下文无关文法来生成。例如，如果字符数量不匹配或顺序不符合，文法的设计会变得非常复杂且不可处理。</p></li><li><p>我们这里可以用一个取巧的证明办法，根据德摩根律：$L_1 \cap L_2 &#x3D; \overline{\overline{L_1} \cup \overline{L_2}}$, 因为交运算不封闭，并运算封闭，那么我们可以推出补运算是不封闭的</p></li></ul></li><li><p><strong>结论</strong>：<br>虽然$L$是一个上下文无关语言，但它的补集$\overline{L}$不是上下文无关语言。因此，CFL对于补运算是不封闭的。</p></li></ol><h2 id="5-Pushdown-Automata"><a href="#5-Pushdown-Automata" class="headerlink" title="5. Pushdown Automata"></a>5. Pushdown Automata</h2><p>Pushdown Automata（PDA）是自动机的一种，它扩展了有限自动机（Finite Automaton, FA）的能力，引入了一个堆栈（Stack）作为额外的存储结构。PDA 特别适用于处理上下文无关语言（Context-Free Languages, CFLs），因为它能够在解析过程中记住之前的状态。</p><p>一个 Pushdown Automaton 可以通过五元组来表示：</p><p>$$PDA &#x3D; (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$$</p><p>其中：</p><ul><li>$Q$：状态集合，表示 PDA 的所有可能状态。</li><li>$\Sigma$：输入字母表（也叫终结符）。</li><li>$\Gamma$：堆栈字母表，表示堆栈中可能的符号。</li><li>$\delta$：转移函数，定义了 PDA 在特定状态下如何根据输入符号和堆栈顶部符号转移到新的状态，以及如何改变堆栈的内容。</li><li>$q_0$：初始状态，表示 PDA 开始的状态。</li><li>$Z_0$：堆栈初始符号，通常是一个特殊的符号，用于标记堆栈的底部。</li><li>$F$：接受状态的集合，PDA 只有进入一个接受状态时，才表示输入字符串被接受。</li></ul><p>PDA 的工作过程可以简单描述为以下步骤：</p><ol><li><p><strong>状态转移</strong>：PDA 根据当前状态、读取到的输入符号和堆栈顶部的符号来决定下一步的动作。PDA 的转移函数 $\delta$ 通常具有三个参数：</p><ul><li>当前状态 $q$。</li><li>当前输入符号 $a$，如果当前没有输入符号可读取，则为空（即 $\epsilon$）。</li><li>堆栈顶部符号 $X$，也可以是空的（即 $\epsilon$）。</li></ul><p>然后，PDA 会根据转移函数 $\delta$ 定义的规则来决定：</p><ul><li>转移到一个新状态。</li><li>改变堆栈的内容（压入或弹出符号）。</li></ul></li><li><p><strong>堆栈操作</strong>：堆栈是 PDA 的一个关键特性。它允许自动机记住状态信息，处理递归或嵌套结构（如括号匹配、算数表达式的解析等）。堆栈的操作包括：</p><ul><li><strong>Push</strong>：将一个符号压入堆栈。</li><li><strong>Pop</strong>：将堆栈顶部的符号弹出。</li><li><strong>No operation (NOP)</strong> ：不对堆栈进行任何操作。</li></ul></li><li><p><strong>接受条件</strong>：PDA 的接受有两种方式：</p><ul><li><strong>接受状态</strong>：当 PDA 进入一个接受状态 $q_f \in F$ 并且输入已经完全读取时，表示接受输入字符串。</li><li><strong>空堆栈</strong>：当 PDA 的堆栈为空且已经完全读取输入时，也可以接受输入字符串。</li></ul></li></ol><p>PDA 的重要特性是能够接受上下文无关语言。上下文无关语言（CFL）是指可以通过上下文无关文法（CFG）生成的语言。而 PDA 可以通过其堆栈的机制来模拟 CFG 生成语言的过程。</p><p>举一个简单的例子，考虑一个上下文无关文法生成的语言：</p><p>$$L &#x3D; \{ a^n b^n \mid n \geq 0 \}$$</p><p>这个语言由所有长度相等的由 $a$ 和 $b$ 组成的字符串组成。PDA 可以通过以下方式接受该语言：</p><ul><li>初始时，PDA 的堆栈为空。</li><li>每读取一个 $a$，PDA 就将一个符号（例如 $A$）压入堆栈。</li><li>每读取一个 $b$，PDA 就从堆栈中弹出一个符号。</li><li>如果堆栈最终为空，并且没有更多输入字符，则接受输入。</li></ul><p>考虑一个简单的 PDA 来接受语言 $L &#x3D; \{a^n b^n \mid n \geq 0 \}$：</p><ul><li>状态集合 $Q &#x3D; \{q_0, q_1, q_f\}$</li><li>输入字母表 $\Sigma &#x3D; \{a, b\}$</li><li>堆栈字母表 $\Gamma &#x3D; \{A, Z_0\}$（$Z_0$ 为堆栈底部符号）</li><li>初始状态 $q_0$</li><li>初始堆栈符号 $Z_0$</li><li>接受状态 $F &#x3D; \{q_f\}$</li><li>转移函数：<ul><li>$\delta(q_0, a, Z_0) &#x3D; (q_0, a Z_0)$（读取 $a$ 时，将 $a$ 压入堆栈）</li><li>$\delta(q_0, a, a) &#x3D; (q_0, aa)$（读取 $a$ 时，将 $a$ 压入堆栈）</li><li>$\delta(q_0, b, a) &#x3D; (q_1, \epsilon)$（读取 $b$ 时，从堆栈弹出 $a$）</li><li>$\delta(q_1, b, a) &#x3D; (q_1, \epsilon)$（读取 $b$ 时，从堆栈弹出 $a$）</li><li>$\delta(q_1, \epsilon, Z_0) &#x3D; (q_f, Z_0)$（当堆栈为空时，进入接受状态）</li></ul></li></ul><center><img src="/img/FL/pda.svg" alt="PDA状态转移" style="max-width: 100%; height: auto;" /></center><p>Pushdown Automaton（PDA）是一种能够处理上下文无关语言的计算模型，它通过引入堆栈这一额外存储结构来增强有限自动机的能力。PDA 的应用广泛，包括编译器中的语法分析、程序解析以及一些递归语言的处理。它可以分为确定性 PDA（DPDA）和非确定性 PDA（NPDA），其中非确定性 PDA 是最强大的，能够处理所有的上下文无关语言。</p><hr><h3 id="5-1-PDA的状态转移"><a href="#5-1-PDA的状态转移" class="headerlink" title="5.1 PDA的状态转移"></a>5.1 PDA的状态转移</h3><p>PDA 的状态转移函数 <strong>δ</strong> 描述了在特定的输入符号和栈顶符号下，PDA 会如何进行状态转移，以及是否需要对栈进行操作。它可以表示为：<br>$$<br>\delta(q, a, X) &#x3D; \{(p, \gamma)\}<br>$$<br>其中：</p><ul><li>$q$ 是当前状态。</li><li>$a$ 是当前的输入符号（如果为空，则是ε，表示没有输入）。</li><li>$X$ 是栈顶符号。</li><li>$p$ 是转移后的状态。</li><li>$\gamma$是栈操作，表示栈顶符号 <strong>X</strong> 被替换为字符串 $\gamma$（也可以是空字符串，表示栈顶符号被弹出）。</li></ul><p>PDA 的状态转移不仅可以改变自动机的状态，还可以对栈进行操作。栈操作有以下几种形式：</p><ul><li><strong>推入（Push）</strong>：将一个符号压入栈中。</li><li><strong>弹出（Pop）</strong>：从栈顶移除一个符号。</li><li><strong>保持不变</strong>：栈顶符号不发生变化。</li></ul><p>例如，假设当前的状态为 <strong>q₀</strong>，栈顶符号为 <strong>X</strong>，输入符号为 <strong>a</strong>，PDA 的状态转移规则可能是：</p><ul><li>$\delta(q₀, a, X) &#x3D; \{(q₁, YX)\}$，表示如果处于状态 <strong>q₀</strong>，读入符号 <strong>a</strong>，栈顶为 <strong>X</strong>，那么自动机转移到状态 <strong>q₁</strong>，并将 <strong>Y</strong> 压入栈顶，原有的 <strong>X</strong> 保留在栈中。</li><li>$\delta(q₀, \epsilon, X) &#x3D; \{(q₁, \epsilon)\}$，表示如果当前没有输入符号（<strong>ε</strong>），且栈顶是 <strong>X</strong>，自动机转移到状态 <strong>q₁</strong>，并弹出栈顶的符号 <strong>X</strong>。</li></ul><p>假设我们有一个 PDA，它的任务是接受语言 $L &#x3D; \{a^n b^n | n \geq 0\}$（即由相同数量的 <strong>a</strong> 和 <strong>b</strong> 组成的字符串）。该 PDA 可以通过以下状态转移来工作：</p><ol><li>初始状态 <strong>q₀</strong>，栈为空，读取到 <strong>a</strong> 时，PDA 将 <strong>a</strong> 推入栈中。</li><li>当 PDA 读取到 <strong>b</strong> 时，它会与栈顶的 <strong>a</strong> 配对，弹出一个 <strong>a</strong>。</li><li>如果字符串中的 <strong>a</strong> 和 <strong>b</strong> 数量相等，栈会空，自动机转到接受状态 <strong>q₁</strong>。</li></ol><p>具体的转移规则可能是：</p><ul><li>$\delta(q₀, a, \epsilon) &#x3D; \{(q₀, a)\}$，即在状态 <strong>q₀</strong>，读取 <strong>a</strong>，将 <strong>a</strong> 压入栈中。</li><li>$\delta(q₀, b, a) &#x3D; \{(q₀, \epsilon)\}$，即在状态 <strong>q₀</strong>，读取 <strong>b</strong>，弹出栈顶的 <strong>a</strong>。</li><li>$\delta(q₀, \epsilon, \epsilon) &#x3D; \{(q₁, \epsilon)\}$，当输入读完且栈为空时，转移到接受状态 <strong>q₁</strong>。</li></ul><p>通过这种方式，PDA 使用栈来“记住”输入中的 <strong>a</strong>，并在读取到 <strong>b</strong> 时进行配对，从而确保 <strong>a</strong> 和 <strong>b</strong> 的数量相等。</p><p>PDA 的状态转移是由当前状态、输入符号和栈顶符号决定的，它允许自动机在每个转移步骤中操作栈，进而能够处理更复杂的语言，如上下文无关语言。通过推入和弹出栈顶符号，PDA 可以模拟许多计算过程，例如平衡括号或匹配括号对等任务。</p><hr><h3 id="5-2-下推自动机接受的语言"><a href="#5-2-下推自动机接受的语言" class="headerlink" title="5.2 下推自动机接受的语言"></a>5.2 下推自动机接受的语言</h3><p><strong>下推自动机</strong>（PDA, Pushdown Automaton）可以通过两种方式来接受语言：<strong>以终态</strong>（final state）接受和<strong>以空栈</strong>（empty stack）接受。</p><p><strong>以终态方式接受的语言</strong></p><p>当 PDA 使用<strong>终态</strong>接受语言时，它通过进入某个特定的终态来判断输入是否被接受。具体来说，如果 PDA 在输入字符串完全读取完毕后，进入了某个 <strong>接受状态</strong>（或终态），那么这个字符串就被认为是被 PDA 接受的。</p><ul><li>输入字符串通过 PDA 的状态转移函数进行处理。</li><li>当输入字符串的所有符号都被读取完毕，PDA 必须进入某个 <strong>接受状态</strong>（或终态）。如果 PDA 达到了这个接受状态，并且已经没有更多的输入符号，那么该字符串就被认为是被接受的。</li></ul><p>这种接受方式类似于有限自动机（DFA 或 NFA），唯一的不同之处在于 PDA 在计算过程中使用了栈来存储中间信息，而不仅仅依赖状态来进行转移。</p><p>假设我们有一个 PDA，任务是接受语言 $L &#x3D; \{ a^n b^n | n \geq 0 \}$。该 PDA 的工作方式可能是：</p><ol><li>在状态 $q_0$，当读取到 $a$ 时，将 $a$ 压入栈。</li><li>当读取到 $b$ 时，弹出一个 $a$。</li><li>输入完全读完，并且 PDA 进入了终态 $q_1$，如果栈为空（所有 $a$ 都已经被匹配），则接受这个字符串。</li></ol><p><strong>以空栈方式接受的语言</strong></p><p>当 PDA 使用<strong>空栈</strong>方式来接受语言时，它并不依赖于终态的存在，而是依赖于栈的状态来判断输入是否被接受。具体来说，输入字符串被接受的条件是，当输入字符串完全读取完毕时，PDA 的栈必须为空。</p><ul><li>在读取输入字符串的过程中，PDA 根据当前输入符号和栈顶符号来进行状态转移。</li><li>当输入字符串完全读取完毕后，PDA 不要求进入特定的接受状态，而是检查栈是否为空。如果栈为空，则认为该字符串被接受。</li></ul><p>使用空栈方式的优点在于它能够仅依赖栈的内容来判断语言是否符合某种规则，而不必考虑终态的存在。</p><p>假设我们有一个 PDA，任务是接受语言 $L &#x3D; \{ a^n b^n | n \geq 0 \}$，此时 PDA 以空栈方式接受。可能的状态转移如下：</p><ol><li>在状态 $q_0$，当读取到 $a$ 时，将 $a$ 压入栈。</li><li>当读取到 $b$ 时，弹出栈顶的 $a$。</li><li>输入字符串读完后，栈应该为空。如果栈为空，则接受该字符串。</li></ol><p>这种方法没有要求 PDA 进入一个特定的接受状态，而仅仅依赖栈的状态来判断输入是否被接受。</p><p><strong>以终态方式接受 vs. 以空栈方式接受</strong></p><ul><li><strong>接受条件</strong>：以终态方式接受时，PDA 需要进入某个特定的接受状态；而以空栈方式接受时，PDA 需要栈为空。</li><li><strong>栈的作用</strong>：无论是终态方式还是空栈方式，栈都用来存储中间信息，以便处理更复杂的语言。不同的是，终态方式可能在栈中保留数据，而空栈方式则强调栈最终必须为空。</li></ul><p><strong>两种接受方式的差异：</strong></p><ul><li><strong>终态接受的语言</strong>：通常来说，终态接受的语言可以通过转换成一个<strong>有穷状态机</strong>（比如 NFA 或 DFA）来描述，尽管下推自动机在转换过程中使用了栈。</li><li><strong>空栈接受的语言</strong>：如果一个语言可以由一个 PDA 使用空栈方式接受，那么这个语言是<strong>上下文无关语言</strong>（CFL, Context-Free Language）。上下文无关语言在形式语言与自动机理论中是 PDA 的经典应用之一。</li></ul><p>实际上，这两种接受方式并不等价：</p><ul><li><strong>空栈接受的语言</strong>：比终态接受的语言的表达能力更强，因为空栈接受的 PDA 可以模拟上下文无关文法（CFG）来生成语言。</li><li><strong>终态接受的语言</strong>：虽然也可以描述某些上下文无关语言，但它通常只能描述一些较为简单的上下文无关语言，或者是某些有限的模式。</li></ul><p>通常，空栈接受方式更为常见和强大，因为它能直接描述<strong>上下文无关语言</strong>，而终态接受方式则较为有限。</p><div class="note note-success">            <p>结论：如果PDA $P_N$以空栈方式接受语言$L$，那么一定存在PDA $P_F$以终态方式接受$L$</p>          </div><hr><h3 id="5-3-PDA与CFG的等价性证明"><a href="#5-3-PDA与CFG的等价性证明" class="headerlink" title="5.3 PDA与CFG的等价性证明"></a>5.3 PDA与CFG的等价性证明</h3><p>在形式语言与自动机理论中，<strong>PDA</strong>（下推自动机，Pushdown Automaton）和 <strong>CFG</strong>（上下文无关文法，Context-Free Grammar）是紧密相关的，事实上，它们是等价的。也就是说，<strong>对于每一个上下文无关语言，都可以存在一个 PDA 来接受它，同时对于每一个 PDA 接受的语言，都可以构造出一个上下文无关文法</strong>。</p><p>这意味着，我们可以通过下推自动机和上下文无关文法之间的转换来证明它们的等价性。下面我将详细讲解 PDA 和 CFG 的等价性证明，主要分为两个部分：</p><ol><li><strong>PDA 和 CFG 等价性证明：从 PDA 到 CFG 的构造</strong></li><li><strong>PDA 和 CFG 等价性证明：从 CFG 到 PDA 的构造</strong></li></ol><hr><p><strong>从 PDA 到 CFG 的构造</strong></p><p>假设我们有一个 PDA，它接受某个上下文无关语言 $L$。我们需要构造一个上下文无关文法 $G$，使得 $G$ 生成的语言就是 $L$。下面是构造的基本思路。</p><ol><li><p><strong>构建一个文法的非终结符</strong>：文法的非终结符是由 PDA 的状态和栈符号构成的。具体来说，文法中的每个非终结符都表示 PDA 在某一状态下，通过一系列的栈操作可以推导出某种字符串。</p><p>假设 PDA 的状态集合为 $Q$，栈字母表为 $\Gamma$，则文法中的非终结符通常是形式为 $[q, X]$ 的符号，其中：</p><ul><li>$q \in Q$，表示 PDA 的一个状态。</li><li>$X \in \Gamma$，表示栈上的一个符号。</li></ul></li><li><p><strong>文法的产生式</strong>：文法的产生式是根据 PDA 的转移函数来构造的。PDA 的转移函数通常表示为 $\delta(q, a, X) &#x3D; { (p, \gamma) }$，其中：</p><ul><li>$q$ 和 $p$ 是 PDA 的状态。</li><li>$a$ 是输入符号。</li><li>$X$ 是栈顶符号。</li><li>$\gamma$ 是栈操作，可以是栈符号的一个串，表示将栈顶的 $X$ 替换为字符串 $\gamma$。</li></ul><p>对应的文法产生式有两种类型：</p><ol><li><p><strong>通过栈操作推出字符串</strong>：</p><ul><li>如果 $\delta(q, a, X) &#x3D; \{ (p, \gamma) \}$，则可以有一个产生式：<br>$$ [q, X] \rightarrow a[p, \gamma] $$<br>这表示在状态 $q$，读取符号 $a$，栈顶是符号 $X$ 时，可以推导出字符串 $a$，然后转移到状态 $p$，栈操作替换成 $\gamma$</li></ul></li><li><p><strong>通过状态转移推导空符号</strong>：</p><ul><li>如果有一个 $\delta(q, \epsilon, X) &#x3D; \{(p, \epsilon)\}$，表示没有输入符号并且弹出栈顶符号 $X$，则产生式为：<br>$$ [q, X] \rightarrow [p, \epsilon] $$<br>这表示在状态 $q$ 时，栈顶符号为 $X$，并且没有读取任何输入符号，可以通过弹出栈顶符号，转移到状态 $p$。</li></ul></li></ol></li><li><p><strong>文法的开始符号</strong>：文法的开始符号通常由 PDA 的初始状态和栈初始符号组成。例如，如果 PDA 的初始状态是 $q_0$，栈的初始符号是 $Z_0$，则文法的开始符号为 $[q_0, Z_0]$。</p></li></ol><p>通过上述步骤，我们可以为每个 PDA 构造出一个等价的上下文无关文法 $G$，使得 $L(G)$ 等于 PDA 所接受的语言 $L(PDA)$。</p><hr><p><strong>从 CFG 到 PDA 的构造</strong></p><p>接下来，我们要证明对于每一个上下文无关文法 $G$，都可以构造出一个等价的 PDA 来接受由该文法生成的语言。构造过程的基本思路是模拟文法的推导过程。</p><p><strong>构造 PDA 的基本思路：</strong></p><ol><li><p><strong>PDA 的状态集合</strong>：PDA 的状态集合包含两个状态：一个是初始状态 $q_0$，另一个是接受状态 $q_1$。</p></li><li><p><strong>栈操作的设计</strong>：栈用于模拟文法的推导过程。在文法中，每个非终结符都有一个产生式，而在 PDA 中，栈顶符号将被替换成对应的右侧部分。具体来说，当 PDA 读取输入符号时，它会根据当前栈顶符号（非终结符或终结符）和当前输入符号执行相应的栈操作。</p><ul><li><strong>对于终结符</strong>：当 PDA 遇到一个终结符（比如文法的终结符 $a$）时，它会检查栈顶是否是该终结符。如果是，则弹出该符号并读取下一个输入符号。</li><li><strong>对于非终结符</strong>：当 PDA 遇到一个非终结符（比如文法的非终结符 $A$），它会将栈顶的 $A$ 替换为该非终结符的右侧产生式。</li></ul></li><li><p><strong>PDA 的状态转移</strong>：</p><ul><li><strong>读取终结符</strong>：当 PDA 遇到输入符号 $a$，栈顶为 $a$ 时，执行操作：弹出 $a$，读取下一个输入符号。</li><li><strong>应用产生式</strong>：当 PDA 遇到栈顶是非终结符 $A$ 时，选择文法中的某个产生式 $A \rightarrow \alpha$，并将 $\alpha$ 推入栈中。</li></ul></li><li><p><strong>PDA 的接受条件</strong>：PDA 在输入字符串被完全读取完毕后，如果栈为空，则接受该字符串。</p></li></ol><p>根据上述过程，我们可以为每个上下文无关文法 $G$ 构造一个等价的 PDA，使得 PDA 接受的语言恰好是 $L(G)$，即文法 $G$ 生成的语言。</p><p>通过从 PDA 到 CFG 的构造，我们可以证明每个 PDA 接受的语言是上下文无关语言。而通过从 CFG 到 PDA 的构造，我们可以证明每个上下文无关语言都可以被某个 PDA 接受。这样，我们就证明了 PDA 和 CFG 在语言的接受能力上是等价的。换句话说，它们都可以接受<strong>所有的上下文无关语言</strong>。</p><hr><h3 id="5-4-DPDA"><a href="#5-4-DPDA" class="headerlink" title="5.4 DPDA"></a>5.4 DPDA</h3><p><strong>DPDA</strong>（Deterministic Pushdown Automaton，确定性下推自动机）是下推自动机（PDA）的一种特殊类型。与普通的 PDA 不同，DPDA 的转移是<strong>确定性的</strong>，即在任何给定的时刻，状态和栈顶符号以及当前输入符号的组合只能导致一个确定的转移。这个特性使得 DPDA 相较于一般的 PDA 更加有限，并且在一些语言的接受能力上有所限制。</p><p><strong>DPDA 与 PDA 的区别：</strong></p><p>普通的 PDA 在处理状态转移时，可能存在多个可行的转移路径，这通常是因为在同一状态下、相同输入符号和栈顶符号的条件下，PDA 可以选择不同的栈操作（推入不同的栈符号或弹出栈符号）。这使得 PDA 是<strong>非确定性的</strong>。</p><p>而在 <strong>DPDA</strong> 中，给定一个输入符号、当前状态和栈顶符号的组合时，转移是唯一的，只有一种可能的状态和栈变换。这种确定性意味着在任何时刻，DPDA 都只能做出一个明确的选择，因此称为<strong>确定性下推自动机</strong>。</p><p>DPDA 是 PDA 的一种特殊类型，其定义如下：</p><ul><li><p><strong>状态集合</strong> $Q$：有限的状态集合。</p></li><li><p><strong>输入字母表</strong> $\Sigma$：有限的输入符号集。</p></li><li><p><strong>栈字母表</strong> $\Gamma$：有限的栈符号集。</p></li><li><p><strong>转移函数</strong> $\delta$：转移函数 $\delta(q, a, X)$，其中 $q$ 是当前状态，$a$ 是当前输入符号（可以是空符号 $\epsilon$），$X$ 是栈顶符号。与普通 PDA 不同，<strong>对于每对 ($q, a, X$)，$\delta$ 中最多只有一个转移</strong>，这使得它是确定性的。</p><p>$\delta: Q \times (\Sigma \cup {\epsilon}) \times \Gamma \rightarrow Q \times \Gamma^*$，意味着从某个状态 $q$，读取输入符号 $a$ 和栈顶符号 $X$，转移到新的状态并且修改栈的内容。</p></li><li><p><strong>初始状态</strong> $q_0$：自动机的起始状态。</p></li><li><p><strong>初始栈符号</strong> $Z_0$：栈的初始符号。</p></li><li><p><strong>接受状态</strong> $F$：一个接受状态的集合，可以是空集（即仅以栈为空来接受）。</p></li></ul><p>DPDA 在读取输入符号的过程中，遵循以下步骤：</p><ol><li><p><strong>读取输入</strong>：从输入字符串中逐个读取字符。</p></li><li><p><strong>栈操作</strong>：</p><ul><li><strong>推入栈</strong>：在某些转移中，DPDA 会将符号压入栈。</li><li><strong>弹出栈</strong>：在其他转移中，DPDA 会从栈顶弹出符号。</li><li><strong>不操作</strong>：在某些情况下，DPDA 会保持栈不变。</li></ul><p>DPDA 的关键特点是，在每次状态转移时，必须有一个唯一的选择，不允许有多个转移选项。</p></li><li><p><strong>接受条件</strong>：</p><ul><li><strong>终止状态</strong>：如果 DPDA 在读取完所有输入符号后进入某个接受状态（$q \in F$），那么该字符串被接受。</li><li><strong>空栈接受</strong>：如果 DPDA 在读取完所有输入符号后栈为空（即栈没有任何符号），则该字符串也被接受。</li></ul></li></ol><p>DPDA 能够接受的语言是<strong>确定性上下文无关语言</strong>（D-CFLs）。这些语言是上下文无关语言的一个子集，限制了语言的结构，使得它们可以被确定性下推自动机处理。虽然 PDA 可以接受所有上下文无关语言（CFLs），但 DPDA 只能接受其中的一部分。</p><p><strong>确定性上下文无关语言</strong>相比一般的上下文无关语言有更严格的结构要求。例如，DPDA 无法处理某些语言，这些语言是上下文无关的，但由于其结构复杂（例如，需要“回溯”或存在“多重选择”），无法通过确定性方式来接受。</p><hr><p>举个例子：</p><ul><li><p>语言 $L &#x3D; \{ a^n b^n | n \geq 0 \}$ 是一个典型的上下文无关语言，它可以被 DPDA 接受。DPDA 可以通过以下方式处理：</p><ol><li>在栈中推入 $a$。</li><li>遇到 $b$ 时弹出栈中的 $a$，并继续。</li><li>输入完全结束时，如果栈为空，则接受该字符串。</li></ol></li><li><p>语言 $L &#x3D; \{ a^n b^n c^n | n \geq 0 \}$ 是一个上下文无关语言，但它不能被任何 DPDA 接受，因为它需要同时处理 $a$、$b$ 和 $c$ 的数量，这要求下推自动机能够在不同的符号之间进行回溯选择，而 DPDA 无法做到这一点。</p></li></ul><table><thead><tr><th>特性</th><th>PDA（下推自动机）</th><th>DPDA（确定性下推自动机）</th></tr></thead><tbody><tr><td><strong>确定性</strong></td><td>非确定性</td><td>确定性</td></tr><tr><td><strong>语言类型</strong></td><td>上下文无关语言（CFL）</td><td>确定性上下文无关语言（D-CFL）</td></tr><tr><td><strong>转移函数</strong></td><td>可能有多个转移</td><td>对每一组合，最多只有一个转移</td></tr><tr><td><strong>栈操作</strong></td><td>可以有多个栈操作</td><td>对每一输入符号和栈顶符号，栈操作唯一</td></tr><tr><td><strong>接受条件</strong></td><td>终态接受、空栈接受</td><td>终态接受、空栈接受</td></tr></tbody></table><hr><h3 id="5-5-正则语言与DPDA"><a href="#5-5-正则语言与DPDA" class="headerlink" title="5.5 正则语言与DPDA"></a>5.5 正则语言与DPDA</h3><ul><li><p><strong>正则语言</strong>（Regular Languages）是最简单的语言类别，可以通过有限自动机（DFA 或 NFA）来接受，也可以通过正则表达式来描述。正则语言的特点是它们的结构非常简单，不需要栈来存储额外的信息，自动机可以在处理时通过状态转移来完成任务。</p></li><li><p><strong>上下文无关语言</strong>（Context-Free Languages，简称 CFLs）是比正则语言更复杂的语言类别。它们可以通过上下文无关文法（CFG）来定义，并且通常需要栈来存储和操作语法信息。上下文无关语言的典型代表就是编程语言中的语法结构，如表达式解析、函数调用等。</p></li><li><p><strong>DPDA</strong>（Deterministic Pushdown Automaton，确定性下推自动机）是一种具有栈的自动机，用于接受上下文无关语言。DPDA 是 PDA（下推自动机）的一种特殊形式，区别在于 DPDA 的转移是<strong>确定性的</strong>，即在每一个状态和栈顶符号以及输入符号的组合下，DPDA 的行为是唯一的。</p></li></ul><p>正则语言比上下文无关语言简单，通常不需要栈来处理。例如，正则语言可以通过 DFA 或 NFA 来接受，利用有限的状态和简单的转移规则即可完成。</p><ul><li><strong>正则语言</strong> 是上下文无关语言的子集，这意味着每个正则语言都可以是上下文无关的。</li><li>因为 <strong>DPDA</strong> 用来接受上下文无关语言，所以它能够接受所有的正则语言。实际上，正则语言的结构不需要栈，因此我们可以认为 <strong>DPDA</strong> 接受正则语言时，栈是“过度”的，它实际上不需要使用栈来完成这个任务。</li></ul><p><strong>为什么 DPDA 可以接受正则语言？</strong></p><ul><li><strong>有限自动机</strong>（DFA 和 NFA）是最简单的自动机，它们仅使用状态来处理输入，而不需要栈。这些自动机能够接受正则语言。</li><li><strong>DPDA</strong> 比 DFA 更强大，因为它有栈可以使用。然而，对于正则语言来说，栈并没有实际的用途。DPDA 在接受正则语言时，仅仅依赖状态转移，而栈并没有被利用。因此，虽然正则语言可以被 DFA 接受，DPDA 也能接受它们，但 <strong>DPDA 是过度使用栈的</strong>，因为它实际上不需要栈的帮助。</li></ul><p>总结：所有的 <strong>正则语言</strong> 都可以通过 <strong>DPDA</strong> 接受。对于正则语言来说，DPDA 不必使用栈，DPDA 是一种比 DFA 更强的模型，但它的栈功能在正则语言中是多余的。</p><p><strong>DPDA 的限制</strong></p><p>虽然 DPDA 可以接受 <strong>确定性上下文无关语言</strong>，但它的能力比一般的 PDA 强度要小。一个普通的 PDA 可以接受 <strong>所有的上下文无关语言</strong>（CFLs），而 DPDA 只能接受其中的一部分，通常是那些 <strong>结构较为简单且具有确定性的</strong> 上下文无关语言。某些上下文无关语言，由于它们的结构过于复杂，DPDA 无法接受。</p><ul><li><strong>正则语言</strong> 是 <strong>最简单</strong> 的语言，可以通过 <strong>有限自动机（DFA）</strong> 来接受。由于正则语言的简单性，<strong>DPDA</strong> 可以接受这些语言，但它的栈功能并没有被实际利用。</li><li><strong>DPDA</strong> 能接受 <strong>所有正则语言</strong>，但它的能力不仅仅局限于此，DPDA 可以接受一些更复杂的语言——<strong>确定性上下文无关语言</strong>（D-CFLs）。</li><li><strong>DPDA</strong> 不能接受 <strong>所有的上下文无关语言</strong>，它只能接受 <strong>确定性上下文无关语言</strong>。对于那些复杂的上下文无关语言，特别是需要非确定性栈操作的语言，DPDA 无法接受。</li></ul><p><strong>总结</strong>：正则语言可以被 <strong>DPDA</strong> 接受，因为正则语言的结构不需要栈，DPDA 的能力足以接受正则语言。然而，DPDA 并不只接受正则语言，它也可以接受一些更复杂的语言，但它的能力是有局限的，不能接受所有的上下文无关语言。</p><hr><h3 id="5-6-语言类的关系"><a href="#5-6-语言类的关系" class="headerlink" title="5.6 语言类的关系"></a>5.6 语言类的关系</h3><p><strong>全语言（Recursively Enumerable Languages，RE）</strong>，也叫做 <strong>递归可枚举语言（RE）</strong>，是形式语言理论中的一个非常宽泛的类别，几乎包含了所有可以被某种计算模型识别的语言。它是语言类中最广泛的一类。全语言包含了所有可以被 <strong>图灵机</strong> 识别的语言。（后面章节讲解）</p><p>在形式语言的分类中，语言类之间的关系可以通过包含关系来描述。具体来说：</p><ul><li><strong>正则语言（Regular Languages）</strong> 是最简单的语言类，所有正则语言都是上下文无关语言（CFL）的子集。正则语言不能表示复杂的嵌套结构。</li><li><strong>上下文无关语言（CFL）</strong> 比正则语言更复杂，可以表示更多的语言结构。</li><li><strong>确定性上下文无关语言（DCFL）</strong> 是上下文无关语言的一个子集。并非所有上下文无关语言都是确定性上下文无关语言。</li><li><strong>全语言（RE）</strong> 是最广泛的语言类，包含了所有可以由图灵机识别的语言。它包含了上下文无关语言、正则语言等，但并不要求这些语言能够被判定。</li></ul><table><thead><tr><th>语言类别</th><th>特征</th><th>示例</th></tr></thead><tbody><tr><td><strong>全语言（RE）</strong></td><td>包含所有递归可枚举语言，可以被图灵机识别，但不一定是可判定的。</td><td>所有能够通过图灵机识别的语言。</td></tr><tr><td><strong>上下文无关语言（CFL）</strong></td><td>可以由上下文无关文法（CFG）生成，可以通过 PDA 识别。</td><td>括号匹配，$a^n b^n$， $S \to aSb | \varepsilon$</td></tr><tr><td><strong>确定性上下文无关语言（DCFL）</strong></td><td>可以由确定性下推自动机（DPDA）识别，是 CFL 的子集。</td><td>$a^n b^n$，$a^n b^n c^n$（非确定性上下文无关语言）</td></tr><tr><td><strong>正则语言（Regular Languages）</strong></td><td>可以由有限自动机（DFA 或 NFA）识别，最简单的语言。</td><td>$a^n b^n$，正则表达式 $a^* b^*$</td></tr></tbody></table><ul><li><strong>正则语言</strong> 是 <strong>最简单</strong> 的语言，可以通过 <strong>有限自动机（DFA）</strong> 来接受。由于正则语言的简单性，<strong>DPDA</strong> 可以接受这些语言，但它的栈功能并没有被实际利用。</li><li><strong>上下文无关语言</strong> 比正则语言更复杂，可以表示更多的语言结构。</li><li><strong>确定性上下文无关语言</strong> 是上下文无关语言的一部分，它们比一般的上下文无关语言更容易处理。</li><li><strong>全语言</strong> 是最广泛的语言类，包含了所有可以由图灵机识别的语言。</li></ul><center><img src="/img/FL/relation.svg" alt="语言类之间的关系" style="max-width: 100%; height: auto;" /></center><h2 id="6-图灵机（Turing-Machine）"><a href="#6-图灵机（Turing-Machine）" class="headerlink" title="6. 图灵机（Turing Machine）"></a>6. 图灵机（Turing Machine）</h2><p>图灵机是由数学家艾伦·图灵（Alan Turing）于1936年提出的一个理论计算模型，旨在为“可计算性”提供一个精确的定义。图灵机本质上是一个抽象的机器，用来模拟任何形式的计算过程。它由以下几个部分组成：</p><ol><li><p><strong>无限长的带子</strong>：带子被分为一格一格，每个格子可以存储一个符号，符号来自一个有限的字母表。带子可以在左右两个方向上移动，并且可以反复读取和修改。</p></li><li><p><strong>读&#x2F;写头</strong>：在带子上移动并读取符号，或者写入符号。读写头每次只能操作一个格子。</p></li><li><p><strong>状态控制器</strong>：图灵机有一个有限的状态集，其中包括一个初始状态、若干个中间状态和一个或多个接受状态（终止状态）。每个状态都可能有不同的行为，包括：读取当前格子的符号，写入新符号，移动带子，或者转到下一个状态。</p></li><li><p><strong>转移函数</strong>：定义了图灵机的行为。它规定了在某个状态下，根据当前读取的符号，图灵机应当写入什么符号，移动到哪个方向，并转移到哪个状态。</p></li></ol><p>图灵机的计算过程是通过状态控制器与带子上符号的交互来进行的。如果图灵机在某个状态下停下来且没有任何进一步的规则，或者进入一个终止状态，则计算结束。</p><p>图灵机是计算理论中的核心工具，它定义了“可计算性”的概念。图灵机不仅可以模拟任何形式的计算过程，也可以用来定义不同类型的语言（如正规语言、上下文无关语言、递归可枚举语言等）。以下是一些图灵机与其他语言之间的关系：</p><ol><li><p><strong>正规语言（Regular Languages）</strong>：正规语言可以由有限自动机（DFA&#x2F;NFA）识别，而图灵机能够识别更广泛的语言。事实上，所有正规语言都可以通过图灵机识别，但并非所有图灵机能识别的语言都是正规语言。</p></li><li><p><strong>上下文无关语言（Context-Free Languages, CFLs）</strong>：上下文无关语言可以由上下文无关文法生成，而图灵机的能力远超上下文无关文法。每个上下文无关语言都可以由图灵机识别，但图灵机可以识别更多类型的语言，包括无法由上下文无关文法生成的语言。</p></li><li><p><strong>递归可枚举语言（Recursively Enumerable Languages）</strong>：这些是所有可以被图灵机识别的语言。图灵机不仅能识别这些语言，还能生成它们的所有字符串，但不能保证总是能在有限的时间内做出决定。递归可枚举语言的一个例子是图灵机的输出语言。</p></li><li><p><strong>递归语言（Recursive Languages）</strong>：递归语言是那些能够由图灵机在有限时间内决定的语言。这些语言不仅可以被图灵机识别，还可以保证图灵机总是在有限时间内做出决定，即图灵机总是停机。</p></li></ol><p>图灵机是计算理论中的核心概念，它是一种抽象的计算模型，用来定义“可计算性”。它的强大之处在于能够识别递归可枚举语言，而在更小的类别中（如正规语言、上下文无关语言）有专门的机器来识别。图灵机的理论研究帮助我们理解了哪些问题是可以计算的，哪些是不可计算的。</p><h2 id="7-偷偷说"><a href="#7-偷偷说" class="headerlink" title="7. 偷偷说"></a>7. 偷偷说</h2><p>费了很大力气，终于把形式语言与自动机这门课的内容更完了。这门课的笔记的字数竟然超过了操作系统😂我觉得自动机的学习还是在关注几个模型上面还有正则语言和上下文无关语言性质的理解上。刷题的话，还是从九州大学的自动机过去问开始入手是最合适的，当然Sisper的课后书的例题也非常值得去做。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Formal Language and Automata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating System</title>
    <link href="/2024/12/11/Operation-System/"/>
    <url>/2024/12/11/Operation-System/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><p>This is for test takers to quickly review Operating System. Credit to 《Operating System, 9th Edition》。操作系统的知识看起来非常得杂乱无章，需要重点关注任务调度算法，内存管理分配算法，以及地址变换机制。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-Introduction-to-Operating-System"><a href="#1-Introduction-to-Operating-System" class="headerlink" title="1. Introduction to Operating System"></a>1. Introduction to Operating System</h2><p>计算机系统可以划分为<strong>4个</strong>主要组件：</p><ol><li><p>硬件(hardware)：指的是物理设备，包括计算机的处理器、内存、硬盘、输入输出设备等。硬件如中央处理单元(CPU)、内存(memory)、输入输出设备(I&#x2F;O device)为系统提供基本的计算资源。</p></li><li><p>操作系统(Operating System)：软件层次上管理硬件资源并提供基本服务的平台，例如 Windows、Linux 等。</p></li><li><p>应用程序(application)：运行在操作系统之上的软件，提供具体的功能和服务，如浏览器、文字处理软件等。</p></li><li><p>用户(user)：使用计算机系统进行操作和执行任务的人员。</p></li></ol><hr><p><strong>单处理器系统（Single-Processor System）</strong> 是指只有一个中央处理单元（CPU）的计算机系统。其特点如下：  </p><ol><li><strong>核心数量</strong>：只有一个处理器核心，用于执行所有的指令和任务。  </li><li><strong>任务调度</strong>：通过时间分片等方法实现多任务操作，但实际上每个时刻只能执行一个任务。  </li><li><strong>适用场景</strong>：适合资源需求较低的应用场景，如传统的个人计算机和嵌入式系统。  </li><li><strong>优点</strong>：结构简单，成本较低，软件开发难度小。  </li><li><strong>缺点</strong>：处理能力有限，无法充分利用多核架构的优势。</li></ol><p><strong>多处理系统（multiprocessing system）(也称为并行系统（parallel system）)</strong> 是指拥有多个处理器（或多个核心）的计算机系统，允许多个任务同时运行。其特点如下：  </p><ol><li><strong>核心数量</strong>：包含两个或更多处理器（或多核），每个核心可以独立执行任务。  </li><li><strong>任务并行</strong>：支持真正的并行计算，显著提高计算速度和效率。  </li><li><strong>架构类型</strong>：分为<strong>对称多处理（Symmetric MultiProcessing, SMP）</strong>和<strong>非对称多处理（Asymmetric MultiProcessing, AMP）</strong>：  <ul><li>SMP：所有处理器平等共享内存和任务。  </li><li>AMP：不同处理器有专门的任务分工。</li></ul></li><li><strong>适用场景</strong>：高性能计算、服务器、多任务处理（如图像处理、机器学习等）。</li></ol><p><strong>多处理器系统的主要优点有：</strong></p><ol><li><p><strong>增加吞吐量</strong>  </p><ul><li>多处理器系统通过并行处理任务显著提高了整体计算吞吐量。  </li><li>多个处理器可以同时执行不同的任务，减少任务队列的等待时间，提高系统的运行效率。  </li><li>特别适用于计算密集型任务，如科学计算、数据处理和复杂的仿真。</li><li>采用N个处理器的加速比不是N，而是小于N（考虑资源共享竞争）</li></ul></li><li><p><strong>规模经济</strong>  </p><ul><li>多处理器系统通过共享内存、I&#x2F;O设备等资源，降低了每个处理器独立配备资源的成本。  </li><li>随着处理器数量增加，系统性能可以线性甚至超线性提升，使整体成本效益更高。  </li><li>常见于需要扩展性强的大型系统，如云计算和服务器集群。</li></ul></li><li><p><strong>增加可靠性</strong>  </p><ul><li>多处理器系统具备更高的容错能力，当一个处理器发生故障时，其他处理器可以接管任务，保证系统的连续运行。  </li><li>提供了冗余机制，使关键任务系统（如航空、医疗设备）在出现硬件问题时仍能保持稳定。比如10个处理器中的1个出了故障，剩下的9个会分担器故障处理器的那部分工作。</li><li>通过任务分配策略，还可有效防止单点故障的影响。</li></ul></li></ol><hr><p><strong>操作系统</strong>（Operating System，OS）是计算机系统中最基础且最重要的<strong>软件</strong>，它负责管理硬件资源并为用户和应用程序提供接口。其主要功能和定义如下：</p><ol><li><p><strong>资源管理者</strong>  : 操作系统负责管理和分配计算机的硬件资源，包括CPU、内存、存储设备和外部设备，以确保各类任务高效运行。</p></li><li><p><strong>用户与硬件之间的桥梁</strong>  : 操作系统提供用户与硬件交互的接口，使用户可以通过简单的命令或图形界面与计算机进行操作，而无需直接了解硬件的底层细节。</p></li><li><p><strong>程序执行的控制中心</strong>  : 操作系统负责调度和协调应用程序的运行，提供多任务处理和资源分配功能，保证系统的稳定性和性能。</p></li><li><p><strong>服务提供者</strong>  : 它为应用程序提供基本的服务，如文件管理、内存管理、进程调度和网络通信，简化了软件开发。</p></li></ol><p>操作系统是计算机系统的核心，它连接硬件和用户，为软件运行提供支持，同时确保系统的高效性和可靠性。</p><hr><p><strong>中断机制</strong>是操作系统中一个关键的功能，用于处理异步事件和高效管理硬件资源。它使得计算机可以响应各种外部或内部事件，如硬件故障、输入输出操作的完成、定时器到期等。下面详细介绍中断机制的各个方面：</p><p>1.<strong>中断的基本概念：</strong> 中断（Interrupt）是指计算机在执行程序的过程中，由于某些突发事件（如硬件设备请求、异常情况等），使得CPU暂时中止当前正在执行的程序，转而去处理这些事件的过程。当中断事件处理完毕后，CPU再回到中断前的程序继续执行。</p><p>2.<strong>中断的分类：</strong></p><ol><li><strong>硬件中断（Hardware Interrupt）</strong>：由外部硬件设备触发，如键盘按键、鼠标点击、网络数据包到达等。</li><li><strong>软件中断（Software Interrupt）</strong>：由软件触发的中断，如系统调用、程序异常等。</li><li><strong>定时器中断（Timer Interrupt）</strong>：由系统定时器触发，用于时间片轮转调度等操作。</li></ol><p>3.<strong>中断处理过程：</strong> 中断处理过程一般包括以下几个步骤：</p><ol><li><strong>中断请求</strong>：外部设备或软件发出中断请求信号。</li><li><strong>中断响应</strong>：CPU检查中断信号，并保存当前执行的上下文（如程序计数器、寄存器等）。</li><li><strong>中断向量</strong>：根据中断类型，CPU查找中断向量表以获取相应的中断服务程序（Interrupt Service Routine，ISR）的入口地址。</li><li><strong>执行中断服务程序</strong>：CPU跳转到ISR，执行相应的中断处理逻辑。</li><li><strong>恢复上下文</strong>：中断处理完成后，CPU恢复先前保存的上下文，继续执行被中断的程序。</li></ol><p>4.<strong>中断优先级：</strong><br>在多种中断同时发生时，需要确定哪个中断优先处理。中断优先级机制用于决定中断处理的顺序。一般来说，硬件中断优先级较高，而软件中断优先级较低。中断控制器（Interrupt Controller）用于管理中断优先级。</p><p>5.<strong>中断屏蔽：</strong> 中断屏蔽是指在某些关键操作期间，暂时禁止某些中断的发生，以防止中断打断正在进行的重要操作。通常使用中断屏蔽寄存器来实现。屏蔽中断可以避免在执行关键代码段时被中断打断，但也需要注意不能长时间屏蔽，以免丢失重要的中断信号。</p><p>6.<strong>中断的优点:</strong></p><ol><li><strong>响应及时</strong>：中断机制可以在事件发生时立即响应，提高系统的实时性。</li><li><strong>资源高效利用</strong>：通过中断机制，可以在硬件设备准备好时才进行处理，而不需要轮询，节省CPU资源。</li><li><strong>多任务处理</strong>：中断机制支持多任务并发处理，增强系统的灵活性和效率。</li></ol><p>7.<strong>中断的缺点:</strong></p><ol><li><strong>中断延迟</strong>：如果中断处理程序过多或过长，可能会导致系统响应延迟。</li><li><strong>复杂性增加</strong>：中断机制需要维护中断向量表和中断控制器，增加了系统的复杂性。</li><li><strong>上下文切换开销</strong>：每次中断处理都涉及上下文切换，带来一定的性能开销。</li></ol><p>以下是一个简单的中断处理流程示例：假设这是一个简单的汇编代码，演示中断处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ORG 100HMOV AX, 0          ; 初始化AX寄存器INTERRUPT_HANDLER:PUSH AX            ; 保存AX寄存器MOV AX, 1234H      ; 中断处理逻辑POP AX             ; 恢复AX寄存器IRET               ; 返回中断前的程序MAIN:MOV AX, 1INT 0              ; 触发中断MOV AX, 2HLT                ; 停止程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个示例中，当执行到 INT 0 指令时，会触发中断并调用 INTERRUPT_HANDLER 来处理中断。在中断处理程序中，保存了AX寄存器的值，并进行了简单的处理后恢复AX寄存器，然后返回到中断前的程序继续执行。通过中断机制，计算机系统可以高效处理各种异步事件，保证系统的稳定性和响应性。</p><hr><p><strong>轮询（Polling）</strong> 是一种通过主动检查设备或资源状态来判断是否需要处理某个事件的机制。操作系统或程序会周期性地访问设备或资源，以确定是否需要执行相关操作。</p><p><strong>轮询的特点：</strong></p><ol><li><p><strong>主动查询</strong>  : 系统不断循环检查设备或资源的状态，而不是等待设备主动通知。</p></li><li><p><strong>简单易实现</strong>  : 轮询机制实现起来比较简单，通常只需要循环读取设备的状态寄存器即可。</p></li><li><p><strong>低效</strong>  : 如果设备状态没有发生变化，CPU可能会浪费大量时间在无意义的查询上，无法高效利用资源。</p></li></ol><p><strong>轮询的工作流程：</strong></p><ol><li>系统通过读取设备状态寄存器获取设备当前状态。  </li><li>如果发现设备准备好（例如I&#x2F;O操作完成），则进行相应的处理。  </li><li>如果设备未准备好，则继续轮询，直到设备状态发生变化。</li></ol><p><strong>轮询的缺点：</strong></p><ul><li><strong>资源浪费</strong>：占用CPU时间，即使设备未准备好也会不断查询。  </li><li><strong>实时性差</strong>：对于需要快速响应的事件，轮询可能无法及时处理。  </li><li><strong>不适合频繁事件</strong>：当事件发生较多时，轮询会影响系统整体性能。</li></ul><p><strong>轮询的优点：</strong></p><ul><li><strong>简单性</strong>：实现简单，不需要复杂的硬件支持。  </li><li><strong>适用性</strong>：适合事件发生频率较低或硬件复杂度较低的场景。</li></ul><p><strong>轮询对比中断机制：</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>轮询</strong></th><th><strong>中断</strong></th></tr></thead><tbody><tr><td>响应方式</td><td>主动查询设备状态</td><td>被动响应设备的中断信号</td></tr><tr><td>资源利用效率</td><td>较低，可能浪费CPU资源</td><td>高效，只在事件发生时占用资源</td></tr><tr><td>实现复杂度</td><td>简单，不需要硬件支持</td><td>复杂，需要硬件和软件配合</td></tr><tr><td>实时性</td><td>较差</td><td>较强</td></tr></tbody></table><p>轮询虽然简单，但在现代操作系统中已逐渐被更高效的<strong>中断机制</strong>取代。</p><hr><p>在操作系统中，<strong>“异常(exception)”</strong> 指的是一种特殊的事件或情况，它们会导致当前正在执行的程序或系统行为发生中断。这些异常可能来自于硬件或软件，通常需要操作系统进行处理，以确保系统的稳定性和安全性。</p><p><strong>异常的分类：</strong></p><ol><li><strong>硬件异常</strong>：由于硬件故障或特殊硬件条件引起，例如内存访问违规、除零错误等。</li><li><strong>软件异常</strong>：由于软件执行过程中出现的非法操作或异常情况引起，例如非法指令、系统调用错误等。</li></ol><p><strong>异常处理过程：</strong></p><ol><li><strong>检测异常</strong>：当异常发生时，硬件或操作系统检测到异常情况。</li><li><strong>保存状态</strong>：当前处理器状态（例如寄存器值、程序计数器）被保存，以便后续恢复。</li><li><strong>调用异常处理程序</strong>：操作系统根据异常类型，调用相应的异常处理程序（Exception Handler）。</li><li><strong>处理异常</strong>：异常处理程序执行特定的操作，以处理或缓解异常情况。</li><li><strong>恢复状态</strong>：异常处理完成后，恢复处理器状态并继续执行被中断的程序。</li></ol><p><strong>常见的异常类型：</strong></p><ul><li><strong>访问违例</strong>：试图访问未授权的内存区域。</li><li><strong>非法指令</strong>：执行了无效或未定义的指令。</li><li><strong>除零错误</strong>：在计算过程中出现除数为零的情况。</li><li><strong>系统调用</strong>：用户程序请求操作系统提供服务时产生的异常。</li></ul><p><strong>异常处理的优点：</strong></p><ul><li><strong>提高系统稳定性</strong>：通过有效的异常处理机制，操作系统可以检测并处理各种错误，避免系统崩溃。</li><li><strong>增强安全性</strong>：异常处理可以防止非法操作，保护系统和用户数据的安全。</li></ul><p>异常处理是操作系统中的一个关键机制，用于管理和处理各种意外事件和错误情况。通过异常处理，操作系统能够保持系统的稳定性和安全性，确保用户和应用程序的正常运行。</p><hr><p>在操作系统中，<strong>中断（Interrupt）和异常（Exception）</strong> 是两种重要的事件，它们都会导致CPU暂停当前的任务，转而去处理这些事件。再总结一下就是：</p><ul><li>中断（Interrupt）：中断是由<u>硬件设备（如键盘，鼠标，网络接口卡等）发出的信号，</u>通知操作系统有一些重要的事件发生，需要立即处理。例如，当你按下键盘上的一个键时，键盘会向CPU发送一个中断信号，CPU会暂停当前的任务，转而去处理这个按键事件。处理完这个事件后，CPU会返回到被中断的任务，继续执行。</li><li>异常（Exception）：异常是由<u>CPU在执行指令过程中发现的问题，</u>如除以零，访问无效的内存地址等。当发生异常时，CPU会暂停当前的任务，转而去执行一个特殊的异常处理程序。处理完这个异常后，CPU可能会返回到被中断的任务，也可能会终止这个任务，这取决于异常的类型和严重性。</li></ul><p>总体来说，中断和异常都是操作系统用来响应和处理重要事件的机制。它们都会导致CPU暂停当前的任务，但来源和处理方式有所不同。<strong>中断通常由外部硬件或定时器触发，表示系统需要对外部事件进行响应，而异常则由程序内部的特殊或错误行为引发，表示需要操作系统介入进行修复或处理</strong>。发生中断或异常时，操作系统都会介入并展开管理工作；<strong>用户态和内核态的切换是通过中断或异常实现的，而中断是实现这种切换的唯一途径，通过修改程序状态字（PSW）来完成状态转换</strong>。</p><hr><p><strong>内存管理</strong> 是操作系统的一项重要功能，负责管理计算机的主存储器，并为应用程序分配和释放内存。内存管理的主要目标是提高内存的使用效率，保证系统的稳定性和安全性。以下是内存管理的一些关键概念和机制：</p><p><strong>内存管理的主要任务:</strong></p><ol><li><strong>内存分配</strong>：为进程分配所需的内存资源，包括动态分配和静态分配。</li><li><strong>内存保护</strong>：确保进程只能访问自己合法的内存区域，防止进程之间相互干扰。</li><li><strong>内存回收</strong>：回收不再使用的内存，以便分配给其他进程。</li></ol><p><strong>内存管理机制:</strong></p><p><strong>1.分段和分页:</strong></p><ul><li><strong>分页</strong>：内存被划分成大小相同的页，每个进程的地址空间也被划分成相同大小的页。通过页表（Page Table）映射进程页和物理内存页，实现内存的管理。</li><li><strong>分段</strong>：内存被划分成不同大小的段，每个段包含一段逻辑地址空间。通过段表（Segment Table）管理和映射各段地址。</li></ul><p><strong>2.虚拟内存:</strong></p><p>虚拟内存技术允许操作系统将实际物理内存与进程的逻辑内存分离，使得进程可以使用比实际物理内存更大的地址空间。虚拟内存通过页表和交换空间（Swap Space）管理，将不常用的页临时存储在磁盘上，需要时再调入内存。</p><p><strong>3.内存保护:</strong></p><ul><li><strong>基址寄存器和界限寄存器</strong>：通过设置每个进程的基址和界限，确保进程只能访问自己的内存区域，防止越界访问。</li><li><strong>页面保护</strong>：通过页表中的保护位控制每个页的访问权限（读、写、执行），保证进程的内存访问安全。</li></ul><p><strong>4. 内存回收:</strong></p><ul><li><strong>垃圾回收</strong>：通过自动检测和回收不再使用的内存，释放资源供其他进程使用。</li><li><strong>内存压缩</strong>：通过内存整理和压缩，减少内存碎片，提高内存利用率。</li></ul><p><strong>内存管理的重要性:</strong></p><ol><li><strong>提高系统性能</strong>：通过有效的内存分配和回收机制，保证进程的高效运行。</li><li><strong>增强系统稳定性</strong>：通过内存保护机制，防止进程之间的相互干扰，保证系统的稳定运行。</li><li><strong>优化资源利用</strong>：通过虚拟内存和分页技术，最大化内存资源的利用率，使得系统能够同时运行更多的进程。</li></ol><p>内存管理是操作系统的一项核心功能，涉及内存的分配、保护和回收等多个方面。通过有效的内存管理，操作系统能够提高系统性能、增强稳定性，并优化资源利用，为应用程序提供稳定可靠的运行环境。</p><hr><p>操作系统的<strong>进程管理</strong>是指对系统中所有进程的创建、调度、执行、和终止进行管理和协调的过程。它是操作系统的核心功能之一，负责保证多个任务能够高效、公平地共享CPU和其他资源。</p><p><strong>进程管理的主要功能：</strong></p><ol><li><p><strong>进程创建与终止</strong>  </p><ul><li>创建新进程：为程序分配必要的资源（如内存、文件句柄）并初始化进程控制块（PCB）。  </li><li>终止进程：释放进程所占用的资源并清理PCB。</li></ul></li><li><p><strong>进程调度</strong>  </p><ul><li>负责决定哪一个进程可以使用CPU。  </li><li>常用的调度算法包括：  <ul><li>先来先服务（FCFS）  </li><li>最短作业优先（SJF）  </li><li>时间片轮转（RR）  </li><li>多级队列调度等。</li></ul></li></ul></li><li><p><strong>进程同步</strong>  </p><ul><li>保证多个进程在访问共享资源时不会产生冲突。  </li><li>使用机制：信号量（Semaphore）、互斥锁（Mutex）、条件变量等。</li></ul></li><li><p><strong>进程通信</strong>  </p><ul><li>提供进程之间交换数据的手段。  </li><li>常用方式：管道（Pipe）、消息队列（Message Queue）、共享内存（Shared Memory）、信号（Signal）等。</li></ul></li><li><p><strong>进程状态管理</strong>  </p><ul><li>维护进程的状态：  <ul><li>新建（New）  </li><li>就绪（Ready）  </li><li>运行（Running）  </li><li>阻塞（Blocked）  </li><li>终止（Terminated）</li></ul></li><li>根据状态变化完成任务切换。</li></ul></li><li><p><strong>多线程支持</strong>  </p><ul><li>管理线程的创建、调度和同步，支持多线程模型（如用户线程和内核线程）。</li></ul></li></ol><p><strong>进程与线程的区别</strong></p><ul><li><strong>进程(Process)</strong> 是资源分配的最小单位，每个进程有独立的地址空间。进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。  </li><li><strong>线程(Thread)</strong> 是CPU调度的最小单位，线程共享进程的地址空间。线程是进程中的一条执行路径，是进程的一个实体，可作为系统独立调度和分派的基本单位。</li></ul><p>进程：就像一家物业管理公司，它独立运营，有自己的一套管理系统（相当于进程的独立地址空间）。这个公司可以接多个任务，但所有任务最终都需要公司的资源来完成。</p><p>单线程：假设你是这家公司的唯一员工。初期，业务量很小，每个任务都需要你亲自去完成。比如，给老张家修完暖气管道，然后再去老李家换电灯泡。这个过程类似于单线程执行——每次只能处理一个任务，必须按顺序进行。</p><ul><li>示例：修暖气管道 -&gt; 换电灯泡</li></ul><p>多线程：随着业务的发展，你雇佣了多个工人。这时，你的公司可以同时为多户人家提供服务。每个工人就是一个线程，他们可以独立处理自己的任务，但仍然共享公司的资源（如工具、交通工具等）。</p><ul><li>示例：工人A修暖气管道，工人B换电灯泡，工人C修水管</li></ul><p>主线程：你作为公司的老板和主线程，负责分配任务、协调工作，确保所有工人（线程）能顺利开展工作。如果某个工人遇到问题（冲突或需要协同），你可以及时介入解决，保持公司的正常运行。</p><p>通过这个类比，进程就像是一个独立的公司，每个线程就像是公司的员工，他们共享公司的资源，并共同完成任务。多线程能提高效率，但需要有效的管理和协调，确保资源的合理使用和任务的顺利完成。</p><p>进程管理是操作系统的核心功能之一，它通过对进程的调度和控制，实现了多任务并发，保证系统资源的高效利用和任务的公平执行。</p><hr><p><strong>API（Application Programming Interface, 应用程序编程接口）</strong> 是一种允许不同软件系统之间进行通信的接口。API 定义了一组函数、方法、协议或工具，使开发者可以利用这些接口来访问另一种软件的功能或数据，而无需了解其内部实现细节。</p><p><strong>API重要特点：</strong></p><ul><li><strong>抽象层（Abstraction Layer）</strong>：API 提供了对底层复杂操作的简化抽象，开发者不需要了解底层实现细节。</li><li><strong>功能封装（Function Encapsulation）</strong>：API 将常用功能封装为可复用的接口，方便开发者调用。</li><li><strong>互操作性（Interoperability）</strong>：不同的软件系统可以通过 API 进行互操作，提高系统的兼容性和可扩展性。</li></ul><p><strong>系统调用（System Call）</strong> 是操作系统内核提供的接口，允许应用程序请求操作系统提供服务。系统调用是程序与操作系统之间的桥梁，使应用程序可以执行底层硬件操作，如文件操作、进程管理和网络通信等。系统调用可以被看作是<strong>操作系统API的一部分</strong>。当你在编程时使用API，你可能会间接地使用系统调用。例如，当你使用C++的文件流对象（如std::fstream）来读写文件时，这些对象内部可能会使用到操作系统的系统调用来进行实际的文件操作。</p><p><strong>系统调用重要特点：</strong></p><ul><li><strong>内核模式（Kernel Mode）</strong>：系统调用将程序从用户模式切换到内核模式，以便执行特权操作。</li><li><strong>服务访问（Service Access）</strong>：通过系统调用，应用程序可以访问操作系统内核提供的服务。</li><li><strong>安全和稳定（Security and Stability）</strong>：系统调用由操作系统内核管理，确保了系统的安全性和稳定性。</li></ul><p><strong>总结：</strong></p><ul><li><strong>API（应用程序编程接口）</strong> 是软件之间进行通信的接口，通过提供预定义的函数和方法，使开发者能够利用现有功能来构建应用程序。</li><li><strong>系统调用（System Call）</strong> 是操作系统提供的接口，使应用程序可以请求操作系统执行底层硬件操作和特权任务。</li></ul><p>API 是一种更高层次的抽象，而系统调用是更底层的接口，两者都在不同层次上为软件开发提供了便利和功能。总的来说，API和系统调用都是使程序员能够更容易地编写代码和交互系统的工具。API提供了更高级别的抽象，而系统调用则提供了对操作系统服务的直接访问。</p><hr><p>操作系统的<strong>四个重要特征</strong>包括：</p><p><strong>1.并发（Concurrency）</strong> 并发是指两个或多个事件在同一时间间隔内发生。在操作系统中，并发可以通过多线程或多进程实现，线程或进程可以在一个处理器上交替执行，或者在多个处理器上同时执行。</p><ul><li><strong>并发（Concurrency）</strong> 是指多个任务在同一时间段内交替进行，给人的感觉是同时发生，但实际上每个任务并不是同时进行的。</li><li><strong>并行（Parallelism）</strong> 与并发不同，并行是指两个或多个事件在同一时刻同时发生。例如：多线程下载文件，多个进程同时处理不同任务。</li></ul><p><strong>2.共享（Sharing）</strong> 共享是指系统中的资源可以被多个并发进程共同使用。共享的方式有两种：同时访问（同时共享）和在一段时间内交替访问（互斥共享）。</p><ul><li><strong>同时共享（Concurrent Sharing）</strong>：多个进程同时访问同一资源。</li><li><strong>互斥共享（Mutual Exclusion Sharing）</strong>：多个进程轮流访问同一资源，以避免冲突。例如：多个进程共享打印机资源，互斥访问临界区。</li></ul><p><strong>3.虚拟化（Virtualization）</strong> 虚拟化是指把一个物理资源（如处理器、内存或磁盘）抽象为多个逻辑资源，或把多个物理资源抽象为一个逻辑资源。虚拟化使得用户感觉有更多的资源可用，或使得资源使用更加高效。</p><ul><li><strong>空分复用（Space Division Multiplexing）</strong>：如虚拟存储器，使4GB内存的计算机能够运行需要超过4GB内存的程序。</li><li><strong>时分复用（Time Division Multiplexing）</strong>：时分复用通过将时间划分为多个时间片，每个时间片分配给不同的任务执行。通过CPU时间片轮转技术实现多任务并行，使得每个任务在短时间内轮流占用CPU资源，给人一种同时执行多个任务的感觉。如虚拟处理器和多任务操作系统，通过CPU时间片轮转技术实现多任务并行。</li></ul><p><strong>4.异步性（Asynchronism）</strong> 异步性是指由于进程间的并发性，使得进程交替执行，进程的执行不是一贯的，也不是在固定的时间间隔内发生。这意味着进程可能走走停停，取决于系统资源的可用性和调度策略。</p><ul><li><strong>示例</strong>：异步I&#x2F;O操作，操作系统在等待I&#x2F;O操作完成时可以执行其他任务。</li></ul><p>这些特征共同作用，使操作系统能够有效地管理计算机资源，提供稳定和高效的运行环境。</p><div class="note note-success">            <p>以上就是操作系统主要关注的内容，后续章节就是扩展讲解上述内容中重要的技术细节和实现思想</p>          </div><h2 id="2-Process-Management"><a href="#2-Process-Management" class="headerlink" title="2. Process Management"></a>2. Process Management</h2><p>本章主要讲解操作系统里面的进程管理部分。理解进程和线程，掌握进程调度相关的各种策略算法，并且熟悉信号量的互斥机制是非常重要的。</p><h3 id="2-1-操作系统的用户交互"><a href="#2-1-操作系统的用户交互" class="headerlink" title="2.1 操作系统的用户交互"></a>2.1 操作系统的用户交互</h3><p>操作系统的用户交互主要分为两种类型：</p><h4 id="2-1-1-命令解释程序（Command-Interpreter）"><a href="#2-1-1-命令解释程序（Command-Interpreter）" class="headerlink" title="2.1.1 命令解释程序（Command Interpreter）"></a>2.1.1 命令解释程序（Command Interpreter）</h4><ul><li>又称为 <strong>命令行界面（CLI，Command Line Interface）</strong>。</li><li>用户通过输入文本命令与操作系统进行交互。</li><li>常见的命令解释程序包括 Unix&#x2F;Linux 系统的 Bash、Windows 的 CMD 和 PowerShell。</li><li><strong>优点</strong>：灵活性高，适合自动化脚本和高级用户。</li><li><strong>缺点</strong>：需要记住大量命令和语法，不直观。</li></ul><p>以下是一个简单的 shell 指令示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 创建一个新的目录mkdir my_new_directory# 进入新创建的目录cd my_new_directory# 创建一个新的空文件touch new_file.txt# 将一段文本写入文件中echo &quot;Hello, World!&quot; &gt; new_file.txt# 显示文件内容cat new_file.txt# 复制文件并重命名cp new_file.txt copy_of_new_file.txt# 显示当前目录中的文件和子目录列表ls -l# 删除复制的文件rm copy_of_new_file.txt# 返回上一级目录cd ..# 删除新创建的目录及其内容rm -r my_new_directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="2-1-2-图形用户界面（GUI，Graphical-User-Interface）"><a href="#2-1-2-图形用户界面（GUI，Graphical-User-Interface）" class="headerlink" title="2.1.2 图形用户界面（GUI，Graphical User Interface）"></a>2.1.2 图形用户界面（GUI，Graphical User Interface）</h4><ul><li>用户通过图形化元素（如窗口、图标、按钮）与操作系统进行交互。</li><li>常见的图形用户界面包括 Windows 的资源管理器（Windows Explorer）、macOS 的 Finder 以及 GNOME 和 KDE 等 Linux 桌面环境。</li><li><strong>优点</strong>：直观易用，适合初学者和普通用户。</li><li><strong>缺点</strong>：灵活性相对较低，复杂操作可能效率不高。</li></ul><p>这两种交互方式各有优缺点，通常操作系统会同时提供这两种方式，以满足不同用户的需求和使用场景。通过结合命令行界面和图形用户界面，用户可以在不同情况下选择最合适的交互方式，提高工作效率和使用体验。</p><hr><h3 id="2-2-操作系统中的系统调用"><a href="#2-2-操作系统中的系统调用" class="headerlink" title="2.2 操作系统中的系统调用"></a>2.2 操作系统中的系统调用</h3><p><strong>系统调用（System Call）</strong> 是操作系统提供的一组接口，允许应用程序与操作系统内核交互，以请求内核执行特权操作。系统调用是程序与操作系统之间的桥梁，使应用程序可以执行低级别的系统功能，如文件操作、进程管理和网络通信等。</p><p><strong>系统调用主要功能:</strong></p><ul><li><strong>文件操作</strong>：创建、打开、读取、写入和关闭文件。</li><li><strong>进程管理</strong>：创建、终止进程，分配资源，进程间通信等。</li><li><strong>内存管理</strong>：分配和释放内存，内存映射等。</li><li><strong>设备管理</strong>：访问和控制硬件设备，如磁盘、网络接口等。</li><li><strong>网络通信</strong>：发送和接收网络数据，设置网络连接等。</li></ul><p><strong>工作原理</strong></p><ol><li><strong>用户模式到内核模式切换</strong>：当应用程序发出系统调用时，CPU将从用户模式切换到内核模式。</li><li><strong>内核执行请求</strong>：操作系统内核接收系统调用请求，并执行相应的特权操作。</li><li><strong>返回结果</strong>：操作系统内核完成操作后，将结果返回给应用程序，并切换回用户模式。</li></ol><p><strong>系统调用示例:</strong></p><ul><li><code>open</code>：打开文件的系统调用。</li><li><code>read</code>：读取文件内容的系统调用。</li><li><code>write</code>：写入文件内容的系统调用。</li><li><code>fork</code>：创建新进程的系统调用。</li><li><code>exec</code>：执行新程序的系统调用。</li></ul><p>通过系统调用，应用程序可以安全、高效地访问操作系统提供的底层资源和服务，实现丰富的功能。</p><img src="/img/OS/system_call.svg" alt="系统调用" style="max-width: 100%; height: auto;" /><p>在后台，<strong>API 函数(Application Programming Interface, API<br>)</strong> 通常为应用程序开发人员提供了调用实际系统调用的函数。API 函数为开发人员提供了一个更高层次的抽象，使他们能够以更简单和统一的方式访问底层操作系统的功能，而不需要了解系统调用的具体实现细节。</p><p>通过调用 API 函数，开发人员可以间接地进行文件操作、进程管理、内存管理、设备控制等操作，这些 API 函数在后台会触发相应的系统调用来完成实际的操作。例如：</p><ul><li><strong>文件操作</strong>：<code>fopen</code> API 函数会调用 <code>open</code> 系统调用。</li><li><strong>进程管理</strong>：<code>fork</code> API 函数直接对应 <code>fork</code> 系统调用。</li><li><strong>内存管理</strong>：<code>malloc</code> API 函数可能会调用 <code>brk</code> 或 <code>mmap</code> 系统调用。</li></ul><p>总之，API 提供了一种方便的方式，使开发人员能够利用操作系统的功能，而不必处理系统调用的复杂性和底层细节。</p><blockquote><p>在后台，API函数通常为应用程序员调用实际的系统调用</p></blockquote><h3 id="2-3-进程的概念"><a href="#2-3-进程的概念" class="headerlink" title="2.3 进程的概念"></a>2.3 进程的概念</h3><p><strong>进程</strong>是计算机中一个正在运行的程序的实例。它不仅包括可执行程序的代码，还包含了该程序的运行状态信息，包括程序计数器、寄存器和变量的值。</p><p><strong>进程的主要特点:</strong></p><ol><li><strong>独立性</strong>：每个进程在其自己的内存空间中运行，独立于其他进程。</li><li><strong>资源拥有</strong>：进程拥有自己的系统资源，如文件句柄和内存段。</li><li><strong>并发性</strong>：操作系统可以在同一时间段内允许多个进程并发执行（即使在单个处理器系统中，通过时间分片实现）。</li><li><strong>状态</strong>：进程有多种状态，包括新建、就绪、运行、等待和终止。</li></ol><p><strong>进程的组成部分:</strong></p><ul><li><strong>可执行代码</strong>：实际的程序代码。</li><li><strong>进程控制块（PCB）</strong>：存储进程的状态信息，如程序计数器、寄存器、内存分配等。</li><li><strong>堆栈</strong>：存储临时数据（函数参数、返回地址、局部变量）。</li><li><strong>堆</strong>：动态分配的内存，用于存储运行时需要的数据。</li><li><strong>数据段</strong>：全局变量和静态变量。</li></ul><p><strong>进程状态切换：</strong></p><ol><li><p><strong>新建（New）</strong>：进程正在被创建。</p><ul><li>当一个程序被启动时，操作系统会为其创建一个新进程。此时进程处于新建状态。</li></ul></li><li><p><strong>就绪（Ready）</strong>：进程已经创建完毕，等待被调度执行。</p><ul><li>进程创建完成后，进入就绪队列，等待调度器将其调度到 CPU 上执行。</li><li><strong>切换方式</strong>：从新建状态切换到就绪状态。</li></ul></li><li><p><strong>运行（Running）</strong>：进程正在执行。</p><ul><li>当调度器选择一个就绪状态的进程并将其分配给 CPU 时，该进程进入运行状态，开始执行。</li><li><strong>切换方式</strong>：<ul><li>从就绪状态切换到运行状态。</li><li>当等待的事件完成后，进程返回就绪状态，待调度器再次分配 CPU。</li></ul></li></ul></li><li><p><strong>等待（Waiting）</strong>：进程在等待某些事件（如I&#x2F;O操作）完成。</p><ul><li>如果进程在执行过程中需要等待某些事件（如 I&#x2F;O 操作、资源可用等），它会进入等待状态。</li><li><strong>切换方式</strong>：从运行状态切换到等待状态（当进程请求的 I&#x2F;O 操作开始执行时）。</li></ul></li><li><p><strong>终止（Terminated）</strong>：进程已经完成执行或被强制终止。</p><ul><li>当进程完成其全部工作或被强制终止时，进入终止状态，等待操作系统回收资源。</li><li><strong>切换方式</strong>：从运行状态切换到终止状态（当进程正常完成或遇到无法恢复的错误时）。</li></ul></li></ol><p><strong>示例流程:</strong></p><ol><li><strong>创建一个新进程</strong>：新进程从新建状态切换到就绪状态。</li><li><strong>调度器选择进程</strong>：调度器将一个就绪进程分配给 CPU，进程从就绪状态切换到运行状态。</li><li><strong>进程请求 I&#x2F;O 操作</strong>：进程在运行过程中请求 I&#x2F;O 操作，切换到等待状态。</li><li><strong>I&#x2F;O 操作完成</strong>：I&#x2F;O 操作完成，进程从等待状态返回就绪状态。</li><li><strong>进程重新获得 CPU</strong>：调度器再次选择该进程，进程切换到运行状态。</li><li><strong>进程完成执行</strong>：进程完成所有任务或被强制终止，进入终止状态。</li></ol><p>这种状态切换机制是多任务操作系统有效管理和调度进程的重要方式，确保系统资源的合理分配和使用。</p><img src="/img/OS/process_diagram.svg" alt="进程状态图" style="max-width: 100%; height: auto;" /><p>当一个程序被加载到内存并开始执行时，操作系统为其创建一个进程，并分配所需的系统资源。操作系统通过进程调度程序管理和调度进程的执行，确保每个进程可以合理地使用 CPU 时间和其他资源。</p><p>进程是多任务操作系统的基础，允许多个程序同时运行，提高系统的效率和资源利用率。</p><hr><p>PCB（<strong>Process Control Block</strong>）是操作系统中用于管理进程的一个数据结构。每个正在运行的进程都有一个对应的 PCB，用于存储进程的各种信息。<u>PCB是进程存在的唯一标志。</u>常见的 PCB 内容包括：</p><ol><li><strong>进程状态</strong>：记录进程当前的状态（如运行、就绪、阻塞等）。</li><li><strong>程序计数器</strong>：指向下一条将执行的指令地址。</li><li><strong>CPU寄存器</strong>：保存进程执行时的 CPU 寄存器内容，包括通用寄存器、程序计数器等。</li><li><strong>内存管理信息</strong>：如进程的内存分配、页表等。</li><li><strong>进程标识符</strong>：进程的唯一标识（PID）。</li><li><strong>调度信息</strong>：包括优先级、调度队列指针等。</li><li><strong>I&#x2F;O信息</strong>：包括进程使用的输入输出设备信息和相关状态。</li></ol><p>PCB 是操作系统调度和管理进程的重要工具，确保操作系统能够有效地保存和恢复进程的状态。</p><h4 id="2-3-1-线程的概念"><a href="#2-3-1-线程的概念" class="headerlink" title="2.3.1 线程的概念"></a>2.3.1 线程的概念</h4><p>线程(Thread) 是操作系统中的基本调度单位，是进程中的一个执行单元。一个进程可以包含多个线程，多个线程共享进程的资源（如内存空间、文件描述符等），但每个线程都有自己的程序计数器、寄存器和堆栈。线程被用来执行并发任务。</p><p><strong>线程的特点：</strong></p><ol><li><strong>轻量级</strong>：相比进程，线程的创建和销毁成本较低，切换速度较快。</li><li><strong>共享资源</strong>：同一进程内的多个线程共享进程的地址空间、全局变量等资源。</li><li><strong>独立执行</strong>：每个线程有自己的程序计数器、栈和局部变量，可以独立执行任务。</li><li><strong>并发执行</strong>：多个线程可以并发或并行地执行，适用于多核处理器和多任务环境。</li></ol><p><strong>线程与进程的区别：</strong></p><ul><li><strong>进程</strong>是资源分配的基本单位，每个进程都有独立的内存空间。</li><li><strong>线程</strong>是 CPU 调度的基本单位，同一进程内的多个线程共享内存资源，但有独立的执行路径。</li></ul><h4 id="2-3-2-操作系统中的多线程模型（Multithreading-Models）"><a href="#2-3-2-操作系统中的多线程模型（Multithreading-Models）" class="headerlink" title="2.3.2 操作系统中的多线程模型（Multithreading Models）"></a>2.3.2 操作系统中的多线程模型（Multithreading Models）</h4><p>操作系统中的多线程模型决定了用户线程与内核线程之间的映射关系。主要有以下几种模型：</p><p><strong>1. 一对一模型（One-to-One Model）</strong></p><ul><li>每个用户线程映射到一个内核线程。</li><li><strong>优点</strong>：可以充分利用多处理器的并行性，因为每个线程可以在不同的处理器上独立运行。</li><li><strong>缺点</strong>：每个线程需要一个内核线程，导致线程的创建和管理开销较大，可能影响性能。</li></ul><p><strong>2. 多对一模型（Many-to-One Model）</strong></p><ul><li>多个用户线程映射到一个内核线程。</li><li><strong>优点</strong>：线程的创建和管理开销较小，因为内核只需要管理一个内核线程。</li><li><strong>缺点</strong>：由于所有用户线程都在同一个内核线程上运行，无法利用多处理器的并行性。如果一个线程阻塞，整个进程都会被阻塞。</li></ul><p><strong>3. 多对多模型（Many-to-Many Model）</strong></p><ul><li>多个用户线程映射到多个内核线程。</li><li><strong>优点</strong>：结合了前两种模型的优点，既可以利用多处理器的并行性，又能控制线程的创建和管理开销。</li><li><strong>缺点</strong>：需要复杂的调度和管理机制来平衡用户线程与内核线程之间的映射关系。</li></ul><p><strong>4. 二级模型（Two-Level Model）</strong></p><ul><li>是多对多模型的变体，允许多个用户线程映射到同一个内核线程，也允许一个用户线程映射到多个内核线程。</li><li><strong>优点</strong>：允许更灵活的线程管理，结合了多对多模型和一对一模型的优点。</li><li><strong>缺点</strong>：需要更复杂的调度机制，增加了系统的实现复杂性。</li></ul><img src="/img/OS/threading_models.svg" alt="多线程模型" style="max-width: 100%; height: auto;" /><h3 id="2-4-进程控制"><a href="#2-4-进程控制" class="headerlink" title="2.4 进程控制"></a>2.4 进程控制</h3><p>进程控制是操作系统管理和调度进程的关键任务。它包括创建、调度、终止进程等操作，以确保系统中的进程能高效、按需执行。</p><p><strong>1. 进程的创建</strong></p><ul><li><strong>创建新进程</strong>：操作系统通过系统调用（如 <code>fork</code> 在 Unix 系统中）创建一个新进程。新进程通常是当前进程的副本，称为子进程。</li><li><strong>资源分配</strong>：当创建新进程时，操作系统为其分配必要的资源（如内存、文件句柄等），并初始化进程控制块（PCB）以存储进程信息。</li></ul><p><strong>2. 进程调度</strong></p><ul><li><strong>进程状态</strong>：进程在执行过程中会经历不同的状态（如就绪、运行、阻塞等）。操作系统调度器负责决定进程在何时进入哪种状态。</li><li><strong>调度算法</strong>：操作系统使用各种调度算法（如先来先服务 FCFS、时间片轮转 RR、最短作业优先 SJF 等）来决定哪个进程应该获得 CPU 时间。</li><li><strong>多任务处理</strong>：操作系统允许多个进程并发运行，通过上下文切换在多个进程间分配 CPU 时间。</li></ul><p><strong>3. 进程同步与通信</strong></p><ul><li><strong>进程同步</strong>：在并发执行的多个进程间，操作系统提供同步机制（如信号量、互斥锁、条件变量等）以确保共享资源的正确使用，避免数据竞争和死锁。</li><li><strong>进程通信</strong>：进程之间可以通过多种方式进行通信，如管道、消息队列、共享内存等。操作系统提供通信机制以允许进程间交换数据。</li></ul><p><strong>4. 进程终止</strong></p><ul><li><strong>进程终止</strong>：进程执行完毕或由于错误发生时，会通过系统调用（如 <code>exit</code>）终止。操作系统会回收进程所占用的资源，关闭文件、释放内存等。</li><li><strong>父子进程的终止</strong>：当子进程终止时，操作系统会向父进程发送信号（如 Unix 系统中的 <code>SIGCHLD</code>），父进程可选择等待子进程的终止并回收子进程资源。</li></ul><p><strong>5. 进程控制块（PCB）</strong></p><ul><li><strong>PCB（Process Control Block）</strong>：每个进程在操作系统中都有一个对应的 PCB，用于存储进程的状态、程序计数器、CPU 寄存器、内存信息等。</li><li><strong>进程调度</strong>：PCB 是进程调度和管理的核心数据结构，操作系统通过它来实现上下文切换和进程状态的转换。</li></ul><p>进程控制是操作系统的重要功能，涉及进程的创建、调度、同步、通信以及终止等方面。通过有效的进程控制，操作系统能够确保多任务环境下的进程按预期运行，资源得到合理分配。</p><h3 id="2-5-进程间调度"><a href="#2-5-进程间调度" class="headerlink" title="2.5 进程间调度"></a>2.5 进程间调度</h3><p>操作系统中的进程调度是管理CPU资源分配的一项重要功能。它决定了哪些进程何时运行，以及如何在多个进程间切换，以实现系统资源的高效利用和响应。</p><p><strong>常见的调度算法主要有：</strong></p><p><strong>1. 先到先服务（First-Come First-Served, FCFS）</strong></p><ul><li>简单且直观，进程按照到达顺序执行。</li><li><strong>优点</strong>：实现简单。</li><li><strong>缺点</strong>：容易导致长进程阻塞短进程（队头阻塞），可能增加平均等待时间。</li></ul><p><strong>2. 短作业优先（Shortest-Job-First, SJF）</strong></p><ul><li>优先执行预计运行时间最短的进程。</li><li><strong>优点</strong>：减少平均等待时间。</li><li><strong>缺点</strong>：需要准确预测进程运行时间，长作业可能会长期得不到调度（饥饿现象）。</li></ul><p><strong>3. 优先级调度算法（Priority Scheduling）</strong></p><ul><li>根据进程的优先级调度，优先级高的进程先执行。</li><li><strong>优点</strong>：灵活性高，可以根据需求调整优先级。</li><li><strong>缺点</strong>：低优先级进程可能会长期得不到调度（饥饿现象）。</li></ul><p><strong>4. 轮转调度（Round-Robin，RR）算法</strong></p><ul><li>每个进程分配一个固定的时间片，时间片到后切换到下一个进程。</li><li><strong>优点</strong>：公平，适用于时间共享系统。</li><li><strong>缺点</strong>：时间片过大或过小会影响系统性能。</li></ul><p><strong>5. 多级反馈队列调度算法（Multilevel Feedback Queue）</strong></p><ul><li>结合多个优先级队列和时间片调度。</li><li>进程根据其行为动态调整优先级和队列位置。</li><li><strong>优点</strong>：灵活性高，能够较好地平衡响应时间和系统吞吐量。</li></ul><p>通过这些调度算法，操作系统能够高效管理和分配CPU资源，保证系统的稳定性和用户体验。下面分别分析上述调度算法.</p><hr><h4 id="2-5-1-先到先服务（First-Come-First-Served-FCFS）"><a href="#2-5-1-先到先服务（First-Come-First-Served-FCFS）" class="headerlink" title="2.5.1 先到先服务（First-Come First-Served, FCFS）"></a>2.5.1 先到先服务（First-Come First-Served, FCFS）</h4><p><strong>先到先服务（First-Come, First-Served，FCFS）</strong> 是一种简单的进程调度算法，它的工作原理是：当进程到达系统时，它们被放入就绪队列。调度器选择队列中的第一个进程进行执行，直到该进程完成或发生阻塞事件，然后调度器选择下一个进程。</p><ul><li>优点：<ul><li>公平性（Fairness）：FCFS算法对所有进程都是公平的，因为它按照进程到达的顺序进行调度。</li><li>简单性（Simplicity）：FCFS算法非常简单和易于实现。</li></ul></li><li>缺点：<ul><li>无法充分利用CPU（Poor CPU Utilization）：如果当前正在运行的进程需要大量的I&#x2F;O操作，那么CPU可能会在等待I&#x2F;O操作完成时处于空闲状态。</li><li>平均等待时间可能较长（Long Average Waiting Time）：在FCFS算法中，短的进程可能会被长的进程阻塞，这种现象被称为“饥饿”（Starvation）或“拖尾效应”（Convoy Effect）。</li><li>无法支持优先级（Lack of Priority Support）：FCFS算法不支持优先级，因此无法保证重要的进程能够优先执行。</li></ul></li></ul><p>总的来说，虽然FCFS算法简单且公平，但由于其无法有效地利用CPU和支持优先级，所以在需要高效率或优先级调度的系统中，通常不会使用FCFS算法。</p><img src="/img/OS/fcfs.svg" alt="先到先服务调度算法" style="max-width: 100%; height: auto;" /><hr><p>在操作系统中，<strong>饥饿（Starvation）</strong> 是指某些进程长时间得不到所需资源，从而无法执行的情况。这通常发生在资源分配机制不公平或不完善的情况下。饥饿现象主要出现在以下几种情况下：</p><ul><li>优先级调度：在优先级调度算法中，如果某些低优先级的进程始终被高优先级进程抢占，低优先级进程可能会一直得不到执行机会，从而陷入饥饿状态。</li><li>资源竞争：当多个进程竞争有限的资源时，某些进程可能持续无法获得资源，导致无法继续执行。</li><li>长作业排队：在先到先服务（FCFS）或短作业优先（SJF）等调度算法中，长时间运行的进程可能会因其他短作业的持续到达而长期得不到调度。</li></ul><p>解决饥饿问题的一种常见方法是<strong>老化机制（Aging）</strong>，即逐渐提高长期未被调度进程的优先级，使其最终能够获得资源并执行。</p><hr><h4 id="2-5-2-短作业优先（Shortest-Job-First-SJF）"><a href="#2-5-2-短作业优先（Shortest-Job-First-SJF）" class="headerlink" title="2.5.2 短作业优先（Shortest-Job-First, SJF）"></a>2.5.2 短作业优先（Shortest-Job-First, SJF）</h4><p>在这种算法中，调度器选择就绪队列中预计运行时间最短的进程进行执行。预计运行时间可以是进程的CPU突发时间（CPU burst time）或者是进程的剩余执行时间。（这里就要看是非抢占式的还是抢占式的了，可以直观理解）</p><p>短作业优先调度算法的主要优点是它最小化了平均等待时间。因为短的进程总是优先于长的进程，所以它们的等待时间会更短，从而使得平均等待时间最小。</p><p>然而，这种算法也有一些缺点。首先，它需要知道进程的预计运行时间，但在实际的系统中，这通常是无法预知的。其次，这种算法可能会导致 <strong>“饥饿”（Starvation）</strong> 现象，即长的进程可能会被无限期地推迟，因为总是有短的进程到来。<br>总的来说，短作业优先调度算法在理论上是非常有效的，但在实际的系统中，由于需要预知进程的运行时间以及可能导致的饥饿问题，它的应用受到了一些限制。</p><img src="/img/OS/sjf.svg" alt="短作业优先调度算法" style="max-width: 100%; height: auto;" /><hr><h4 id="2-5-3-优先级调度算法（Priority-Scheduling）"><a href="#2-5-3-优先级调度算法（Priority-Scheduling）" class="headerlink" title="2.5.3 优先级调度算法（Priority-Scheduling）"></a>2.5.3 优先级调度算法（Priority-Scheduling）</h4><p>优先级调度算法是一种操作系统中的进程调度算法。在这种算法中，每个进程都有一个优先级，操作系统总是选择优先级最高的进程来运行。这种算法的主要特点如下：</p><ul><li>优先级：每个进程都有一个优先级，优先级高的进程优先执行。（抢占式，preemptive）</li><li>动态调整：系统可以根据需要动态调整进程的优先级。例如，为了防止低优先级的进程永远得不到执行，系统可能会随着时间的推移提高等待进程的优先级。</li><li>饿死问题：如果总是有新的高优先级进程出现，那么低优先级的进程可能永远得不到执行，这就是所谓的饿死问题。为了解决这个问题，系统可能会采取一些策略，比如老化（随着时间的推移提高等待进程的优先级）。</li></ul><p>这种算法在实时系统中特别有用，因为在这些系统中，有些任务（比如控制飞机的自动驾驶仪）比其他任务更重要，因此需要优先执行。但是，这种算法也有一些缺点，比如可能会导致低优先级的进程饿死。因此，设计一个好的优先级调度算法需要权衡各种因素。</p><img src="/img/OS/priority.svg" alt="优先级调度算法" style="max-width: 100%; height: auto;" /><hr><h4 id="2-5-4-轮转调度（Round-Robin，RR）算法"><a href="#2-5-4-轮转调度（Round-Robin，RR）算法" class="headerlink" title="2.5.4 轮转调度（Round-Robin，RR）算法"></a>2.5.4 轮转调度（Round-Robin，RR）算法</h4><p>轮转调度（Round-Robin，RR）算法是一种非常常见的操作系统进程调度算法。以下是对其的简要解释：</p><ul><li>时间片（Time Quantum）：在轮转调度算法中，每个进程被分配一个固定长度的时间片来执行。当一个进程的时间片用完时，它将被移出CPU，下一个进程将开始执行。</li><li>公平性（Fairness）：由于每个进程都有相同长度的时间片来执行，因此这种算法被认为是公平的。没有进程会因为优先级低而被饿死。<br>上下文切换（Context Switch）：当一个进程的时间片用完，操作系统需要进行上下文切换，将CPU从当前进程切换到下一个进程。这会产生一定的开销。</li><li>响应时间（Response Time）：轮转调度算法通常能提供良好的响应时间，因为每个进程都会定期得到CPU时间。</li></ul><p>这种算法适用于时间共享系统，但如果时间片设置得不合适，可能会导致过多的上下文切换，从而降低系统性能。因此，选择合适的时间片长度是实现轮转调度算法的关键。如果时间片过长，那么系统的响应时间可能会变差；如果时间片过短，那么上下文切换的开销可能会变大。</p><p>同一时刻两个进程 A 和 B, A 刚下处理机, B 刚进入队列, 默认 B 先轮转时间片。</p><ul><li>如果时间片太大, 退化为FCFS, 会增大进程响应时间</li><li>如果时间片太小, 进程切换频繁, 切换进程会花费大量时间</li></ul><p>一般来说, 设计时间片要让切换进程的开销占比不超过 1%</p><img src="/img/OS/rr.svg" alt="轮转调度算法" style="max-width: 100%; height: auto;" /><hr><h4 id="2-5-5-多级反馈队列调度算法（Multilevel-Feedback-Queue）"><a href="#2-5-5-多级反馈队列调度算法（Multilevel-Feedback-Queue）" class="headerlink" title="2.5.5 多级反馈队列调度算法（Multilevel Feedback Queue）"></a>2.5.5 多级反馈队列调度算法（Multilevel Feedback Queue）</h4><p>多级反馈队列调度算法（Multilevel Feedback Queue Scheduling）是一种操作系统中的进程调度算法。以下是对其的简要解释：</p><ul><li>多级队列（Multilevel Queues）：在这种算法中，存在多个队列，每个队列都有自己的优先级。优先级最高的队列中的进程首先得到执行。（也就是前一队列为空的时候，才能执行当前队列！！）</li><li>反馈（Feedback）：如果一个进程在其分配的时间片内没有完成，那么它将被移动到优先级较低的队列。这就是所谓的“反馈”机制。</li><li>公平性和灵活性（Fairness and Flexibility）：这种算法旨在结合优先级调度和轮转调度的优点，以实现公平性和灵活性。它可以确保高优先级的进程快速执行，同时也不会饿死低优先级的进程。</li><li>动态优先级（Dynamic Priorities）：进程的优先级不是固定的，而是可以根据其行为动态改变。例如，如果一个进程经常阻塞等待I&#x2F;O操作，那么它的优先级可能会提高，以便在I&#x2F;O操作完成后能够快速得到执行。</li></ul><p>这种算法在许多操作系统中都得到了应用，因为它既可以处理交互式进程（这些进程需要快速响应），也可以处理批处理进程（这些进程需要长时间运行）。然而，它的实现相对复杂，需要维护多个队列，并动态调整进程的优先级。此外，选择合适的队列数量和时间片长度也是一个挑战。如果设置不当，可能会导致某些进程得不到公平的CPU时间，或者系统的上下文切换开销过大。因此，实现这种算法需要权衡各种因素。</p><p>这个算法无明显缺点，但是会导致饥饿！考虑一种情况：长时间运行的进程一直被降级到低优先级队列，而新到达的高优先级进程源源不断地占用CPU资源，那么低优先级的进程可能会长期得不到调度，导致饥饿。</p><img src="/img/OS/multive_queue.svg" alt="多级反馈队列调度算法" style="max-width: 100%; height: auto;" /><h3 id="2-6-进程间通信"><a href="#2-6-进程间通信" class="headerlink" title="2.6 进程间通信"></a>2.6 进程间通信</h3><p>进程间通信（IPC，Inter-Process Communication）是操作系统中的一项重要机制，用于让不同进程之间交换数据或同步操作。操作系统提供了多种进程间通信方式，每种方式有其特点和适用场景。以下是几种常见的进程间通信方式的详细讲解：</p><h4 id="2-6-1-管道（Pipe）"><a href="#2-6-1-管道（Pipe）" class="headerlink" title="2.6.1 管道（Pipe）"></a>2.6.1 管道（Pipe）</h4><p>管道是一种最基本的进程间通信方式，允许数据在一个进程与另一个进程之间单向流动。它适用于父子进程之间的通信。</p><ul><li><strong>匿名管道（Anonymous Pipe）</strong>：不具备名字，一般用于有亲缘关系的进程（如父子进程）。匿名管道是半双工的，即数据只能单向流动。</li><li><strong>命名管道（Named Pipe）</strong>：有名字，可以在无亲缘关系的进程间使用，因此适用于不同进程间的通信。命名管道是全双工的，即可以双向传输数据。</li></ul><img src="/img/OS/pipe.svg" alt="管道通信" style="max-width: 100%; height: auto;" /><p>匿名管道通常用于父子进程之间的通信。它是半双工的，只能进行单向数据流动。在下面这个示例中，父进程通过匿名管道发送数据给子进程，子进程接收并打印出来。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token comment"># 创建一个匿名管道</span>pipe_read<span class="token punctuation">,</span> pipe_write <span class="token operator">=</span> os<span class="token punctuation">.</span>pipe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 创建子进程</span>pid <span class="token operator">=</span> os<span class="token punctuation">.</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 父进程</span>    <span class="token comment"># 关闭读端，只写</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_read<span class="token punctuation">)</span>    <span class="token comment"># 向管道中写入数据</span>    os<span class="token punctuation">.</span>write<span class="token punctuation">(</span>pipe_write<span class="token punctuation">,</span> <span class="token string">b"Hello from parent process!"</span><span class="token punctuation">)</span>    <span class="token comment"># 关闭写端</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_write<span class="token punctuation">)</span>    <span class="token keyword">elif</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 子进程</span>    <span class="token comment"># 关闭写端，只读</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_write<span class="token punctuation">)</span>    <span class="token comment"># 从管道中读取数据</span>    message <span class="token operator">=</span> os<span class="token punctuation">.</span>read<span class="token punctuation">(</span>pipe_read<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Child process received message: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token comment"># 关闭读端</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_read<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>命名管道可以用于不同进程之间的通信。命名管道通过文件系统提供了一个可以由多个进程访问的接口。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token comment"># *****父进程写数据******* #</span><span class="token comment"># 创建命名管道（FIFO）</span>fifo_path <span class="token operator">=</span> <span class="token string">"/tmp/my_named_pipe"</span><span class="token keyword">try</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>mkfifo<span class="token punctuation">(</span>fifo_path<span class="token punctuation">)</span><span class="token keyword">except</span> FileExistsError<span class="token punctuation">:</span>    <span class="token keyword">pass</span>  <span class="token comment"># 如果管道已经存在，跳过创建</span><span class="token comment"># 向命名管道写数据</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>fifo_path<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fifo<span class="token punctuation">:</span>    fifo<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Hello from parent process!"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Parent process has written the message."</span><span class="token punctuation">)</span><span class="token comment"># 父进程使用 mkfifo() 创建一个命名管道 /tmp/my_named_pipe。然后，父进程通过写操作将消息写入管道。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token comment"># ****子进程读数据**** #</span>fifo_path <span class="token operator">=</span> <span class="token string">"/tmp/my_named_pipe"</span><span class="token comment"># 从命名管道读取数据</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>fifo_path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fifo<span class="token punctuation">:</span>    message <span class="token operator">=</span> fifo<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Child process received message: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>message<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment"># 子进程打开相同的管道文件并从中读取消息。这说明命名管道是全双工的，可以在不同的进程间进行通信。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="2-6-2-消息队列（Message-Queue）"><a href="#2-6-2-消息队列（Message-Queue）" class="headerlink" title="2.6.2 消息队列（Message Queue）"></a>2.6.2 消息队列（Message Queue）</h4><p>消息队列是由内核维护的一种数据结构，用于在进程间传递消息。消息队列中的消息按照优先级或发送顺序排队，可以支持多个进程进行通信。</p><ul><li>消息队列是一种基于消息的通信机制，可以支持多对多的通信模式。</li><li>通过消息队列，进程可以通过发送消息和接收消息来进行数据交换。</li><li>它的优势是，进程间通信不需要共享内存，但也会有一定的性能开销。</li></ul><img src="/img/OS/message.svg" alt="消息队列" style="max-width: 100%; height: auto;" /><h4 id="2-6-3-共享内存（Shared-Memory）"><a href="#2-6-3-共享内存（Shared-Memory）" class="headerlink" title="2.6.3 共享内存（Shared Memory）"></a>2.6.3 共享内存（Shared Memory）</h4><p>共享内存是一种效率较高的进程间通信方式，多个进程可以直接访问同一块内存区域。一个进程创建并映射这块共享内存，其他进程可以直接访问该内存区域。</p><ul><li>共享内存允许多个进程共享数据，因此可以显著提高进程间的数据交换效率。</li><li>但由于多个进程可能同时读写共享内存，必须通过信号量等同步机制来保证数据一致性，避免竞争条件和冲突。</li></ul><img src="/img/OS/shared_memory.svg" alt="共享内存" style="max-width: 100%; height: auto;" /><h4 id="2-6-4-信号量（Semaphore）"><a href="#2-6-4-信号量（Semaphore）" class="headerlink" title="2.6.4 信号量（Semaphore）"></a>2.6.4 信号量（Semaphore）</h4><p>信号量是一种同步工具，通常用于控制多个进程对共享资源的访问。信号量内部包含一个计数器，该计数器控制访问共享资源的进程数目。</p><ul><li>信号量常用于控制对共享内存、文件等资源的访问，它可以防止资源竞争。</li><li>信号量有两种类型：<strong>计数信号量</strong>（控制资源的数量）和<strong>二值信号量</strong>（类似于锁，只允许一个进程访问资源）。</li><li>信号量通常与共享内存结合使用，用于保证对临界区的同步和互斥。</li></ul><p>信号量机制非常重要，随后仔细讲解这个内容。</p><img src="/img/OS/semaphore.svg" alt="信号量机制" style="max-width: 100%; height: auto;" /><h4 id="2-6-5-信号（Signal）"><a href="#2-6-5-信号（Signal）" class="headerlink" title="2.6.5 信号（Signal）"></a>2.6.5 信号（Signal）</h4><p>信号是一种异步通知机制，用于向进程发送通知，告知其某个事件已经发生。例如，操作系统可以向进程发送 <code>SIGINT</code> 信号来中断它，或者使用 <code>kill</code> 命令向一个进程发送信号。</p><ul><li>信号是一种非常轻量级的进程间通信方式，适用于通知进程发生了某种事件或请求处理。</li><li>信号通常不会携带大量数据，主要用于进程间的控制和通知。</li></ul><img src="/img/OS/signal.svg" alt="信号通信" style="max-width: 100%; height: auto;" /><h4 id="2-6-6-套接字（Socket）"><a href="#2-6-6-套接字（Socket）" class="headerlink" title="2.6.6 套接字（Socket）"></a>2.6.6 套接字（Socket）</h4><p>套接字是一种广泛用于进程间通信的机制，尤其适用于不同主机之间的通信。通过网络协议，套接字允许不同机器上的进程进行通信。</p><ul><li>套接字不仅可以用于不同主机间的进程间通信，也可以用于本地主机上的进程间通信。</li><li>套接字可以是<strong>面向连接的</strong>（如 TCP 套接字）或<strong>无连接的</strong>（如 UDP 套接字），适用于不同的应用场景。</li><li>它是进程间通信中最为通用和灵活的一种方式，尤其在分布式系统中具有重要作用。</li></ul><img src="/img/OS/socket.svg" alt="套接字" style="max-width: 100%; height: auto;" /><hr><p>总的来说，这些通信方式有下面的应用场景。</p><ul><li><strong>管道</strong>适用于父子进程的单向通信。</li><li><strong>消息队列</strong>适合需要按消息传递数据的多进程场景。</li><li><strong>共享内存</strong>提供高效的跨进程数据共享，但需要同步机制来保证数据一致性。</li><li><strong>信号量</strong>用于控制对共享资源的访问，并且用于进程间的同步与互斥。</li><li><strong>信号</strong>是一种简单的异步通信机制，用于进程间的通知。</li><li><strong>套接字</strong>是最通用的进程间通信机制，尤其在网络编程中得到广泛应用。</li></ul><h3 id="2-7-进程间的并发和同步"><a href="#2-7-进程间的并发和同步" class="headerlink" title="2.7 进程间的并发和同步"></a>2.7 进程间的并发和同步</h3><p>操作系统中的并发控制主要涉及多个进程或线程在共享资源时如何协调与管理，以避免冲突和问题。首先需要熟悉下面的几个概念：</p><h4 id="2-7-1-临界区（Critical-Section）"><a href="#2-7-1-临界区（Critical-Section）" class="headerlink" title="2.7.1. 临界区（Critical Section）"></a>2.7.1. 临界区（Critical Section）</h4><ul><li><strong>背景</strong>：  多个进程或线程需要访问共享资源（如内存、文件、设备等）时，为了防止并发访问导致数据错误，需要对访问过程进行限制。临界区是程序中可能发生资源竞争的部分，需要特殊保护。</li></ul><img src="/img/OS/critical_section.svg" alt="临界区" style="max-width: 100%; height: auto;" /><h4 id="2-7-2-互斥（Mutual-Exclusion）"><a href="#2-7-2-互斥（Mutual-Exclusion）" class="headerlink" title="2.7.2 互斥（Mutual Exclusion）"></a>2.7.2 互斥（Mutual Exclusion）</h4><ul><li><strong>背景</strong>：  为了解决共享资源访问冲突的问题，互斥保证任何时刻只有一个进程或线程可以进入临界区。  </li><li><strong>常见的实现方式</strong>：  <ul><li><strong>锁（Locks）</strong>  </li><li><strong>信号量（Semaphores）</strong>  </li><li><strong>监视器（Monitors）</strong></li></ul></li></ul><h4 id="2-7-3-死锁（Deadlock）"><a href="#2-7-3-死锁（Deadlock）" class="headerlink" title="2.7.3 死锁（Deadlock）"></a>2.7.3 死锁（Deadlock）</h4><ul><li><strong>背景</strong>：  死锁问题发生在资源分配和进程调度的场景中。当多个进程在相互等待对方释放资源时，系统进入无法继续运行的状态。  </li><li><strong>避免死锁需要使用特定的资源分配算法和机制</strong>：  <ul><li><strong>银行家算法（Banker’s Algorithm）</strong></li></ul></li></ul><h4 id="2-7-4-饥饿（Starvation）"><a href="#2-7-4-饥饿（Starvation）" class="headerlink" title="2.7.4 饥饿（Starvation）"></a>2.7.4 饥饿（Starvation）</h4><ul><li><strong>背景</strong>：  在资源分配和调度策略不公平的情况下，有些进程可能长时间得不到资源，无法执行。这种问题称为饥饿。  </li><li><strong>为了避免饥饿，需要使用公平的调度算法，确保每个进程都有机会进入临界区</strong>：  <ul><li><strong>先到先服务（FCFS）调度</strong>  </li><li><strong>动态优先级调整</strong></li></ul></li></ul><h4 id="2-7-5-信号（Signals）"><a href="#2-7-5-信号（Signals）" class="headerlink" title="2.7.5 信号（Signals）"></a>2.7.5 信号（Signals）</h4><ul><li><strong>背景</strong>：  信号是一种异步通信机制，用于通知进程某个事件的发生。例如，使用<code>kill</code>命令发送信号。</li><li><strong>应用</strong>： 常用于进程终止、定时器中断、资源耗尽等场景。</li></ul><h4 id="2-7-6-线程同步（Thread-Synchronization）"><a href="#2-7-6-线程同步（Thread-Synchronization）" class="headerlink" title="2.7.6 线程同步（Thread Synchronization）"></a>2.7.6 线程同步（Thread Synchronization）</h4><ul><li><strong>背景</strong>：  在多线程环境中，线程之间的同步与进程同步类似，但由于线程共享相同的内存地址空间，面临的问题和解决方案略有不同。</li><li><strong>实现方式</strong>：<ul><li><strong>互斥锁（Mutexes）</strong></li><li><strong>条件变量（Condition Variables）</strong></li><li><strong>读写锁（Read-Write Locks）</strong></li></ul></li></ul><h4 id="2-7-7-条件变量（Condition-Variables）"><a href="#2-7-7-条件变量（Condition-Variables）" class="headerlink" title="2.7.7 条件变量（Condition Variables）"></a>2.7.7 条件变量（Condition Variables）</h4><ul><li><strong>背景</strong>：  条件变量用于在线程之间实现复杂的同步机制，通过等待某一条件为真后再继续执行。</li><li><strong>应用</strong>： 常与互斥锁配合使用，解决生产者-消费者问题等。</li></ul><h4 id="2-7-8-自旋锁（Spin-Locks）"><a href="#2-7-8-自旋锁（Spin-Locks）" class="headerlink" title="2.7.8 自旋锁（Spin Locks）"></a>2.7.8 自旋锁（Spin Locks）</h4><ul><li><strong>背景</strong>：  自旋锁是一种忙等待的锁机制，用于保护短时间临界区。</li><li><strong>应用</strong>： 适用于临界区非常短且线程切换开销较大的情况。</li></ul><h4 id="2-7-9-信号量（Semaphores）"><a href="#2-7-9-信号量（Semaphores）" class="headerlink" title="2.7.9 信号量（Semaphores）"></a>2.7.9 信号量（Semaphores）</h4><ul><li><strong>背景</strong>：  信号量用于控制对资源的访问，支持同步和互斥机制。</li><li><strong>类型</strong>：<ul><li><strong>二进制信号量（Binary Semaphores）</strong>： 类似于互斥锁。</li><li><strong>计数信号量（Counting Semaphores）</strong>： 允许多个线程访问一定数量的资源。</li></ul></li></ul><p>以上概念是操作系统中<strong>并发程序设计和同步机制</strong>的核心问题，旨在协调多进程或线程的资源访问，确保系统的正确性和高效性。有了以上的背景，我们再来解决操作系统中进程同步互斥的经典问题如：</p><ul><li>生产者-消费者问题（Producer-Consumer Problem）</li><li>读者-写者问题（Readers-Writers Problem）</li><li>哲学家进餐问题（Dining Philosophers Problem）</li></ul><hr><h3 id="2-7-进程互斥"><a href="#2-7-进程互斥" class="headerlink" title="2.7 进程互斥"></a>2.7 进程互斥</h3><p>在操作系统中，<strong>进程互斥（Mutual Exclusion）</strong> 是确保多个进程在访问共享资源时不发生冲突的关键概念。互斥的目的是防止并发进程同时进入临界区（Critical Section），以避免数据不一致和其他错误。</p><h4 id="2-7-1-进程互斥的软件实现方法"><a href="#2-7-1-进程互斥的软件实现方法" class="headerlink" title="2.7.1 进程互斥的软件实现方法"></a>2.7.1 进程互斥的软件实现方法</h4><p>在操作系统中，为了解决多个进程共享资源时的互斥问题，可以通过<strong>标志检查算法</strong>实现互斥控制。以下是几种经典的软件实现方法：</p><hr><p><strong>1️⃣ 单标志法（Single Flag Method）</strong></p><ul><li>使用一个共享的布尔标志表示是否有进程正在执行临界区。  </li><li>如果标志为真，则其他进程必须等待，直到标志变为假。</li></ul><p><strong>代码示例：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 等待临界区空闲</span>    critical section<span class="token punctuation">;</span>    <span class="token comment">// 进入临界区</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 交出控制权</span>    remainder section<span class="token punctuation">;</span>   <span class="token comment">// 进入剩余区</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>单标志法</strong>存在的问题是：</p><ul><li>访问顺序固定为 0 → 1 → 0 → 1…，不满足空闲让进原则。</li><li>当临界区空闲且 P0 未进入时，P1 仍无法进入，导致资源浪费。</li></ul><hr><p><strong>2️⃣ 双标志先检查法（Two Flags, Check First Method）</strong></p><ul><li>每个进程都有一个标志，表示它是否希望进入临界区。</li><li>进程在进入临界区前检查对方的标志，确保对方不需要进入临界区时才进入。</li></ul><p><strong>代码示例：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// flag[i] = true 表示进程 i 想进入临界区</span><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 检查对方标志</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment">// 设置自己的标志</span>    critical section<span class="token punctuation">;</span>  <span class="token comment">// 进入临界区</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>   <span class="token comment">// 离开时清除标志</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>双标志先检查法</strong>存在的问题是：</p><ul><li>如果 P0 在退出 while 循环后，标志尚未设置为 true 时被切换，P1 也可能进入临界区，导致不满足忙则等待原则。</li></ul><hr><p><strong>3️⃣ 双标志后检查法（Two Flags, Check Afterwards Method）</strong></p><ul><li>在设置自己的标志后，再检查对方的标志。</li><li>如果对方不需要进入临界区，当前进程即可进入。</li></ul><p><strong>示例代码：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>     <span class="token comment">// 先设置自己的标志</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 后检查对方标志</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>双标志后检查法</strong>存在的问题是：</p><ul><li>可能导致饥饿问题：如果两个进程交替设置标志，低优先级进程可能一直无法进入临界区。</li></ul><hr><p><strong>4️⃣ Peterson 算法（Peterson’s Algorithm）</strong></p><ul><li>通过两个共享变量实现互斥：<ul><li>flag[2] 表示每个进程是否希望进入临界区。</li><li>turn 表示轮到哪个进程进入临界区。</li></ul></li><li>设置自己的标志后，将进入权交给对方，主动等待对方进入临界区。</li></ul><p><strong>代码示例：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token comment">// 设置自己的标志</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">// 让出优先权</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待对方离开或轮到自己</span>    critical section<span class="token punctuation">;</span>      <span class="token comment">// 进入临界区</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>       <span class="token comment">// 离开时清除标志</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>Peterson 算法</strong>的优缺点有：</p><ul><li>优点<ul><li>满足互斥性：任意时刻只有一个进程能进入临界区。</li><li>避免死锁：两个进程不会无限等待。</li><li>满足空闲让进原则：当临界区空闲时，进程可立即进入。</li></ul></li><li>缺点<ul><li>仅适用于两个进程的场景。</li><li>扩展到多进程环境时，算法会变得复杂。</li></ul></li></ul><hr><p>简单总结一下以上进程互斥的软件实现方法</p><table><thead><tr><th>方法</th><th>优点</th><th>问题或缺点</th></tr></thead><tbody><tr><td>单标志法</td><td>简单易实现</td><td>可能导致竞态条件，不满足空闲让进原则</td></tr><tr><td>双标志先检查法</td><td>避免竞态条件</td><td>不满足忙则等待原则，可能导致数据竞争</td></tr><tr><td>双标志后检查法</td><td>避免死锁</td><td>可能导致饥饿问题</td></tr><tr><td>Peterson 算法</td><td>满足互斥性、避免死锁和饥饿，符合互斥原则</td><td>仅适用于两个进程的互斥场景</td></tr></tbody></table><h4 id="2-7-2-进程互斥的硬件实现方法"><a href="#2-7-2-进程互斥的硬件实现方法" class="headerlink" title="2.7.2 进程互斥的硬件实现方法"></a>2.7.2 进程互斥的硬件实现方法</h4><p><strong>1.禁止中断（Disable Interrupts）</strong></p><ul><li>机制：<br>在单处理器系统中，进程在进入临界区之前，通过禁用中断来保证它不被打断。这意味着在执行关键代码时，不会发生上下文切换，也就避免了其他进程同时访问共享资源的可能性。</li><li>优点：<ul><li>简单且易于实现。</li><li>在单处理器环境下，可以有效地防止竞态条件（Race Condition）。</li></ul></li><li>缺点：<ul><li>仅适用于单处理器系统：在多处理器系统中，禁止一个处理器的中断并不能阻止其他处理器访问共享资源。</li><li>影响系统响应性：如果进程在临界区花费较长时间，系统将无法及时响应硬件中断（如 I&#x2F;O 事件），可能导致性能问题。</li><li>不适合用户程序：只有操作系统（内核）才能控制中断，普通用户进程无法使用这一方法。</li></ul></li><li>适用场景：小型、实时性要求不高的单处理器系统。</li></ul><p>禁止中断通常由操作系统的内核代码实现。以下是一个伪代码示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 单处理器系统伪代码</span><span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">disable_interrupts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 禁止中断</span>        <span class="token comment">// 临界区代码</span>    shared_resource<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">enable_interrupts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 恢复中断</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>注意：</p><ul><li><code>disable_interrupts() </code>和 <code>enable_interrupts() </code>是硬件相关的低级操作，不适用于用户态程序。</li><li>这种方法仅用于单处理器环境。</li></ul><hr><p><strong>2.特殊机器指令（Special Machine Instructions）</strong></p><p>机制：</p><ul><li>现代硬件通常提供特殊指令来帮助实现进程互斥。这些指令能够在单个不可中断的原子操作中完成对共享内存位置的读取和修改。</li><li>常见的指令包括：<ul><li>测试并设置（Test and Set）：<ul><li>功能：检查一个变量的值是否为 0（或特定值），如果是则设置为 1，并返回原来的值。</li><li>应用：可以用它来实现一个简单的锁。</li></ul></li><li>交换（Swap）：<ul><li>功能：交换两个内存单元的值，保证操作是原子的。</li><li>应用：常用于实现信号量或互斥锁。</li></ul></li></ul></li></ul><p>优点：</p><ul><li>高效：不需要禁用中断，能在多处理器系统中使用。</li><li>硬件支持：这些指令的设计初衷就是为了解决同步问题。</li></ul><p>缺点：</p><ul><li>忙等待（Busy Waiting）：使用这些指令实现的锁通常基于自旋锁（Spinlock），可能导致等待进程一直占用 CPU（忙等），浪费计算资源。</li><li>增加硬件复杂性：硬件必须支持这些指令。</li><li>适用场景：<ul><li>多处理器系统。</li><li>临界区很短、避免禁用中断的情况下。</li></ul></li></ul><p>以下是使用 Test and Set 指令实现锁的示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 使用 Test and Set 指令实现的锁</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">lock_t</span><span class="token punctuation">;</span><span class="token class-name">lock_t</span> lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 0 表示未加锁，1 表示已加锁</span><span class="token keyword">int</span> <span class="token function">test_and_set</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token operator">*</span>lock<span class="token punctuation">;</span>    <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 将锁设置为 1</span>    <span class="token keyword">return</span> old<span class="token punctuation">;</span> <span class="token comment">// 返回原来的值</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">test_and_set</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 自旋等待</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加锁</span>        <span class="token comment">// 临界区代码</span>    shared_resource<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>说明：</p><ul><li><code>test_and_set() </code>是一个不可中断的原子操作，硬件确保其操作的原子性。</li><li>如果锁已被占用，进程会在循环中等待（自旋锁）。</li></ul><hr><p><strong>3.原子操作（Atomic Operations）</strong></p><p>机制：</p><ul><li>原子操作指的是在执行时不会被中断的一系列操作。这些操作通常是通过硬件或特殊指令实现的，确保即使多个进程或线程同时访问共享变量，操作的结果仍然是可预测的。</li><li>应用中最常见的是信号量和互斥锁的实现。</li><li>原子操作的核心是“不可分割性”：一次性完成对共享资源的修改，防止竞态条件。</li></ul><p>常见例子：</p><ul><li>增&#x2F;减操作：如 atomic_increment() 或 atomic_decrement()。</li><li>比较并交换（Compare and Swap, CAS）：<ul><li>功能：比较内存中的值和给定值，如果相等，则将内存中的值替换为新值。</li><li>应用：用于实现无锁数据结构。</li></ul></li></ul><p>优点：</p><ul><li>不需要禁用中断，适用于多处理器系统。</li><li>性能高效：适合在时间关键的并发操作中使用。</li></ul><p>缺点：</p><ul><li>与忙等待类似，使用不当可能导致资源浪费。</li><li>需要硬件支持，且某些复杂的原子操作可能受限于硬件实现。</li></ul><p>适用场景：</p><ul><li>多线程或多进程的同步场景，特别是当需要实现高性能无锁数据结构时。</li></ul><p>使用<strong>Compare and Swap (CAS)</strong> 指令实现锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 使用 Compare and Swap 实现锁</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">lock_t</span><span class="token punctuation">;</span><span class="token class-name">lock_t</span> lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 0 表示未加锁，1 表示已加锁</span><span class="token keyword">int</span> <span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span> <span class="token keyword">int</span> new_value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token operator">*</span>addr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>old <span class="token operator">==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>addr <span class="token operator">=</span> new_value<span class="token punctuation">;</span> <span class="token comment">// 将值替换为 new_value</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> old<span class="token punctuation">;</span> <span class="token comment">// 返回旧值</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 自旋等待</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加锁</span>        <span class="token comment">// 临界区代码</span>    shared_resource<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>说明：</p><ul><li>compare_and_swap() 是一个硬件提供的原子操作。</li><li>当 lock 的值是期望值（expected）时，才会将其更新为新值（new_value）。</li><li>CAS 在实现无锁数据结构时非常常用。</li></ul><hr><p>总结一下：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>关键代码</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>禁止中断</td><td><code>disable_interrupts()</code></td><td>简单，适合单处理器系统</td><td>不适合多处理器，影响响应性</td></tr><tr><td>Test and Set</td><td><code>test_and_set(lock)</code></td><td>高效，适合多处理器系统</td><td>忙等待，自旋可能浪费资源</td></tr><tr><td>Compare and Swap</td><td><code>compare_and_swap(lock)</code></td><td>强大灵活，可用于无锁数据结构</td><td>忙等待，需要硬件支持</td></tr></tbody></table><h3 id="2-8-信号量机制"><a href="#2-8-信号量机制" class="headerlink" title="2.8 信号量机制"></a>2.8 信号量机制</h3><p><strong>信号量（Semaphore）</strong> 是一种用于同步进程或线程的机制，确保多个进程或线程可以安全、协调地访问共享资源。它通常用于解决临界区（Critical Section）问题。</p><p>信号量是一种整型变量，表示资源的可用数量。信号量分为两种类型：</p><ul><li>计数信号量（Counting Semaphore）：其值可以任意增减，通常用于管理多个相同的资源。</li><li>二进制信号量（Binary Semaphore）：其值只能为0或1，类似于互斥锁（Mutex）。</li></ul><hr><h4 id="2-8-1-信号量机制中的PV操作"><a href="#2-8-1-信号量机制中的PV操作" class="headerlink" title="2.8.1 信号量机制中的PV操作"></a>2.8.1 信号量机制中的PV操作</h4><p><strong>1. P操作（Proberen，Test）：</strong></p><ul><li>功能：试图获取信号量。将信号量的值减1。</li><li>逻辑：如果信号量的值大于0，表示有可用资源，继续执行。否则，进程进入等待状态，直到信号量的值大于0。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token keyword">while</span> S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token operator">:</span>        wait    S <span class="token operator">=</span> S <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>2. V操作（Verhogen，Increment）：</strong></p><ul><li>功能：释放信号量。将信号量的值加1。</li><li>逻辑：表示释放一个资源。如果有进程在等待信号量，该操作会唤醒其中一个进程.</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">:</span>    S <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>下面是使用Python实现的一个简单示例，演示如何使用信号量控制对共享资源的访问。假设我们有一个共享计数器，需要多个线程安全地访问。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token comment"># 定义一个信号量，初始值为1（相当于一个互斥锁）</span>semaphore <span class="token operator">=</span> threading<span class="token punctuation">.</span>Semaphore<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>counter <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 共享资源</span><span class="token comment"># 定义一个函数，使用信号量控制访问共享资源</span><span class="token keyword">def</span> <span class="token function">safe_increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> counter    <span class="token keyword">with</span> semaphore<span class="token punctuation">:</span>  <span class="token comment"># P操作，获取信号量</span>        temp <span class="token operator">=</span> counter        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>  <span class="token comment"># 模拟一些操作</span>        counter <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Counter value: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>counter<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token comment"># 创建多个线程</span>threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>safe_increment<span class="token punctuation">)</span>    threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 等待所有线程完成</span><span class="token keyword">for</span> t <span class="token keyword">in</span> threads<span class="token punctuation">:</span>    t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Final counter value: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>counter<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个示例中，信号量<code>semaphore</code>控制对共享资源<code>counter</code>的访问。每个线程在进入临界区前都会调用P操作（即<code>with semaphore</code>语句），在离开临界区时自动调用V操作（即退出<code>with</code>块）。</p><p>看一个更直观的示例代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-Cpp" data-language="Cpp"><code class="language-Cpp">Semaphore S &#x3D; 0;void P1()&#123;    code 1;    code 2;    V(S);    code 3;&#125;void P2()&#123;    P(S);    code 4;    code 5;    code 6;&#125;&#x2F;&#x2F; 这样P1先执行，P2后执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-9-经典同步互斥问题"><a href="#2-9-经典同步互斥问题" class="headerlink" title="2.9 经典同步互斥问题"></a>2.9 经典同步互斥问题</h3><p>操作系统中的同步与互斥问题涉及多个进程或线程在共享资源上的访问协调。它们解决了并发执行时资源共享所可能引发的冲突，确保系统的正确性和稳定性。</p><ol><li>同步问题（Synchronization）：<br>同步问题是指多个进程或线程需要按照某种顺序或时序执行，确保彼此之间的操作能够协调一致。同步的目的是保证特定的操作在适当的时机执行，以避免竞争条件和不一致状态。</li><li>互斥问题（Mutual Exclusion）：<br>互斥问题是指多个进程或线程在访问共享资源时，必须保证在同一时刻只有一个进程或线程能够访问该资源，避免冲突和不一致。</li></ol><p>假设两个线程 A 和 B 都需要访问一个共享的文件资源：</p><ul><li>同步：假如 A 必须在 B 完成某个任务后才能开始自己的任务，这时需要同步。</li><li>互斥：如果 A 和 B 同时修改文件内容，就需要互斥，确保只有一个线程可以修改文件。</li></ul><hr><h4 id="2-9-1-生产者-消费者问题（Producer-Consumer-Problem）"><a href="#2-9-1-生产者-消费者问题（Producer-Consumer-Problem）" class="headerlink" title="2.9.1 生产者-消费者问题（Producer-Consumer Problem）"></a>2.9.1 生产者-消费者问题（Producer-Consumer Problem）</h4><p>生产者-消费者问题描述了两个进程（或线程）之间的协调，一个是生产者，负责生产数据；另一个是消费者，负责消费数据。这个问题的核心是在生产者和消费者之间通过一个缓冲区（Buffer）进行数据传递，生产者和消费者必须正确同步，避免数据丢失或缓冲区溢出。以下是该问题的关键点：</p><ol><li><p>缓冲区：生产者将生产的数据放入缓冲区，而消费者从缓冲区中取出数据。当缓冲区满时，生产者必须等待，直到消费者消耗了数据；当缓冲区空时，消费者必须等待，直到生产者生产了新数据。</p></li><li><p>同步机制：为了避免竞争条件（Race Condition），需要使用同步机制（如信号量、互斥锁或条件变量）来确保生产者和消费者之间的正确协调。例如，信号量（Semaphore）可以控制生产者等待缓冲区有空位，消费者等待缓冲区有数据。</p></li><li><p>阻塞和唤醒：生产者和消费者在相应的条件下进行阻塞（等待）和唤醒（通知）。例如，当缓冲区满时，生产者阻塞；当缓冲区有空位时，唤醒生产者。消费者在缓冲区为空时阻塞；当缓冲区有数据时，唤醒消费者。</p></li></ol><p>下面是一个简化的伪代码示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 信号量初始化</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 表示缓冲区中的数据量</span>semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span>       <span class="token comment">// 表示缓冲区中的空位数（N为缓冲区大小）</span>mutex buffer_mutex<span class="token punctuation">;</span>        <span class="token comment">// 互斥锁，保护缓冲区的访问</span><span class="token comment">// 生产者</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 生产一个数据项</span>        <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 等待空位（empty信号量减1）</span>        <span class="token function">wait</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取缓冲区互斥锁</span>        <span class="token function">put_item_in_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将数据项放入缓冲区</span>        <span class="token function">signal</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 释放缓冲区互斥锁</span>        <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 通知有新的数据（full信号量加1）</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 消费者</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 等待数据（full信号量减1）</span>        <span class="token function">wait</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取缓冲区互斥锁</span>        <span class="token function">remove_item_from_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从缓冲区取出数据项</span>        <span class="token function">signal</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 释放缓冲区互斥锁</span>        <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 通知有新的空位（empty信号量加1）</span>        <span class="token function">consume_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 消费数据项</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><hr><h4 id="2-9-2-读者-写者问题（Readers-Writers-Problem）"><a href="#2-9-2-读者-写者问题（Readers-Writers-Problem）" class="headerlink" title="2.9.2 读者-写者问题（Readers-Writers Problem）"></a>2.9.2 读者-写者问题（Readers-Writers Problem）</h4><p>读者-写者问题是操作系统中的另一个经典同步问题，涉及多线程的并发控制。它描述了多个线程在共享资源（例如数据库或文件）上执行读和写操作时的协调机制。这个问题的关键在于要确保以下几点：</p><ol><li><p>读操作和写操作的互斥：多个读者可以同时读取共享资源，但如果有一个写者正在写，则读者必须等待。同样，当有读者在读时，写者也必须等待。</p></li><li><p>避免饥饿：即使系统中有多个读者和写者，也要确保每个读者和写者都能最终访问到共享资源，避免某些读者或写者长时间无法获得访问权限。</p></li></ol><p>读者-写者问题的两种常见变体是：</p><ul><li><p>优先读者（Reader-Preference）：当有读者请求时，允许读者先行，写者只有在没有读者时才能进行写操作。这样可能会导致写者饥饿。</p></li><li><p>优先写者（Writer-Preference）：当有写者请求时，优先允许写者进行写操作，读者在写者完成后才能读取。这有助于避免写者饥饿，但可能会导致读者饥饿。</p></li></ul><p>以下是一个简单的伪代码示例，展示如何通过信号量（Semaphore）和互斥锁（Mutex）实现读者-写者问题的同步机制：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 信号量和互斥锁初始化</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 保护读者计数器的互斥锁</span>semaphore wrt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 用于写者的信号量</span><span class="token keyword">int</span> readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 记录当前正在读取的读者数量</span><span class="token comment">// 读者</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 进入临界区，保护readcount</span>        readcount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">wait</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 第一个读者阻塞写者</span>        <span class="token punctuation">&#125;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 退出临界区</span>        <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 执行读操作</span>        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 进入临界区</span>        readcount<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 最后一个读者解除写者阻塞</span>        <span class="token punctuation">&#125;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 退出临界区</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 写者</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 请求写操作</span>        <span class="token function">write_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行写操作</span>        <span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 释放写操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><hr><h4 id="2-9-3-哲学家进餐问题（Dining-Philosophers-Problem）"><a href="#2-9-3-哲学家进餐问题（Dining-Philosophers-Problem）" class="headerlink" title="2.9.3 哲学家进餐问题（Dining Philosophers Problem）"></a>2.9.3 哲学家进餐问题（Dining Philosophers Problem）</h4><p>哲学家进餐问题用于展示多线程同步和资源共享的挑战。该问题描述了一组哲学家围坐在一张圆桌旁进餐的情景，他们在吃面条时需要使用筷子，但筷子的数量比哲学家少。</p><p>场景：有五个哲学家（可以是任意数量）围坐在一张圆桌旁，每个哲学家面前有一个碗和两根筷子。每对相邻的哲学家共享一根筷子，因此总共有五根筷子。</p><p>行为：哲学家交替进行思考和吃饭。当哲学家想要吃饭时，他们必须同时拿起左右两边的筷子。如果筷子被其他哲学家使用，则哲学家必须等待。</p><p>问题：如何设计一种机制，使得哲学家能够正确地同步使用筷子，避免死锁（即所有哲学家都在等待筷子，最终无人能吃饭）和饥饿（某个哲学家长时间不能吃饭）。</p><p>下面是一个简化的伪代码示例，展示如何通过互斥锁（Mutex）和条件变量（Condition Variable）实现哲学家进餐问题的同步机制：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 互斥锁和条件变量初始化</span>mutex chopsticks<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 每根筷子一个互斥锁</span><span class="token comment">// 哲学家编号为 0 到 4</span><span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哲学家思考</span>        <span class="token function">wait</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拿起左边的筷子</span>        <span class="token function">wait</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拿起右边的筷子</span>        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哲学家吃面条</span>        <span class="token function">signal</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 放下左边的筷子</span>        <span class="token function">signal</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 放下右边的筷子</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这种简单的方案存在可能的死锁问题，为了避免死锁，可以引入一些改进方法，例如：</p><ol><li><p>规定顺序：规定所有哲学家必须按照某个顺序（如顺时针）拿筷子，从而避免循环等待。</p></li><li><p>允许最多四个哲学家同时拿筷子：限制最多允许四个哲学家同时尝试拿筷子，保证至少有一位哲学家可以吃饭。</p></li><li><p>随机背诵策略：引入随机元素，使哲学家在等待过程中进行随机的思考或其他操作，减少发生死锁的概率。</p></li></ol><hr><h3 id="2-10-管程（Monitor）"><a href="#2-10-管程（Monitor）" class="headerlink" title="2.10 管程（Monitor）"></a>2.10 管程（Monitor）</h3><p>管程是操作系统中一种用于同步并发进程的高级抽象机制，它为多线程程序提供了一种结构化的方法来管理共享资源的访问。通过管程，可以避免一些常见的并发问题，如死锁和资源竞争。</p><p>以下是管程的主要特点和工作原理：</p><ol><li><p>封装共享资源：管程封装了共享资源（如变量、数据结构等）以及访问这些资源的代码。只有通过调用管程中的方法，才能对共享资源进行访问，这样可以确保对资源的控制。</p></li><li><p>互斥访问：管程内部使用互斥锁（Mutex）来确保同一时间只有一个线程能够执行管程中的代码。这种互斥访问机制可以避免多个线程同时访问共享资源时产生的不一致性。</p></li><li><p>条件变量：管程中引入了条件变量（Condition Variable）来管理线程的等待和唤醒。线程可以在某个条件不满足时等待，并在条件满足时被唤醒。条件变量通常与互斥锁配合使用，以确保对条件的检查和修改是原子操作。</p></li><li><p>简化同步代码：使用管程可以将同步操作封装在管程内，使得并发程序的代码更加简洁和易于维护。这样，开发者不必直接处理低级别的锁和信号量，而是通过调用管程的方法进行同步。</p></li></ol><p>以下是一个简化的伪代码示例，展示如何使用管程来管理共享缓冲区的生产者-消费者问题：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">monitor Buffer <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> buffer<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 共享缓冲区</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 当前缓冲区中的数据数量</span>    condition notFull<span class="token punctuation">;</span>     <span class="token comment">// 缓冲区未满的条件变量</span>    condition notEmpty<span class="token punctuation">;</span>    <span class="token comment">// 缓冲区未空的条件变量</span>    <span class="token comment">// 生产者方法</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 缓冲区满，等待</span>            <span class="token function">wait</span><span class="token punctuation">(</span>notFull<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        buffer<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>notEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知消费者缓冲区非空</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 消费者方法</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 缓冲区空，等待</span>            <span class="token function">wait</span><span class="token punctuation">(</span>notEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> item <span class="token operator">=</span> buffer<span class="token punctuation">[</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>notFull<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 通知生产者缓冲区未满</span>        <span class="token keyword">return</span> item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><hr><h3 id="2-11-死锁的产生和处理"><a href="#2-11-死锁的产生和处理" class="headerlink" title="2.11 死锁的产生和处理"></a>2.11 死锁的产生和处理</h3><p><strong>死锁（Deadlock）</strong> 是操作系统中一种常见的并发问题，它发生在两个或多个进程（或线程）彼此等待对方释放资源，从而导致所有进程都无法继续执行的状态。简单来说，死锁是指一种资源争夺的僵局，进程永远无法获得所需的资源，导致系统停滞。</p><p>为了更好地理解死锁，假设有两个进程 $P_1$ 和 $P_2$ ，它们分别需要资源 $R_1$ 和 $R_2$ 来执行任务。以下情况可能导致死锁：</p><ul><li><p>资源保持和等待：进程 $P_1$ 已经持有资源 $R_1$，并请求资源 $R_2$ 但未获得；与此同时，进程 $P_2$ 已经持有资源 $R_2$，并请求资源 $R_1$ 但未获得。</p></li><li><p>循环等待：由于进程之间互相等待对方释放资源，形成了循环等待链。即 $P_1$ 等待 $P_2$ 释放资源 $R_2$，而 $P_2$ 等待 $P_1$ 释放资源 $R_1$。</p></li></ul><p>以下是一个简单的伪代码示例，展示了两个进程之间如何由于资源请求的顺序导致死锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 假设有两个资源 R1 和 R2，以及两个进程 P1 和 P2</span><span class="token comment">// 进程 P1</span><span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R1</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R2</span>    <span class="token comment">// 执行某些操作</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R2</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R1</span><span class="token punctuation">&#125;</span><span class="token comment">// 进程 P2</span><span class="token keyword">void</span> <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R2</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R1</span>    <span class="token comment">// 执行某些操作</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R1</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R2</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个示例中，进程 P1 先请求资源 R1，然后请求资源 R2；而进程 P2 先请求资源 R2，然后请求资源 R1。如果 P1 已经持有 R1 并且 P2 已经持有 R2，则 P1 会等待 R2，而 P2 会等待 R1，形成一个死锁循环，导致两个进程都无法继续执行。</p><p>在理解死锁的时候还要区分其他两个概念：</p><ol><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先 （SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”<br>而发生长进程</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是<br>程序员故意设计的。</li></ol><hr><h4 id="2-11-1-死锁产生的条件"><a href="#2-11-1-死锁产生的条件" class="headerlink" title="2.11.1 死锁产生的条件"></a>2.11.1 死锁产生的条件</h4><p>死锁的形成通常需要满足以下四个必要条件：</p><ul><li><p>互斥（Mutual Exclusion）：每个资源在一个时刻只能由一个进程使用。</p></li><li><p>保持并等待（Hold and Wait）：一个进程已经持有一个资源，并且等待其他资源的释放。</p></li><li><p>不可剥夺（No Preemption）：资源不能被强制从进程中剥夺，必须由持有进程主动释放。</p></li><li><p>循环等待（Circular Wait）：存在一组进程，每个进程都在等待资源，而这些资源正被这组中的其他进程持有。</p></li></ul><p>所有，可以有一个结论：发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p><h4 id="2-11-2-死锁常见问题"><a href="#2-11-2-死锁常见问题" class="headerlink" title="2.11.2 死锁常见问题"></a>2.11.2 死锁常见问题</h4><blockquote><p>问： 什么时候会发生死锁？</p></blockquote><ol><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的p操作在实现同步的p操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资<br>源）</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h4 id="2-11-3-死锁的处理策略"><a href="#2-11-3-死锁的处理策略" class="headerlink" title="2.11.3 死锁的处理策略"></a>2.11.3 死锁的处理策略</h4><p>处理死锁通常有有如下3种策略：</p><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><hr><p>先讲第1点，<strong>预防死锁</strong>策略主要是通过破坏死锁产生的四个必要条件中的一个或几个来实现。以下是具体的预防策略：</p><ol><li><strong>破坏互斥条件（Mutual Exclusion）：</strong></li></ol><p>这个策略很难完全实现，因为大部分资源都是互斥性的（例如打印机、文件）。但可以尝试将某些资源变为可共享的，例如只读文件可以同时被多个进程访问。这里可以了解一下SPOOLing技术</p><blockquote><p>SPOOLing技术：把独占设备在逻辑上改造成共享设备, 将输出传输到输出进程， 进程端视作完成了输出（打印机）</p></blockquote><img src="/img/OS/spooling.svg" alt="Spooling技术" style="max-width: 100%; height: auto;" /><ol start="2"><li><strong>破坏保持并等待条件（Hold and Wait）：</strong></li></ol><p>方案一： 进程请求新的资源得不到满足时， 它必须释放所保持的所有资源， 待以后需要时重新申请。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p><p>该策略的缺点：</p><ul><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ul><ol start="3"><li><strong>破坏不可剥夺条件（No Preemption）：</strong></li></ol><p>允许操作系统强制性地从进程中剥夺资源。如果一个进程请求某个资源但被拒绝，操作系统可以强制释放进程已持有的资源，使其他进程可以使用这些资源。</p><p>这个策略实现简单，但也有缺点：</p><ul><li>有些资源可能需要用很短的时间， 因此如果进程运行期间一直保持， 造成了严重的资源浪费，资源利用率低。</li><li>另外，该策略也有可能导致某些进程饥饿。</li></ul><ol start="4"><li><strong>破坏循环等待条件（Circular Wait）：</strong></li></ol><p>给所有资源定义一个线性顺序，并要求进程按这个顺序请求资源。即进程只能在获得序号较小的资源后，才能请求序号较大的资源。这可以有效避免形成循环等待链。</p><p>该策略的缺点：</p><ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号。</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费。</li><li>必须按规定次序申请资源，用户编程麻烦。</li></ul><hr><p>现在讲解一下处理死锁的第二种策略，也就是<strong>避免死锁</strong>。我们引入一个银行家算法的策略。</p><p><strong>银行家算法（Banker’s Algorithm）</strong> 是由艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）提出的一种避免死锁的算法，主要用于资源分配系统。它通过模拟银行家为客户分配贷款的过程，判断系统是否会进入不安全状态，从而避免死锁的发生。</p><p>以下是银行家算法的基本原理和步骤：</p><ol><li><p>基本原理：银行家算法假设系统中的每个进程都会声明最大资源需求，并且在实际运行过程中不会超过这个声明。系统在每次资源分配时，都会检查分配后的状态是否安全。如果发现资源分配会导致系统进入不安全状态（即可能发生死锁），则拒绝分配请求。</p></li><li><p>关键概念：</p><ul><li><p>最大需求矩阵（Maximum Need Matrix）：表示每个进程可能需要的最大资源数量。</p></li><li><p>分配矩阵（Allocation Matrix）：表示当前已经分配给每个进程的资源数量。</p></li><li><p>需求矩阵（Need Matrix）：表示每个进程还需要的资源数量，计算公式为：Need &#x3D; Maximum - Allocation。</p></li><li><p>可用资源向量（Available Vector）：表示系统当前可用的资源数量。</p></li></ul></li><li><p>算法步骤：</p><ul><li><p>初始化：根据系统状态，初始化最大需求矩阵、分配矩阵、需求矩阵和可用资源向量。</p></li><li><p>资源请求：当进程请求资源时，系统会执行以下步骤：</p><ul><li><p>检查请求是否小于等于进程的最大需求（Request ≤ Need）。</p></li><li><p>检查请求是否小于等于系统的可用资源（Request ≤ Available）。</p></li></ul></li><li><p>模拟分配：系统假设满足进程的请求，并更新相应的矩阵和向量：</p><ul><li><p>Available &#x3D; Available - Request</p></li><li><p>Allocation &#x3D; Allocation + Request</p></li><li><p>Need &#x3D; Need - Request</p></li></ul></li></ul></li><li><p>安全性检查：使用安全性算法（Safety Algorithm）检查系统是否处于安全状态。如果系统仍然处于安全状态，则分配请求得到满足；否则，撤销模拟分配，拒绝请求。</p></li></ol><p><strong>示例</strong> ：假设系统有如下资源：</p><ul><li><p>总资源：$[10, 5, 7]$</p></li><li><p>可用资源：$[3, 3, 2]$</p></li></ul><p>最大需求矩阵：</p><p>$$\left[<br>\begin{matrix}<br>7 &amp; 5 &amp; 3\\<br>3 &amp; 2 &amp; 2 \\<br>9 &amp; 0 &amp; 2 \\<br>2 &amp; 2 &amp; 2 \\<br>4 &amp; 3 &amp; 3<br>\end{matrix}<br>\right]<br>$$</p><p>分配矩阵：</p><p>$$\left[<br>\begin{matrix}<br>0 &amp; 1 &amp; 0\\<br>2 &amp; 0 &amp; 0 \\<br>3 &amp; 0 &amp; 2 \\<br>2 &amp; 1 &amp; 1 \\<br>0 &amp; 0 &amp; 2<br>\end{matrix}<br>\right]<br>$$</p><p>需求矩阵（通过最大需求矩阵和分配矩阵计算得到）：</p><p>$$\left[<br>\begin{matrix}<br>7 &amp; 4 &amp; 3\\<br>1 &amp; 2 &amp; 2 \\<br>6 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 1 \\<br>4 &amp; 3 &amp; 1<br>\end{matrix}<br>\right]<br>$$</p><p>当一个进程请求资源时，银行家算法会检查系统是否能够在分配资源后保持安全状态，以避免死锁。我们就手动模拟给进程分配资源，然后进程结束收回资源，找到这样一个安全的进程序列的话，那么死锁就可以避免。</p><img src="/img/OS/bankers.svg" alt="银行家算法" style="max-width: 100%; height: auto;" /><hr><p>现在我们分析处理死锁的第三种策略：<strong>死锁的检测和解除</strong></p><img src="/img/OS/deadlock.svg" alt="死锁检测" style="max-width: 100%; height: auto;" /><p>在这个图中的死锁环路形成过程如下：</p><ol><li>P3已获得R2资源（绿色实线），同时请求R3资源（红色虚线）</li><li>R3已被分配给P4（绿色实线）</li><li>P4已获得R3，同时请求R2资源（红色虚线）</li><li>R2已被分配给P3（回到第1步）</li></ol><p>这形成了一个循环等待：P3等待P4释放R3，而P4等待P3释放R2。由于每个进程都在等待其他进程释放资源，且都不会主动释放自己持有的资源，因此形成了死锁。检测到这种循环等待关系，就意味着检测到了死锁的存在。</p><p>我们有如下的死锁的解决办法：</p><ol><li><p><strong>资源剥夺（Resource Preemption）：</strong> 通过强制性剥夺资源，可以打破循环等待链。例如，在图中的死锁情况下，可以选择剥夺 P3 持有的 R2 或剥夺 P4 持有的 R3，然后重新分配这些资源，从而打破死锁。</p></li><li><p><strong>终止进程（Process Termination）：</strong> 逐一终止进程是比较直接的方法。例如，首先终止 P3，使得 R2 被释放出来，然后 P4 就可以获得 R2，从而打破死锁链。</p></li><li><p><strong>资源回收（Resource Reclamation）：</strong> 强制进程在某个时间点释放资源（例如通过定时器），可以暂时打破资源占用状态，使得其他进程有机会获得资源。例如，要求 P3 或 P4 在一定时间段内释放资源，从而避免长时间的死锁状态。</p></li></ol><h2 id="3-Memory-Management"><a href="#3-Memory-Management" class="headerlink" title="3. Memory Management"></a>3. Memory Management</h2><p>本章讲解操作系统中的内存管理，主要的重点在虚实地址转换，段页式管理方式，以及页面置换算法。在了解虚实地址转换之前，首先要辨别虚拟地址和物理地址的概念。</p><p>在操作系统中，虚拟地址（<strong>Virtual Address</strong>）和物理地址（<strong>Physical Address</strong>）是两种不同层级的地址，它们涉及到内存管理的不同方面。理解这两个概念非常重要，因为它们与内存的访问、分配以及操作系统如何管理硬件资源密切相关。</p><h4 id="3-1-虚拟地址（Virtual-Address）与物理地址（Physical-Address）"><a href="#3-1-虚拟地址（Virtual-Address）与物理地址（Physical-Address）" class="headerlink" title="3.1 虚拟地址（Virtual Address）与物理地址（Physical Address）"></a>3.1 虚拟地址（Virtual Address）与物理地址（Physical Address）</h4><p>虚拟地址是由程序（或进程）在运行时所使用的地址。在现代操作系统中，每个进程都认为它有一整块连续的内存空间，这就是所谓的<strong>虚拟地址空间</strong>（<strong>Virtual Address Space</strong>）。操作系统通过虚拟内存管理（<strong>Virtual Memory Management</strong>）来提供这种抽象，使得程序不需要直接操作物理内存地址。</p><p><strong>虚拟地址的特点：</strong></p><ul><li><strong>独立性（Independence）</strong>：每个进程都有独立的虚拟地址空间，彼此之间互不干扰。</li><li><strong>抽象性（Abstraction）</strong>：程序只能看到虚拟地址，操作系统负责将这些虚拟地址映射到实际的物理内存地址。</li><li><strong>安全性（Security）</strong>：虚拟地址空间的使用减少了不同进程之间的干扰，增加了系统的安全性。例如，进程无法直接访问其他进程的内存，避免了内存泄漏或数据窃取。</li></ul><hr><p>物理地址是计算机硬件（如内存控制器、RAM）直接使用的内存地址，它表示了内存芯片中实际的位置。操作系统将虚拟地址通过一种称为<strong>地址映射</strong>（<strong>Address Mapping</strong>）的机制转换为物理地址，从而让 CPU 可以实际访问内存。</p><p><strong>物理地址的特点：</strong></p><ul><li><strong>实际存在（Real Existence）</strong>：物理地址代表的是计算机中的实际内存单元（如 RAM）。</li><li><strong>固定性（Fixed Nature）</strong>：物理地址通常与硬件布局相关，无法随操作系统的调度变化而变化。</li></ul><hr><p>虚拟地址与物理地址的关系：地址映射（Address Mapping）</p><p>操作系统通过硬件（通常是内存管理单元，<strong>MMU</strong>，<strong>Memory Management Unit</strong>）来实现虚拟地址和物理地址之间的映射。虚拟地址通过<strong>页表</strong>（<strong>Page Table</strong>）映射到物理地址。这一过程称为<strong>地址转换</strong>（<strong>Address Translation</strong>），它是现代操作系统内存管理的核心。</p><p><strong>地址转换的过程：</strong></p><ol><li><p><strong>分段与分页（Segmentation and Paging）</strong>：</p><ul><li><strong>分页（Paging）</strong>：操作系统将虚拟地址空间分为固定大小的页（Page），每一页会映射到物理内存中的一块区域。页的大小通常为 4 KB、8 KB 或更大。</li><li><strong>分段（Segmentation）</strong>：虚拟地址空间不仅可以通过分页来管理，还可以通过分段将地址空间分为不同的段（如代码段、数据段、堆栈段等）。</li></ul></li><li><p><strong>页表（Page Table）</strong>：操作系统通过维护页表来实现虚拟页到物理页的映射。页表记录了虚拟页和物理页之间的对应关系。MMU 会根据虚拟地址中的页号查找页表，从而获取对应的物理页号，完成虚拟地址到物理地址的转换。</p></li><li><p><strong>TLB（Translation Lookaside Buffer）</strong>：为了提高地址转换的效率，操作系统会使用一个硬件缓存（TLB）来存储最近使用的虚拟地址到物理地址的映射。</p></li></ol><p><strong>举个例子：</strong> 假设虚拟地址为 <code>0x7fffffff</code>，操作系统通过页表将其映射到物理地址 <code>0x1001ffff</code>，通过这种方式，程序就可以通过虚拟地址访问到实际的内存。</p><hr><p>虚拟地址与物理地址的优点：</p><ul><li><strong>内存保护（Memory Protection）</strong>：虚拟内存使得每个进程只能访问它自己被分配的内存空间，避免了进程间的内存干扰。</li><li><strong>进程隔离（Process Isolation）</strong>：操作系统能够通过虚拟内存为每个进程提供独立的内存地址空间，防止进程直接访问或修改其他进程的数据。</li><li><strong>内存共享（Memory Sharing）</strong>：操作系统可以通过映射不同进程的虚拟地址到相同的物理地址，实现进程间共享内存。</li></ul><p>最后简单总结一下：</p><ul><li><strong>虚拟地址（Virtual Address）</strong> 是程序用来访问内存的地址，操作系统通过虚拟内存技术提供给每个进程一个独立的虚拟地址空间。</li><li><strong>物理地址（Physical Address）</strong> 是实际的内存地址，由硬件使用。</li><li>操作系统通过内存管理单元（<strong>MMU</strong>）和页表（<strong>Page Table</strong>）将虚拟地址映射到物理地址，从而实现虚拟内存和物理内存之间的映射。</li></ul><p>虚拟地址和物理地址的映射机制使得操作系统能够高效、安全地管理内存资源，提供了内存保护、进程隔离以及高效的内存共享等优点。</p><p>本章接下来的内容就是深入底层探讨上面的涉及到的内容。</p><hr><h3 id="3-2-内存的概念"><a href="#3-2-内存的概念" class="headerlink" title="3.2 内存的概念"></a>3.2 内存的概念</h3><p>内存（Memory）是计算机中的一种硬件资源，主要用于存储和快速访问程序和数据。它是计算机系统中非常重要的一部分，负责存放正在运行的程序指令、数据以及操作系统的相关信息。内存主要有两种类型：</p><ul><li>RAM（随机存取存储器）：用于存储正在运行的程序和数据，是一种易失性存储器，断电后数据会丢失。</li><li>ROM（只读存储器）：存储系统启动时需要的固件或引导程序，通常是非易失性的。</li></ul><p>内存的编址方式有两种主要方式：<strong>按字节编址</strong>和<strong>按字编址</strong>。这两种方式的主要区别在于每个地址对应的数据单位的大小不同。</p><h4 id="3-2-1-按字节编址（Byte-Addressing）"><a href="#3-2-1-按字节编址（Byte-Addressing）" class="headerlink" title="3.2.1 按字节编址（Byte Addressing）"></a>3.2.1 按字节编址（Byte Addressing）</h4><ul><li><strong>内存地址从 00 开始，每个地址对应一个存储单元</strong>：每个内存地址指向 1 字节（8 bit）的数据。</li><li><strong>每个存储单元大小为 1 字节</strong>：即每个存储单元占用 1 字节（8 bit），1 字节 &#x3D; 8 bit。</li><li><strong>按字节编址</strong>：每个地址指向 1 字节。</li></ul><p>假设内存的内容如下，每个位置对应一个字节的数据：</p><table><thead><tr><th>地址</th><th>数据</th></tr></thead><tbody><tr><td>00</td><td>0x1A</td></tr><tr><td>01</td><td>0x2B</td></tr><tr><td>02</td><td>0x3C</td></tr><tr><td>03</td><td>0x4D</td></tr><tr><td>04</td><td>0x5E</td></tr></tbody></table><p>在这种情况下，每个内存地址对应一个字节（8 bit）的数据。例如：</p><ul><li>地址 00 存储的数据为 0x1A</li><li>地址 01 存储的数据为 0x2B</li><li>地址 02 存储的数据为 0x3C</li></ul><p>如果某程序需要访问地址 02 的数据，它将直接访问 0x3C。</p><hr><h4 id="3-2-2-按字编址（Word-Addressing）"><a href="#3-2-2-按字编址（Word-Addressing）" class="headerlink" title="3.2.2 按字编址（Word Addressing）"></a>3.2.2 <strong>按字编址（Word Addressing）</strong></h4><ul><li><strong>内存地址从 00 开始，每个地址对应一个存储单元</strong>：每个内存地址指向 1 个字（通常是 16 位或 2 字节）。</li><li><strong>每个存储单元大小为 1 个字</strong>：即每个存储单元占用 16 位（2 字节），1 字 &#x3D; 16 bit。</li><li><strong>按字编址</strong>：每个地址指向 1 个字。</li></ul><p>假设内存的内容如下，每个位置对应一个字（通常是 16 位或 2 字节）的数据：</p><table><thead><tr><th>地址</th><th>数据</th></tr></thead><tbody><tr><td>00</td><td>0x1A2B</td></tr><tr><td>01</td><td>0x3C4D</td></tr><tr><td>02</td><td>0x5E6F</td></tr><tr><td>03</td><td>0x7081</td></tr><tr><td>04</td><td>0x9ABC</td></tr></tbody></table><p>在这种情况下，每个内存地址对应一个字（16 bit 或 2 字节）的数据。例如：</p><ul><li>地址 00 存储的数据为 0x1A2B</li><li>地址 01 存储的数据为 0x3C4D</li><li>地址 02 存储的数据为 0x5E6F</li></ul><p>如果某程序需要访问地址 01 的数据，它将直接访问 0x3C4D。</p><hr><h4 id="3-2-3-按字节编址与按字编址的区别"><a href="#3-2-3-按字节编址与按字编址的区别" class="headerlink" title="3.2.3. 按字节编址与按字编址的区别"></a>3.2.3. <strong>按字节编址与按字编址的区别</strong></h4><table><thead><tr><th>特性</th><th>按字节编址（Byte Addressing）</th><th>按字编址（Word Addressing）</th></tr></thead><tbody><tr><td><strong>存储单元大小</strong></td><td>每个存储单元为 1 字节（8 bit）</td><td>每个存储单元为 1 个字（16 bit 或 2 字节）</td></tr><tr><td><strong>地址步进</strong></td><td>每个内存地址指向 1 字节</td><td>每个内存地址指向 1 个字</td></tr><tr><td><strong>内存访问单位</strong></td><td>字节（Byte）</td><td>字（Word）</td></tr><tr><td><strong>示例</strong></td><td>地址 <code>00</code> 存储 1 字节，地址 <code>01</code> 存储 1 字节</td><td>地址 <code>00</code> 存储 1 个字（16 bit），地址 <code>01</code> 存储下一个字（16 bit）</td></tr><tr><td><strong>常见应用</strong></td><td>现代计算机普遍采用（如 32 位系统、64 位系统）</td><td>较早或特定的计算机系统（如 16 位字长的机器）</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li><strong>按字节编址（Byte Addressing）</strong>：每个内存地址对应 1 字节（8 bit），常用于现代计算机系统。</li><li><strong>按字编址（Word Addressing）</strong>：每个内存地址对应 1 个字（16 bit 或 2 字节），通常出现在字长为 16 位的计算机系统中。</li></ul><p>这些编址方式对计算机的内存管理和程序的内存访问模式有重要影响。在字节编址中，内存的访问单位较小，适合处理各种小规模的数据。而在字编址中，内存访问通常更高效，特别是在处理需要 16 位宽度的数据时。</p><hr><h3 id="3-3-连续内存分配（Contiguous-Memory-Allocation）"><a href="#3-3-连续内存分配（Contiguous-Memory-Allocation）" class="headerlink" title="3.3 连续内存分配（Contiguous Memory Allocation）"></a>3.3 连续内存分配（Contiguous Memory Allocation）</h3><p>“连续内存分配”是操作系统中的一种内存管理方式，它要求程序在执行时必须占用一块连续的内存空间。这种方式通常用于简化内存管理，并提高内存访问的效率。它可以通过将程序所需的内存块按顺序分配，避免了碎片化问题，但也带来了一些局限性。</p><p><strong>分段（Segmentation）</strong> 在某些情况下可以看作是连续内存分配的一种扩展或优化方法。分段是一种逻辑上的内存划分，它把程序划分为多个不同的段（如代码段、数据段、堆栈段等），每个段是连续的，因此每个段的内存空间在物理内存中是连续的。这样，分段的方式不仅保持了连续内存分配的优点，还能够通过合理划分程序的不同部分，提供更好的内存管理和灵活性。</p><p><strong>连续内存分配的主要特点：</strong></p><ul><li><strong>连续性</strong>：每个进程或程序在内存中的存储空间是连续的，没有分散的碎片。分段也是基于这一理念，虽然程序被分成不同的段，但每个段内部仍然是连续分配的。</li><li><strong>简单性</strong>：实现比较简单，管理方便。分段虽然比纯粹的连续分配稍微复杂，但它仍然保持了分配连续内存的基本结构，只是对程序进行逻辑上的划分。</li><li><strong>内存浪费</strong>：由于要求分配的内存是连续的，容易造成内存碎片，从而导致内存利用率降低。分段同样也会面临内存碎片问题，尤其是<strong>外部碎片</strong>。不过，分段通过划分段的方式（例如代码段、数据段等）减少了内存管理的复杂度。</li></ul><p><strong>分配方式：</strong></p><p><strong>1.固定分区分配：</strong></p><ul><li>内存被划分为若干个固定大小的分区。每个分区只能分配给一个进程。分段和这种方式类似，但分段是将进程划分为多个段，而每个段的大小可以不同。</li></ul><p><strong>2.动态分区分配：</strong></p><ul><li>内存不预先划分为固定大小的分区，而是根据进程的需求动态分配。通过“首次适应算法”、“最佳适应算法”、“最差适应算法”等来寻找合适的内存块。分段的内存分配方式更灵活，可以根据进程的逻辑结构来动态调整段的大小。</li></ul><img src="/img/OS/memory_allocation.svg" alt="内存分配" style="max-width: 100%; height: auto;" /><p><strong>连续内存分配产生的内存碎片：</strong></p><ul><li><p><strong>外部碎片（External Fragmentation）</strong>：内存中的小块空闲空间，由于这些空间不连续，无法分配给新进程。分段同样可能会产生外部碎片，因为每个段的大小是动态的，释放的段可能导致空闲空间分散，无法为其他进程分配大块连续的内存区域。</p></li><li><p><strong>内部碎片（Internal Fragmentation）</strong>：分配的内存块比进程实际需要的内存大，导致分配的内存块内部存在未使用的空间。分段通常较少产生内部碎片，因为段是按需分配的，但如果段的大小过大，仍然可能存在一定的内部分配浪费。</p></li></ul><p><strong>连续内存分配的优缺点：</strong></p><ul><li><p><strong>优点</strong>：简单易实现，适用于内存需求较小、较少变化的系统。分段提供了更细粒度的内存分配，适合管理不同类型的内存需求（如代码、数据和堆栈等）。</p></li><li><p><strong>缺点</strong>：内存利用率较低，容易产生内存碎片，难以适应现代操作系统的需求。分段虽能够通过合理划分程序的不同部分来减少碎片，但仍然可能面临外部碎片问题，需要采取紧凑化（Compaction）等技术来缓解。</p></li></ul><img src="/img/OS/fragmentation.svg" alt="内存碎片" style="max-width: 100%; height: auto;" /><p><strong>内存碎片：</strong></p><ul><li><strong>紧凑（Compaction）</strong>：紧凑是一种用于解决外部碎片问题的技术。它的基本思想是将内存中的所有进程移动到内存的一端，使得所有的空闲分区都集中在内存的另一端，从而形成一个大的、连续的空闲分区。这样，就可以满足大的内存请求，从而解决外部碎片问题。然而，紧凑需要移动进程，因此会产生一定的开销。在分段中，紧凑化同样适用于解决外部碎片问题，但由于段的分配是按逻辑划分的，因此紧凑的过程可能更复杂。</li></ul><p><strong>总结：</strong><br>在 <strong>连续内存分配</strong> 中，程序的内存是按顺序分配的，保证了每个进程的内存空间是连续的。而 <strong>分段（Segmentation）</strong> 作为连续内存分配的一种扩展，它通过将程序划分为多个逻辑段（如代码段、数据段、堆栈段等），每个段在内存中仍然是连续的。虽然分段可以提供更多的灵活性，但它仍然面临外部碎片的问题，因此需要通过紧凑化等技术来优化内存使用。</p><h4 id="3-3-1-动态分区分配算法"><a href="#3-3-1-动态分区分配算法" class="headerlink" title="3.3.1 动态分区分配算法"></a>3.3.1 动态分区分配算法</h4><p>动态分区分配算法用于在内存中动态分配空闲区域，特别是在程序执行过程中。与静态分配不同，动态分区分配是根据程序的实际需求（如内存大小）动态调整内存的分配。主要的动态分区分配算法包括 <strong>首次适应（First-fit）</strong>、<strong>最优适应（Best-fit）</strong>、<strong>最坏适应（Worst-fit）</strong> 和 <strong>临近适应（Next-fit）</strong> 等。</p><hr><p><strong>1.首次适应（First-fit）</strong></p><p><strong>首次适应</strong>算法从内存的开始位置开始查找，寻找第一个足够大的空闲内存块来满足请求。当找到一个合适的空闲块后，立即分配内存。</p><p><strong>过程：</strong></p><ol><li>从内存中的第一个空闲块开始查找。</li><li>遍历空闲块，找到第一个可以满足请求的块。</li><li>如果找到合适的空闲块（Free block），则分配内存。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：实现简单，查找速度较快。</li><li><strong>缺点</strong>：可能导致内存碎片（Memory Fragmentation），因为分配的是第一个找到的块，后续的空闲块可能很小。</li></ul><img src="/img/OS/first_fit.svg" alt="首次适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>2.最优适应（Best-fit）</strong></p><p><strong>最优适应</strong>算法遍历整个内存，寻找所有能满足请求的空闲块，并选择<strong>最小的</strong>空闲块进行分配，即选择一个最接近请求大小的块。</p><p><strong>过程：</strong></p><ol><li>遍历所有空闲内存块。</li><li>选择一个大小最合适（最小且足够大）的空闲块。</li><li>分配内存。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：可以减少剩余空闲内存块的大小，从而减少碎片。</li><li><strong>缺点</strong>：查找过程较慢，因为需要遍历所有空闲块，效率较低。</li></ul><img src="/img/OS/best_fit.svg" alt="最优适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>3.最坏适应（Worst-fit）</strong></p><p><strong>最坏适应</strong>算法选择一个最大的空闲内存块来进行分配。这种方法的假设是，通过选择最大空闲块，可以避免创建过多的小碎片。</p><p><strong>过程：</strong></p><ol><li>遍历所有空闲内存块。</li><li>选择最大的空闲块。</li><li>将内存分配给进程。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：通过选择最大的空闲块，减少了碎片化的风险。</li><li><strong>缺点</strong>：可能会导致较大的空闲块被拆分成小块，减少了可用的空间。</li></ul><img src="/img/OS/worst_fit.svg" alt="最坏适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>4.临近适应（Next-fit）</strong></p><p><strong>临近适应</strong>算法与<strong>首次适应</strong>算法类似，不同之处在于，<strong>临近适应</strong>算法在上次分配的位置继续查找空闲块，而不是从内存的开头重新开始查找。</p><p><strong>过程：</strong></p><ol><li>从上次分配位置开始查找。</li><li>遍历空闲块，找到第一个足够大的空闲块。</li><li>分配内存。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：避免了每次从内存的开头开始查找，查找过程较快。</li><li><strong>缺点</strong>：仍然可能会出现碎片化，尤其是在内存末尾。</li></ul><img src="/img/OS/next_fit.svg" alt="临近适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>动态分区分配算法总结</strong></p><table><thead><tr><th>算法</th><th>查找空闲块的顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>首次适应</strong></td><td>从头开始查找</td><td>实现简单，查找速度较快</td><td>可能产生较多的碎片</td></tr><tr><td><strong>最优适应</strong></td><td>遍历所有空闲块</td><td>减少剩余碎片，内存利用较好</td><td>查找速度较慢，可能产生小碎片</td></tr><tr><td><strong>最坏适应</strong></td><td>遍历所有空闲块</td><td>减少小碎片产生，较为稳定</td><td>可能浪费大量内存，产生较大碎片</td></tr><tr><td><strong>临近适应</strong></td><td>从上次分配位置开始查找</td><td>查找速度较快，避免从头开始查找</td><td>可能导致末尾碎片或不均匀的碎片分布</td></tr></tbody></table><p>这些算法都有各自的应用场景和适用范围，在实际系统中，操作系统可能会根据不同的内存需求，选择合适的分配算法，或采用多种算法的组合来平衡内存的分配效率和碎片化问题。</p><hr><h4 id="3-3-2-分段寻址（Segmentation-Addressing）"><a href="#3-3-2-分段寻址（Segmentation-Addressing）" class="headerlink" title="3.3.2 分段寻址（Segmentation Addressing）"></a>3.3.2 分段寻址（Segmentation Addressing）</h4><p>在分段管理中，程序的内存被划分为多个逻辑上的段，如代码段、数据段、堆栈段等。每个段在物理内存中都有一个连续的存储空间。分段寻址是通过两个部分来定位内存中的具体位置：</p><ol><li>段基址（Segment Base Address）：每个段在物理内存中的起始地址。</li><li>段内偏移量（Offset）：在该段内的具体位置，相对于该段的起始位置的偏移。</li></ol><p><strong>分段寻址过程：</strong><br>当程序需要访问某个内存位置时，操作系统会将逻辑地址转换为物理地址。逻辑地址由两个部分组成：</p><ul><li>段号（Segment Number）：指示需要访问的段。</li><li>内偏移量（Offset）：指示在该段内具体的位置。</li></ul><p>计算物理地址的公式：<strong>物理地址 &#x3D; 段基址 + 段内偏移量</strong></p><p>假设我们有以下段信息，存放在段表 (Segment Table)：</p><ul><li>代码段（Code Segment）：基址为<code>1000</code>，长度为<code>500</code>。</li><li>数据段（Data Segment）：基址为<code>2000</code>，长度为<code>300</code>。</li><li>堆栈段 (Stack Segment)：基址为<code>2500</code>，长度为<code>400</code>。</li></ul><p>步骤：</p><ol><li>查找段号：这里是<code>数据段</code>，段号为<code>2</code>。</li><li>获取段基址：数据段的基址是<code>2000</code>。</li><li>获取偏移量：我们需要访问数据段的第<code>150</code>个字节，所以偏移量是<code>150</code>。</li><li>计算物理地址：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">物理地址 = 段基址 + 偏移量 = 2000 + 150 = 2150<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>因此，访问<code>数据段</code>中第<code>150</code>个字节的物理地址是<code>2150</code>。</p><img src="/img/OS/segmentation_addressing.svg" alt="分段寻址" style="max-width: 100%; height: auto;" /><h3 id="3-4-分页（Paging）"><a href="#3-4-分页（Paging）" class="headerlink" title="3.4 分页（Paging）"></a>3.4 分页（Paging）</h3><p>在操作系统中，分页（Paging）是一种内存管理方案，它将物理内存分割成大小相等的块，称为页帧（Page Frames），而逻辑内存（也就是程序使用的内存）则被划分为相同大小的块，称为页（Pages）。分页的目标是将内存的使用更加高效地管理，减少内存碎片，提高系统的可用性和性能。</p><h4 id="3-4-1-分页的基本概念"><a href="#3-4-1-分页的基本概念" class="headerlink" title="3.4.1 分页的基本概念"></a>3.4.1 分页的基本概念</h4><ol><li>页（Page）：页是逻辑内存的基本单位，通常大小为4KB、8KB或更大。操作系统将程序的虚拟内存划分为若干页，每一页在物理内存中都有一个对应的页帧。</li><li>页帧（Page Frame）：页帧是物理内存中的基本单位。每个页帧与一个页一一对应。物理内存被划分成许多页帧，大小与页一致。</li><li>页表（Page Table）：页表是操作系统用来管理页与页帧之间映射关系的数据结构。每个进程都有自己的页表，页表中的每个条目包含一个页帧号（Page Frame Number），指示该逻辑页对应的物理页帧。</li><li>虚拟地址（Virtual Address）：程序使用的地址，是程序在执行时产生的地址，经过分页后可以转换为物理地址。</li><li>物理地址（Physical Address）：实际的硬件内存地址，通过页表映射从虚拟地址转换得到。</li><li>页表项（Page Table Entry, PTE）：页表中的每个条目，通常包含页帧号以及其他控制信息，如有效位（Valid Bit）、访问权限等。</li></ol><h4 id="3-4-2-分页地址转换"><a href="#3-4-2-分页地址转换" class="headerlink" title="3.4.2 分页地址转换"></a>3.4.2 分页地址转换</h4><p>在分页机制下，程序使用的是虚拟地址空间，而实际的内存地址是物理地址。分页地址转换的基本过程就是通过页表把虚拟地址转为物理地址。</p><p>在简单的分页系统中，虚拟地址通常被分为两部分：</p><ul><li>页号（Page Number）：虚拟地址的高位部分，用于索引页表，找到虚拟页号对应的物理页帧号。</li><li>页内偏移（Offset）：虚拟地址的低位部分，用来表示数据在该页内的偏移位置。<br>这种结构适用于简单的分页机制，每个虚拟地址空间的页表只有一级。</li></ul><p>举个例子，在按字节编址的存储器中，有32个页面，每页 1KB；内存为 64KB，页号和物理块号对应表如图所示，计算逻辑地址<code>0x0C5D</code>所对应的物理地址</p><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>9</td><td>5</td></tr><tr><td>2</td><td>4</td></tr><tr><td>3</td><td>8</td></tr></tbody></table><p>紧接着，<code>0x0C5D</code>转换为二进制：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">0000 1100 0101 1101<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>紧接着，根据页表大小，$1KB &#x3D; 2^{10}B$，按字节编址，所以页内偏移需要$10\text{bit}$来表示，即为<code>0001011101</code></p><p>因为存储器有32个页面，$32 &#x3D; 2^5$,所以我们需要$5 \text{bit}$来表示页号,即为<code>00011</code>,虚拟页号对应十进制的<code>3</code>，通过查表，我们对应到物理地址的<code>8</code>号块，对应2进制<code>1000</code></p><p>内存为 $64 \text{KB} &#x3D; 2^{16}B$,按字节编址，需要$16 \text{bit}$来表示地址,因此需要补充前导0</p><p>因此最终的物理地址：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">0010 0000 0101 1101    // 对应0x205D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="3-4-3-分页机制中的有效位"><a href="#3-4-3-分页机制中的有效位" class="headerlink" title="3.4.3 分页机制中的有效位"></a>3.4.3 分页机制中的有效位</h4><p>在分页机制中，操作系统使用页表（page table）来存储虚拟页和物理页框之间的映射关系。每个页表条目（PTE，Page Table Entry）通常包含以下信息：</p><ol><li><strong>物理页框地址</strong>：对应虚拟页映射到的物理页框地址。</li><li><strong>有效位（Valid Bit）</strong>：指示当前页是否有效，即该虚拟页是否已经映射到物理内存。</li><li><strong>其他控制位</strong>：如访问权限位、修改位（dirty bit）、引用位等。</li></ol><p>有效位的作用可以通过以下几种情况来解释：</p><p><strong>1. 有效位 &#x3D; 1</strong></p><ul><li>表示该页已经映射到物理内存，即虚拟页存在于物理页框中。操作系统可以直接访问该虚拟页对应的物理内存。</li><li>如果 CPU 要访问该虚拟页，硬件就会通过页表查找该页对应的物理页框地址，从而实现地址转换。</li></ul><p><strong>2. 有效位 &#x3D; 0</strong></p><ul><li>表示该虚拟页尚未映射到物理内存，或者该页映射不合法（例如，页未加载、该页不在物理内存中，或该页是无效的）。如果 CPU 尝试访问该虚拟页，会触发一个页错误（page fault）。</li><li>页错误通常会引发操作系统的处理机制（比如页面置换），它可能会从磁盘（例如交换空间或文件系统）加载该页到物理内存中，或者进行其他处理。</li></ul><p><strong>分页机制中的其他相关位：</strong></p><ol><li><p><strong>修改位（脏位，Dirty Bit）</strong>：表示该页自从加载到内存后是否被修改过。如果该页被修改过，操作系统可能会在需要将其写回磁盘时进行相应处理。</p></li><li><p><strong>访问位（Access Bit）</strong>：用于记录页是否被访问过，这对于实现页面置换算法（如最近最少使用算法，LRU）非常重要。</p></li><li><p><strong>保护位（Protection Bit）</strong>：用于控制该页的访问权限（如只读、可写、可执行等）。</p></li></ol><h3 id="3-5-段页式管理方式（Segmentation-with-Paging）"><a href="#3-5-段页式管理方式（Segmentation-with-Paging）" class="headerlink" title="3.5 段页式管理方式（Segmentation with Paging）"></a>3.5 段页式管理方式（Segmentation with Paging）</h3><p><strong>段页式管理（Segmentation with Paging）</strong> 结合了上述两种方式的优点。具体来说，段页式管理将进程的地址空间首先分为若干段，每个段再进一步划分为若干页。段页式管理的内存地址由两个部分组成：</p><ul><li><strong>段号（Segment Number）</strong>：指示访问的是哪个段。</li><li><strong>页号和页内偏移（Page Number and Offset）</strong>：指示访问的是哪个页和页内的具体位置。</li></ul><p><strong>步骤</strong></p><ol><li><strong>段表查找</strong>：根据段号查找段表，得到该段的基地址和段长。</li><li><strong>页表查找</strong>：根据页号查找页表，得到该页的物理地址。</li><li><strong>物理地址计算</strong>：将物理页框基地址与页内偏移合并，得到最终的物理地址。</li></ol><p><strong>优点</strong></p><ul><li><strong>逻辑清晰与高效利用</strong>：既保留了段式存储管理的逻辑单元划分，又利用了分页存储管理的高效内存利用方式。</li><li><strong>灵活性高</strong>：可以对每个段独立进行保护和管理。</li></ul><img src="/img/OS/segmentation_paging.svg" alt="段页式管理方式" style="max-width: 100%; height: auto;" /><p>段页式地址转换示例，这里假设：</p><ul><li>段大小：最大 4KB（$2^{12}$字节）</li><li>页大小：1KB（$2^{10}$字节）</li><li>每段最多可分4页</li><li>逻辑地址结构：3位段号 + 2位页号 + 10位页内偏移</li></ul><p>假设逻辑地址：<code>2,1,256</code>（段号2，页号1，偏移256）</p><p>段表：</p><table><thead><tr><th>段号</th><th>页表基址</th><th>段长度</th></tr></thead><tbody><tr><td>0</td><td>12000</td><td>2页</td></tr><tr><td>1</td><td>13000</td><td>4页</td></tr><tr><td>2</td><td>14000</td><td>3页</td></tr><tr><td>3</td><td>15000</td><td>1页</td></tr><tr><td>4</td><td>16000</td><td>4页</td></tr></tbody></table><p><strong>段2的页表（基址14000）</strong></p><table><thead><tr><th>页号</th><th>物理页号</th></tr></thead><tbody><tr><td>0</td><td>20</td></tr><tr><td>1</td><td>25</td></tr><tr><td>2</td><td>30</td></tr></tbody></table><p><strong>地址转换示例：</strong></p><ul><li>逻辑地址：段号&#x3D;2, 页号&#x3D;1, 页内偏移&#x3D;256</li><li>段表查找：段号2 → 页表基址14000</li><li>页表查找：页号1 → 物理页号25</li><li>计算物理地址：25 * 1024 + 256 &#x3D; 25856</li></ul><p>因此逻辑地址<code>2,1,256</code>转换为物理地址25856。</p><h3 id="3-6-TLB机制"><a href="#3-6-TLB机制" class="headerlink" title="3.6 TLB机制"></a>3.6 TLB机制</h3><p><strong>TLB（Translation Lookaside Buffer）</strong> 是一种高速缓存，用于加速虚拟地址到物理地址的转换过程。在现代操作系统中，虚拟内存技术使得程序运行时使用的是虚拟地址，而物理内存使用的是物理地址。每当程序访问内存时，硬件需要将虚拟地址转换为物理地址，这一过程通常由 <strong>内存管理单元（MMU）</strong> 完成。</p><p><strong>TLB机制的作用：</strong> 由于地址转换的过程可能涉及多次查找页表，而页表可能非常大，查找过程会比较慢。因此，TLB机制通过缓存最近使用的虚拟地址到物理地址的映射关系，来显著提高地址转换的速度。</p><hr><p><strong>TLB的工作原理</strong></p><ol><li><p><strong>TLB命中（Hit）</strong>：</p><ul><li>当CPU生成一个虚拟地址时，MMU会首先检查TLB是否已经缓存了该虚拟地址到物理地址的映射。如果找到映射（称为“TLB命中”），MMU直接返回物理地址，访问内存。</li></ul></li><li><p><strong>TLB未命中（Miss）</strong>：</p><ul><li>如果TLB中没有找到相应的映射（称为“TLB未命中”），MMU会访问页表，查找虚拟地址对应的物理地址，并将该映射加载到TLB中，以便下次访问时加速转换过程。</li></ul></li><li><p><strong>替换策略</strong>：</p><ul><li>当TLB已满且需要缓存新的映射时，硬件会采用一定的替换策略（如<strong>LRU</strong>，最近最少使用）来选择一个旧的映射项进行替换。</li></ul></li></ol><img src="/img/OS/tlb.svg" alt="TLB机制" style="max-width: 100%; height: auto;" /><p>举个例子来加深理解引入TLB之后的地址转换过程</p><p>当CPU需要访问内存时，会生成一个逻辑地址（虚拟地址）。MMU（内存管理单元）需要将该虚拟地址转换为物理地址。转换过程的第一步是检查TLB。</p><p>TLB是一个小型的、高速缓存，用于存储最近访问的虚拟地址到物理地址的映射。<br>当虚拟地址生成后，MMU首先使用虚拟页号查找TLB。</p><p>如果TLB中存储了虚拟页号对应的物理页框号（即映射），称为TLB命中。<br>如果命中，TLB直接返回物理页框号，然后将虚拟地址中的页内偏移与该物理页框号结合，形成完整的物理地址。</p><p><strong>物理地址 &#x3D; 物理页框号 + 页内偏移</strong></p><p><strong>示例：</strong></p><p>假设：</p><ul><li>虚拟地址：<code>0x1234 5678</code><ul><li>页号（20位）：<code>0x12345</code></li><li>页内偏移（12位）：<code>0x678</code></li></ul></li><li>TLB命中：虚拟页号 <code>0x12345</code> 映射到物理页框 <code>0x78901</code></li></ul><p>则物理地址：</p><ul><li><strong>物理地址 &#x3D; 0x78901 + 0x678</strong></li><li><strong>物理地址 &#x3D; 0x789679</strong></li></ul><p>如果在TLB中没有找到对应的映射（即TLB未命中），MMU会执行以下步骤：</p><ol><li><p><strong>访问页表</strong>：MMU会通过访问操作系统维护的页表来查找虚拟页号到物理页框号的映射。页表是一个数据结构，存储虚拟页号与物理页框号之间的关系。</p><p>页表的查找可能会采用多级页表（例如两级、三四级页表），每级页表根据虚拟地址的高位逐级查找。</p></li><li><p><strong>更新TLB</strong>：一旦页表返回物理页框号，MMU将这个映射加载到TLB中，以便下次访问时可以加速查找。</p></li><li><p><strong>生成物理地址</strong>：将页表中获取到的物理页框号与虚拟地址中的页内偏移结合，形成最终的物理地址。</p></li></ol><p><strong>物理地址 &#x3D; 物理页框号 + 页内偏移</strong></p><p><strong>示例：</strong></p><p>假设：</p><ul><li>虚拟地址：<code>0x1234 5678</code><ul><li>页号（20位）：<code>0x12345</code></li><li>页内偏移（12位）：<code>0x678</code></li></ul></li><li>TLB未命中：虚拟页号 <code>0x12345</code> 没有映射，需访问页表。</li><li>页表查询返回：物理页框号 <code>0x78901</code></li></ul><p>则物理地址：</p><ul><li><strong>物理地址 &#x3D; 0x78901 + 0x678</strong></li><li><strong>物理地址 &#x3D; 0x789679</strong></li></ul><p>如果TLB已满，需要替换其中的一个条目。常见的替换策略有：</p><ul><li>最佳页面置换算法（Optimal Page Replacement Algorithm）</li><li>最近最少使用页面置换算法（Least Recently Used, LRU）</li><li>先进先出页面置换算法（First-In-First-Out, FIFO）</li><li>时钟页面置换算法（Clock Page Replacement Algorithm）</li><li>最不常用页面置换算法（Least Frequently Used, LFU）</li></ul><hr><p>最后再简单做一个TLB的总结</p><table><thead><tr><th><strong>TLB的优点</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>提高性能</strong></td><td>由于TLB缓存了常用的虚拟地址到物理地址的映射，能够减少访问页表的次数，从而提高内存访问的速度。</td></tr><tr><td><strong>减少延迟</strong></td><td>通过快速查找TLB，减少了虚拟地址到物理地址转换的时间，减少了内存访问延迟。</td></tr></tbody></table><table><thead><tr><th><strong>TLB的局限性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>缓存命中率受限</strong></td><td>TLB的容量通常很小，仅能缓存最近访问的少量地址映射，因此，TLB的命中率可能受到限制。</td></tr><tr><td><strong>TLB Miss Penalty</strong></td><td>当发生TLB未命中时，访问页表会导致较大的延迟，因此TLB的命中率直接影响系统的性能。</td></tr></tbody></table><blockquote><p>TLB相关的有效内存访问时间计算，就根据概率来进行加权，可以直观理解，这里就不赘述了</p></blockquote><h3 id="3-7-请求调页（Demand-Paging）"><a href="#3-7-请求调页（Demand-Paging）" class="headerlink" title="3.7 请求调页（Demand Paging）"></a>3.7 请求调页（Demand Paging）</h3><p>请求调页是虚拟内存管理的一种机制，指的是：</p><ul><li>页面并不是在程序启动时就全部加载到内存，而是只有在程序访问某个页面时，操作系统才会将该页面从磁盘加载到物理内存中。</li><li>这种按需加载的方式避免了将整个程序或数据集加载到内存中，从而节省了内存空间。</li></ul><p>当程序访问一个尚未加载到内存的页面时，会触发缺页异常（Page Fault）。这时，操作系统会按照以下步骤处理：</p><ul><li>缺页异常触发：当进程访问一个不在物理内存中的虚拟页面时，硬件会触发缺页异常。</li><li>查找页面的磁盘位置：操作系统查找页表，确定虚拟页面的物理存储位置。如果该页面还未加载到内存中，操作系统会查找存储该页面的磁盘位置，通常是磁盘上的交换空间或文件系统。</li><li>从磁盘加载页面：操作系统会将该页面从磁盘加载到物理内存中的一个空闲页框（或通过页面置换腾出空间）。这个页面通常存储在交换空间（swap space）或映射文件中。</li><li>更新页表：一旦页面加载到内存中，操作系统会更新页表，将该虚拟页面的映射关系指向新的物理页框。</li></ul><img src="/img/OS/page_fault.svg" alt="缺页异常" style="max-width: 100%; height: auto;" /><p>在这里我们要区分2个重要的概念，分别是缺页（Page Fault）和抖动（Thrashing）</p><h4 id="3-7-1-缺页（Page-Fault）"><a href="#3-7-1-缺页（Page-Fault）" class="headerlink" title="3.7.1 缺页（Page Fault）"></a>3.7.1 缺页（Page Fault）</h4><p><strong>缺页</strong>是指在虚拟内存管理中，进程尝试访问的页面（虚拟地址空间中的一个块）不在物理内存中，导致操作系统需要处理的事件。</p><p><strong>缺页的发生过程</strong>：</p><ol><li><strong>进程访问虚拟地址</strong>：当进程尝试访问一个虚拟地址时，MMU（内存管理单元）会首先检查该地址是否已经映射到物理内存中的一个页面。</li><li><strong>缺页异常</strong>：如果虚拟地址对应的页面不在物理内存中，MMU会触发一个缺页异常（Page Fault）。这是操作系统介入并处理的信号。</li><li><strong>操作系统处理</strong>：<ul><li>操作系统通过查看进程的页表，确认该页面在磁盘上的位置，通常是在交换空间或某个文件中。</li><li>操作系统会将该页面从磁盘加载到物理内存中。</li><li>如果物理内存已满，操作系统需要使用<strong>页面置换算法</strong>选择一个页面从内存中换出并写回磁盘，以腾出空间给新的页面。</li></ul></li><li><strong>恢复程序执行</strong>：当页面被加载到内存后，操作系统更新页表，并恢复进程的执行，进程继续访问内存。</li></ol><p><strong>缺页的原因</strong>：</p><ul><li><strong>页面尚未加载</strong>：进程访问的页面可能从未加载到内存中。</li><li><strong>页面被换出</strong>：内存中的页面被操作系统换出到磁盘，以腾出空间给其他页面。</li><li><strong>大块数据访问</strong>：对于大数据结构或程序，操作系统可能会选择按需加载数据，避免加载整个文件或数据集。</li></ul><p><strong>缺页的影响</strong>：</p><ul><li>缺页会导致内存访问的延迟，因为需要从磁盘加载页面，而磁盘I&#x2F;O速度远慢于内存。</li><li>当缺页频繁发生时，会增加磁盘访问次数，降低系统性能。</li></ul><p><strong>缺页的处理策略</strong>：</p><ul><li>增加物理内存（最直接的办法）</li><li>优化程序内存使用</li><li>使用页面置换算法</li><li>减少并发进程数</li><li>使用压缩内存技术</li><li>优化内存映射文件的使用</li><li>使用合适的磁盘存储和交换空间</li></ul><h4 id="3-7-2-抖动（Thrashing）"><a href="#3-7-2-抖动（Thrashing）" class="headerlink" title="3.7.2 抖动（Thrashing）"></a>3.7.2 <strong>抖动（Thrashing）</strong></h4><p><strong>抖动</strong>是指系统由于频繁的页面缺失和页面置换导致的性能急剧下降的现象。抖动通常发生在系统的物理内存不足时，操作系统不停地将页面从内存换出到磁盘，又从磁盘换入新页面，造成大量的磁盘I&#x2F;O操作，从而使得系统的响应速度极慢，甚至完全停止响应。有的书对抖动也称之为<strong>颠簸（Bouncing）</strong>。</p><p><strong>抖动的发生过程</strong>：</p><ol><li><strong>内存不足</strong>：系统的物理内存不足以容纳当前运行的所有进程和页面。</li><li><strong>频繁的页面置换</strong>：由于内存不足，操作系统不断地将一些页面换出到磁盘，同时又需要加载新的页面。这会导致大量的页面置换操作，频繁的磁盘I&#x2F;O。</li><li><strong>严重的性能下降</strong>：每次页面缺失时，操作系统需要从磁盘加载页面，由于磁盘I&#x2F;O速度远低于内存，整个过程会非常缓慢。当页面置换频繁发生时，系统的性能会急剧下降，进程的执行几乎停滞。</li></ol><p><strong>抖动的症状</strong>：</p><ul><li><strong>CPU利用率低</strong>：虽然CPU处于工作状态，但由于大量时间被浪费在页面置换上，CPU的实际工作负载非常低。</li><li><strong>高磁盘I&#x2F;O</strong>：系统的磁盘I&#x2F;O非常高，因为操作系统需要频繁读写磁盘。</li><li><strong>响应缓慢</strong>：由于缺页和页面置换，进程的响应速度非常慢，甚至可能完全停止。</li></ul><p><strong>抖动的原因</strong>：</p><ul><li><strong>内存过载</strong>：系统没有足够的内存来运行当前的程序。当进程需要的内存页数超出了物理内存的容量时，就会频繁发生页面置换。</li><li><strong>不合理的页面置换策略</strong>：如果页面置换算法选择不当，可能导致过多的页面被频繁换出和换入，从而引发抖动。</li><li><strong>大量进程竞争内存</strong>：多个进程同时运行并争夺有限的内存资源，也会导致频繁的页面交换。</li></ul><p><strong>抖动的解决方法</strong>：</p><ol><li><strong>增加物理内存</strong>：最直接的方式是增加系统的物理内存容量，从而减少频繁的页面置换。</li><li><strong>优化程序</strong>：减少程序的内存使用，尤其是避免大数据结构在内存中的频繁访问。</li><li><strong>改进页面置换算法</strong>：选择更合适的页面置换算法，如LRU、时钟算法等，以减少不必要的页面置换。</li><li><strong>减少并发进程数</strong>：通过限制同时运行的进程数量，避免多个进程同时占用过多内存。</li></ol><figure>  <img src="/img/OS/thrashing.svg" alt="抖动" style="max-width: 100%; height: auto;" />  <figcaption style="font-size: small; text-align: center;">注意看，频繁换出换入的页面在闪烁</figcaption></figure><p><strong>总结：</strong></p><ul><li><strong>缺页</strong>是指进程尝试访问的页面不在物理内存中，需要从磁盘加载。</li><li><strong>抖动</strong>是系统因频繁的页面置换而导致的性能严重下降现象，通常发生在系统内存不足时，频繁的页面缺失和加载导致大量磁盘I&#x2F;O和系统响应迟缓。</li></ul><h3 id="3-8-页面置换算法"><a href="#3-8-页面置换算法" class="headerlink" title="3.8 页面置换算法"></a>3.8 页面置换算法</h3><p>页面置换算法是操作系统内存管理中的一个重要机制，用于决定在物理内存已满的情况下，哪一个页面应当被移出内存以腾出空间来加载新的页面。这个过程称为页面置换。页面置换算法的主要目的是提高系统的内存利用效率和整体性能。下面重点讲解一下常见的页面置换算法。</p><h4 id="3-8-1-最佳页面置换算法（Optimal-Page-Replacement-Algorithm）"><a href="#3-8-1-最佳页面置换算法（Optimal-Page-Replacement-Algorithm）" class="headerlink" title="3.8.1 最佳页面置换算法（Optimal Page Replacement Algorithm）"></a>3.8.1 最佳页面置换算法（Optimal Page Replacement Algorithm）</h4><p><strong>最佳页面置换算法（Optimal Page Replacement Algorithm）</strong> 是一种理论上的页面置换算法，它通过预见未来的页面访问模式来做出最优决策，选择在未来最长时间内不会再被访问的页面进行置换。</p><p><strong>算法原理</strong>：</p><ul><li><strong>基本思想</strong>：最佳页面置换算法的核心思想是，当内存中的页面已满，操作系统需要选择一个页面将其从内存中移除。该算法通过预测接下来最久不会被访问的页面进行置换，从而最小化缺页率。</li><li><strong>理想情况</strong>：由于它需要知道未来的页面访问序列，这使得该算法在实际操作系统中无法实现，因为操作系统无法预测未来的页面访问模式。但是，它是评估其他页面置换算法的一个理论基准。</li></ul><p><strong>具体操作</strong>：</p><ol><li><p><strong>判断是否缺页</strong>：当进程访问某个页面时，操作系统首先检查该页面是否已经在内存中。如果该页面已经在内存中，则继续执行；如果不在内存中，则发生缺页。</p></li><li><p><strong>选择页面置换</strong>：在内存已满的情况下，操作系统选择一个页面进行置换。最佳页面置换算法选择的是那些在接下来最长时间内不会被访问的页面进行置换。</p><ul><li>例如，如果某个页面接下来有很长一段时间不再被访问，而其他页面会在较短时间内被访问到，那么该页面就会被置换。</li></ul></li><li><p><strong>更新内存</strong>：将被置换的页面从内存中移出，并将新的页面加载到内存中。</p></li></ol><p><strong>优点</strong>：</p><ul><li><strong>理论最优</strong>：最佳页面置换算法在所有页面置换算法中提供了最小的缺页率，因为它总是选择最合适的页面进行置换，最大化内存的利用率。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不可实现</strong>：实际系统无法预测未来的页面访问顺序，因此无法实现最佳页面置换算法。操作系统只能依赖于当前的页面访问信息做出决策，无法像该算法那样知道未来的访问情况。</li><li><strong>计算成本高</strong>：如果实现类似的算法，可能需要持续追踪所有页面的未来访问情况，这在实际操作中开销较大。</li></ul><p>举个简单的例子：假设有一个内存管理系统，其物理内存有 3 个页框，进程产生的页面访问序列如下：<code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2</code></p><p>OPT算法步骤：</p><ol><li>初始状态：页框为空</li><li>访问页面 <code>7</code>：<ul><li>页面 <code>7</code> 加入内存，[7]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 加入内存，[7, 0]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，[7, 0, 1]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>OPT 算法会选择未来最久不使用的页面。此时，<code>7</code> 最久不使用，因此置换掉 <code>7</code>，加入 <code>2</code>，[2, 0, 1]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 1]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>OPT 算法选择未来最久不使用的页面。此时，<code>1</code> 最久不使用，因此置换掉 <code>1</code>，加入 <code>3</code>，[2, 0, 3]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 3]</li></ul></li></ol><blockquote><p>后面的顺序可以直观理解，这里就不赘述了</p></blockquote><p>最佳页面置换算法在理论上是最优的，但由于实际无法预测未来的页面访问模式，因此无法在实际操作系统中实现,但它为其他页面置换算法（如 LRU 和 FIFO）提供了一个参照标准，帮助我们评估这些算法的性能。</p><hr><h4 id="3-8-2-最近最少使用页面置换算法（Least-Recently-Used-LRU）"><a href="#3-8-2-最近最少使用页面置换算法（Least-Recently-Used-LRU）" class="headerlink" title="3.8.2 最近最少使用页面置换算法（Least Recently Used, LRU）"></a>3.8.2 最近最少使用页面置换算法（Least Recently Used, LRU）</h4><p>LRU 算法选择最近一段时间内最少使用的页面进行置换，基于这样一个假设：最近使用过的页面在未来仍然可能会被使用，而很久没使用的页面将来可能不再使用。</p><p>举例说明：假设有一个内存管理系统，其物理内存有 3 个页框，进程产生的页面访问序列如下：<code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2</code></p><p><strong>步骤如下：</strong></p><ol><li>初始状态 ：页框为空</li><li>访问页面 <code>7</code> ：<ul><li>页面 <code>7</code> 加入内存，[7]</li></ul></li><li>访问页面 <code>0</code> ：<ul><li>页面 <code>0</code> 加入内存，[7, 0]</li></ul></li><li>访问页面 <code>1</code> ：<ul><li>页面 <code>1</code> 加入内存，[7, 0, 1]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>LRU 算法会选择最近最少使用的页面。此时，<code>7</code> 最近最少使用，因此置换掉 <code>7</code>，加入 <code>2</code>，[2, 0, 1]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 1]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>1</code> 最近最少使用，因此置换掉 <code>1</code>，加入 <code>3</code>，[2, 0, 3]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 3]</li></ul></li><li>访问页面 <code>4</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>2</code> 最近最少使用，因此置换掉 <code>2</code>，加入 <code>4</code>，[4, 0, 3]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>3</code> 最近最少使用，因此置换掉 <code>3</code>，加入 <code>2</code>，[4, 0, 2]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>0</code> 最近最少使用，因此置换掉 <code>0</code>，加入 <code>3</code>，[4, 3, 2]</li></ul></li><li>访问页面 <code>0</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>4</code> 最近最少使用，因此置换掉 <code>4</code>，加入 <code>0</code>，[0, 3, 2]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 已在内存中，无需置换，[0, 3, 2]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 已在内存中，无需置换，[0, 3, 2]</li></ul></li></ol><p>通过上述一系列页面访问，LRU 算法有效地将最近最少使用的页面置换出去，优化了内存使用效率。</p><hr><h4 id="3-8-3-先进先出页面置换算法（First-In-First-Out-FIFO）"><a href="#3-8-3-先进先出页面置换算法（First-In-First-Out-FIFO）" class="headerlink" title="3.8.3 先进先出页面置换算法（First-In-First-Out, FIFO）"></a>3.8.3 先进先出页面置换算法（First-In-First-Out, FIFO）</h4><p><strong>先进先出页面置换算法（FIFO）</strong> 是最简单的页面置换算法之一。其基本思想是，当内存已满且需要进行页面置换时，选择最早进入内存的页面进行置换。FIFO 算法的工作方式类似于排队的原理，先到的页面先被移出内存。</p><ul><li><strong>基本思路</strong>：FIFO 将页面访问序列看作一个队列。每当一个页面被加载到内存时，它会被放到队列的末尾。每当需要置换页面时，操作系统选择队列头部的页面进行置换，即最早进入内存的页面。</li><li><strong>页面置换</strong>：当进程需要访问一个页面，而该页面不在内存中时，发生缺页。此时操作系统会选择内存中最早加载的页面进行置换。</li></ul><p><strong>FIFO算法的工作流程</strong>：</p><ol><li><strong>页面访问</strong>：进程访问某个页面时，操作系统检查该页面是否已在内存中。如果在内存中，直接访问；如果不在内存中，则发生缺页。</li><li><strong>置换操作</strong>：当内存已满时，操作系统根据FIFO算法选择队列头部的页面进行置换，然后将新页面加载到内存中，并将其添加到队列的末尾。</li></ol><p>假设有一个内存管理系统，其物理内存有 3 个页框，进程产生的页面访问序列如下：<code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2</code></p><p><strong>FIFO算法步骤：</strong></p><ol><li>初始状态：页框为空</li><li>访问页面 <code>7</code>：<ul><li>页面 <code>7</code> 加入内存，[7]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 加入内存，[7, 0]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，[7, 0, 1]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>FIFO 算法会选择最早进入内存的页面。此时，<code>7</code> 最早进入，因此置换掉 <code>7</code>，加入 <code>2</code>，[0, 1, 2]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[0, 1, 2]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>0</code> 最早进入，因此置换掉 <code>0</code>，加入 <code>3</code>，[1, 2, 3]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 加入内存，替换最早进入的页面 <code>1</code>，[2, 3, 0]</li></ul></li><li>访问页面 <code>4</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>2</code> 最早进入，因此置换掉 <code>2</code>，加入 <code>4</code>，[3, 0, 4]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>3</code> 最早进入，因此置换掉 <code>3</code>，加入 <code>2</code>，[0, 4, 2]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>0</code> 最早进入，因此置换掉 <code>0</code>，加入 <code>3</code>，[4, 2, 3]</li></ul></li><li>访问页面 <code>0</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>4</code> 最早进入，因此置换掉 <code>4</code>，加入 <code>0</code>，[2, 3, 0]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 已在内存中，无需置换，[2, 3, 0]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 已在内存中，无需置换，[2, 3, 0]</li></ul></li></ol><p>通过上述一系列页面访问，FIFO 算法按照进入内存的顺序进行置换，维护了简单的页面管理逻辑。</p><p><strong>FIFO算法优点</strong>：</p><ul><li><strong>简单易懂</strong>：FIFO 算法非常简单，易于实现。</li><li><strong>实现简单</strong>：只需维护一个队列，记录页面的加载顺序。</li></ul><p><strong>FIFO算法缺点</strong>：</p><ul><li><strong>不考虑页面的实际使用频率</strong>：FIFO 仅根据页面的加载顺序进行置换，而不考虑页面被访问的频率或最近是否被访问过。因此，它可能会导致页面置换的效率低下。</li><li><strong>可能导致“Belady’s Anomaly”</strong>：在某些情况下，增加内存的数量反而可能导致缺页率增加，这种现象被称为 Belady’s Anomaly。</li></ul><blockquote><p>Belady现象：当为进程分配的物理块数增大时，缺页次数不减反增。<strong>只有FIFO算法</strong>发生Belady异常。FIFO实现简单，但不适应，算法性能差</p></blockquote><hr><h4 id="3-8-4-时钟页面置换算法（Clock-Page-Replacement-Algorithm）"><a href="#3-8-4-时钟页面置换算法（Clock-Page-Replacement-Algorithm）" class="headerlink" title="3.8.4 时钟页面置换算法（Clock Page Replacement Algorithm）"></a>3.8.4 时钟页面置换算法（Clock Page Replacement Algorithm）</h4><p>时钟页面置换算法是一种改进的最近最少使用（LRU）算法。它通过一个环形缓冲区（类似于时钟）和一个使用位（Use bit）来决定页面的置换。算法的核心思想是对页面进行循环扫描，当发现某个页面的使用位为 0 时，将其置换出去；否则，将其使用位清零，并继续扫描下一个页面。</p><p>假设有一个内存管理系统，其物理内存有 4 个页框，进程产生的页面访问序列如下：<code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code></p><p><strong>步骤：</strong></p><ol><li>初始状态：页框为空，指针指向第一个页框</li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*, 2*]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*]</li></ul></li><li>访问页面 <code>4</code>：<ul><li>页面 <code>4</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*, 4*]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 已在内存中，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*, 4*]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 已在内存中，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*, 4*]</li></ul></li><li>访问页面 <code>5</code>（内存已满）：<ul><li>指针指向页面 <code>1</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>2</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>3</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>4</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>1</code>，使用位为 0，将其置换为 <code>5</code>，设置使用位为 1，指针移动 [5*, 2, 3, 4]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，置换页面 <code>2</code>，设置使用位为 1，指针移动 [5*, 1*, 3, 4]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 加入内存，置换页面 <code>3</code>，设置使用位为 1，指针移动 [5*, 1*, 2*, 4]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 加入内存，置换页面 <code>4</code>，设置使用位为 1，指针移动 [5*, 1*, 2*, 3*]</li></ul></li><li>访问页面 <code>4</code>：<ul><li>页面 <code>4</code> 加入内存，置换页面 <code>5</code>，设置使用位为 1，指针移动 [4*, 1*, 2*, 3*]</li></ul></li><li>访问页面 <code>5</code>：<ul><li>页面 <code>5</code> 加入内存，置换页面 <code>1</code>，设置使用位为 1，指针移动 [4*, 5*, 2*, 3*]</li></ul></li></ol><hr><h4 id="3-8-5-最不常用页面置换算法（Least-Frequently-Used-LFU）"><a href="#3-8-5-最不常用页面置换算法（Least-Frequently-Used-LFU）" class="headerlink" title="3.8.5 最不常用页面置换算法（Least Frequently Used, LFU）"></a>3.8.5 最不常用页面置换算法（Least Frequently Used, LFU）</h4><p><strong>最不常用页面置换算法（LFU）</strong> 是一种根据页面访问频率进行页面置换的算法。LFU 的核心思想是将最少被访问的页面优先置换出去。即，系统会跟踪每个页面的访问次数，并选择访问次数最少的页面进行置换。</p><ul><li><strong>基本思路</strong>：LFU 维护一个计数器，用于记录每个页面被访问的频率。每当一个页面被访问时，其访问计数器增加。算法会选择那些访问次数最少的页面进行置换。</li><li><strong>页面置换</strong>：当内存已满且需要进行页面置换时，LFU 选择访问次数最少的页面。如果多个页面的访问频率相同，则选择其中最久未被访问的页面。</li></ul><p><strong>LFU算法的工作流程</strong>：</p><ol><li><strong>页面访问</strong>：每当一个页面被访问时，操作系统会将该页面的访问频率计数器加 1。</li><li><strong>页面置换</strong>：当内存已满时，系统选择访问频率最低的页面进行置换。如果多个页面的访问频率相同，系统将选择最久未被访问的页面进行置换。</li></ol><p>假设系统的内存可以存放 3 个页面，且进程的页面访问序列如下：<code>A, B, C, A, B, D, A, B, C, D</code></p><p><strong>初始状态：</strong></p><ul><li>内存容量为 3，初始为空。</li><li>访问序列：<code>A, B, C, A, B, D, A, B, C, D</code></li></ul><p><strong>按照访问序列进行页面置换</strong></p><ol><li><p><strong>访问页面 A</strong>：加载 A 到内存，访问频率为 1。</p><ul><li>内存状态：[A]</li></ul></li><li><p><strong>访问页面 B</strong>：加载 B 到内存，访问频率为 1。</p><ul><li>内存状态：[A, B]</li></ul></li><li><p><strong>访问页面 C</strong>：加载 C 到内存，访问频率为 1。</p><ul><li>内存状态：[A, B, C]</li></ul></li><li><p><strong>访问页面 A</strong>：A 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (2), B, C]</li></ul></li><li><p><strong>访问页面 B</strong>：B 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (2), B (2), C]</li></ul></li><li><p><strong>访问页面 D</strong>：内存已满，选择访问频率最低的页面 C 进行置换，加载 D 到内存。</p><ul><li>内存状态：[A (2), B (2), D (1)]</li></ul></li><li><p><strong>访问页面 A</strong>：A 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (3), B (2), D (1)]</li></ul></li><li><p><strong>访问页面 B</strong>：B 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (3), B (3), D (1)]</li></ul></li><li><p><strong>访问页面 C</strong>：选择访问频率最低的页面 D 进行置换，加载 C 到内存。</p><ul><li>内存状态：[A (3), B (3), C (1)]</li></ul></li><li><p><strong>访问页面 D</strong>：选择访问频率最低的页面 C 进行置换，加载 D 到内存。</p><ul><li>内存状态：[A (3), B (3), D (2)]</li></ul></li></ol><p><strong>最终内存状态</strong>：</p><ul><li>内存状态：[A, B, D]</li><li>页面置换序列：[C -&gt; D, C -&gt; D]</li></ul><p><strong>LFU算法的优缺点</strong>：</p><p><strong>优点</strong>：</p><ul><li><strong>考虑访问频率</strong>：LFU 算法通过考虑页面的访问频率，更加合理地选择置换页面，通常可以减少置换不常用的页面，减少缺页率。</li><li><strong>适用于长期不变的访问模式</strong>：当某些页面频繁访问时，LFU 能够有效保留这些页面，避免频繁置换。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>需要额外的空间和计算</strong>：LFU 需要维护每个页面的访问计数，并且在页面置换时可能需要遍历所有页面来查找访问频率最少的页面，增加了额外的空间和计算开销。</li><li><strong>容易受到初始访问模式的影响</strong>：如果页面的访问模式变化较大，LFU 可能会将那些短期内访问较少的页面置换出去，导致“页面漂移”问题。</li></ul><p>LFU 算法根据页面的访问频率来决定置换哪个页面，优先置换那些访问频率较低的页面。尽管 LFU 能够较好地反映页面的实际访问情况，但它在实现上比较复杂，并且在一些动态变化的访问模式下可能效率较低。</p><h2 id="4-File-Management"><a href="#4-File-Management" class="headerlink" title="4. File Management"></a>4. File Management</h2><p>文件的常见属性如下：</p><ol><li><p><strong>文件名（File Name）</strong></p><ul><li><strong>定义</strong>：文件名是操作系统用来标识文件的名称，它通常包括文件的主名和扩展名（例如：<code>document.txt</code>）。</li><li><strong>特点</strong>：在同一目录下，文件名必须唯一，否则会发生冲突。不同操作系统对文件名的长度和字符限制有所不同（例如，Windows不允许使用某些特殊字符，如 <code>*</code>, <code>?</code>, <code>:</code>, 等）。</li></ul></li><li><p><strong>标识符（Identifier）</strong></p><ul><li><strong>定义</strong>：标识符是操作系统用来唯一标识一个文件的内部名称。它对用户是不可见的。</li><li><strong>作用</strong>：操作系统通过标识符来区分不同的文件，即使它们的文件名相同。在操作系统内部，每个文件都需要一个独立的标识符，以避免文件冲突或误操作。</li></ul></li><li><p><strong>类型（Type）</strong></p><ul><li><strong>定义</strong>：文件类型指示文件的内容类别或格式（例如，文本文件、图像文件、音频文件等）。</li><li><strong>作用</strong>：文件类型可以帮助操作系统和用户理解文件的内容，甚至决定如何打开或处理该文件。例如，一个 <code>.txt</code> 文件通常表示纯文本文件，而 <code>.jpg</code> 则表示图像文件。操作系统通过文件扩展名或文件头来判断文件类型。</li></ul></li><li><p><strong>位置（Location）</strong></p><ul><li><strong>定义</strong>：文件位置表示文件在存储设备中的存放路径。</li><li><strong>作用</strong>：<ul><li><strong>用户使用的路径</strong>：这通常是用户查看和访问文件时所看到的路径，例如 <code>/home/user/documents/file.txt</code>。</li><li><strong>操作系统使用的地址</strong>：这是文件实际在存储设备（如硬盘）上的物理存放位置。这个信息通常是操作系统内部使用的，用户一般无法直接看到或修改。</li></ul></li></ul></li><li><p><strong>大小（Size）</strong></p><ul><li><strong>定义</strong>：文件的大小表示文件占用的存储空间量，通常以字节（byte）为单位。</li><li><strong>作用</strong>：文件大小帮助操作系统了解文件所需的存储空间，并且对用户来说，它是了解文件内容多少的一个重要指标。例如，一个 1MB 的图像文件相较于一个 10KB 的文本文件显然占用了更多的存储空间。</li></ul></li><li><p><strong>创建信息、上次修改时间、文件所有者信息（Creation Info, Last Modified Time, File Owner Info）</strong></p><ul><li><strong>定义</strong>：这些是文件的元数据，记录了文件的创建时间、最后一次修改的时间以及文件的所有者等信息。</li><li><strong>作用</strong>：<ul><li><strong>创建信息</strong>：记录文件的创建时间，帮助用户或系统追踪文件的生命周期。</li><li><strong>上次修改时间</strong>：记录文件最后一次被修改的时间，通常用于文件管理和版本控制。</li><li><strong>文件所有者信息</strong>：记录文件的拥有者和对文件的权限，通常与操作系统的权限管理系统相关，用来决定谁可以访问、修改文件。</li></ul></li></ul></li><li><p><strong>保护信息（Protection Info）</strong></p><ul><li><strong>定义</strong>：保护信息是文件的访问控制信息，指定哪些用户或程序可以读取、修改或删除文件。</li><li><strong>作用</strong>：操作系统通常通过权限（如读、写、执行权限）来保护文件，防止未授权的访问或操作。文件的保护信息决定了文件的安全性，确保只有具有适当权限的用户能够进行相关操作。</li></ul></li></ol><h3 id="4-1-文件在外存的存在方式"><a href="#4-1-文件在外存的存在方式" class="headerlink" title="4.1 文件在外存的存在方式"></a>4.1 文件在外存的存在方式</h3><p>文件在外存中存在的方式是由操作系统和存储设备的类型（如硬盘、固态硬盘、光盘、磁带等）共同决定的。外存（外部存储）是指计算机系统中的长期存储介质，和内存（RAM）相比，外存具有更大的存储容量，但访问速度较慢。文件在外存中的存储方式涉及文件的组织结构、存储地址分配、数据存储方法等多个方面。以下是文件如何在外存中存储的详细解释：</p><p><strong>1.文件的逻辑组织与物理存储</strong></p><p><strong>逻辑组织</strong></p><ul><li><strong>文件</strong>：文件是操作系统管理的基本数据单位，通常由文件名、文件类型、文件内容和元数据（如创建时间、修改时间、权限等）组成。用户通过文件系统对文件进行访问，而不需要关注文件在物理设备上的存储方式。</li><li><strong>目录结构</strong>：文件在外存中通常通过目录结构进行管理。目录（也叫文件夹）用来组织文件，以便于查找和管理。操作系统通过文件路径来定位文件的位置，路径可以是相对路径或绝对路径。</li></ul><p><strong>物理存储</strong></p><ul><li><p><strong>存储介质</strong>：外存设备（如硬盘、SSD）提供了文件存储的实际硬件介质。不同的存储设备有不同的存储方式。例如：</p><ul><li>硬盘（HDD）存储数据为磁性信号，采用磁头在盘片上移动进行读写。</li><li>固态硬盘（SSD）使用闪存芯片存储数据，通过电子信号读写数据。</li><li>光盘（CD&#x2F;DVD）使用激光束读取和写入数据。</li></ul><p>虽然存储介质不同，但大多数情况下文件的存储方式都基于 <strong>块（Block）</strong> 或 <strong>簇（Cluster）</strong> 的概念，即文件会被划分成多个小块，分布在存储介质的不同位置。</p></li></ul><p><strong>2.文件在外存中的存储方式</strong></p><p><strong>连续存储方式（Contiguous Allocation）</strong></p><ul><li>在这种方式下，文件的所有数据块是连续存储的。即文件内容被写入外存时，操作系统会为其分配一段连续的存储空间，确保文件的所有数据都在这段空间内。</li><li><strong>优点</strong>：读取速度较快，因为文件的数据存储在连续的块中，磁头无需频繁跳转。</li><li><strong>缺点</strong>：随着文件的增加和删除，外存中的空闲空间可能变得零散，这会导致“外碎片”，并且难以为大型文件分配足够大的连续空间。</li></ul><p><strong>链式存储方式（Linked Allocation）</strong></p><ul><li>在这种方式下，文件被分成多个数据块，每个数据块都包含一个指向下一个数据块的指针。文件的数据块可以存储在磁盘上的任何位置，操作系统通过指针链接这些数据块。</li><li><strong>优点</strong>：可以灵活地分配空间，不需要连续的存储块，可以避免外碎片问题。</li><li><strong>缺点</strong>：由于每个数据块都包含指针，读取时需要多次磁盘寻址，速度相对较慢。</li></ul><p><strong>索引存储方式（Indexed Allocation）</strong></p><ul><li>在这种方式下，操作系统为每个文件创建一个索引块，该索引块包含指向文件数据块的指针。文件的实际数据块可以存储在磁盘上的任何位置，操作系统通过索引块来查找文件的各个数据块。</li><li><strong>优点</strong>：提高了查找效率，文件的各个数据块可以非连续存储，避免了外碎片问题。</li><li><strong>缺点</strong>：需要额外的存储空间来保存索引块，且对于大文件，索引块可能需要多级索引。</li></ul><img src="/img/OS/file_storage.svg" alt="文件在外存的存储方式" style="max-width: 100%; height: auto;" /><p><strong>3.文件系统（File System）</strong></p><p>文件系统是操作系统与存储设备之间的桥梁，它定义了文件如何在外存中存储、管理、访问和保护。文件系统负责将逻辑文件映射到物理存储介质上。</p><p><strong>常见的文件系统类型</strong></p><ul><li><strong>FAT（File Allocation Table）</strong>：FAT 是一种早期的文件系统，适用于小型存储设备。它采用简单的链式存储方式，通过一个文件分配表记录文件数据块的存储位置。</li><li><strong>NTFS（New Technology File System）</strong>：NTFS 是 Windows 操作系统常用的文件系统，支持更复杂的文件存储方式，如索引存储、文件权限管理、加密等。</li><li><strong>ext3&#x2F;ext4</strong>：Linux 操作系统常用的文件系统。ext4 是 ext3 的改进版，提供更好的性能、可靠性和更大的文件支持。</li><li>HFS+：macOS 使用的文件系统，支持元数据和文件权限控制。</li></ul><p><strong>文件系统的工作原理</strong></p><ul><li><strong>文件分配</strong>：操作系统通过文件系统将文件划分成多个数据块，并将这些数据块分配到外存中。不同文件系统可能使用不同的分配策略（如连续分配、链式分配、索引分配等）。</li><li><strong>目录管理</strong>：文件系统通过目录结构来组织文件。每个文件都有一个唯一的路径，路径帮助操作系统找到文件的位置。目录项通常包含文件名、文件大小、创建时间、修改时间、权限等信息。</li><li><strong>文件元数据</strong>：文件的元数据（如创建时间、权限等）存储在文件系统的索引节点（inode）或类似结构中。这些元数据有助于文件的管理和访问控制。</li></ul><p><strong>4.访问文件</strong></p><p>文件一旦存储到外存中，用户或程序就可以通过文件路径访问文件。操作系统通过文件系统将用户的请求转化为磁盘读写操作：</p><ul><li><strong>读取文件</strong>：操作系统根据文件路径找到文件的索引信息，然后查找文件在外存中的数据块。接着，操作系统读取这些数据块，并将文件内容返回给用户。</li><li><strong>写入文件</strong>：当文件需要修改时，操作系统会分配新的数据块（如果需要）并将修改后的内容写入外存。同时，文件的元数据（如修改时间）也会被更新。</li></ul><p><strong>5.文件的保护与安全</strong></p><p>操作系统通过文件系统提供对文件的保护机制，确保文件的安全性和完整性。这些保护措施包括：</p><ul><li><strong>权限控制</strong>：文件系统通常会为文件设置访问权限（如读、写、执行权限），并为每个用户或用户组设置不同的权限，以限制未授权的访问。</li><li><strong>加密与备份</strong>：操作系统还可以通过加密技术保护文件的内容，并通过备份机制防止文件丢失或损坏。</li></ul><hr><h3 id="4-2-文件管理功能"><a href="#4-2-文件管理功能" class="headerlink" title="4.2 文件管理功能"></a>4.2 文件管理功能</h3><p>操作系统向上提供的文件管理功能是通过系统调用来实现的。系统调用是程序与操作系统之间的接口，用户程序通过系统调用请求操作系统执行某些任务，如文件的创建、删除、读写等。以下是每个功能的详细解释：</p><p><strong>1.创建文件 (create 系统调用)</strong></p><p>功能：</p><ul><li><code>create</code> 系统调用用于在文件系统中创建一个新的文件。当用户希望在磁盘或其他外部存储设备上存储数据时，首先需要创建一个文件。</li></ul><p>过程：</p><ul><li>操作系统首先检查文件名是否有效，以及是否已经存在同名文件。</li><li>如果文件名有效且没有同名文件，操作系统会为该文件分配一个唯一的文件标识符，并在文件系统中为文件分配存储空间。</li><li>创建文件时，操作系统通常会为该文件生成相关的元数据（如创建时间、权限等）。</li></ul><p>返回值：</p><ul><li>成功时，返回一个指向新文件的文件描述符（用于后续的读写操作）。</li><li>失败时，返回错误代码（如文件已存在、权限不足等）。</li></ul><p><strong>2.删除文件 (delete 系统调用)</strong></p><p>功能：</p><ul><li><code>delete</code> 系统调用用于删除指定的文件。它将文件从文件系统中移除，释放文件所占用的存储空间。</li></ul><p>过程：</p><ul><li>操作系统首先会检查文件是否存在。如果文件不存在，删除操作将失败。</li><li>接着，操作系统会清除文件的目录项，删除与文件相关的元数据。</li><li>文件的实际数据块也会被标记为空闲，准备供其他文件使用。</li><li>删除文件时，操作系统还会处理可能的文件锁定和权限问题，确保删除操作不会影响正在访问该文件的进程。</li></ul><p>返回值：</p><ul><li>成功时，文件会被删除，返回成功状态。</li><li>失败时，返回错误代码（如文件不存在、权限不足等）。</li></ul><p><strong>3.读文件 (read 系统调用)</strong></p><p>功能：</p><ul><li><code>read</code> 系统调用用于从已经打开的文件中读取数据。进程使用 <code>read</code> 调用将文件中的内容加载到内存中，供程序使用。</li></ul><p>过程：</p><ul><li>操作系统检查文件是否已经被成功打开。</li><li>操作系统会根据文件描述符定位文件的当前读取位置，并从文件中读取指定大小的数据。</li><li>读取的数据会存储在用户提供的缓冲区中，供进程使用。</li><li>每次读取后，操作系统会更新文件的指针，指向下一个待读取的位置。</li></ul><p>返回值：</p><ul><li>成功时，返回实际读取的字节数。如果到达文件末尾，返回 0。</li><li>失败时，返回错误代码（如文件不存在、权限问题等）。</li></ul><p><strong>4.写文件 (write 系统调用)</strong></p><p>功能：</p><ul><li><code>write</code> 系统调用用于将数据写入到已经打开的文件中。进程通过该调用向文件中存储数据。</li></ul><p>过程：</p><ul><li>操作系统检查文件是否已经打开并具有写权限。</li><li>操作系统根据文件描述符定位文件的当前写入位置，并将数据写入文件。</li><li>写入操作可能会涉及到将数据从用户空间传输到内核空间，再由内核空间传输到存储设备（如硬盘）。</li><li>操作系统在写入数据后，会更新文件的指针，指向下一个待写入的位置。</li></ul><p>返回值：</p><ul><li>成功时，返回实际写入的字节数。</li><li>失败时，返回错误代码（如磁盘空间不足、权限问题等）。</li></ul><p><strong>5.打开文件 (open 系统调用)</strong></p><p>功能：</p><ul><li><code>open</code> 系统调用用于打开一个现有文件，或者创建一个新文件以供后续读写操作。打开文件时，操作系统会为文件分配一个文件描述符。</li></ul><p>过程：</p><ul><li>操作系统会检查文件路径和文件名是否有效，并确认文件是否存在。如果文件不存在且请求创建，操作系统会创建新文件。</li><li>操作系统会检查文件的访问权限（如读、写、执行等），以确保进程有足够的权限访问该文件。</li><li>文件描述符是文件在操作系统中的唯一标识符，打开文件时，操作系统会为文件分配一个文件描述符，并返回给用户进程。</li><li>如果成功打开文件，进程可以通过该文件描述符进行后续的读写操作。</li></ul><p>返回值：</p><ul><li>成功时，返回文件的文件描述符。</li><li>失败时，返回错误代码（如文件不存在、权限不足等）。</li></ul><p><strong>6.关闭文件 (close 系统调用)</strong></p><p>功能：</p><ul><li><code>close</code> 系统调用用于关闭一个已经打开的文件，释放文件描述符，使得该文件不再被当前进程使用。</li></ul><p>过程：</p><ul><li>操作系统检查文件描述符是否有效。如果有效，操作系统会关闭该文件，释放相关的资源。</li><li>关闭文件时，操作系统会更新文件的元数据（如最后访问时间），并确保文件的缓冲区数据已经刷新到存储设备中，防止数据丢失。</li><li>关闭文件后，文件描述符不再有效，进程无法再通过该描述符进行读写操作。</li></ul><p>返回值：</p><ul><li>成功时，返回成功状态。</li><li>失败时，返回错误代码（如文件描述符无效等）。</li></ul><hr><h3 id="4-3-文件控制块-FCB"><a href="#4-3-文件控制块-FCB" class="headerlink" title="4.3 文件控制块(FCB)"></a>4.3 文件控制块(FCB)</h3><p>操作系统中的 <strong>文件控制块</strong>（File Control Block，FCB）是操作系统用来管理文件的一种数据结构，它包含了文件的各种信息，支持操作系统对文件的有效管理和访问。每个文件在文件系统中都有一个与之对应的 FCB，当文件被打开时，操作系统会创建一个 FCB 并将其存储在内存中，以便对文件进行操作。</p><p>FCB 的主要作用是：</p><ol><li><strong>文件管理</strong>：操作系统通过 FCB 来管理文件的存储位置、大小、权限等元数据。</li><li><strong>文件访问</strong>：FCB 使得操作系统能够快速、准确地访问文件的相关信息，从而支持对文件的读写操作。</li><li><strong>资源管理</strong>：FCB 包含文件的使用信息，帮助操作系统协调对文件的访问，确保文件的安全性和一致性。</li></ol><p>FCB 中存储了与文件相关的多种信息，具体包括但不限于以下内容：</p><ol><li><p>文件名（File Name）：存储文件的名称。文件名用于标识文件，可以是文件的完整路径或仅是文件名。</p></li><li><p>文件标识符（File Identifier）：用于唯一标识一个文件。在文件操作中，操作系统通过文件标识符（例如文件描述符）来引用文件。</p></li><li><p>文件类型（File Type）：指定文件的类型，例如文本文件、二进制文件、图像文件等。操作系统根据文件类型来决定如何处理文件的内容。</p></li><li><p>文件大小（File Size）：文件的当前大小，通常以字节为单位。操作系统根据文件大小来分配空间、管理磁盘存储等。</p></li><li><p>文件位置（File Location）：存储文件的数据在磁盘中的位置。操作系统通过这一信息来找到文件的数据块并执行文件的读写操作。可能包含一个或多个数据块的位置信息。</p></li><li><p>访问权限（Access Control Information）：包含文件的访问控制信息，指定哪些用户或进程有权读取、写入或执行该文件。常见的权限包括读取权限、写入权限和执行权限。</p></li><li><p>文件状态（File Status）：记录文件的当前状态，例如是否被打开、是否被锁定等。操作系统根据文件状态来决定文件的访问和操作。</p></li><li><p>文件的创建时间、修改时间和访问时间（Timestamps）：记录文件的创建时间、最后修改时间以及最后访问时间。这些信息对文件的管理、审计和备份等操作非常重要。</p></li><li><p>文件的所有者信息（Owner Information）：文件的所有者或创建者的标识。操作系统利用这些信息来实施权限控制和安全性检查。</p></li><li><p>文件指针（File Pointer）：文件指针指向文件中当前读取或写入的位置。每次文件读取或写入时，操作系统会更新文件指针的位置，以便下一次操作。</p></li><li><p>文件锁定信息（File Locking Information）：用于文件锁定机制中，指示文件是否被某个进程锁定。文件锁定机制可以防止多个进程同时访问同一文件，造成数据冲突或损坏。</p></li></ol><hr><p>文件控制块的工作原理如下：</p><ol><li><p><strong>文件的创建和打开</strong>：</p><ul><li>当用户创建或打开一个文件时，操作系统会在内存中为该文件分配一个 FCB。FCB 包含了文件的各种元数据，操作系统会根据 FCB 来管理文件的存储和访问。</li></ul></li><li><p><strong>文件的访问</strong>：</p><ul><li>每当文件被读取或写入时，操作系统会通过 FCB 来获取文件的位置、大小、状态等信息，确保文件操作的正确性和安全性。</li></ul></li><li><p><strong>文件的关闭</strong>：</p><ul><li>当文件操作完成后，操作系统会更新文件的元数据（如修改时间、文件大小等），并释放 FCB。文件控制块在文件关闭时会被销毁。</li></ul></li><li><p><strong>文件的删除</strong>：</p><ul><li>删除文件时，操作系统会首先检查文件的 FCB，然后清除文件的元数据，并释放文件所占用的空间。删除文件的 FCB 通常会从文件控制块表中移除。</li></ul></li></ol><hr><p>文件控制块的具体结构和存储方式会根据不同的文件系统有所不同。例如：</p><ul><li><p><strong>FAT（File Allocation Table）文件系统</strong>：</p><ul><li>在 FAT 文件系统中，文件控制块通常包含一个指向文件分配表的指针。文件分配表记录了文件的数据块位置，因此操作系统可以通过文件控制块快速查找到文件的存储位置。</li></ul></li><li><p><strong>NTFS 文件系统</strong>：</p><ul><li>NTFS 使用称为 “MFT（Master File Table）条目” 的数据结构，每个文件在 MFT 中有一个对应的条目，类似于 FCB。这个条目中保存了文件的各种元数据，包括文件大小、存储位置、权限等。</li></ul></li><li><p><strong>ext3&#x2F;ext4 文件系统</strong>：</p><ul><li>在 Linux 的 ext 文件系统中，文件控制块类似于一个 inode（索引节点）。inode 中存储了文件的元数据，但不包括文件名，文件名存储在目录结构中。每个文件都对应一个 inode，操作系统通过 inode 来管理文件的存储。</li></ul></li></ul><p>文件控制块是操作系统中用于管理文件的核心数据结构，它包含了文件的各种元数据，帮助操作系统执行对文件的读取、写入、删除等操作。通过文件控制块，操作系统能够高效地管理文件系统，确保文件的完整性、安全性和一致性。</p><h2 id="5-I-O-Device-Management"><a href="#5-I-O-Device-Management" class="headerlink" title="5. I&#x2F;O Device Management"></a>5. I&#x2F;O Device Management</h2><p>I&#x2F;O（输入&#x2F;输出）设备管理是操作系统中一个重要的功能模块，它负责管理和调度计算机系统中各种硬件设备的输入和输出操作。I&#x2F;O 设备管理的主要任务是通过提供统一的接口，使得操作系统和应用程序能够方便、高效地与外部设备进行交互，而不需要直接操控硬件。操作系统通过一组 I&#x2F;O 控制器（I&#x2F;O Controllers）和驱动程序（Device Drivers）来实现对硬件设备的控制和管理。</p><p>I&#x2F;O 设备通常分为以下几种类型：</p><ul><li><strong>输入设备</strong>：如键盘、鼠标、扫描仪、麦克风等。</li><li><strong>输出设备</strong>：如显示器、打印机、扬声器等。</li><li><strong>存储设备</strong>：如硬盘、固态硬盘（SSD）、光盘、USB 驱动器等。</li><li><strong>网络设备</strong>：如网络接口卡（NIC）、无线适配器等。</li></ul><p>这些设备通常与计算机的中央处理单元（CPU）之间通过总线连接，操作系统需要负责这些设备的数据传输、缓冲区管理、设备调度等。</p><p>I&#x2F;O 设备管理的核心任务是提供一个抽象层，使得应用程序可以透明地访问不同类型的 I&#x2F;O 设备。具体包括以下几个方面：</p><p><strong>2.1 I&#x2F;O 调度（I&#x2F;O Scheduling）</strong></p><p>I&#x2F;O 调度是操作系统负责安排和管理对 I&#x2F;O 设备的访问。I&#x2F;O 调度的目标是优化 I&#x2F;O 操作，提高系统的整体性能和响应速度。常见的 I&#x2F;O 调度算法有：</p><ul><li><strong>先来先服务（FCFS，First-Come, First-Served）</strong>：按照 I&#x2F;O 请求的到达顺序进行处理。虽然简单，但可能导致较长的等待时间。</li><li><strong>最短寻道时间优先（SSTF，Shortest Seek Time First）</strong>：选择离当前磁头位置最近的 I&#x2F;O 请求，减少磁盘寻道时间。</li><li><strong>扫描算法（SCAN）</strong>：磁头从一端扫描到另一端，处理所有请求，然后反向扫描。又称电梯算法（Elevator Algorithm）。</li><li><strong>循环扫描算法（C-SCAN）</strong>：类似 SCAN，但在到达磁盘的一端后，磁头会跳回另一端，而不是反向扫描。</li></ul><hr><p><strong>2.2 I&#x2F;O 操作的抽象（Device Abstraction）</strong></p><p>I&#x2F;O 操作的抽象指的是将具体的硬件操作（如读写硬盘、打印文件等）转化为更高层次的操作接口。操作系统通过设备驱动程序提供一个标准化的接口，允许用户和应用程序在不考虑底层硬件的情况下进行操作。</p><p>例如，应用程序请求读取文件时，操作系统会将该请求转化为对硬件设备的读写操作，而不需要程序了解硬盘是如何工作的。这样，操作系统就屏蔽了硬件细节，为程序提供了统一的访问接口。</p><hr><p><strong>2.3 I&#x2F;O 缓冲（Buffering）</strong></p><p>I&#x2F;O 缓冲是操作系统用来提高 I&#x2F;O 性能的一种技术。缓冲区是一块在内存中的区域，用于暂时存储从 I&#x2F;O 设备读取的数据或写入 I&#x2F;O 设备的数据。通过使用缓冲区，操作系统可以在等待 I&#x2F;O 操作完成的同时执行其他任务，减少设备的空闲时间和等待时间。</p><ul><li><strong>输入缓冲（Input Buffering）</strong>：当从输入设备（如键盘、网络等）读取数据时，操作系统会先将数据存放在缓冲区，应用程序再从缓冲区读取数据。</li><li><strong>输出缓冲（Output Buffering）</strong>：操作系统将待写入输出设备的数据先放到缓冲区中，然后由设备驱动程序将数据写入实际的设备中。</li></ul><hr><p><strong>2.4 I&#x2F;O 错误处理（Error Handling）</strong></p><p>由于硬件设备可能会出现各种故障（如设备未响应、硬件损坏等），操作系统需要具备处理 I&#x2F;O 错误的能力。常见的错误处理策略包括：</p><ul><li><strong>重试机制</strong>：在发生 I&#x2F;O 错误时，操作系统可以重试操作，尝试恢复操作。</li><li><strong>错误日志记录</strong>：操作系统可以记录发生错误的详细信息，以便后续的调试和维护。</li><li><strong>设备替换或恢复</strong>：如果某个设备出现故障，操作系统可以尝试切换到备用设备或恢复设备的功能。</li></ul><hr><p><strong>2.5 设备驱动程序（Device Drivers）</strong></p><p>设备驱动程序是操作系统与硬件设备之间的桥梁。它提供了一个标准化的接口，允许操作系统控制各种硬件设备。设备驱动程序通常是为每个硬件设备单独编写的，负责管理设备的初始化、数据传输、错误处理等。</p><ul><li><strong>设备初始化</strong>：设备驱动程序负责初始化设备，使设备能够正常工作。</li><li><strong>数据传输</strong>：设备驱动程序负责从设备读取数据或将数据写入设备。</li><li><strong>设备控制</strong>：设备驱动程序通过控制命令（如启动、停止、暂停）管理设备的状态。</li></ul><hr><p><strong>2.6 I&#x2F;O 同步与异步（Synchronous vs Asynchronous）</strong></p><p>I&#x2F;O 操作可以是同步的（Synchronous）或异步的（Asynchronous）：</p><ul><li><strong>同步 I&#x2F;O</strong>：应用程序会等待 I&#x2F;O 操作完成后才继续执行后续操作。即，程序执行被阻塞，直到 I&#x2F;O 操作完成。</li><li><strong>异步 I&#x2F;O</strong>：应用程序发起 I&#x2F;O 操作后，不必等待操作完成，可以继续执行其他任务。操作系统会在 I&#x2F;O 操作完成时通知应用程序。</li></ul><hr><p>操作系统通常通过以下几个机制实现对 I&#x2F;O 设备的管理：</p><p><strong>3.1 I&#x2F;O 控制器</strong></p><p>I&#x2F;O 控制器（I&#x2F;O Controllers）是硬件组件，用于管理 I&#x2F;O 设备和 CPU 之间的通信。它负责将来自 CPU 的 I&#x2F;O 请求转化为适合设备理解的命令，并将设备的响应转化为 CPU 可理解的格式。</p><p><strong>3.2 I&#x2F;O 总线</strong></p><p>I&#x2F;O 总线（I&#x2F;O Bus）是连接 CPU、内存和 I&#x2F;O 设备的通信通道。通过 I&#x2F;O 总线，操作系统可以控制多个设备，同时传输数据。常见的 I&#x2F;O 总线包括 PCI（Peripheral Component Interconnect）、SATA（Serial ATA）、USB（Universal Serial Bus）等。</p><p><strong>3.3 设备独立性</strong></p><p>操作系统提供了设备独立性（Device Independence），使得应用程序可以在不关心底层硬件的情况下进行 I&#x2F;O 操作。设备独立性由设备驱动程序和操作系统的抽象机制提供。</p><p>I&#x2F;O 设备管理是操作系统中至关重要的组成部分，涉及设备调度、错误处理、数据传输、设备驱动程序等多个方面。操作系统通过设备驱动程序和 I&#x2F;O 调度算法提供了一个统一的接口，使得应用程序能够高效、可靠地与各种硬件设备进行交互。良好的 I&#x2F;O 管理不仅可以提高系统性能，还能有效提升用户体验。</p><hr><p>最后需要简单补充一下2个常用到的技术。</p><p><strong>DMA（Direct Memory Access，直接内存存取）</strong> 是一种允许外围设备（如硬盘、网络卡等）直接与内存之间进行数据传输的技术，而无需通过CPU。这种方式可以显著减少CPU的负担，提高系统的整体性能。</p><p><strong>DMA工作过程</strong></p><ol><li><strong>初始化</strong>：CPU首先向DMA控制器发送命令，指定数据传输的源地址、目的地址和传输的数据量。</li><li><strong>传输过程</strong>：DMA控制器接管总线的控制权，并在设备和内存之间直接进行数据传输。这时，CPU可以处理其他任务，不需要参与传输过程。</li><li><strong>传输完成</strong>：当数据传输完成后，DMA控制器会向CPU发送中断信号，通知CPU传输已经完成。</li></ol><p><strong>DMA优点</strong></p><ul><li><strong>提高效率</strong>：因为CPU不需要直接参与数据传输，所以可以腾出更多资源来处理其他任务。</li><li><strong>减少延迟</strong>：直接传输数据，减少了数据传输过程中的延迟。</li><li><strong>高效处理大量数据</strong>：适用于大规模数据传输，如多媒体文件的读取和写入。</li></ul><p><strong>DMA应用场景</strong></p><ul><li><strong>多媒体处理</strong>：视频、音频等大文件的快速传输。</li><li><strong>网络数据传输</strong>：如网络适配器中数据包的快速处理。</li><li><strong>硬盘数据读取&#x2F;写入</strong>：提升硬盘读写速度。</li></ul><img src="/img/OS/dma.svg" alt="DMA方式" style="max-width: 100%; height: auto;" /><hr><p>SPOOLing（Simultaneous Peripheral Operations On-Line）是一种将外围设备的输入&#x2F;输出操作排队等待执行的技术。它通过将任务临时存储在中间存储设备（如硬盘或内存）中，使CPU和外围设备能够同时处理多个任务，从而提高系统的整体效率。</p><p><strong>SPOOLing工作过程</strong></p><ol><li><strong>任务提交</strong>：作业被提交到系统中，系统将作业存储在一个临时存储区域（如磁盘）中，这个过程称为任务排队。</li><li><strong>任务排队</strong>：系统将多个作业排队等待处理。当外围设备空闲时，系统从队列中取出一个作业进行处理。</li><li><strong>任务执行</strong>：外围设备（如打印机、磁带机等）根据排队的顺序依次处理每个作业。处理完成后，系统将作业从队列中移除。</li></ol><p><strong>优点</strong></p><ul><li><strong>提高资源利用率</strong>：通过任务排队和并行处理，提高了系统资源（CPU、外围设备等）的利用率。</li><li><strong>减少等待时间</strong>：作业可以在外围设备空闲时自动开始处理，减少了用户的等待时间。</li><li><strong>高效处理大量任务</strong>：适用于需要处理大量I&#x2F;O操作的场景，如打印作业、磁带备份等。</li></ul><p><strong>应用场景</strong></p><ul><li><strong>打印作业</strong>：多个打印任务被排队等待处理，提高打印机的利用率。</li><li><strong>磁带备份</strong>：备份任务排队等待磁带机处理，提高备份效率。</li><li><strong>批处理作业</strong>：适用于需要批量处理的任务，如数据处理、报表生成等。</li></ul><img src="/img/OS/spooling_diagram.svg" alt="SPOOLing方式" style="max-width: 100%; height: auto;" /><blockquote><p>这里再啰嗦一下SPOOling技术，因为我在很多修考题里面看到了对这个名词的解释的题目</p></blockquote><h2 id="6-Large-Capacity-Storage-Structures"><a href="#6-Large-Capacity-Storage-Structures" class="headerlink" title="6. Large Capacity Storage Structures"></a>6. Large Capacity Storage Structures</h2><p>操作系统中的大容量存储结构主要用于持久存储大量数据，确保数据的长期保存和高效访问。常见的大容量存储结构包括以下几种：</p><p>1.硬盘（Hard Disk Drive, HDD）：硬盘是最常见的大容量存储设备，广泛应用于计算机中。它通过磁性介质（通常是磁盘盘片）来存储数据，使用磁头进行读写操作。</p><ul><li><strong>特点</strong>：容量大、成本相对低、读写速度较慢。</li><li><strong>存储结构</strong>：磁盘被划分为多个<strong>磁道（Track）</strong>和<strong>扇区（Sector）</strong>，数据以块的形式存储。多个磁道组成一个<strong>柱面（Cylinder）</strong>。</li></ul><p>2.固态硬盘（Solid State Drive, SSD）:SSD是近年来发展迅速的存储设备，它使用闪存（Flash Memory）来存储数据，没有机械部件，因此在性能上优于HDD。</p><ul><li><strong>特点</strong>：读写速度快、抗震、噪音低、功耗低，但成本较高。</li><li><strong>存储结构</strong>：SSD没有机械盘片，数据存储在<strong>NAND闪存单元</strong>中，数据存储结构是基于<strong>块（Block）</strong>和<strong>页面（Page）</strong>，每个块由多个页面组成。</li></ul><p>3.光盘（CD&#x2F;DVD&#x2F;Blu-ray）:光盘通过激光读取和写入数据，适用于大容量数据的长期存储和归档。</p><ul><li><strong>特点</strong>：容量较大、价格便宜、便于携带，但读写速度较慢，且不适用于频繁读写。</li><li><strong>存储结构</strong>：光盘上的数据通过螺旋轨迹排列，可以按块存储数据。常见的结构包括<strong>光盘的扇区</strong>，和不同容量的光盘（如CD、DVD、Blu-ray）。</li></ul><p>4.磁带（Magnetic Tape）:磁带是较早的存储设备，通常用于大规模数据备份和归档。它通过磁性介质进行数据存储。</p><ul><li><strong>特点</strong>：存储容量大，成本低，但随机访问速度慢，主要用于长期存储和备份。</li><li><strong>存储结构</strong>：数据以顺序方式存储在磁带上，采用线性存储结构。通过磁头顺序读取数据，适合用于批量处理和备份。</li></ul><p>5.网络附加存储（NAS, Network Attached Storage）:NAS是一种通过网络连接的存储设备，允许多个用户和计算机共享存储资源，常用于文件存储和数据备份。</p><ul><li><strong>特点</strong>：容量可扩展、支持共享存储、易于管理，但性能依赖网络带宽和设备配置。</li><li><strong>存储结构</strong>：NAS使用文件系统来组织和管理数据，可以支持多种存储结构，如<strong>RAID</strong>、<strong>LUN（Logical Unit Number）</strong>等。</li></ul><p>6.存储区域网络（SAN, Storage Area Network）:SAN是一种专门为存储设备提供高速网络连接的架构，主要用于数据中心、企业级存储。</p><ul><li><strong>特点</strong>：高性能、高可扩展性、支持大容量数据存储和快速访问。</li><li><strong>存储结构</strong>：SAN一般使用<strong>块存储</strong>，通常配合<strong>RAID技术</strong>进行冗余存储。通过高速光纤通道（Fibre Channel）或iSCSI协议连接存储设备和服务器。</li></ul><p>7.云存储（Cloud Storage）:云存储指通过互联网将数据存储在远程数据中心的服务，通常由第三方提供，如Amazon S3、Google Drive、OneDrive等。</p><ul><li><strong>特点</strong>：易于扩展、数据安全性高、可以实现跨平台访问，但依赖于网络连接。</li><li><strong>存储结构</strong>：云存储通常采用<strong>对象存储</strong>（如Amazon S3）或<strong>块存储</strong>（如EBS），并通过网络接口与用户的设备进行交互。</li></ul><p>8.闪存卡（Flash Card）:闪存卡是一种基于闪存的存储设备，常见的如SD卡、CF卡等，广泛用于移动设备和相机等设备中。</p><ul><li><strong>特点</strong>：容量适中、速度较快、便于携带。</li><li><strong>存储结构</strong>：与SSD类似，闪存卡的数据以块和页面为单位存储。</li></ul><p>9.RAM磁盘（RAM Disk）:RAM磁盘是一种使用计算机内存作为虚拟磁盘的技术，通常用于需要极高速访问的临时数据存储。</p><ul><li><strong>特点</strong>：极高的读写速度，但数据会随着断电丢失。</li><li><strong>存储结构</strong>：RAM磁盘使用系统内存中的一部分区域来模拟磁盘，数据以块的方式进行存储。</li></ul><p>10.分布式存储系统分布式存储是通过多个节点（服务器）共同协作，提供一个虚拟化的存储空间，常用于大规模数据存储和处理，如HDFS（Hadoop分布式文件系统）。</p><ul><li><strong>特点</strong>：高可扩展性、高容错性、适合大规模数据存储。</li><li><strong>存储结构</strong>：数据通常分布</li></ul><h3 id="6-1-磁盘调度算法"><a href="#6-1-磁盘调度算法" class="headerlink" title="6.1 磁盘调度算法"></a>6.1 磁盘调度算法</h3><p>磁盘调度算法是操作系统用来决定磁盘请求的处理顺序的策略，目的是优化磁盘的性能，减少磁头的寻道时间，从而提高系统的整体性能。磁盘的读写操作需要移动磁头到不同的磁道，而磁头的移动时间被称为<strong>寻道时间</strong>。磁盘调度算法通过合理安排请求的处理顺序，减少磁头的移动，提高磁盘的利用效率。</p><p>下面介绍一下常见的磁盘调度算法</p><h4 id="6-1-先来先服务（FCFS-First-Come-First-Served）"><a href="#6-1-先来先服务（FCFS-First-Come-First-Served）" class="headerlink" title="6.1 先来先服务（FCFS, First-Come First-Served）"></a>6.1 先来先服务（FCFS, First-Come First-Served）</h4><p><strong>FCFS</strong>是最简单的一种磁盘调度算法，磁盘请求按照到达的顺序处理，不进行优化。</p><ul><li><strong>原理</strong>：按请求到达的顺序处理磁盘请求。</li><li><strong>优点</strong>：<ul><li>实现简单，易于理解。</li><li>无需额外的计算开销。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能导致磁头来回移动，增加寻道时间，特别是当请求在磁盘的两端时。</li><li><strong>寻道时间</strong>不确定，效率较低。</li></ul></li></ul><h4 id="6-2-最短寻道时间优先（SSTF-Shortest-Seek-Time-First）"><a href="#6-2-最短寻道时间优先（SSTF-Shortest-Seek-Time-First）" class="headerlink" title="6.2 最短寻道时间优先（SSTF, Shortest Seek Time First）"></a>6.2 最短寻道时间优先（SSTF, Shortest Seek Time First）</h4><p><strong>SSTF</strong>算法每次选择离当前磁头位置最近的请求进行处理，优先处理距离当前磁头最近的磁道请求。</p><ul><li><strong>原理</strong>：每次处理最接近当前磁头的请求，从而最小化寻道时间。</li><li><strong>优点</strong>：<ul><li>比FCFS更高效，因为它减少了磁头的移动。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能会导致“饥饿”现象，即距离磁头较远的请求可能长时间得不到处理。</li><li>无法保证所有请求的公平性。</li></ul></li></ul><h4 id="6-3-扫描算法（SCAN）"><a href="#6-3-扫描算法（SCAN）" class="headerlink" title="6.3 扫描算法（SCAN）"></a>6.3 扫描算法（SCAN）</h4><p><strong>SCAN</strong>算法也叫电梯算法，它模拟电梯的运动方式，磁头在一个方向上扫描，直到达到磁盘的一端，再反向扫描，处理请求。</p><ul><li><strong>原理</strong>：磁头沿着磁盘扫描，遇到请求就处理，直到扫描到磁盘的边缘，然后反方向扫描。</li><li><strong>优点</strong>：<ul><li>较为平衡，能够避免“饥饿”现象。</li><li>磁头的运动有规律，寻道时间较为可控。</li></ul></li><li><strong>缺点</strong>：<ul><li>磁头每次扫描到磁盘的最远端后，再反向扫描，可能导致一端的请求处理得较慢。</li></ul></li></ul><h4 id="6-4-循环扫描算法（C-SCAN）"><a href="#6-4-循环扫描算法（C-SCAN）" class="headerlink" title="6.4 循环扫描算法（C-SCAN）"></a>6.4 循环扫描算法（C-SCAN）</h4><p><strong>C-SCAN</strong>是对<strong>SCAN</strong>算法的改进。当磁头扫描到一端后，不返回，而是立即跳到另一端继续扫描。</p><ul><li><strong>原理</strong>：磁头向一个方向扫描，扫描到达磁盘一端后，迅速跳到另一端继续扫描。每次都从一端扫描到另一端。</li><li><strong>优点</strong>：<ul><li>提供了更加均衡的响应时间，避免了SCAN中一端请求较慢的问题。</li><li>改进了磁头的移动模式，减少了等待时间。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能会浪费一些时间来跳转磁盘的两端。</li></ul></li></ul><h4 id="6-5-LOOK算法"><a href="#6-5-LOOK算法" class="headerlink" title="6.5 LOOK算法"></a>6.5 LOOK算法</h4><p><strong>LOOK</strong>算法与SCAN类似，不同之处在于磁头在扫描到达请求的最远端后就会反向，而不是继续扫描到磁盘的最端点。</p><ul><li><strong>原理</strong>：磁头扫描时，遇到磁盘请求后进行处理，但扫描到最远请求后即返回，而不必扫描到磁盘的最后端。</li><li><strong>优点</strong>：<ul><li>更高效，因为它避免了不必要的扫描。</li></ul></li><li><strong>缺点</strong>：<ul><li>与SCAN类似，可能造成某些请求的延迟处理。</li></ul></li></ul><h4 id="6-6-C-LOOK算法"><a href="#6-6-C-LOOK算法" class="headerlink" title="6.6 C-LOOK算法"></a>6.6 C-LOOK算法</h4><p><strong>C-LOOK</strong>是对<strong>LOOK</strong>算法的进一步优化。当磁头到达最远请求时，它会跳到最远请求的另一端继续扫描，而不继续扫描到磁盘的末端。</p><ul><li><strong>原理</strong>：类似于C-SCAN，磁头扫描到一个方向的最远请求后，跳转到另一端继续扫描。</li><li><strong>优点</strong>：<ul><li>提供更加均衡的响应时间，并减少了不必要的寻道。</li></ul></li><li><strong>缺点</strong>：<ul><li>在某些场景下，跳转过程可能会引入额外的开销。</li></ul></li></ul><h4 id="6-7-最短请求时间优先（SRTF-Shortest-Request-Time-First）"><a href="#6-7-最短请求时间优先（SRTF-Shortest-Request-Time-First）" class="headerlink" title="6.7 最短请求时间优先（SRTF, Shortest Request Time First）"></a>6.7 最短请求时间优先（SRTF, Shortest Request Time First）</h4><p><strong>SRTF</strong>算法选择响应时间最短的请求优先处理。这种算法与SSTF类似，不过SRTF更加关注请求的响应时间，而不仅仅是距离。</p><ul><li><strong>原理</strong>：选择响应时间最短的请求进行处理，类似于CPU调度中的最短剩余时间优先（SRTF）算法。</li><li><strong>优点</strong>：<ul><li>可以最大化磁盘请求的响应速度。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现较复杂，可能会增加系统的计算开销。</li></ul></li></ul><p>磁盘调度算法的选择取决于具体的应用场景。不同的算法在不同的情况下有不同的优势和劣势。以下是一些选择考虑因素：</p><ul><li><strong>FCFS</strong>：适合请求到达时间比较均匀、对性能要求不高的场景。</li><li><strong>SSTF</strong>：适用于请求较为密集，磁头位置较为接近的场景，但可能会造成“饥饿”现象。</li><li><strong>SCAN和C-SCAN</strong>：适合请求在磁盘两端不均匀的情况，能够减少磁头的频繁反向运动。</li><li><strong>LOOK和C-LOOK</strong>：比SCAN更加高效，适用于对磁头寻道次数要求较高的环境。</li></ul><p>磁盘调度算法的核心目标是减少磁头的移动，优化磁盘访问的效率。每种算法都有其适用的场景，了解每种算法的原理和特点，有助于在不同的实际应用中选择最合适的磁盘调度策略。</p><h2 id="7-偷偷说"><a href="#7-偷偷说" class="headerlink" title="7. 偷偷说"></a>7. 偷偷说</h2><p>我写的第四篇关于计算机修考专业科目的笔记终于结束了，太不容易了。操作系统真的是一门非常非常深奥的学问！我已经尝试写完所有我认为能接触到的知识点了，但我觉得这也仅仅是冰山一角，尽管操作系统这篇的字数已经超过算法，机组，数电的总和，甚至还多出1万字…</p><p>在写这篇笔记的时候，我觉得异常异常的乏力！乏力的地方在于我很难把从上层到下层的逻辑串起来。我已经很努力的在梳理整个操作系统的框架了，从最上层的进程开始，再下到我们的存储结构，再下到文件系统，再下到我们的输出设备管理，最后下到大容量存储结构。</p><p>操作系统我认为也非常体现能计算机体系的精华，我们可以从上面的内容提取到冗余（redundancy）、并行（parallel）、分而治之提升效率等思想。</p><p>我在第一次学习操作系统的时候，纯纯的就是在背概念和记题型，并没有深刻体会到操作系统的内涵。现在当我重新串一遍操作系统的知识时，我又有了很多更深入的理解。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东北大学2024年冬计算机组成_问题5</title>
    <link href="/2024/12/10/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A62024%E5%B9%B4%E5%86%AC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E6%83%85%E6%8A%A5%E7%94%9F%E5%91%BD/"/>
    <url>/2024/12/10/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A62024%E5%B9%B4%E5%86%AC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E6%83%85%E6%8A%A5%E7%94%9F%E5%91%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="东北大学2024年冬计算机-问题5-by-偷偷"><a href="#东北大学2024年冬计算机-问题5-by-偷偷" class="headerlink" title="东北大学2024年冬计算机_问题5 by 偷偷"></a>东北大学2024年冬计算机_问题5 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p>Consider the following recursive function $f$ that takes an integer and returns an integer.</p><p>$$<br>f(n)&#x3D;<br>\begin{cases}<br>0,\quad n\leq 0 \\<br>f(n-1) \times 2 + n, \quad n&gt;0<br>\end{cases}<br>$$</p><p>Answer the following questions.</p><hr><p><strong>(1)</strong> Find the value of $f(3)$. Show also the intermediate steps in the calculation.</p><p>$$f(0) &#x3D; 0$$<br>$$f(1) &#x3D; f(0) \times 2 + 1 &#x3D; 1$$<br>$$f(2) &#x3D; f(1) \times 2 + 2 &#x3D; 4$$<br>$$f(3) &#x3D; f(2) \times 2 + 3 &#x3D; 11$$</p><hr><p><strong>(2)</strong> Consider a machine with three integer registers $r_{0}$, $r_{1}$, and $r_{2}$, a stack of sufficient size, and the instruction set in Fig.5(a). A program is a sequence of instructions and there is no limit on the size of integers. The program in Fig.5(b) displays the value of $f(30)$ on the screen and terminates. Give an instruction (or part of an instruction) that is appropriate for each of <u>(A), (B), (C),</u> and <u>(D).</u> Also explains in several lines of text how this program goes.</p><center><img src="/img/exam_other/tohoku24.jpg" alt="Memory Access" style="max-width: 100%; height: auto;" /></center><p>Let’s briefly read the assembly language</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">1. set 30, $r12. set 5, $r0      # 这里的‘5’用来记录函数退出的位置，即第5行代码3. push r04. jmp 65. halt r1         # r1用来返回最终的计算结果6. ifpos r1, ______(A) # 循环7. set 0, r18. ret9. push r1              # 不断往栈放入r1，后续必定有弹出r1的动作10. dec r111. set ____(B), r012. push r013. jmp 6              # 循环14. add r1, r1, r2     # 计算乘2的过程，即f(n-1) x 215. ____(C)16. add r1, r2, r1     # 计算加n的过程17. ____(D)            # 需要找准时机退出循环，即要和‘5’呼应上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p><strong>Hint:</strong> 可以尝试令$r1 &#x3D; 3, 然后手动模拟栈计算f(3)的过程</p></blockquote><p>Ans:</p><ul><li>(A): jmp 9</li><li>(B): 14</li><li>(C): pop r1</li><li>(D): ret</li></ul><p>This program initially places the calculation of the recursive endpoint $f(30)$ at the bottom of the stack. It then recursively processes from the bottom upwards until the starting value of the recursion is placed at the top of the stack. Following this, it begins to recursively process from the top downward until it reaches the calculation of the recursive endpoint $f(30)$.</p>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>东北大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>东北大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2023年夏计算机组成</title>
    <link href="/2024/12/08/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A620223%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/08/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A620223%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2023年计算机组成答案-by-偷偷"><a href="#九州大学2023年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2023年计算机组成答案 by 偷偷"></a>九州大学2023年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider a microprocessor having a pipelined datapath. Program execution time ET can be represented by using the three parameters, instruction count required to complete the whole program execution IC, the number of executed instructions per clock cycle IPC, and clock frequency F, as shown in the following equation.<br>$$ET &#x3D; \frac{IC}{IPC \times F}$$</p><p>Answer the following questions.</p><hr><p><strong>(1)</strong> Consider an in-order microprocessor whose instruction issue width is one. Explain the effects of pipelined datapath implementation on IC, IPC, and F, compared to a single-cycle datapath implementation where each instruction is executed in a single clock cycle, respectively. If there are no effects on each parameter, answer “no effects.”</p><ul><li><p><strong>IC：</strong> <strong>No effects.</strong> The instruction count is determined by the program being executed and is independent of whether the processor uses a pipelined or a single-cycle datapath. The same number of instructions will be executed in both cases.</p></li><li><p><strong>IPC:</strong> IPC typically <strong>increases</strong> in a pipelined processor because multiple instructions can be in different stages of execution at the same time. This allows the processor to issue a new instruction each cycle, leading to higher throughput.</p></li><li><p><strong>F</strong>: The clock frequency F can potentially be <strong>higher</strong> in a pipelined processor. This is because each stage of the pipeline is smaller (handling only part of the instruction) compared to the single-cycle implementation where the entire instruction is processed in one cycle. This smaller stage size allows for faster clock cycles, thus enabling a higher frequency.</p></li></ul><hr><p><strong>(2)</strong> We extend the pipelined datapath by increasing the instruction issue width from one to two that forms an in-order superscalar microprocessor, i.e., at most two independent instructions can be executed in parallel. Explain the effects of this extension on IC, IPC, and F, respectively. If there are no effects on each parameter, answer “no effects.”</p><ul><li><p><strong>IC:</strong> <strong>No effects.</strong> The instruction count is still determined by the program being executed.</p></li><li><p><strong>IPC:</strong>  In general, increasing the issue width should <strong>increase IPC</strong>, assuming there are enough independent instructions to take advantage of the increased width. Consider other factors, such as dependencies (data hazards, control hazards) can reduce the potential benefit.</p></li><li><p><strong>F:</strong> <strong>No effects.</strong> Although there may be a slight decrease in frequency due to the added complexity of issuing two instructions per cycle.</p></li></ul><hr><p><strong>(3)</strong> Assume that the instruction issue width is four. Answer the upper limit of IPC that can be achieved by the pipelined datapath.</p><p>Ans: <strong>4</strong></p><hr><p><strong>[Q3]</strong> Consider computer memory systems. Assume a direct-mapped cache memory implemented in a microprocessor chip. The microprocessor uses word addressing, the word size is 4 bytes, the cache size is 16 bytes, the block size is 4 bytes, and the address width is 4 bits. Suppose the cache was initially empty, and the memory access sequence for the following word addresses (represented in the binary numeral system) has occurred. 1101 ⇒ 1010 ⇒ 1111 ⇒ 1101 </p><p>Then we have the following five memory accesses (memory access  ① -⑤ ) consecutively.</p><center><img src="/img/exam/kyusyu23.jpeg" alt="Memory Access" style="max-width: 100%; height: auto;" /></center><p>Answer the following questions.</p><hr><p>(1) Find all of the memory accesses among ① -⑤ that cause a cache hit. If there is no corresponding memory access, answer “not applicable.”</p><blockquote><p><strong>Hint:</strong> Word Addressing. 按字编址</p></blockquote><ul><li>Block offset：block size is <strong>4 bytes(1 word)</strong> and it requires 1 bit.</li><li>Index bit: the number of cache blocks is $\frac{16bytes}{4bytes} &#x3D; 4 &#x3D; 2^2$,the index bit requires 2 bits.</li><li>Tag bits: it requires 4 - 2 - 1 &#x3D; 1 bits</li></ul><p>Before：</p><table><thead><tr><th>Cache Block</th><th>Accessing Order</th></tr></thead><tbody><tr><td>00</td><td></td></tr><tr><td>01</td><td>1010</td></tr><tr><td>10</td><td>1101</td></tr><tr><td>11</td><td>1111</td></tr></tbody></table><p>After：</p><ul><li>1010: hit</li><li>1001: miss</li><li>1000: hit</li><li>0011: miss</li><li>1111: hit</li></ul><hr><p><strong>(2)</strong> Find all of the memory accesses among  ① -⑤  that cause a compulsory miss. If there is no corresponding memory access, answer “not applicable.”</p><p>Compulsory miss: ②</p><hr><p><strong>(3)</strong> Explain how to modify this cache memory to reduce the conflict miss. Also, if there are any demerits to the modification, explain them.</p><p>Modigy the cache to fully associative cache. The index now maps to a set of multiple cache lines, and the block can be placed in any available line within the set, reducing the likelihood of conflicts. However, it requires additional hardware for selecting the correct cache line.</p>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2022年夏计算机组成</title>
    <link href="/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2022年计算机组成答案-by-偷偷"><a href="#九州大学2022年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2022年计算机组成答案 by 偷偷"></a>九州大学2022年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider an in-order microprocessor that has 5-stage pipelined datapath. The implemented pipeline stage are IF, ID, EX, MEM, and WB. The operations in each stage for the “add” are defined in the following table. Assume that the operations in each pipeline stage can be completed in one clock cycle. The written data in the WB stage of an instruction can be read in the ID stage of a subsequent instruction in the same clock cycle. All RAW(Read-After-Write) hazards are resolved by applying a pipeline stall mechanism. Answer the following questions.</p><center><img src="/img/exam/kyusyu22.jpg" alt="Operations of the pipelined datapath" style="max-width: 100%; height: auto;" /></center><hr><p><strong>(1)</strong> Consider the following assembly program. The words on the right of the ‘#’ symbol in each line are comments. Identify all flow dependencies by describing which instruction depends on which instructions through which register.</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add $1, $3, $5 # &lt;1&gt;add $9, $2, $3 # &lt;2&gt;add $6, $3, $3 # &lt;3&gt;add $3, $4, $3 # &lt;4&gt;add $4, $7, $1 # &lt;5&gt;add $5, $7, $4 # &lt;6&gt;add $9, $3, $6 # &lt;7&gt;add $2, $7, $6 # &lt;8&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p><strong>Hint:</strong> 流依赖（Flow Dependency），也称为Read-After-Write (RAW) 依赖，是指一条指令需要读取一个由前一条指令写入的寄存器值。</p></blockquote><p>从上到下依次分析写入的寄存器，可以得到存在的Flow Dependencies 有：</p><ul><li>&lt;5&gt; depends on &lt;1&gt; through $1</li><li>&lt;7&gt; depends on &lt;3&gt; through $6</li><li>&lt;8&gt; depends on &lt;3&gt; through $6</li><li>&lt;7&gt; depends on &lt;4&gt; through $3</li><li>&lt;6&gt; depends on &lt;5&gt; through $4</li></ul><hr><p><strong>(2)</strong> Assume the instruction issue width is one. Answer the number of clock cycles required for the execution of the assembly program.</p><blockquote><p><strong>Hint:</strong> 一条指令在写回（WB）阶段写入的数据，可以在同一个时钟周期内被随后的指令在指令解码（ID）阶段读取。</p></blockquote><p>We can draw the pipeline stages below.</p><img src="/img/exam/kyusyu22.svg" alt="pipeline" style="max-width: 100%; height: auto;" /><p>According to the pipeline stages, it requires <strong>14</strong> clock cycles for the execution of the assembly program.</p><hr><p><strong>(3)</strong> We extend the datapath by increasing the instruction issue width from one to two that forms an in-order superscalar microprocessor, i.e., at most, two independent instructions can be executed in parallel. Answer the number of clock cycles required for the execution of the assembly program on the extended datapath.</p><p>We can draw the pipeline stages below.</p><img src="/img/exam/kyusyu22-2.svg" alt="pipeline" style="max-width: 100%; height: auto;" /><p>According to the pipeline stages, it requires <strong>12</strong> clock cycles for the execution of the assembly program.</p><hr><p><strong>(4)</strong> The data path extension presented in (3) causes a 5% decrease in its clock frequency. Answer the performance improvement rate achieved by implementing the extension.</p><p>We know that,</p><p>$$\text{CPU Time} &#x3D; IC \times CPI \times \frac{1}{f}$$</p><p>When extending the datapath, IC reimains the same, CPI improves $\frac{14}{12}$ and the frequency decreases 5%. The improvement $K$ is:</p><p>$$ K &#x3D; \frac{\text{CPU Time}}{\text{CPU Time’}}&#x3D; \frac{14 \times 0.95}{12} \approx \text{111%} $$</p><hr><p><strong>[Q3]</strong> Explain what “compulsory misses”, “conflict misses”, and what “capacity misses” are in cache memory systems, respectively.</p><blockquote><p><strong>Hint:</strong> 直接映射缺失的3C模型</p></blockquote><ul><li><p><strong>Compulsory Misses:</strong> Misses that occur when data is accessed for the first time.</p></li><li><p><strong>Conflict Misses:</strong> Misses that occur  when different data blocks are mapped to the same cache line position causing frequent replacements, resulting in misses even if the cache capacity is sufficient.</p></li><li><p><strong>Capacity Misses:</strong> Due to limited cache capacityeven if all blocks in the cache are fully utilized, it still cannot accommodate all the needed data blocks, resulting in misses.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2021年夏计算机组成</title>
    <link href="/2024/12/06/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/06/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2021年计算机组成答案-by-偷偷"><a href="#九州大学2021年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2021年计算机组成答案 by 偷偷"></a>九州大学2021年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider a microprocessor that has a 5-stage pipelined datapath. The implemented pipeline stages are IF (Instruction Fetch), ID (Instruction Decode), EX (EXecution),MEM (MEMory access), and WB (Write Back). Answer the following questions.</p><hr><p><strong>(1)</strong> The latency of pipeline stages, IF, ID, EX, MEM, and WB, is 240 ps, 400 ps, 200ps, 250 ps, and 180 ps, respectively. Answer the maximum clock frequency of this datapath (unit is GHz).</p><blockquote><p><strong>Hint:</strong> The clock period is determined by the slowest (longest latency) pipeline stage.</p></blockquote><p>The slowest stage is ID with a latency of 400 ps. The clock period must be at least as long as this latency to ensure that the slowest stage completes in one cycle.</p><p>$$<br>\text{Clock Frequency} &#x3D; \frac{1}{\text{Clock Period}} &#x3D; \frac{1}{400 \ \text{ps}} &#x3D; \frac{1}{400 \times 10^{-12}} &#x3D; 2.5\ \text{GHz}<br>$$</p><hr><p><strong>(2)</strong> Consider increasing the number of pipeline stages from 5 to 6 by partitioning a single pipeline stage, IF, ID, EX, MEM, or WB, to two stages. Assume the latency of the partitioned pipeline stages is half of that of the original stage. Choose one pipeline stage that should be partitioned for maximising the clock frequency of the datapath, and answer the maximum clock frequency we can achieve by this design optimization (unit is GHz).</p><p>To get the maximum clock frequency, we need to minimize the clock period, thus the best stage to partition for maximizing the clock frequency is the ID stage.</p><ul><li>By splitting the ID stage, its latency is halved to 200 ps.</li><li>The MEM stage becomes the longest (250 ps), so the clock period is now determined by MEM.</li></ul><p>$$<br>\text{Clock Frequency} &#x3D; \frac{1}{\text{Clock Period}} &#x3D; \frac{1}{250 \ \text{ps}} &#x3D; \frac{1}{250 \times 10^{-12}} &#x3D; 4 \ \text{GHz}<br>$$</p><hr><p><strong>(3)</strong> For the execution of a program, the pipeline stage partitioning presented in (2)caused 10 % increase in CPI (Clock cycles Per Instruction). Assume there are no negative effects caused by the pipeline stage partitioning except for the CPI increase.Answer the performance improvement rate achieved by applying the pipeline stage partitioning.</p><ul><li>Before:</li></ul><p>$$\text{CPU Time} &#x3D; \frac {IC \cdot CPI}{f} &#x3D; \frac{IC \cdot CPI} {2.5 \ \text{GHz}}$$</p><ul><li>After partitioning:</li></ul><p>$$ \text{CPU Time’} &#x3D; \frac {IC \cdot CPI \cdot \text{110%} }{f’} &#x3D; \frac{IC \cdot CPI \cdot  \text{110%}}{4 \ \text{GHz}} $$</p><ul><li>The improvement rate K is:</li></ul><p>$$ K &#x3D; \frac{\text{CPU Time}}{\text{CPU Time’}} \approx \text{145%} $$</p><hr><p><strong>(4)</strong> Explain the advantages and disadvantages of increasing the number of pipeline stages.</p><ol><li><p><strong>Advantages：</strong></p><ul><li><strong>Higher Clock Frequency：</strong> each stage performs a smaller part of the instruction cycle. This can reduce the latency of each stage, allowing the processor to run at a higher clock frequency.</li><li><strong>Improved Instruction Throughput：</strong> With more pipeline stages, instructions can be processed more concurrently. This increases the potential instruction throughput because multiple instructions can be in different stages of execution at the same time.</li></ul></li><li><p><strong>Disadvantages:</strong></p><ul><li><strong>Increased Latency per Instruction:</strong> With more stages being executed in the pipeline, even though each individual stage is shorter, an instruction still takes more cycles to pass through all the stages which leads to the increasing of CPI</li><li><strong>More Complex Control Logic:</strong> As the number of pipeline stages increases, the control logic required to manage the pipeline also becomes more complex, which may results in pipeline hazards</li></ul></li></ol><hr><p><strong>[Q3]</strong> Consider a direct-mapped cache memory that accepts a 32-bit memory address consisting of a cache tag field, a cache index field, and a cache block offset field. Suppose a byte addressing scheme, the word size is 4 bytes, the cache size is 16 Kilo-bytes, and the cache block size is 32 bytes. Answer the bit-width of the cache tag field.</p><p>$32 \ bytes &#x3D; 2^5 \ bytes$, the block offset is $5 \ bits$</p><p>$\text{number of cache blocks} &#x3D; \frac{16KByte}{32Byte} &#x3D; 2^9$, the cache index requires $9 \ bits$</p><p>$$ Cache \ tag \ width &#x3D; 32 − Index bits − Offset bits &#x3D; 32 - 9 - 5 &#x3D; 18\ bits $$</p><hr>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Digital Circuit</title>
    <link href="/2024/11/04/Digital-Circuit/"/>
    <url>/2024/11/04/Digital-Circuit/</url>
    
    <content type="html"><![CDATA[<h1 id="Digital-Circuit"><a href="#Digital-Circuit" class="headerlink" title="Digital Circuit"></a>Digital Circuit</h1><p>Credit to《Digital Design and Computer Architecture, Second Edition》🤯 Let’s quickly review this subject. The diagram is powered by <a href="https://github.com/jgraph/drawio-desktop">@drawio</a></p><blockquote><p> 催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Logic-Gates"><a href="#1-Logic-Gates" class="headerlink" title="1. Logic Gates"></a>1. Logic Gates</h2><p>第一章主要认识最基础的逻辑门元件，然后熟悉其对应的真值表(Truth Table),主要是为第二章的组合电路(combinational circuit)做铺垫。</p><p><strong>NOT 门（非门）:</strong> 输出是输入的逻辑反， $Y &#x3D; \neg A$</p><p><strong>BUF 门（缓冲器）:</strong> 输出与输入相同，用于信号强化。$Y &#x3D; A$</p><p><strong>AND 门（与门）:</strong> 所有输入均为1时，输出才为1。$Y &#x3D; A \cap B$</p><p><strong>OR 门（或门）:</strong> 任意输入为1时，输出为1。$Y &#x3D; A \cup B$</p><img src="/img/DC/add.svg" alt="逻辑门1" style="max-width: 100%; height: auto;" /><p><strong>NAND 门（与非门）:</strong> 与门输出取反。 $ Y &#x3D; \neg (A \cap B) $</p><p><strong>NOR 门（或非门）:</strong> 或门输出取反。 $ Y &#x3D; \neg (A \cup B) $</p><p><strong>XOR 门（异或门）:</strong> 相异为1，相同为0。 $ Y &#x3D; A \oplus B $</p><p><strong>XNOR 门（同或门）:</strong> 相同为0，相异为1。 $ Y &#x3D; \neg (A \oplus B) $</p><img src="/img/DC/nand.svg" alt="逻辑门2" style="max-width: 100%; height: auto;" /><p><strong>三态缓冲器（tristate buffer）</strong> 是一种数字电路元件，其输出可以处于三种状态之一：高电平（1）、低电平（0）或高阻态（Z）。高阻态表示输出像断开一样，不驱动任何电流，可以用于总线控制等应用。</p><p><strong>高水平有效（Active High）</strong></p><p>在高水平有效的三态缓冲器中，当控制信号为高电平（1）时，缓冲器输出有效，即输出输入信号的值。当控制信号为低电平（0）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 &#x3D; 1：输出 &#x3D; 输入信号</li><li>控制信号 &#x3D; 0：输出 &#x3D; 高阻态（Z）</li></ul><p><strong>低水平有效（Active Low）</strong></p><p>在低水平有效的三态缓冲器中，当控制信号为低电平（0）时，缓冲器输出有效，即输出输入信号的值。当控制信号为高电平（1）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 &#x3D; 0：输出 &#x3D; 输入信号</li><li>控制信号 &#x3D; 1：输出 &#x3D; 高阻态（Z）</li></ul><p align="center">  <img src="/img/DC/buffer.svg" alt="逻辑门3" style="max-width: 110%; height: auto;" /></p><h2 id="2-Combinational-Logic-Circuit"><a href="#2-Combinational-Logic-Circuit" class="headerlink" title="2. Combinational Logic Circuit"></a>2. Combinational Logic Circuit</h2><p>组合逻辑电路（Combinational Logic Circuit）是一种数字电路，其中输出仅依赖于当前输入，而不依赖于之前的输入状态。这意味着组合电路没有存储元件，因此它没有记忆功能。其主要特性包括：</p><ul><li><p>无记忆功能：输出<strong>仅由当前输入决定</strong>，与之前的输入无关。</p></li><li><p>固定的逻辑功能：根据输入信号的组合，输出信号以确定的方式变化。</p></li><li><p>构建简单：组合电路通常由基本逻辑门（如AND、OR、NOT、NAND、NOR、XOR、XNOR）构建，可以用来实现任意逻辑功能。</p></li></ul><p>在有逻辑门的基础知识下，还需要有布尔表达式以及卡诺图的基础下才能完成组合电路的设计。</p><h3 id="2-1-Boolean-Equation"><a href="#2-1-Boolean-Equation" class="headerlink" title="2.1 Boolean Equation"></a>2.1 Boolean Equation</h3><p><strong>与或式（Sum of Products, SOP）</strong> 是一种布尔表达式形式，表示多个与项（积项）之间的或操作。每个积项由一个或多个变量通过与操作连接而成。与或式通常用于表达布尔函数的标准形式之一。例如：</p> <center>$ Y = A \cdot B + \overline{A}  \cdot C + B \cdot \overline{C} $</center><p><strong>或与式（Product of Sums, POS）</strong> 是布尔表达式的另一种形式，表示多个或项（和项）之间的与操作。每个和项由一个或多个变量通过或操作连接而成。或与式也常用于表达布尔函数的标准形式之一。例如：</p><center> $ Y = (A + B) \cdot (\overline {A} + C) \cdot (B + \overline{C}) $</center><p><strong>最小项 (Minterms)</strong> 是布尔函数的标准形式之一，其中每个最小项对应一个输出为1的输入组合。最小项由所有变量的与运算构成，每个变量可能是原变量或其补变量。通俗解释就是输出为1对应积项为1的累加。</p><p>示例：考虑一个布尔函数 ( F(A, B, C) )：</p><ul><li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最小项为 $ ( A \cdot \overline{B} \cdot C )$ </li><li>当 ( A &#x3D; 0 ), ( B &#x3D; 1 ), ( C &#x3D; 0 ) 时，最小项为 $ ( \overline{A} \cdot B \cdot \overline{C} )$</li></ul><p>假设布尔函数在以下输入组合下输出为1：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>相应的最小项表示为：</p><center>$ F(A, B, C) = \overline{A} \cdot \overline{B} \cdot C + \overline{A} \cdot B \cdot \overline{C} + A \cdot \overline{B} \cdot C $</center><p><strong>最大项 (Maxterms)</strong> 是布尔函数的另一种标准形式，其中每个最大项对应一个输出为0的输入组合。最大项由所有变量的或运算构成，每个变量可能是原变量或其补变量。通俗解释就是输入为0所对应的和项为0的累乘</p><p>示例：同样考虑布尔函数 ( F(A, B, C) )：</p><p>这两个组合对应的最大项为：</p><ul><li>当 ( A &#x3D; 0 ), ( B &#x3D; 0 ), ( C &#x3D; 0 ) 时，最大项为$ (A + B + C) $</li><li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最大项为$ (\overline{A} + B + \overline{C} ) $</li></ul><p>假设布尔函数 ( F(A, B, C) ) 在以下输入组合下输出为0：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>因此，相应的最大项表达式为：</p><center> \[F(A, B, C) = (A + B + C) \cdot (\overline{A} + \overline{B} + C)\] </center><p><strong>总结</strong></p><ul><li><strong>最小项</strong>：布尔函数输出为1时，对应输入组合的与运算。</li><li><strong>最大项</strong>：布尔函数输出为0时，对应输入组合的或运算。</li></ul><blockquote><p>这些概念在布尔代数和数字电路设计中非常有用，也是这门课的高频考点</p></blockquote><h3 id="2-2-Boolean-Operation-Rules"><a href="#2-2-Boolean-Operation-Rules" class="headerlink" title="2.2 Boolean Operation Rules"></a>2.2 Boolean Operation Rules</h3><p>布尔运算的基本定律，和卡诺图一样，是逻辑电路化简的主要手段</p><h4 id="2-2-1-交换律（Commutative-Law）"><a href="#2-2-1-交换律（Commutative-Law）" class="headerlink" title="2.2.1 交换律（Commutative Law）"></a>2.2.1 交换律（Commutative Law）</h4><p>交换律表示在布尔运算中，操作数的位置可以互换。</p><ul><li><strong>与运算</strong>：$ A \cdot B &#x3D; B \cdot A $</li><li><strong>或运算</strong>：$ A + B &#x3D; B + A $</li></ul><h4 id="2-2-2-结合律（Associative-Law）"><a href="#2-2-2-结合律（Associative-Law）" class="headerlink" title="2.2.2 结合律（Associative Law）"></a>2.2.2 结合律（Associative Law）</h4><p>结合律表示在布尔运算中，操作数的组合方式不影响运算结果。</p><ul><li><strong>与运算</strong>：$ (A \cdot B) \cdot C &#x3D; A \cdot (B \cdot C) $</li><li><strong>或运算</strong>：$ (A + B) + C &#x3D; A + (B + C) $</li></ul><h4 id="2-2-3-分配律（Distributive-Law）"><a href="#2-2-3-分配律（Distributive-Law）" class="headerlink" title="2.2.3 分配律（Distributive Law）"></a>2.2.3 分配律（Distributive Law）</h4><p>分配律表示一种运算可以分配到另一种运算上。</p><ul><li><strong>与对或</strong>：$ A \cdot (B + C) &#x3D; (A \cdot B) + (A \cdot C) $</li><li><strong>或对与</strong>：$ A + (B \cdot C) &#x3D; (A + B) \cdot (A + C) $</li></ul><h4 id="2-2-4-吸收律（Absorption-Law）"><a href="#2-2-4-吸收律（Absorption-Law）" class="headerlink" title="2.2.4 吸收律（Absorption Law）"></a>2.2.4 吸收律（Absorption Law）</h4><p>吸收律表示通过某些布尔运算可以简化表达式。</p><ul><li>$ A + (A \cdot B) &#x3D; A $</li><li>$ A \cdot (A + B) &#x3D; A $</li></ul><h4 id="2-2-5-合并律（Combining-Law）"><a href="#2-2-5-合并律（Combining-Law）" class="headerlink" title="2.2.5 合并律（Combining Law）"></a>2.2.5 合并律（Combining Law）</h4><p>合并律表示布尔变量和其补变量的某些组合具有特定的结果。</p><ul><li>$ A + \overline{A} &#x3D; 1 $</li><li>$ A \cdot \overline{A} &#x3D; 0 $</li></ul><h4 id="2-2-6-一致律（Identity-Law）"><a href="#2-2-6-一致律（Identity-Law）" class="headerlink" title="2.2.6 一致律（Identity Law）"></a>2.2.6 一致律（Identity Law）</h4><p>一致律表示布尔变量与1和0的运算结果。</p><ul><li><strong>与1</strong>：$ A \cdot 1 &#x3D; A $</li><li><strong>与0</strong>：$ A \cdot 0 &#x3D; 0 $</li><li><strong>或1</strong>：$ A + 1 &#x3D; 1 $</li><li><strong>或0</strong>：$ A + 0 &#x3D; A $</li></ul><h4 id="2-2-7-德摩根律（De-Morgan’s-Laws）"><a href="#2-2-7-德摩根律（De-Morgan’s-Laws）" class="headerlink" title="2.2.7 德摩根律（De Morgan’s Laws）"></a>2.2.7 德摩根律（De Morgan’s Laws）</h4><p>德摩根律表示对布尔表达式取反的规则。</p><ul><li>$ \overline{A \cdot B} &#x3D; \overline{A} + \overline{B} $</li><li>$ \overline{A + B} &#x3D; \overline{A} \cdot \overline{B} $</li></ul><h4 id="2-2-8-部分二级公式推导"><a href="#2-2-8-部分二级公式推导" class="headerlink" title="2.2.8 部分二级公式推导"></a>2.2.8 部分二级公式推导</h4><ul><li>$ A + \overline{A}B &#x3D; A + B$</li></ul><p>证明: $A(1 + B) + {A}B &#x3D; A + AB + \overline{A}B &#x3D; A + B $ </p><ul><li>$ (A + B) \cdot (A + C) &#x3D; A + (B \cdot C) $</li></ul><p>证明: $ AA + AC + AB + BC &#x3D; A + AB + AC + BC &#x3D; A(1 + B + C) + BC &#x3D; A + BC $</p><ul><li>$A \cdot (A + B) &#x3D; A$</li></ul><p>证明: $AA + AB &#x3D; A + AB &#x3D; A(1 + B) &#x3D; A$</p><ul><li>$BC + B\overline{C} &#x3D; B$</li></ul><p>证明: $B \cdot (C + \overline{C}) &#x3D; B \cdot 1 &#x3D; B$</p><ul><li>$(A + B) \cdot (A + \overline{B}) &#x3D; A$</li></ul><p>证明: $AA + A\overline{B} + AB + B\overline{B} &#x3D; A + A(B + \overline{B}) &#x3D; A + A &#x3D; A$</p><ul><li>$AB + \overline{A}C + BC &#x3D; AB + \overline{A}C$</li></ul><p>证明关键：使用吸收律 $A + AB &#x3D; A$, 推广为$AB + ABC &#x3D; AB$</p><p>$$<br>\begin{aligned}<br>&amp;AB + \overline{A}C + BC \\<br>&amp;&#x3D; AB + \overline{A}C + (A + \overline{A})BC \\<br>&amp;&#x3D; AB + \overline{A}C + ABC + \overline{A}CB \\<br>&amp;&#x3D; AB + ABC + \overline{A}C + \overline{A}CB \text{(使用推广公式)} \\<br>&amp;&#x3D; AB + \overline{A}C<br>\end{aligned}<br>$$</p><p>根据吸收律可继续推广下去：<br>$$AB + \overline{A}C + BC\cdot(\text{其他任何项}) &#x3D; AB + \overline{A}C  $$ </p><p>在表达式中，无论包含 $B$ 和 $C$ 的项如何复杂（例如 $BCDEFGH$），它都不会改变整个表达式的最终结果。</p><div class="note note-primary">            <p>渲染上述公式太折磨了！修考一般不考如此复杂的化简，一般掌握K-Map化简足够应付</p>          </div><h3 id="2-3-K-Map"><a href="#2-3-K-Map" class="headerlink" title="2.3 K-Map"></a>2.3 K-Map</h3><p>在绘制卡诺图的时候需要用到格雷码的表格。首先引入一个格雷码的概念。</p><h4 id="2-3-1-Gray-Code"><a href="#2-3-1-Gray-Code" class="headerlink" title="2.3.1 Gray Code"></a>2.3.1 Gray Code</h4><p>格雷码（Gray Code）是一种<strong>特殊的二进制编码方式</strong>，其特点是<strong>相邻的两个数码之间仅有一位二进制数不同</strong>。格雷码的发明即是用来将误差之可能性缩减至最小，编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码，可以使装置做数字步进时只更动最少的位元数以提高稳定性。</p><p><strong>格雷码的特性</strong></p><ul><li><strong>相邻差一位</strong>：每个相邻编码仅一位不同，减少了转换时的误差风险。</li><li><strong>非权重编码</strong>：格雷码不按照传统二进制编码的权值（如 $1, 2, 4, 8, \dots$）累加。</li></ul><p><strong>2 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>01</td></tr><tr><td>1</td><td>11</td><td>10</td></tr></tbody></table><p><strong>3 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>001</td><td>011</td><td>010</td></tr><tr><td>1</td><td>110</td><td>111</td><td>101</td><td>100</td></tr></tbody></table><p><strong>4 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>00</td><td>0000</td><td>0001</td><td>0011</td><td>0010</td></tr><tr><td>01</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td></tr><tr><td>11</td><td>1110</td><td>1111</td><td>1101</td><td>1100</td></tr><tr><td>10</td><td>1010</td><td>1011</td><td>1001</td><td>1000</td></tr></tbody></table><blockquote><p>上述表格，无论是以x轴对称，或者y轴对称，或者中心对称，均只有1位的差异</p></blockquote><h4 id="2-3-2-卡诺图化简步骤"><a href="#2-3-2-卡诺图化简步骤" class="headerlink" title="2.3.2 卡诺图化简步骤"></a>2.3.2 卡诺图化简步骤</h4><ol><li><p>构建 K 图：根据布尔函数的输入变量数量，构建相应大小的 K 图：</p><ul><li>2 位变量：4 格（2×2）</li><li>3 位变量：8 格（2×4）</li><li>4 位变量：16 格（4×4）</li></ul></li></ol><p>横轴和纵轴的变量顺序需按照<strong>格雷码</strong>排列，以确保相邻格子之间只有一个变量不同。</p><ol start="2"><li><p>填写真值表和无关项：</p><ul><li>根据逻辑函数或真值表，在 K 图中标记输出为 1 的位置。</li><li>将无关项标(Don’t Care Conditions)记为 X。无关项是那些对最终结果没有影响的输入组合，可以被自由选择为 1 或 0，以帮助扩大合并区域。</li></ul></li><li><p>寻找最大合并区域：</p><ul><li>在 K 图中，寻找可以合并的 1 和 X 区域。合并的目标是形成2 的幂次方大小的区域（例如 1、2、4、8 等格），并使每个 1 尽量包含在最大的区域中。</li><li>合并时遵循以下规则：<ul><li>只允许合并相邻的 1 和 X（上下、左右、包围环绕相邻）。</li><li>尽量优先选择包含更多无关项 X 的区域，以增加合并区域的大小。</li><li>合并区域可以是矩形、正方形，甚至是环绕 K 图的封闭区域。</li></ul></li></ul></li><li><p>合并相邻项：</p><ul><li>每个合并区域中的变量中，如果某个变量在区域内既有 0 又有 1，则忽略该变量（因为它在该区域中无关紧要）。</li><li>将每个合并区域的共同变量提取为一个积项。对于每个变量：<ul><li>如果变量在区域内始终为 1，则使用原变量（如 $A$）。</li><li>如果变量在区域内始终为 0，则使用其反码（如 $\overline{A}$）。</li></ul></li></ul></li><li><p>写出最简化表达式：</p><ul><li>将所有合并区域的积项求和，得到逻辑函数的最简化形式。</li><li>所有包含在化简表达式中的项应尽量少，以确保表达式是最简形式。</li></ul></li></ol><blockquote><p>多练多化简就行了，没什么难度</p></blockquote><h3 id="2-4-常见数字模块"><a href="#2-4-常见数字模块" class="headerlink" title="2.4 常见数字模块"></a>2.4 常见数字模块</h3><p>这一小节跟计算机组成中的算术运算关联度很高，数字电路就是来讲解计算机所呈现出来的算术运算在底层是如何用逻辑元器件实现的。</p><h4 id="2-4-1-Half-Adder"><a href="#2-4-1-Half-Adder" class="headerlink" title="2.4.1 Half Adder"></a>2.4.1 Half Adder</h4><p><strong>半加器 (Half Adder)</strong> 是一个基本的数字电路，用于计算两个单比特二进制数的和。它的功能是执行二进制加法，并且产生两个输出：</p><ul><li>Sum：表示两个输入二进制数加法的结果（不考虑进位）。这里用$S$来表示和。</li><li>Carry：表示加法结果中<strong>产生的进位</strong>。这里用$Cout$来表示产生的进位了。</li></ul><p>根据如下K-Map我们可以得出和与进位的表达式，分别为：$S &#x3D; A \oplus B$ , $Cout &#x3D; A\cdot B$，再把组合电路进行封装📦(encapsulation)可以得到半加器这个电路元件<br><img src="/img/DC/half_adder.svg" alt="半加器" style="max-width: 100%; height: auto;" />  </p><h4 id="2-4-2-Full-Adder"><a href="#2-4-2-Full-Adder" class="headerlink" title="2.4.2 Full Adder"></a>2.4.2 Full Adder</h4><p><strong>全加器 (Full Adder)</strong> 是数字电路中的一种基本元件，用于对二进制数进行加法运算。与半加器（Half Adder）相比，全加器可以对两个二进制数和一个进位位进行加法运算，并输出结果和新的进位位。</p><p>全加器的输入包括三个位：</p><ul><li><p>A（第一个加数位）</p></li><li><p>B（第二个加数位）</p></li><li><p>Cin（输入进位位）</p></li></ul><p>全加器的输出包括两个位：</p><ul><li><p>S（和位）：表示加法结果的当前位。</p></li><li><p>Cout（输出进位位）：表示加法结果的进位位。</p></li></ul><img src="/img/DC/full_adder.svg" alt="全加器" style="max-width: 100%; height: auto;" />  <p>首先分析真值表写出最小项表达式，对于$S$有：</p><p>$$<br>\begin{aligned}<br>S &amp;&#x3D; \overline{A} \cdot B \cdot \overline{C_{in}} + A \cdot\overline{B} \cdot \overline{C_{in}} + \overline{A} \cdot \overline{B} \cdot C_{in} + A \cdot B \cdot C_{in} \\<br>&amp;&#x3D; \overline{C_{in}}(A \oplus B) + C_{in} \overline{(A \oplus B)} \\<br>&amp;&#x3D; A \oplus B \oplus C_{in}<br>\end{aligned}<br>$$</p><p>对于$C_{out}$有：</p><p>$$<br>\begin{aligned}<br>C_{out} &amp;&#x3D; AB \overline{C_{in}} + \overline{A}BC_{in} + A \overline{B}C_{in} + ABC_{in} \\<br>&amp;&#x3D; AB + C_{in}(A \oplus B)<br>\end{aligned}<br>$$</p><p><strong>思考🤔</strong> ：为什么黑书给的是 $C_{out} &#x3D; AB + AC_{in} + BC_{in}$ ，这时候可以借助K-Map化简：如下图所示</p><div style="text-align: center;">  <img src="/img/DC/fa1.svg" alt="k-map" style="max-width: 100%; height: auto;" /></div><p>根据K-Map化简，我们的全加器的画法会得出上图的电路，而如果根据真值表进行表达式化简，我们会得到下图的全加器。</p><img src="/img/DC/fa2.svg" alt="Full Adder" style="max-width: 100%; height: auto;" />  <p>我们可以用2个半加器和一个或门封装成一个全加器,具体的计算过程就不赘述了，这是修考重点！</p><img src="/img/DC/fa3.svg" alt="全加器封装" style="max-width: 100%; height: auto;" />  <h4 id="2-4-3-Ripple-Carry-Adder"><a href="#2-4-3-Ripple-Carry-Adder" class="headerlink" title="2.4.3 Ripple-Carry Adder"></a>2.4.3 Ripple-Carry Adder</h4><p><strong>Ripple-Carry Adder</strong> （行波进位加法器）是一种用于二进制数加法的简单组合逻辑电路，由多个一位全加器（Full Adder）级联而成，每个全加器负责处理输入位和进位。</p><ol><li><p><strong>组成结构</strong>  </p><ul><li>Ripple-Carry Adder 包括 $n$ 个全加器，用于计算 $n$ 位二进制数的加法。  </li><li>每个全加器接收两个输入位 $A[i]$ 和 $B[i]$，以及前一位的进位 $C[i]$。  </li><li>输出为和 $S[i]$ 和进位 $C[i+1]$。</li></ul></li><li><p><strong>进位传播</strong>  </p><ul><li>第一个全加器处理最低有效位 $A[0]$ 和 $B[0]$ 以及初始进位（通常为 0），产生和 $S[0]$ 和进位 $C[1]$。  </li><li>进位 $C[1]$ 传递到下一个全加器，依次类推，直到最高有效位。</li></ul></li><li><p><strong>优缺点</strong></p><ul><li><p><strong>优点</strong>  </p><ul><li>设计简单，硬件实现容易。</li></ul></li><li><p><strong>缺点</strong>  </p><ul><li><strong>进位传播延迟</strong>：每个全加器必须等待前一级的进位信号，导致延迟随位数线性增长，影响运算速度。</li></ul></li></ul><p>Ripple-Carry Adder 适用于简单、低速应用；但无法满足更高速的加法需求。</p></li></ol><img src="/img/DC/ripple.svg" alt="4bit行波进位加法器" style="max-width: 100%; height: auto;" />  <h4 id="2-4-4-Carry-Lookahead-Adder-CLA"><a href="#2-4-4-Carry-Lookahead-Adder-CLA" class="headerlink" title="2.4.4 Carry-Lookahead Adder (CLA)"></a>2.4.4 Carry-Lookahead Adder (CLA)</h4><p><strong>Carry-Lookahead Adder (CLA)</strong> ，即先行进位加法器，是一种改进的加法器，用于快速执行二进制加法，解决 Ripple-Carry Adder 中进位传播延迟的问题。</p><p>Carry-Lookahead Adder 通过并行计算进位信号，而不依赖逐级传播，从而显著提高速度。其核心思想是利用生成信号和传播信号：</p><ol><li><p><strong>生成信号 (Generate)</strong>  ：表示某一位的加法会直接产生一个进位：<br>$G_i &#x3D; A_i \cdot B_i$</p></li><li><p><strong>传播信号 (Propagate)</strong>  ：表示某一位的加法会将来自上一位的进位传递下去：<br>$P_i &#x3D; A_i + B_i$</p></li><li><p><strong>进位计算公式</strong>  ：根据生成和传播信号，计算每一位的进位：<br>$C_{i+1} &#x3D; G_i + P_i \cdot C_i$   其中，$C_0$ 是初始进位。</p></li></ol><p><strong>推导证明：</strong><br>根据前面全加器的结论，我们有：</p><ol><li><p><strong>初始公式</strong><br>$$C_{i + 1} &#x3D; A_{i} \cdot B_{i} + (A_{i} + B_{i}) \cdot C_{i}$$</p></li><li><p><strong>引入生成信号和传播信号</strong>(都是已知信号)<br>$$G_{i} &#x3D; A_{i} \cdot B_{i}$$<br>$$P_{i} &#x3D; A_{i} + B_{i}$$</p></li><li><p><strong>公式代换</strong><br>$$C_{i + 1} &#x3D; G_{i} + P_{i} \cdot C_{i} \quad \text{(用 $P_{i}$ 代换 $(A_{i} + B_{i})$)}$$</p></li></ol><p>那么我就可以用已知的输入 $A_{0}$  ~  $A_{n-1}$ 和 $B_{0}$  ~  $B_{n-1}$ 以及 $C_{0}$ 来确定进位是什么了。比如：</p><p>$$C_{1} &#x3D; G_{0} + P_{0} \cdot C_{0}$$</p><p>$$C_{2} &#x3D; G_{1} + P_{1} \cdot C_{1} &#x3D; G_{1} + P_{1} G_{0} + P_{1}P_{0}C_{0}$$<br>不断迭代我们可以得出 $C_{3}$ 和 $C_{4}$ ，甚至到 $C_{n-1}$ ，但是！考虑到电路的复杂程度和电路成本的情况下，我们可以稍微妥协一下，采用分块的策略，比如实现一个32bit的加法器，我们可以将四个全加器分成一个块使用上面推导出来的门电路封装成一个块打包好。然后我们就可以迅速确定当前块的进位，减少等待进位的时间。<em>在不考虑其他门延迟的情况下</em></p><ul><li>不分块的情况下：需要等32次进位的传递</li><li>4个为一块的情况下：只需要等$32&#x2F;4 &#x3D; 8$次进位传递</li></ul><img src="/img/DC/lookahead.jpeg" alt="黑书: 32bit超前进位加法器" style="max-width: 100%; height: auto;" />  <p><strong>优点</strong></p><ul><li><strong>减少延迟</strong>：进位计算是并行完成的，速度显著快于 Ripple-Carry Adder。</li><li><strong>高效的硬件实现</strong>：适合多位二进制数加法的高速场景。</li></ul><p><strong>缺点</strong></p><ul><li><strong>硬件复杂度增加</strong>：需要额外的逻辑电路来计算生成和传播信号，随着位数增加，复杂性迅速提高。</li><li><strong>功耗较高</strong>：更多逻辑门导致功耗增加。</li></ul><p>Carry-Lookahead Adder 是一种高效的加法器设计，常用于高速处理器中。相比 Ripple-Carry Adder，它通过并行化进位计算显著提高了运算速度，但也牺牲了一定的硬件简单性。</p><h4 id="2-4-5-Half-Subtractor"><a href="#2-4-5-Half-Subtractor" class="headerlink" title="2.4.5 Half Subtractor"></a>2.4.5 Half Subtractor</h4><p>半减法器（Half Subtractor）可以对两个单个位的二进制数进行减法运算。它有两个输入：被减数$A$和减数$B$，输出包括差值（Difference, $D$）和借位（Borrow, $B_{0}$）。</p><ul><li><p>差值 $D &#x3D; A \oplus B$</p></li><li><p>借位$B_{0} &#x3D; \overline{A}B$</p></li></ul><div style="text-align: center;"><img src="/img/DC/half.svg" alt="半减法器" style="max-width: 100%; height: auto;" />  </div><h4 id="2-4-6-Full-Subtractor"><a href="#2-4-6-Full-Subtractor" class="headerlink" title="2.4.6 Full Subtractor"></a>2.4.6 Full Subtractor</h4><p>全减法器（Full Subtractor）可以对两个单个位的二进制数以及一个借位输入进行减法运算。它有三个输入：被减数$X$，减数$Y$，来自低位借位输入（Borrow_in, $B_{in}$），输出包括差值（Difference, $D$）和向高位的借位输出（Borrow_out, $B_{out}$）。</p><p>差值$D &#x3D; X ⊕ Y ⊕ B_{in}$</p><p>借位输出$<br>B_{out}&#x3D; \overline{X}B_{in} + \overline{X}Y + YB_{in}<br>$</p><blockquote><p>上述公式可以通过真值表和K-map得出，这里就省略了</p></blockquote><div style="text-align: center;"><img src="/img/DC/sub2.svg" alt="半减法器" style="max-width: 100%; height: auto;" />  </div><p>Q：<em>如何用N-bit全加器实现全减器？</em></p><p>计算机中的加减运算都是通过补码进行的，根据补码运算有$A - B$ 实现的时候可以转化为$A + (-B)$, 我们又有 $\overline{B} + 1 &#x3D; -B$，所以$Y &#x3D; A - B &#x3D; A + \overline{B} + 1$</p><div style="text-align: center;"><img src="/img/DC/sub3.svg" alt="N-bit减法器" style="max-width: 100%; height: auto;" />  </div><h4 id="2-4-7-Multiplexer"><a href="#2-4-7-Multiplexer" class="headerlink" title="2.4.7 Multiplexer"></a>2.4.7 Multiplexer</h4><p>复用器(Multiplexer)是一种数字电路元件，它的主要功能是将多个输入信号中的一个传递到输出端。复用器可以被视为一个多路选择开关，通过控制选择信号选择特定的输入线路。</p><p><strong>工作原理：</strong></p><ul><li><strong>输入信号</strong>：有 $2^n$ 个输入信号线，每条线路可传递一个信号。</li><li><strong>选择信号</strong>：通过 $n$ 条选择线决定选取哪一个输入信号。</li><li><strong>输出信号</strong>：仅有一个输出，输出选定的输入信号。</li></ul><p>复用器的输出可表示为：<br>$$<br>Y &#x3D; I_i \quad (i \text{由选择信号确定})<br>$$<br>其中 $I_i$ 是第 $i$ 个输入。下图是一个用门电路设计2:1 MUX并封装的过程</p><img src="/img/DC/mux.svg" alt="2:1 MUX" style="max-width: 100%; height: auto;" />  <p><strong>基本结构：</strong></p><ul><li><strong>数据输入端（Data Inputs）</strong>：多路信号的输入端口。</li><li><strong>选择端（Select Lines）</strong>：控制信号，决定选用哪个输入。</li><li><strong>输出端（Output Line）</strong>：传递选定信号的端口。</li></ul><p>例如：<br>对于一个 <strong>4路复用器（4-to-1 MUX）</strong>：</p><ul><li>有 4 个输入线：$I_0, I_1, I_2, I_3$。</li><li>有 2 个选择线：$S_1, S_0$。</li><li>有 1 个输出线：$Y$。</li></ul><p>输出由选择信号 $S_1$ 和 $S_0$ 确定：</p><p>$$<br>Y &#x3D;<br>\begin{cases}<br>I_0, &amp; \text{if } S_1S_0 &#x3D; 00 \\<br>I_1, &amp; \text{if } S_1S_0 &#x3D; 01 \\<br>I_2, &amp; \text{if } S_1S_0 &#x3D; 10 \\<br>I_3, &amp; \text{if } S_1S_0 &#x3D; 11<br>\end{cases}<br>$$</p><p>通过增加选择信号线数，复用器可以扩展为更大的多路选择器（如 8-to-1、16-to-1）。</p><img src="/img/DC/mux2.svg" alt="MUX" style="max-width: 100%; height: auto;" />  <h4 id="2-4-8-Decoder"><a href="#2-4-8-Decoder" class="headerlink" title="2.4.8 Decoder"></a>2.4.8 Decoder</h4><p>译码器是一种<strong>组合逻辑电路</strong>，其主要功能是将输入的<strong>二进制代码</strong>转换为<strong>独热码（one-hot code）</strong>，即在输出中只有一条线路为高电平，其余为低电平。</p><div class="note note-success">            <p>独热码工作原理:如果有 $n$ 个类别，则需要一个长度为 $n$ 的二进制向量。对应某个类别的位置为1，其余位置为0。例如，对于3个类别：A, B, C：</p><ul><li>类别 A 编码为：$[1, 0, 0]$</li><li>类别 B 编码为：$[0, 1, 0]$</li><li>类别 C 编码为：$[0, 0, 1]$</li></ul>          </div><p><strong>译码器工作原理</strong></p><ul><li><strong>输入信号</strong>：有 $n$ 条输入信号线，用于表示二进制编码。</li><li><strong>输出信号</strong>：有 $2^n$ 条输出信号线，每个输出对应一种输入组合。</li><li><strong>控制信号（可选）</strong>：部分译码器可能需要使能信号（Enable），用于控制译码器的工作状态。</li></ul><p>译码器根据输入信号的值，激活唯一对应的输出线。例如：</p><ul><li>输入：$00, 01, 10, 11$</li><li>输出：$Y_0, Y_1, Y_2, Y_3$ 依次被激活。</li></ul><p><strong>译码器基本结构</strong></p><p>对于一个 $n$ 位输入的译码器：</p><ul><li>有 $2^n$ 个输出信号线。</li><li>每个输出信号线对应一个输入组合。</li></ul><p>例如，一个 <strong>2-to-4 译码器</strong>（2位输入，4个输出）：</p><ul><li>输入：$A_1, A_0$。</li><li>输出：$Y_0, Y_1, Y_2, Y_3$。</li><li>输出逻辑：<br>$$<br>Y_0 &#x3D; \overline{A_1} \cdot \overline{A_0}, \quad<br>Y_1 &#x3D; \overline{A_1} \cdot A_0, \quad<br>Y_2 &#x3D; A_1 \cdot \overline{A_0}, \quad<br>Y_3 &#x3D; A_1 \cdot A_0<br>$$</li></ul><p>译码器是数字电路中重要的基础模块，用于信号的<strong>解码与路由</strong>。</p><img src="/img/DC/decoder.svg" alt="译码器" style="max-width: 100%; height: auto;" />  <h3 id="2-5-传播延迟和最小延迟"><a href="#2-5-传播延迟和最小延迟" class="headerlink" title="2.5 传播延迟和最小延迟"></a>2.5 传播延迟和最小延迟</h3><p><strong>传播延迟（Propagation Delay, $t_{pd}$）</strong></p><ul><li>定义：信号从输入端变化到输出端<strong>完全稳定</strong>所需的时间。对于组合电路来说就是关键路径上面每一个元件的传播延迟之和</li><li>影响因素：<ul><li>器件特性：如晶体管的开关速度、驱动能力。</li><li>负载电容：较大的负载电容会增加传播延迟。</li><li>电路拓扑：更复杂的路径结构会增加延迟。</li></ul></li><li>意义：传播延迟决定了电路的速度性能，即最大运行频率。</li></ul><p><strong>最小延迟（Contamination Delay, $t_{cd}$）</strong></p><ul><li>定义：信号在电路中传输所需的<strong>最短时间</strong>，反映信号可能在某些路径上过快到达输出端的时间。对于组合电路来说是最短路径上面每个元件的最小延迟之和。</li><li>影响因素：<ul><li>布线长度和材料特性。</li><li>逻辑门数量与优化设计。</li></ul></li><li>意义：<ul><li>保持时间（Hold Time）违规：最小延迟可能导致竞争冒险或保持时间问题。</li><li>必须确保最小延迟不会破坏电路的时序完整性。</li></ul></li></ul><img src="/img/DC/pd.svg" alt="传播延迟和最小延迟" style="max-width: 100%; height: auto;" />  <div class="note note-success">            <p>Note: 每个门的传播延迟和最小延迟要看参数表,而且传播延迟和最小延迟这个问题非常艰深…</p>          </div><h3 id="2-6-Glitch"><a href="#2-6-Glitch" class="headerlink" title="2.6 Glitch"></a>2.6 Glitch</h3><p><strong>毛刺（Glitch）</strong> 是数字电路中由于信号传播延迟或竞争冒险导致的短暂错误信号脉冲，通常表现为在信号稳定之前出现的意外高电平或低电平跳变。</p><p><strong>产生原因：</strong></p><ul><li>竞争冒险（Hazards）：当多条信号路径的传播延迟不一致时，可能导致某一时刻输出信号短暂错误。</li><li>门延迟： 逻辑门的延迟导致信号在不同路径上到达输出端的时间不同。</li><li>不完全同步：异步信号未正确对齐，导致输出出现瞬时错误信号。</li></ul><img src="/img/DC/glitch.svg" alt="毛刺时序图" style="max-width: 100%; height: auto;" />  <p>为了消除毛刺，可以通过添加冗余项优化逻辑表达式，确保信号在所有可能的变化路径中保持稳定。</p><p><strong>步骤：</strong></p><ul><li>构造卡诺图：根据真值表将逻辑表达式填入卡诺图。</li><li>标记相邻格子：将输出为“1”的相邻单元块分组，覆盖现有的逻辑区域。<br>检查是否有相邻的“1”之间存在空隙（可能导致冒险）。</li><li>添加冗余项：对于无法完全覆盖的相邻“1”之间的空隙，添加额外的逻辑项来补充。<br>确保每一个相邻的“1”都连通，避免由于输入信号变化导致逻辑的不连续。</li><li>生成优化后的逻辑表达式：将包含冗余项的逻辑表达式写出并实现。</li></ul><p>通过使用卡诺图消除毛刺的关键是：</p><ol><li>识别相邻逻辑之间的不连续性。</li><li>添加冗余项确保逻辑表达式的稳定性。</li><li>优化后可减少信号跳变，避免毛刺的产生。</li></ol><img src="/img/DC/glitch2.svg" alt="毛刺消除" style="max-width: 100%; height: auto;" />  <h2 id="3-Sequential-Logic-Circuit"><a href="#3-Sequential-Logic-Circuit" class="headerlink" title="3. Sequential Logic Circuit"></a>3. Sequential Logic Circuit</h2><p><strong>时序逻辑电路（Sequential Logic Circuit）</strong> 是一类输出<u>不仅取决于当前输入，还与电路的历史状态相关的电路。</u>它通过存储元件（如触发器、锁存器等）记录状态，具有<em>记忆功能</em>。</p><p><strong>时序逻辑电路特点:</strong></p><ul><li>记忆功能：与组合逻辑电路不同，时序逻辑电路可以存储数据。</li><li>状态变化：状态的变化通常由时钟信号控制，随着时钟信号的边沿（上升沿或下降沿）进行更新。</li><li>输出依赖性：输出依赖于当前输入和之前的状态。</li></ul><h3 id="3-1-Latch"><a href="#3-1-Latch" class="headerlink" title="3.1 Latch"></a>3.1 Latch</h3><p><strong>锁存器（Latch）</strong>是一种<strong>基本的存储元件</strong>，用于存储一个<strong>单个位的二进制信息</strong>。它的输出状态会随输入信号的变化而更新，具体取决于使能信号（通常称为<strong>控制信号</strong>或<strong>使能信号</strong>）。</p><p>工作方式为<strong>电平触发</strong>：  锁存器根据控制信号的电平（高电平或低电平）决定是否更新输出。  </p><ul><li>当使能信号为有效电平时，输出跟随输入变化。</li><li>当使能信号为无效电平时，锁存器保持当前状态（记忆功能）。</li></ul><p><strong>1. 锁存器类型：</strong></p><ul><li><p><strong>SR锁存器（Set-Reset Latch）</strong>：</p><ul><li>基于两个交叉耦合的与非门（NAND）或或非门（NOR）构成。</li><li>通过 $S$（置位）和 $R$（复位）信号控制状态。</li><li>存在不允许 $S &#x3D; R &#x3D; 1$ 的<strong>无效状态</strong>（对于NOR实现）。</li></ul></li><li><p><strong>D锁存器（Data Latch）</strong>：</p><ul><li>又称为<strong>数据锁存器</strong>。</li><li>有效控制信号时，输出 $Q$ 跟随输入 $D$；无效时，输出保持不变。</li></ul></li><li><p><strong>JK锁存器</strong>：</p><ul><li>改进了SR锁存器的无效状态问题，能够实现翻转（Toggle）功能。</li></ul></li></ul><p><strong>2. 锁存器特点：</strong></p><ul><li><strong>电平敏感</strong>：锁存器会在控制信号有效的整个时间内更新状态，而不是像触发器那样在时钟边沿更新。</li><li><strong>记忆功能</strong>：能够存储当前状态，直到输入或控制信号改变。</li></ul><p><strong>3. 锁存器应用</strong></p><ul><li><strong>数据暂存</strong>：存储单个位的信息。</li><li><strong>寄存器的构成</strong>：多个锁存器组合可以组成寄存器，用于数据存储和处理。</li><li><strong>时序电路</strong>：如简单的状态存储元件。</li></ul><p>锁存器是电平触发的基本存储元件，可以根据输入和使能信号存储信息或保持状态。其在数字电路中的作用类似“开关”，用以暂存和传递数据。</p><h4 id="3-1-1-SR锁存器（Set-Reset-Latch）"><a href="#3-1-1-SR锁存器（Set-Reset-Latch）" class="headerlink" title="3.1.1 SR锁存器（Set-Reset Latch）"></a>3.1.1 SR锁存器（Set-Reset Latch）</h4><p>SR锁存器是一种<strong>基本的锁存器类型</strong>，用于通过置位信号（Set）和复位信号（Reset）控制输出状态。它是由两个交叉耦合的逻辑门（通常是 NAND 或 NOR 门）构成的。</p><p><strong>SR Latch工作方式：</strong></p><ul><li><strong>输入信号</strong>：  <ul><li>$S$（Set）：置位信号，用于将输出 $Q$ 设置为高电平（1）。</li><li>$R$（Reset）：复位信号，用于将输出 $Q$ 设置为低电平（0）。</li></ul></li><li><strong>输出信号</strong>：<ul><li>$Q$：当前状态输出。</li><li>$\overline{Q}$：$Q$ 的反相输出，满足 $Q \cdot \overline{Q} &#x3D; 0$。</li></ul></li></ul><p>SR 锁存器的状态随 $S$ 和 $R$ 的变化而更新，具体规则如下：</p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$\overline{Q}$</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>保持</td><td>保持</td><td>保持当前状态</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>复位（Reset）</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>置位（Set）</td></tr><tr><td>1</td><td>1</td><td>无效</td><td>无效</td><td>无效状态（禁止）</td></tr></tbody></table><p><strong>SR Latch特点：</strong></p><ul><li><strong>电平敏感</strong>：<br>SR锁存器根据 $S$ 和 $R$ 的电平信号控制输出状态。</li><li><strong>无效状态</strong>：<br>当 $S &#x3D; 1$ 且 $R &#x3D; 1$ 时，$Q$ 和 $\overline{Q}$ 都为 0，这种状态被定义为无效状态，通常在设计中需要避免。</li></ul><p><strong>SR Latch实现：</strong> SR锁存器可以通过以下两种逻辑门实现：</p><ul><li><strong>NOR门实现：</strong>：<ul><li>当 $S &#x3D; 1$ 时，置位 $Q &#x3D; 1$；当 $R &#x3D; 1$ 时，复位 $Q &#x3D; 0$。</li></ul></li><li><strong>NAND门实现：</strong>：<ul><li>信号逻辑与 NOR 门相反，通常 $S$ 和 $R$ 信号需要取反。</li></ul></li></ul><p><strong>SR Latch应用：</strong></p><ul><li><strong>状态存储</strong>：  记录电路中的状态信号。</li><li><strong>控制电路</strong>：  用于实现简单的时序控制功能。</li><li><strong>锁存电路</strong>：  用作更复杂存储元件（如触发器）的基础单元。</li></ul><p>SR锁存器是最基本的锁存器，通过置位和复位信号控制输出状态，但需要避免无效状态。它在简单存储和状态保持电路中有广泛应用。</p><img src="/img/DC/sr.svg" alt="NOR门SR锁存器" style="max-width: 100%; height: auto;" />  <p>还有一种是由NAND门构成的SR锁存器，注意真值表和由NOR门构成的SR锁存器的区别</p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$\overline{Q}$</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td><strong>无效状态</strong>（禁止）</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>复位（Reset）</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>置位（Set）</td></tr><tr><td>1</td><td>1</td><td>保持</td><td>保持</td><td>保持当前状态</td></tr></tbody></table><img src="/img/DC/sr2.svg" alt="NAND门SR锁存器" style="max-width: 100%; height: auto;" />  <h4 id="3-1-2-D锁存器（Data-Latch）"><a href="#3-1-2-D锁存器（Data-Latch）" class="headerlink" title="3.1.2 D锁存器（Data Latch）"></a>3.1.2 D锁存器（Data Latch）</h4><p>D锁存器是一种基本的时序逻辑电路，用于存储1位二进制数据。它根据时钟信号的状态决定是否允许数据输入被存储。</p><ol><li><p><strong>输入和输出：</strong></p><ul><li><strong>D（Data）输入</strong>：需要存储的数据。</li><li><strong>使能信号（Enable&#x2F;Clock，通常用<code>E</code>或<code>EN</code>表示）</strong>：控制数据存储的信号。</li><li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li></ul></li><li><p><strong>工作原理：</strong></p><ul><li>当 <strong>使能信号为高</strong>（<code>E = 1</code>）：锁存器“打开”，D输入的值直接通过电路输出到 Q。</li><li>当 <strong>使能信号为低</strong>（<code>E = 0</code>）：锁存器“锁住”，Q 保持之前存储的值，不受 D 输入变化的影响。</li></ul></li><li><p><strong>特性：</strong></p><ul><li>数据在 <strong>使能信号有效期间</strong> 会被更新。</li><li>D锁存器消除了竞争（Race）条件，因为它只有一个数据输入（D），避免了像 SR 锁存器中的非法状态（S&#x3D;R&#x3D;1）。</li></ul></li><li><p><strong>应用：</strong></p></li></ol><ul><li><strong>数据存储单元</strong>：用作基本的位存储器。</li><li><strong>数据保持电路</strong>：维持信号的稳定性。</li><li><strong>边沿触发寄存器</strong>（如 D 触发器）的基本构造单元。</li></ul><table><thead><tr><th>Enable (E)</th><th>Data (D)</th><th>Output (Q)</th></tr></thead><tbody><tr><td>0</td><td>X (任意)</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>D锁存器逻辑门组成：</p><ul><li>两个<strong>与非门（NAND）或与门（AND）</strong>用来生成控制信号。</li><li>两个交叉耦合的 NAND 门（或 NOR 门）构成一个基本的锁存器（SR 锁存器）。</li></ul><img src="/img/DC/dlatch.svg" alt="D锁存器" style="max-width: 100%; height: auto;" />  <h4 id="3-1-3-JK锁存器（JK-Latch）"><a href="#3-1-3-JK锁存器（JK-Latch）" class="headerlink" title="3.1.3 JK锁存器（JK Latch）"></a>3.1.3 JK锁存器（JK Latch）</h4><p>JK锁存器是一种增强型的时序逻辑电路，是对 SR 锁存器的改进，避免了 SR 锁存器中 <code>S=1</code> 和 <code>R=1</code> 时的非法状态问题。它被广泛用于时序电路中，能够实现多种功能，如保持、置位、复位和翻转。</p><ol><li><p><strong>输入和输出：</strong></p><ul><li><strong>J（Set）</strong>：对应置位功能。</li><li><strong>K（Reset）</strong>：对应复位功能。</li><li><strong>使能信号（Enable 或 Clock）</strong>：控制锁存器工作状态。</li><li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li></ul></li><li><p><strong>功能定义：</strong></p><ul><li><strong>J&#x3D;0, K&#x3D;0</strong>：保持状态（Q 保持不变）。</li><li><strong>J&#x3D;0, K&#x3D;1</strong>：复位（Q&#x3D;0）。</li><li><strong>J&#x3D;1, K&#x3D;0</strong>：置位（Q&#x3D;1）。</li><li><strong>J&#x3D;1, K&#x3D;1</strong>：翻转状态（Q 从 0 变为 1，或从 1 变为 0）。</li></ul></li></ol><table><thead><tr><th>Enable (E)</th><th>J</th><th>K</th><th>Q (Next State)</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>0</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>Q̅（翻转）</td></tr></tbody></table><ol start="3"><li><strong>JK锁存器应用:</strong></li></ol><ul><li><strong>寄存器设计</strong>：作为存储单元使用。</li><li><strong>计数器</strong>：通过翻转功能实现二进制计数器。</li><li><strong>时序电路</strong>：作为基本的控制逻辑单元。</li></ul><img src="/img/DC/jklatch.svg" alt="JK锁存器" style="max-width: 100%; height: auto;" />  <h3 id="3-2-Flip-FLop"><a href="#3-2-Flip-FLop" class="headerlink" title="3.2 Flip-FLop"></a>3.2 Flip-FLop</h3><p>触发器是数字电路中的一种基本<strong>时序逻辑电路</strong>，用于存储一个二进制位的信息。它具有<strong>存储能力</strong>和<strong>同步性</strong>，是寄存器、计数器等时序电路的基础组件。</p><p><strong>触发器的特点：</strong></p><ol><li><strong>存储能力</strong>：可以存储1位二进制数据（0或1）。</li><li><strong>同步性</strong>：大多数触发器通过<strong>时钟信号（Clock）</strong>控制状态的改变。</li><li><strong>状态保持</strong>：在没有输入信号变化时，触发器会保持当前状态。</li></ol><p><strong>常见触发器类型：</strong></p><p><strong>SR触发器：</strong></p><ul><li>基本类型，具有两个输入：<strong>Set（置1）</strong> 和 <strong>Reset（清0）</strong>。</li><li>特点：<ul><li>S&#x3D;1, R&#x3D;0：输出为1。</li><li>S&#x3D;0, R&#x3D;1：输出为0。</li><li>S&#x3D;0, R&#x3D;0：保持状态。</li><li><strong>S&#x3D;1, R&#x3D;1</strong>：不稳定状态（无效）。</li></ul></li></ul><p><strong>D触发器（数据触发器）：</strong></p><ul><li>具有一个数据输入端（D）和一个时钟输入端（CLK）。</li><li>特点：<ul><li>在时钟信号的有效边沿（上升沿或下降沿）到来时，将输入D的值传递到输出Q。</li></ul></li><li>应用：<ul><li>常用于数据同步和寄存器设计。</li></ul></li></ul><p><strong>JK触发器：</strong></p><ul><li>是RS触发器的改进型，消除了<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态。</li><li>输入为J和K：<ul><li>J&#x3D;1, K&#x3D;0：置1。</li><li>J&#x3D;0, K&#x3D;1：清0。</li><li>J&#x3D;K&#x3D;1：状态翻转。</li></ul></li><li>应用：<ul><li>广泛用于计数器和状态机设计。</li></ul></li></ul><p><strong>T触发器（触发翻转器）：</strong></p><ul><li>只有一个输入（T）。</li><li>特点：<ul><li>T&#x3D;1：状态翻转。</li><li>T&#x3D;0：状态保持。</li></ul></li><li>应用：<ul><li>常用于计数器电路。</li></ul></li></ul><p>触发器是数字电路中<strong>存储单元的核心</strong>，用来实现数据存储和同步控制。不同类型的触发器适用于不同的功能需求：</p><ul><li>SR触发器用于简单存储；</li><li>D触发器用于数据锁存；</li><li>JK触发器适合复杂逻辑控制；</li><li>T触发器常用于计数和分频。</li></ul><h4 id="3-2-1-SR-Flip-Flop"><a href="#3-2-1-SR-Flip-Flop" class="headerlink" title="3.2.1 SR Flip-Flop"></a>3.2.1 SR Flip-Flop</h4><p><strong>SR触发器</strong>是一种基本的双稳态存储单元，用于存储1位二进制信息。SR触发器由 <strong>Set（S）</strong> 和 <strong>Reset（R）</strong> 两个输入控制输出状态，常用于简单的存储和逻辑控制。</p><p><strong>工作原理</strong></p><ul><li><strong>S（Set）</strong>：设置触发器的输出为1（Q&#x3D;1）。</li><li><strong>R（Reset）</strong>：重置触发器的输出为0（Q&#x3D;0）。</li><li>$Q$ 和 $\overline{Q}$：为触发器的输出和其反向输出。</li></ul><p><strong>逻辑功能表</strong></p><table><thead><tr><th>S</th><th>R</th><th>Q（输出）</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>保持</td><td>保持上次状态</td></tr><tr><td>0</td><td>1</td><td>0</td><td>清零</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置1</td></tr><tr><td>1</td><td>1</td><td>无效</td><td>不允许状态</td></tr></tbody></table><p> <strong>状态说明</strong></p><ol><li><strong>S&#x3D;0, R&#x3D;0</strong>：触发器保持当前状态，不发生变化。</li><li><strong>S&#x3D;1, R&#x3D;0</strong>：输出Q被置为1（Set）。</li><li><strong>S&#x3D;0, R&#x3D;1</strong>：输出Q被重置为0（Reset）。</li><li><strong>S&#x3D;1, R&#x3D;1</strong>：为无效状态，因Q和Q’会同时为1，违背Q和Q’互补的逻辑。</li></ol><p> <strong>应用场景</strong></p><ul><li><strong>存储单元</strong>：用于存储1位数据。</li><li><strong>逻辑控制</strong>：作为简单的状态保持和切换电路。</li><li><strong>锁存器</strong>：用于构成其他类型的触发器（如D触发器和JK触发器）。</li></ul><p>SR触发器是最基本的触发器类型，但存在<strong>S&#x3D;1, R&#x3D;1</strong>的不允许状态，限制了它在复杂电路中的使用。改进型触发器（如JK触发器）解决了这一问题。</p><p>SR触发器状态转移公式：<br>$$<br>\begin{cases}<br>Q_{n+1}  &#x3D; S + \overline{R}Q_{n} \\<br>S \cdot R &#x3D; 0  (约束条件)<br>\end{cases}<br>$$</p><img src="/img/DC/srff.svg" alt="SR触发器" style="max-width: 100%; height: auto;" />  <h4 id="3-2-2-D-Flip-Flop"><a href="#3-2-2-D-Flip-Flop" class="headerlink" title="3.2.2 D Flip-Flop"></a>3.2.2 D Flip-Flop</h4><p><strong>D触发器</strong>（Data Flip-Flop, DFF）是数字电路中一种基本的时序逻辑电路，用于存储1位二进制数据。它通过 <strong>数据输入端（D）</strong> 和 <strong>时钟信号（CLK）</strong> 实现同步数据存储。D触发器也经常称为主从触发器（master-slave flip-flop），边沿触发器（edge-triggered flip-flop）或者正边沿触发器（positive edge-triggered flip-flop）。</p><p> <strong>工作原理:</strong></p><ul><li><strong>D输入</strong>：决定触发器的输出值。</li><li><strong>CLK输入</strong>：控制触发器的状态更新，确保输出只有在特定时钟条件下（如上升沿或下降沿）才更新。</li><li>当时钟信号有效时，<strong>D的值会传递到输出Q</strong>，同时Q’为Q的反相。</li></ul><p> <strong>逻辑功能表:</strong></p><table><thead><tr><th>CLK（时钟）</th><th>D（数据）</th><th>Q（输出）</th><th>状态</th></tr></thead><tbody><tr><td>上升沿</td><td>0</td><td>0</td><td>输出清零</td></tr><tr><td>上升沿</td><td>1</td><td>1</td><td>输出置1</td></tr><tr><td>其他</td><td>-</td><td>保持</td><td>状态不变</td></tr></tbody></table><p> <strong>DFF特点:</strong></p><ol><li><strong>同步性</strong>：依赖时钟信号控制，输出只在时钟有效时更新。</li><li><strong>无争议状态</strong>：相比SR触发器，D触发器没有无效状态。</li><li><strong>锁存功能</strong>：在时钟无效时，输出保持上一次的状态。</li></ol><p> <strong>DFF应用场景:</strong></p><ol><li><strong>寄存器</strong>：用于存储和传输数据。</li><li><strong>移位寄存器</strong>：通过多级D触发器实现数据位移。</li><li><strong>计数器</strong>：作为计数器电路的基础单元。</li><li><strong>同步电路</strong>：用于数据同步或信号稳定。</li></ol><p>D触发器是一种<strong>简单高效的存储单元</strong>，它通过时钟信号的控制实现数据的同步存储，广泛应用于各种数字电路中。一个D触发器可以由反相时钟控制的2个背靠背的D锁存器构成。</p><img src="/img/DC/dff.svg" alt="D触发器" style="max-width: 100%; height: auto;" />  <p><em>对于上升沿触发的DFF的时序图：</em></p><div style="text-align: center;"><img src="/img/DC/dff2.svg" alt="DFF" style="max-width: 100%; height: auto;" />  </div><div class="note note-success">            <p>至于为什么是上升沿触发，可以画一下主锁存器的值和从锁存器的值的时序图，此处省略</p>          </div><p><em>当然还有下降沿触发的DFF的时序图：</em></p><img src="/img/DC/dff3.svg" alt="下降沿DFF" style="max-width: 100%; height: auto;" />  <p>D触发器状态转移公式：<br>$$Q_{n+1} &#x3D; D$$</p><h4 id="3-2-3-JK-Flip-Flop"><a href="#3-2-3-JK-Flip-Flop" class="headerlink" title="3.2.3 JK Flip-Flop"></a>3.2.3 JK Flip-Flop</h4><p><strong>JK触发器</strong>是一种改进型的双稳态触发器，是对<strong>SR触发器</strong>的增强，解决了SR触发器中<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态问题。它通过输入信号J和K以及时钟信号CLK实现状态控制，具有更强的功能和更广的应用。</p><p> <strong>JKFF工作原理：</strong></p><ul><li><strong>J（Set）</strong>：与SR触发器的S功能类似，用于设置输出Q&#x3D;1。</li><li><strong>K（Reset）</strong>：与SR触发器的R功能类似，用于清零输出Q&#x3D;0。</li><li><strong>CLK（时钟信号）</strong>：用于同步控制，触发器的状态仅在时钟信号的有效边沿发生变化。</li></ul><p><strong>JKFF逻辑功能表：</strong></p><table><thead><tr><th>J</th><th>K</th><th>$Q_{n}$（输出）</th><th>$Q_{n+1}$（下一状态）</th><th>状态描述</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Q</td><td>保持</td><td>状态保持</td></tr><tr><td>0</td><td>1</td><td>0</td><td>清零</td><td>Reset</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置1</td><td>Set</td></tr><tr><td>1</td><td>1</td><td>Q’（反相）</td><td>翻转</td><td>Toggle（翻转）</td></tr></tbody></table><p> <strong>JKFF特点：</strong></p><ol><li><strong>无无效状态</strong>：J&#x3D;1, K&#x3D;1 时，触发器的输出状态翻转，解决了SR触发器的争议状态问题。</li><li><strong>同步性</strong>：在时钟信号控制下工作，确保状态变化的同步。</li><li><strong>功能多样</strong>：可以通过J和K的输入实现保持、置1、清零、翻转等功能。</li></ol><p> <strong>JKFF结构组成：</strong></p><ul><li>由SR触发器扩展而来，增加了逻辑门以控制输入S和R，确保J&#x3D;1, K&#x3D;1 时实现输出翻转。</li><li>常采用 <strong>边沿触发（Edge-triggered）</strong> 的设计，使其适用于复杂的时序电路。</li></ul><p> <strong>JKFF应用场景：</strong></p><ol><li><strong>计数器</strong>：JK触发器在计数器电路中广泛应用，用于实现递增或递减计数。</li><li><strong>状态机</strong>：设计复杂的同步时序电路。</li><li><strong>分频器</strong>：利用J&#x3D;1, K&#x3D;1的翻转特性实现时钟信号分频。</li></ol><p>JK触发器的实现可以通过主从结构，由两个SR触发器级联完成。</p><img src="/img/DC/jkff.svg" alt="JKFF" style="max-width: 100%; height: auto;" />  <p>下面是<em>下降沿触发</em>的JKFF的时序图:</p><img src="/img/DC/jkff2.svg" alt="JKFF时序图" style="max-width: 100%; height: auto;" />  <p>我们可以得出JKFF的状态转移公式：</p><p>$$Q_{n+1} &#x3D; J\overline{Q_{n}} + \overline{k}Q_{n}$$</p><div class="note note-success">            <p>JKFF时序图口诀：00不变，11翻转，10置1，01置0</p>          </div><h4 id="3-2-4-T-Flip-Flop"><a href="#3-2-4-T-Flip-Flop" class="headerlink" title="3.2.4 T Flip-Flop"></a>3.2.4 T Flip-Flop</h4><p><strong>T触发器</strong>（Toggle Flip-Flop）是一种基本的时序逻辑电路，用于实现<strong>状态翻转</strong>或<strong>分频功能</strong>。</p><p><strong>TFF工作原理：</strong></p><ul><li><strong>T输入（Toggle）</strong>：用于控制触发器的翻转功能。<ul><li>T&#x3D;0：保持当前状态</li><li>T&#x3D;1：状态翻转</li></ul></li><li><strong>CLK（时钟信号）</strong>：控制T触发器的状态更新，输出仅在时钟信号的有效边沿发生变化。</li></ul><p><strong>TFF逻辑功能表：</strong></p><table><thead><tr><th>CLK（时钟）</th><th>T（输入）</th><th>$Q_{n}$（输出）</th><th>$Q_{n+1}$（下一状态）</th><th>状态描述</th></tr></thead><tbody><tr><td>上升沿</td><td>0</td><td>Q</td><td>保持</td><td>状态保持</td></tr><tr><td>上升沿</td><td>1</td><td>Q’</td><td>翻转</td><td>Toggle（翻转）</td></tr><tr><td>其他</td><td>-</td><td>保持</td><td>保持</td><td>状态不变</td></tr></tbody></table><p><strong>TFF特点：</strong></p><ol><li><strong>状态翻转</strong>：当T&#x3D;1时，输出状态在每个时钟边沿发生翻转。</li><li><strong>分频功能</strong>：每次翻转需要一个时钟信号，因此输出频率为输入时钟频率的一半。</li><li><strong>简化结构</strong>：通过将JK触发器的J和K输入连接为同一信号T，简化了设计。</li></ol><p><strong>TFF实现方式：</strong></p><ol><li><strong>由JK触发器实现</strong>：将J&#x3D;K&#x3D;T，形成T触发器的逻辑。</li><li><strong>直接实现</strong>：通过逻辑门电路设计，实现T输入控制翻转功能。</li></ol><p><strong>TFF应用场景：</strong></p><ol><li><strong>计数器</strong>：用于实现二进制计数器的单个计数位。</li><li><strong>分频器</strong>：将时钟信号的频率降低一半，用于时钟分频。</li><li><strong>状态机</strong>：在简单状态转换电路中用作基本单元。</li></ol><p>TFF的一种实现如下图：<br><img src="/img/DC/tff.svg" alt="TFF" style="max-width: 100%; height: auto;" />  </p><p>TFF的时序图如下：<br><img src="/img/DC/tff2.svg" alt="TFF Time Diagram" style="max-width: 100%; height: auto;" />  </p><p>我们可以得出TFF的状态转移方程式为：</p><p>$$Q_{n+1} &#x3D; T \oplus Q_{n}$$</p><h3 id="3-3-Synchronous-Sequential-Logic"><a href="#3-3-Synchronous-Sequential-Logic" class="headerlink" title="3.3 Synchronous Sequential Logic"></a>3.3 Synchronous Sequential Logic</h3><p>Synchronous Sequential Logic（同步时序逻辑）是一类数字逻辑电路，其输出不仅取决于当前的输入，还取决于电路的状态（通常存储在触发器中）。这种电路的状态变化由一个<u>全局时钟信号</u>同步控制。</p><p>同步时序电路可以设计为两种类型：</p><ul><li>Mealy电路：输出依赖于当前状态和输入（对应有限自动机中的 Mealy 机）。</li><li>Moore电路：输出<strong>仅依赖于</strong>当前状态（对应有限自动机中的 Moore 机）。</li></ul><div class="note note-success">            <p>记忆：摩尔庄园–&gt;摩尔当前–&gt;摩尔电路只依赖于当前状态</p>          </div><img src="/img/DC/fsm.svg" alt="FSM" style="max-width: 100%; height: auto;" />  <p>根据上图可以再深入理解一下两种有限状态机（Finite State Machine, FSM），举个例子，判断输出1是如何依赖的：</p><ul><li>Mealy型FSM输出1需要同时依赖<strong>当前状态</strong>和<strong>输入</strong><ul><li>当前状态B并且输入1，可以输出1</li><li>当前状态B并且输入0，可以输出1</li></ul></li><li>Moore型FSM输出1只依赖当前状态：<ul><li>当前状态是B是，输出1</li><li>当前状态是C，输出1</li></ul></li></ul><p>关于同步时序电路的设计一般有如下步骤：</p><ol><li>原始状态图</li><li>状态图化简（当两个状态具有同样的输入时，也具有相同的输出和相同的次态时，可以合并）</li><li>状态分配（画状态表的时候与卡诺图一一对应比较合理高效！例如00、01、11、10这样子）</li><li>选触发器（D、JK；3个状态选2个FF，5个状态选3个FF； $2^{n-1} &lt; M \leq 2^{n}$）</li><li>确定激励方程组以及输出方程组</li><li>画图✍️检查能否自启动</li></ol><p>常见的同步时序电路设计一般包含：计数器，序列检测器，串行数据检测器等。</p><div class="note note-primary">            <p>同步时序电路设计的思路都很固定，参考过去问巩固练习即可</p>          </div><p>计数器过去问典型题目：马不停蹄🐎</p><p>序列检测器典型题目：马不停蹄🐎</p><p>串行数据检测器典型题目：马不停蹄🐎</p><h3 id="3-4-Asynchronous-Sequential-Logic"><a href="#3-4-Asynchronous-Sequential-Logic" class="headerlink" title="3.4 Asynchronous Sequential Logic"></a>3.4 Asynchronous Sequential Logic</h3><p><strong>Asynchronous Sequential Logic（异步时序逻辑）</strong> 是一种不依赖全局时钟信号的逻辑电路设计。其状态的变化由输入信号的变化直接触发，而不是由时钟脉冲控制。与同步时序逻辑相比，异步逻辑更灵活，但设计和调试更复杂。</p><p><strong>异步时序逻辑特点：</strong></p><ol><li>无全局时钟信号：异步电路的状态变化完全由输入信号或内部信号的变化触发，而不需要时钟信号协调。</li><li>依赖传播延迟：异步逻辑的行为受门延迟和信号传播时间的影响，可能会导致竞争和冒险现象。</li><li>更快的响应速度：输入变化会立即影响输出，因此响应速度通常比同步电路快。</li><li>更复杂的设计：需要解决元态（Metastability）、竞争（Race Condition）和冒险（Hazard）问题，设计和验证复杂度较高。</li></ol><div class="note note-primary">            <p>修考基本很少考异步时序电路设计，参考过去问巩固练习。</p>          </div><p>异步时序电路设计题目：马不停蹄🐎</p><h2 id="4-偷偷说"><a href="#4-偷偷说" class="headerlink" title="4. 偷偷说"></a>4. 偷偷说</h2><p>数字电路的重点就是组合电路和时序电路的设计，在理解每个元件特性的基础上，设计类的题目都非常固定。数字电路的黑书说实话写的很差劲：一是逻辑不连贯，二是忽略了很多推导细节。相反，《論理回路入門》by：坂井 修一，这本书我觉得写的非常不错，短小精悍，非常适合修考备考。</p><p>Thanks <a href="https://github.com/jgraph/drawio-desktop">@drawio</a> for generating the powerful diagrams.</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Digital Circuit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Architecture</title>
    <link href="/2024/10/21/Computer-Architecture/"/>
    <url>/2024/10/21/Computer-Architecture/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h1><p>This is for test takers to quickly review Computer Architecture. The whole notes contain 5 parts and I try to make it clear and simple. Credit to《Computer Organization and Design : The Hardware&#x2F;Software Interface, 5th Edition》目前我也在<a href="https://www.xly-edu.com/">@新领域理工塾</a>，讲授这门课😇</p><blockquote><p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>在本章中，主要引入一下计算机组成的概念然后讲解衡量计算机的性能指标，并着重讲解涉及到的计量单位和公式。</p><h3 id="1-1-常用单位"><a href="#1-1-常用单位" class="headerlink" title="1.1 常用单位"></a>1.1 常用单位</h3><p>容量单位常用<strong>字节(Byte)</strong> ,衡量单位是<em>2进制(Binary)</em> ,容量之间的数量级关系是：$2^{10}$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如： $1TB&#x3D;2^{10} GB&#x3D; 1024GB$; $1GB&#x3D;2^{10}MB&#x3D;1024MB$</p></blockquote><p>衡量传输速度常用<strong>位每秒(bps,bit per secod)</strong> ,衡量单位是<em>10进制(Decimal)</em> ,传输速度之间的数量级关系是：$10^3$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如：$1kbit&#x2F;s&#x3D;1000bit&#x2F;s$, $1mbit&#x2F;s&#x3D;1000kbit&#x2F;s$</p></blockquote><p>另外需要注意的单位换算是：</p><ul><li>$bit&#x2F;s$记作$bps$</li><li>$1 Byte &#x3D; 8 bit$</li><li>$1 Bps &#x3D; 1 Byte&#x2F;second &#x3D; 8 bit&#x2F;second &#x3D; 8 bps$</li></ul><h3 id="1-2-计算机结构中的8个伟大思想"><a href="#1-2-计算机结构中的8个伟大思想" class="headerlink" title="1.2 计算机结构中的8个伟大思想"></a>1.2 计算机结构中的8个伟大思想</h3><ul><li>Moore’s Law: 芯片上的集成度每18～24个月翻一番</li><li>Abstraction：使用抽象来表示不同设计层次，化繁为简</li><li>Common Case Fast: 加速大概率事件远比优化小概率事件更能提高性能，即抓住主要矛盾</li><li>Parallel Performance: 并行操作来提高性能，说白了就是<del>打工人能做多少做多少</del></li><li>Pipeline: 这是一个并行场景的具体实现，后面章节会详细讲解🔎</li><li>Prediction：通过猜测的方式提前启动某些操作，提高性能，投资人讲究一个增收降本的策略。</li><li>Hierachy of memory: 用存储器层次来解决容量，速度，成本之间的相互矛盾需求。小而精则贵，大而糙则贱</li><li>Dependable：任何一个物理器件都有可能失效，使用冗余部件的方式来提高系统的可靠性，即备胎🛞</li></ul><p>在加速大概率事件中有一个定量分析的<strong>Amdahl定律</strong>：</p><center>$改进后的执行时间 = 改进影响的执行时间 / 加速比 + 改进不影响的执行时间$</center><center>$t_{\text{改进}} = t_{\text{相关}} / S + t_{\text{无关}}$</center><h3 id="1-3-计算机语言"><a href="#1-3-计算机语言" class="headerlink" title="1.3 计算机语言"></a>1.3 计算机语言</h3><p>计算机语言主要分为三类：<strong>高级语言</strong>、<strong>汇编语言</strong>和<strong>机器语言</strong>。程序执行的过程是先将高级语言编译为汇编语言，然后通过汇编，将汇编语言转化为相应的机器语言。</p><h4 id="1-3-1-高级语言-High-level-programming-language"><a href="#1-3-1-高级语言-High-level-programming-language" class="headerlink" title="1.3.1 高级语言(High-level programming language)"></a>1.3.1 高级语言(High-level programming language)</h4><p>最接近人类自然语言的编程语言。常见的高级语言包括C++, Java, Python, 和JavaScript。</p><h4 id="1-3-2-汇编语言-Assembly-language"><a href="#1-3-2-汇编语言-Assembly-language" class="headerlink" title="1.3.2 汇编语言(Assembly language)"></a>1.3.2 汇编语言(Assembly language)</h4><p>汇编语言是一种低级编程语言，它直接对应于机器语言，但使用人类更易理解的符号和短语来表示。每条汇编指令通常都对应一条机器语言指令，因此汇编语言被认为是机器语言的符号表示。汇编语言需要使用汇编器（Assembler）将代码转换为机器语言。这种语言通常用于编写需要精确控制硬件的程序，如操作系统内核和驱动程序。汇编语言的分类一般有两种主要类型：<strong>RISC指令集（Reduced Instruction Set Computing）</strong> 和 <strong>CISC指令集（Complex Instruction Set Computing）</strong>。</p><ul><li><strong>RISC指令集：</strong> 即简化指令集计算（Reduced Instruction Set Computing）：这种类型的指令集特点是<em>指令集较为简单，每条指令执行时间固定而短，通常在一个时钟周期内完成</em>。这使得RISC处理器能够更快速地执行大量简单的指令。代表性的RISC架构包括<u>ARM、MIPS和SPARC。</u></li><li><strong>CISC指令集：</strong>即复杂指令集计算（Complex Instruction Set Computing），这种类型的指令集特点是指令集复杂，每条指令可能<em>需要多个时钟周期</em>才能完成执行。CISC处理器通过一个复杂的指令集试图降低编程的复杂性，使得某些复杂操作能通过一条指令完成。典型的CISC架构包括<u>x86和VAX。</u></li></ul><div class="note note-success">            <p>在修考中，出现的汇编语言是RISC指令集，因此在后序章节只讲解RISC指令</p>          </div><h4 id="1-3-3-机器语言-Machine-language"><a href="#1-3-3-机器语言-Machine-language" class="headerlink" title="1.3.3 机器语言(Machine language)"></a>1.3.3 机器语言(Machine language)</h4><p>机器语言是计算机能够直接执行的最底层编程语言。它由二进制代码组成，每条指令由一串0和1表示（eg. 00000111111010001），直接控制计算机的硬件操作。由于其复杂性和难以阅读，人类很少直接编写机器语言程序。</p><blockquote><p>总结：高级语言编译为汇编语言，然后汇编语言通过汇编转化为由01串组成的机器语言</p></blockquote><h3 id="1-4-冯·诺伊曼结构-Von-Neumann-architecture"><a href="#1-4-冯·诺伊曼结构-Von-Neumann-architecture" class="headerlink" title="1.4 冯·诺伊曼结构(Von Neumann architecture)"></a>1.4 冯·诺伊曼结构(Von Neumann architecture)</h3><img src="/img/CA/von.svg" alt="冯诺伊曼结构" style="max-width: 100%; height: auto;" /><p><strong>输入设备(Input Devices)</strong> 是用于向计算机输入数据和指令的硬件。例如，键盘（Keyboard）、鼠标（Mouse）、扫描仪（Scanner）、话筒（Microphone）等。它们将用户的操作转化为计算机能够理解的信号。</p><p><strong>输出设备(Output Devices)</strong> 是用于从计算机输出数据和结果的硬件。例如，显示器（Monitor）、打印机（Printer）、扬声器（Speakers）等。它们将计算机处理后的数据转化为用户可以理解的信息。</p><p><strong>控制器(Control Unit, CU)</strong> 是负责从存储器读取指令，并解释和执行指令的计算机部件。它管理和协调计算机的各个部分，以确保指令被按顺序执行。</p><p><strong>运算器(Arithmetic Logic Unit, ALU)</strong> 是执行算术运算和逻辑运算的核心部件。它能处理整数和浮点数的加、减、乘、除等运算，也能进行与、或、非等逻辑运算。</p><p><strong>存储器(Memory)</strong> 是存储数据和指令的地方。分为主存储器（Main Memory）和辅助存储器（Secondary Storage）。主存储器（如RAM，随机存取存储器，Random Access Memory）用于存储当前正在使用的数据和指令；辅助存储器（如硬盘，Hard Disk Drive）用于长期存储数据。</p><p><strong>中央处理器(Central Processing Unit, CPU)</strong> 是计算机的“大脑”，负责解释和执行指令。它由控制器（Control Unit, CU）和运算器（Arithmetic Logic Unit, ALU）组成，管理并处理所有的计算任务。</p><h3 id="1-5-计算机性能指标"><a href="#1-5-计算机性能指标" class="headerlink" title="1.5 计算机性能指标"></a>1.5 计算机性能指标</h3><p><strong>响应时间（Response Time）：</strong> 响应时间，又称执行时间，是指系统从接收到请求到开始产生输出结果所经过的时间。</p><p><strong>吞吐率（Throughput）：</strong> 吞吐率是指在单位时间内系统能够处理的请求数量。它衡量的是系统的处理能力。高吞吐率意味着在同样的时间内，系统能够处理更多的请求或完成更多的工作。</p><p><strong>CPU性能公式(Performance)：</strong></p><center>$CPU性能 = 1 / 执行时间$</center><p>A的性能比B的性能高$X$倍计算：  $X&#x3D;t_{B执行时间}&#x2F;t_{A执行时间}$</p><p><strong>时钟周期长度(Clock Cycle Length):</strong><br>是指计算机时钟信号中相邻两个相同状态（如两个上升沿）之间的时间间隔。CPU做的任何动作所消耗的时间都是一个时钟周期的整数倍。通常以纳秒（ns）为单位,记作 $T$</p><p><strong>时钟周期频率(Clock Cycle Frequency):</strong><br>则是时钟信号每秒钟振荡的次数，通常以赫兹（Hz）为单位。它是时钟周期长度的倒数。例如，如果时钟周期长度是2纳秒，那么时钟频率就是0.5 GHz,记作 $f$</p><p>两者之间的关系是：</p><ul><li><p>时钟周期长度 &#x3D; 1 &#x2F; 时钟周期频率, 即 $T &#x3D; 1 &#x2F; f$</p></li><li><p>时钟周期频率 &#x3D; 1 &#x2F; 时钟周期长度, 即 $f &#x3D; 1 &#x2F; T$</p></li></ul><p><strong>CPI(Cycles Per Instruction):</strong><br>是计算机性能指标，用于衡量每条指令所需的平均时钟周期数。它反映了CPU执行指令的效率。CPI的计算公式是：</p><center>$ \text{CPI} = \frac{\text{总时钟周期数}}{\text{指令数}} $</center><p><strong>时钟周期数计算公式(Clock Cycle):</strong></p><center>$Clock Cycle=指令数\times平均每条指令所需周期数 = IC \times CPI$</center><blockquote><p>注：指令数(Instruction Count, IC)是指CPU在执行一个程序时，需要执行的指令总数。</p></blockquote><p><strong>CPU执行时间：</strong></p><center>$ \text{CPU Time} = \text{指令数} \times \text{CPI} \times \text{时钟周期长度} = IC \times CPI \times T = IC \times CPI / f$</center><p>还有一个衡量指标<strong>是MIPS(million instructions per second)</strong>:</p><center>$ MIPS = IC / (\text{CPU Time} \times 10^{6}) = f / (CPI \times 10^{6})$</center><p><strong>功耗计算公式：</strong> 记住就行</p><center> $P = \frac{1}{2} \times U^2 \times f$</center><blockquote><p>注： $P$ 是功耗，$C$ 是负载电容， $U$ 是电压， $f$ 是开关频率</p></blockquote><h2 id="2-Instructions-The-Language-of-Computers"><a href="#2-Instructions-The-Language-of-Computers" class="headerlink" title="2. Instructions: The Language of Computers"></a>2. Instructions: The Language of Computers</h2><p>这一章非常重要，因为修考题目中经常出现理解汇编语言的题目。本章主要讲解RISC-V指令集架构还有五种寻址方式</p><h3 id="2-1-Instrcucton"><a href="#2-1-Instrcucton" class="headerlink" title="2.1 Instrcucton"></a>2.1 Instrcucton</h3><p>计算机在底层执行程序时，通过读取由0和1组成的机器指令来执行命令。在RISC-V指令集中，所有的机器指令都是32位长，也就是32位的二进制串。这些32位的机器指令对应的汇编语言指令通常由操作码和两个地址码组成（形式：操作码 + 地址码 + 地址码）。规定：</p><ul><li>程序中的变量存放在保存寄存器（store reg）中：$s0~$s7共8个</li><li>临时变量，中间变量存放在临时寄存器（temp reg）中：$t0~$t7共8个</li><li>零寄存器，永远存放32位的0，记作$zero</li></ul><h3 id="2-2-RISC-V-Instruction-Set"><a href="#2-2-RISC-V-Instruction-Set" class="headerlink" title="2.2 RISC-V Instruction Set"></a>2.2 RISC-V Instruction Set</h3><h4 id="2-2-1-基本指令"><a href="#2-2-1-基本指令" class="headerlink" title="2.2.1 基本指令"></a>2.2.1 基本指令</h4><p><strong>加法，减法指令(add, sub):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; c &#x3D; a + b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; badd $s2, $s0, $s1  &#x2F;&#x2F; c &#x3D; a - b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; bsub $s2, $s0, $s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>加立即数指令(addi):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; i &#x3D; i + 1, i存放在$s0寄存器中addi $s0, $s0, 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>逻辑运算指令:</strong> and(与)，or(或)，nor（或非）</p><p><strong>逻辑左移(shift left logic, sll)和右移(shift right logic, srl):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sll $to, $s2, 2 &#x2F;&#x2F; 将$s2寄存器的值左移2位，即变为4倍，存放在$t0中srl $to, $s2, 1 &#x2F;&#x2F; 将$s2寄存器的值右移1位，即变为1&#x2F;2倍，存放在$t0中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>取字指令(load word, lw)和存字指令(save word, sw):</strong><br>因为寄存器是按字(Word)存储，而内存是按字节(Byte)编址,在RISC-V指令集中，约定：1 Word &#x3D; 32 bit &#x3D; 4 Byte。</p><blockquote><p>举个例子：已知a[0]的地址存放在寄存器s0中，现在需要取a[2]的值存放在寄存器t0中；a[2]和a[0]之间的字节偏移有 2 * 4 &#x3D; 8 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw $t0, 8($s0)  &#x2F;&#x2F; 取出$s0偏移8字节的位置的值，存放在$t0寄存器中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><blockquote><p>同理，如果我们要把t0寄存器的值存到a[4]中去，可以知道a[4]与a[0]的字节偏移有 4 * 4 &#x3D; 16 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw $t0, 16($s0) &#x2F;&#x2F; 注意操作的方向和lw相反<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="2-2-2-装载32位立即数到寄存器"><a href="#2-2-2-装载32位立即数到寄存器" class="headerlink" title="2.2.2 装载32位立即数到寄存器"></a>2.2.2 装载32位立即数到寄存器</h4><p>因为装载的32位立即数不能完全放进32位的机器指令中，因此寄存器可以通过两条指令来完成：LUI (Load Upper Immediate) 和 ORI (OR Immediate)。比如将立即数 0xF7EE57AD 装载到寄存器中这个两个指令需要完成的动作是：</p><blockquote><p>0xF7EE57AD 对应的 32 位二进制数是：1111 0111 1110 1110 0101 0111 1010 1101</p></blockquote><ul><li><p>LUI 指令：取0xF7EE57AD的高16位数（1111 0111 1110 1110) 放入寄存器的高16位</p></li><li><p>ORI 指令：将寄存器和剩下的低16位数做立即与的动作(0101 0111 1010 1101)</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $s1, 63470 &#x2F;&#x2F; 1111 0111 1110 1110 对应的十进制数是 63470ori $s1, 22957 &#x2F;&#x2F; 0101 0111 1010 1101 对应的十进制数是 22957&#x2F;* 整个动作如下：step1: 取到高16位数，$s1的值为 1111 0111 1110 1110 0000 0000 0000 0000step2: $s1的值与低16位数立即与 0000 0000 0000 0000 0101 0111 1010 1101最终$s1的值为 1111 0111 1110 1110 0101 0111 1010 1101*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然还有其他写法：比如lui和addi。例如，要将立即数 0x12345678 装载到寄存器 t0 中</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $t0, 0x12345 &#x2F;&#x2F; 将高20位0x12345装载到t0addi $t0, $t0, 0x678 &#x2F;&#x2F; 将剩余的12位0x678添加到t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li></ul><h4 id="2-2-3-判断和决策指令"><a href="#2-2-3-判断和决策指令" class="headerlink" title="2.2.3 判断和决策指令"></a>2.2.3 判断和决策指令</h4><p><strong>BEQ（Branch if Equal） 指令：</strong></p><ul><li><strong>功能</strong>：比较两个寄存器的值，如果它们相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>beq rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">beq $t0, $t1, label &#x2F;&#x2F; 如果t0和t1相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>BNE（Branch if Not Equal） 指令：</strong></li></ul></li><li><strong>功能</strong>：比较两个寄存器的值，如果它们不相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>bne rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">bne $t0, $t1, label &#x2F;&#x2F; 如果t0和t1不相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>小于则置位(set less than, slt)：</strong></li></ul></li></ul><p><strong>功能</strong>：将两个寄存器中的值进行比较，如果第一个寄存器的值小于第二个寄存器的值，则将目标寄存器设为1，否则设为0。</p><ul><li><strong>格式</strong>：<code>slt rd, rs1, rs2</code><ul><li><code>rd</code>：目标寄存器</li><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">slt $t0, $t1, $t2 &#x2F;&#x2F; 如果t1 &lt; t2，则将t0设为1；否则设为0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>J指令(JUMP)</strong></p><ul><li><strong>功能</strong>：无条件跳转到指定的目标地址。这个指令改变了程序的执行流程，立即将控制转移到指定的地址。</li><li><strong>格式</strong>：<code>j offset</code><ul><li><code>offset</code>：相对当前地址的跳转偏移量</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j label &#x2F;&#x2F; 无条件跳转到label标记的位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-3-Assembly-language-and-High-level-programming-language"><a href="#2-3-Assembly-language-and-High-level-programming-language" class="headerlink" title="2.3 Assembly language and High-level programming language"></a>2.3 Assembly language and High-level programming language</h3><p>举个例子，有C++代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value3 <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t0 <span class="token operator">=</span> value1<span class="token punctuation">;</span>    <span class="token keyword">int</span> t1 <span class="token operator">=</span> value2<span class="token punctuation">;</span>    <span class="token keyword">int</span> t2 <span class="token operator">=</span> t0 <span class="token operator">+</span> t1<span class="token punctuation">;</span> <span class="token comment">// t2 = t0 + t1</span>    <span class="token keyword">int</span> t3 <span class="token operator">=</span> t1 <span class="token operator">-</span> t0<span class="token punctuation">;</span> <span class="token comment">// t3 = t1 - t0</span>    <span class="token keyword">int</span> t4 <span class="token operator">=</span> t0 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment">// t4 = t0 + 4</span>    <span class="token keyword">int</span> t5 <span class="token operator">=</span> t0 <span class="token operator">&amp;</span> t1<span class="token punctuation">;</span> <span class="token comment">// t5 = t0 AND t1</span>    <span class="token keyword">int</span> t6 <span class="token operator">=</span> t0 <span class="token operator">|</span> t1<span class="token punctuation">;</span> <span class="token comment">// t6 = t0 OR t1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t0 <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> ELSE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> main<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>ELSE<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于 nop)</span>    <span class="token keyword">goto</span> EXIT<span class="token punctuation">;</span>main<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于循环到 main)</span>EXIT<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于结束)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>其对应的汇编语言是</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.datavalue1: .word 5value2: .word 10value3: .word 15.textmain:    lw $t0, value1      # 将value1的值加载到$t0    lw $t1, value2      # 将value2的值加载到$t1    add $t2, $t0, $t1     # $t2 &#x3D; $t0 + $t1    sub $t3, $t1, $t0     # $t3 &#x3D; $t1 - $t0    addi $t4, $t0, 4     # $t4 &#x3D; $t0 + 4    and $t5, $t0, $t1     # $t5 &#x3D; $t0 AND $t1    or $t6, $t0, $t1      # $t6 &#x3D; $t0 OR $t1    beq $t0, $t1, ELSE   # 如果$t0 &#x3D;&#x3D; $t1，则跳转到ELSE    bne $t0, $t1, main   # 如果$t0 !&#x3D; $t1，则跳转到mainELSE:    j EXIT             # 无条件跳转到EXITEXIT:    nop                # 无操作（用于占位）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-4-Three-Instruction-Formats"><a href="#2-4-Three-Instruction-Formats" class="headerlink" title="2.4 Three Instruction Formats"></a>2.4 Three Instruction Formats</h3><p>在汇编语言中，主要有三种指令格式：R型指令、I型指令和J型指令。每种格式有特定的结构，用于不同类型的操作。</p><h4 id="2-4-1-R-type-Register-Instructions"><a href="#2-4-1-R-type-Register-Instructions" class="headerlink" title="2.4.1 R-type (Register) Instructions"></a>2.4.1 R-type (Register) Instructions</h4><ul><li><strong>目的</strong>：用于需要三个寄存器的算术和逻辑操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：第一个源寄存器。</li><li><code>rs2</code>：第二个源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>funct3</code> 和 <code>funct7</code>：附加功能代码，用于指定具体操作。</li></ul></li><li><strong>例子</strong>：<code>add rd, rs1, rs2</code> <ul><li>将 <code>rs1</code> 和 <code>rs2</code> 中的内容相加，并将结果存储在 <code>rd</code> 中。</li></ul></li></ul><h4 id="2-4-2-I-type-Immediate-Instructions"><a href="#2-4-2-I-type-Immediate-Instructions" class="headerlink" title="2.4.2 I-type (Immediate) Instructions"></a>2.4.2 I-type (Immediate) Instructions</h4><ul><li><strong>目的</strong>：用于带有立即数（嵌入指令中的常数）的操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>imm</code>：立即数（常数）。</li><li><code>funct3</code>：附加功能代码。</li></ul></li><li><strong>例子</strong>：<code>addi rd, rs1, imm</code><ul><li>将 <code>rs1</code> 和 <code>imm</code> 的内容相加，并将结果存储在 <code>rd</code></li></ul></li></ul><h4 id="2-4-3-J-type-Jump-Instructions"><a href="#2-4-3-J-type-Jump-Instructions" class="headerlink" title="2.4.3 J-type (Jump) Instructions"></a>2.4.3 J-type (Jump) Instructions</h4><ul><li><strong>目的</strong>：用于修改程序控制流的跳转操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>offset</code>：跳转偏移量。</li></ul></li><li><strong>例子</strong>：<code>j offset</code><ul><li>跳转到通过将 <code>offset</code> 添加到当前程序计数器（PC）计算出的地址。</li></ul></li></ul><h3 id="2-5-Five-Addressing-Modes"><a href="#2-5-Five-Addressing-Modes" class="headerlink" title="2.5 Five Addressing Modes"></a>2.5 Five Addressing Modes</h3><h4 id="2-5-1-立即寻址（Immediate-Addressing）"><a href="#2-5-1-立即寻址（Immediate-Addressing）" class="headerlink" title="2.5.1 立即寻址（Immediate Addressing）"></a>2.5.1 立即寻址（Immediate Addressing）</h4><ul><li><strong>定义</strong>：操作数直接在指令中给出。</li><li><strong>例子</strong>：<code>MOV AL, 5</code><ul><li>这里，数值 <code>5</code> 直接被移动到寄存器 <code>AL</code> 中。</li></ul></li></ul><h4 id="2-5-2-直接寻址（Direct-Addressing）"><a href="#2-5-2-直接寻址（Direct-Addressing）" class="headerlink" title="2.5.2 直接寻址（Direct Addressing）"></a>2.5.2 直接寻址（Direct Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址在指令中明确给出。</li><li><strong>例子</strong>：<code>MOV AX, [1234H]</code><ul><li>该指令将内存地址 <code>1234H</code> 的值移动到寄存器 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-3-间接寻址（Indirect-Addressing）"><a href="#2-5-3-间接寻址（Indirect-Addressing）" class="headerlink" title="2.5.3 间接寻址（Indirect Addressing）"></a>2.5.3 间接寻址（Indirect Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址存储在寄存器或内存位置中。</li><li><strong>例子</strong>：<code>MOV AX, [BX]</code><ul><li>内存位置 <code>[BX]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-4-索引寻址（Indexed-Addressing）"><a href="#2-5-4-索引寻址（Indexed-Addressing）" class="headerlink" title="2.5.4 索引寻址（Indexed Addressing）"></a>2.5.4 索引寻址（Indexed Addressing）</h4><ul><li><strong>定义</strong>：操作数的最终地址由寄存器内容与常数相加生成。</li><li><strong>例子</strong>：<code>MOV AX, [SI+20H]</code><ul><li>内存位置 <code>[SI + 20H]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-5-寄存器寻址（Register-Addressing）"><a href="#2-5-5-寄存器寻址（Register-Addressing）" class="headerlink" title="2.5.5 寄存器寻址（Register Addressing）"></a>2.5.5 寄存器寻址（Register Addressing）</h4><ul><li><strong>定义</strong>：操作数位于寄存器中，寄存器在指令中直接指定。</li><li><strong>例子</strong>：<code>MOV AX, BX</code><ul><li><code>BX</code> 中的值被移动到 <code>AX</code></li></ul></li></ul><div class="note note-primary">            <p>程序计数器PC在取指令时会自增4（每条指令是4字节），因此，下一条指令的地址是PC + 4。若当前指令需要进行跳转或分支，字地址偏移量则用于计算目标地址。具体来说，如果你有一个偏移量offset，在跳转指令中，你通常会将其左移2位（因为地址是字节为单位的），然后加到PC + 4上来获得目标地址。</p>          </div><h2 id="3-Arithmetic-Operations-in-Computers"><a href="#3-Arithmetic-Operations-in-Computers" class="headerlink" title="3. Arithmetic Operations in Computers"></a>3. Arithmetic Operations in Computers</h2><p>本章主要讲解的知识点有，计算机是如何表示整数和进行整数运算的，以及浮点数的表示规范。本章在修考的考察非常精细，一定要理清每种数的表示。下面的例子都用8bit来表示并且给出对应的表示范围。</p><h3 id="3-1-Integer-Representation"><a href="#3-1-Integer-Representation" class="headerlink" title="3.1 Integer Representation"></a>3.1 Integer Representation</h3><p>本小节介绍无符号整数、原码、反码和补码的表示方法。</p><h4 id="3-1-1-无符号整数（Unsigned-Integer）"><a href="#3-1-1-无符号整数（Unsigned-Integer）" class="headerlink" title="3.1.1 无符号整数（Unsigned Integer）"></a>3.1.1 无符号整数（Unsigned Integer）</h4><p><strong>表示方法</strong>：<br>无符号整数只表示<strong>非负数</strong>，使用所有位表示数值，不用负号。8位无符号整数的取值范围是从0到255。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$0$</li><li>最大值：$2^8 - 1 &#x3D; 255$</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的无符号表示：<code>00000101</code></li><li>十进制数255的无符号表示：<code>11111111</code></li></ul><h4 id="3-1-2-原码（Sign-Magnitude）"><a href="#3-1-2-原码（Sign-Magnitude）" class="headerlink" title="3.1.2 原码（Sign-Magnitude）"></a>3.1.2 原码（Sign-Magnitude）</h4><p><strong>表示方法</strong>：<br>原码使用最高位作为符号位（0表示正数，1表示负数），其余位表示数值的绝对值。对于8位原码，正数的最高位是0，负数的最高位是1。因此原码有$+0$和$-0$两种表示方法，分别是$00000000$,$10000000$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>1111111</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的原码表示：<code>00000101</code></li><li>十进制数-5的原码表示：<code>10000101</code></li></ul><h4 id="3-1-3-反码（One’s-Complement）"><a href="#3-1-3-反码（One’s-Complement）" class="headerlink" title="3.1.3 反码（One’s Complement）"></a>3.1.3 反码（One’s Complement）</h4><p><strong>表示方法</strong>：<br>反码对正数和负数的表示方法稍有不同。正数的反码与原码相同，负数的反码是将其绝对值的原码的每一位取反（0变1，1变0）。因此反码有也有$+0$和$-0$两种表示方法，分别是$00000000$和$11111111$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>10000000</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的反码表示：<code>00000101</code></li><li>十进制数-5的反码表示：<code>11111010</code>（原码<code>00000101</code>取反）</li></ul><h4 id="3-1-4-补码（Two’s-Complement）"><a href="#3-1-4-补码（Two’s-Complement）" class="headerlink" title="3.1.4 补码（Two’s Complement）"></a>3.1.4 补码（Two’s Complement）</h4><p><strong>表示方法</strong>：<br>补码是最常用的负数表示方法。正数的补码与原码相同，负数的补码是其绝对值的原码取反后加1。补码的意义是<em>消除原码和反码有2种零的表示方法</em>，可以用于直接计算。计算机都是用补码进行整数加减运算。因为补码只有一种$0$的表示方法，因此负数的表示范围会比整数多一个。</p><blockquote><p>补码非常爱考的一个点：$11111111$(-1), $10000000$(-128,因为超出8位范围), $00000000$(0)</p></blockquote><p><strong>表示范围</strong>：</p><ul><li>最小值：$-128$（<code>10000000</code>），🚨重中之重</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的补码表示：<code>00000101</code></li><li>十进制数-5的补码表示：<code>11111011</code>（原码<code>00000101</code>取反后加1）</li></ul><h4 id="3-1-5-表示方法总结"><a href="#3-1-5-表示方法总结" class="headerlink" title="3.1.5 表示方法总结"></a>3.1.5 表示方法总结</h4><table><thead><tr><th>表示法</th><th>最小值</th><th>最大值</th><th>示例 - 正数</th><th>示例 - 负数</th><th>0的表示个数</th></tr></thead><tbody><tr><td>无符号整数</td><td>0</td><td>255</td><td><code>00000101</code> (5)</td><td>N&#x2F;A</td><td>1</td></tr><tr><td>原码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>10000101</code> (-5)</td><td>2</td></tr><tr><td>反码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111010</code> (-5)</td><td>2</td></tr><tr><td>补码</td><td>-128</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111011</code> (-5)</td><td>1</td></tr></tbody></table><h3 id="3-2-符号位扩展与大小端编址"><a href="#3-2-符号位扩展与大小端编址" class="headerlink" title="3.2 符号位扩展与大小端编址"></a>3.2 符号位扩展与大小端编址</h3><p>这几个考点经常出现在题目的开胃前菜，是很容易忽略的一个考点，切记切记。</p><h4 id="3-2-1-符号位扩展（sign-extension）"><a href="#3-2-1-符号位扩展（sign-extension）" class="headerlink" title="3.2.1 符号位扩展（sign extension）"></a>3.2.1 符号位扩展（sign extension）</h4><p><strong>符号位扩展（sign extension）</strong> 是指在将带符号的数从较小的位数扩展到较大位数时，保持其数值的正负性。这个过程通常在处理数值的运算或数据类型转换时使用。<br>填充高位：</p><ul><li>如果符号位为0，扩展时在左边填充0。</li><li>如果符号位为1，扩展时在左边填充1。<br>假设我们要将一个8位的补码数扩展到16位：</li></ul><p><strong>8位正数</strong></p><ul><li>原数：<code>00001010</code>（十进制10）</li><li>扩展后：<code>00000000 00001010</code>（仍然是十进制10）</li></ul><p><strong>8位负数</strong></p><ul><li>原数：<code>11111010</code>（十进制-6）</li><li>扩展后：<code>11111111 11111010</code>（仍然是十进制-6）</li></ul><h4 id="3-2-2-大端编址（Big-endian）和小端编址（Little-endian）"><a href="#3-2-2-大端编址（Big-endian）和小端编址（Little-endian）" class="headerlink" title="3.2.2 大端编址（Big-endian）和小端编址（Little-endian）"></a>3.2.2 大端编址（Big-endian）和小端编址（Little-endian）</h4><p>大端编址（Big-endian）和小端编址（Little-endian）是两种不同的数据存储方式，决定了多字节数据在内存中的排列顺序。</p><p><strong>大端编址（Big-endian）</strong></p><ul><li><strong>定义</strong>：在大端模式下，数据的高位字节存储在低地址，低位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>12</code></li><li>地址 <code>0x01</code>：<code>34</code></li><li>地址 <code>0x02</code>：<code>56</code></li><li>地址 <code>0x03</code>：<code>78</code></li></ul></li></ul><p><strong>小端编址（Little-endian）</strong></p><ul><li><strong>定义</strong>：在小端模式下，数据的低位字节存储在低地址，高位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>78</code></li><li>地址 <code>0x01</code>：<code>56</code></li><li>地址 <code>0x02</code>：<code>34</code></li><li>地址 <code>0x03</code>：<code>12</code></li></ul></li></ul><p><strong>应用</strong></p><ul><li><strong>大端</strong>：常用于网络协议（如TCP&#x2F;IP），因为网络字节顺序采用大端。</li><li><strong>小端</strong>：通常用于个人电脑（如x86架构的处理器）。</li></ul><img src="/img/CA/endianness.svg" alt="大端和小端序" style="max-width: 100%; height: auto;" /><h3 id="3-3-Arithmetic-Operations-Logic"><a href="#3-3-Arithmetic-Operations-Logic" class="headerlink" title="3.3 Arithmetic Operations Logic"></a>3.3 Arithmetic Operations Logic</h3><p>参照<a href="https://toutou.zeabur.app/2024/11/04/Digital-Circuit/">数字电路笔记</a>第二章的算术运算实现</p><h3 id="3-4-IEEE754-Float-Point-Number"><a href="#3-4-IEEE754-Float-Point-Number" class="headerlink" title="3.4 IEEE754 Float Point Number"></a>3.4 IEEE754 Float Point Number</h3><p><strong>IEEE 754 单精度浮点数</strong></p><p>IEEE 754 单精度浮点数总共32位：1位符号位（S），8位指数位（E），23位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为127，即实际的指数值是存储的指数值减去127。<ul><li>例如，如果指数部分存储的是10000001（二进制的129），实际的指数就是129-127&#x3D;2。</li></ul></li><li><strong>尾数位（F）</strong>：23位，表示小数部分。注意尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 127)} \times 1.F$ </center><p><strong>IEEE 754 双精度浮点数</strong></p><p>IEEE 754 双精度浮点数总共64位：1位符号位（S），11位指数位（E），52位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为1023，即实际的指数值是存储的指数值减去1023。<ul><li>例如，如果指数部分存储的是10000000010（二进制的1026），实际的指数就是1026-1023&#x3D;3。</li></ul></li><li><strong>尾数位（F）</strong>：52位，表示小数部分。尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 1023)} \times 1.F$ </center><img src="/img/CA/float.svg" alt="浮点数表示格式" style="max-width: 100%; height: auto;" /><blockquote><p>思考：为什么需要偏阶值(Bias)的存在？</p></blockquote><p>偏阶（Bias）的存在主要是为了简化浮点数的比较和计算过程。以下是几个具体原因：</p><ol><li><p><strong>简化比较操作</strong>：<br>通过使用偏阶，所有可能的指数值都被映射到一个非负范围内，使得比较浮点数时可以简单地比较其指数部分的数值。例如，对于单精度浮点数，偏阶127确保了指数范围从 -127 到 128 被映射到 0 到 255。</p></li><li><p><strong>标准化表示</strong>：<br>使用偏阶可以确保指数部分总是一个非负数，从而使浮点数表示更为统一和标准化。这对于硬件电路设计和算法实现有很大的便利性。</p></li><li><p><strong>处理负指数</strong>：<br>偏阶允许使用非负整数来表示负指数，这对表示非常小的浮点数（接近于0）尤其有用。通过偏阶值，可以直接在指数部分进行加法和减法，而不需要额外处理负数。</p></li></ol><p>举个例子，对于单精度浮点数，偏阶是127。这意味着：</p><ul><li>实际指数为0时，存储的指数值是127。</li><li>实际指数为-1时，存储的指数值是126。</li><li>实际指数为+1时，存储的指数值是128。</li></ul><p>这种设计大大简化了计算和比较过程，让浮点运算变得高效和准确。</p><h2 id="4-Processor"><a href="#4-Processor" class="headerlink" title="4.  Processor"></a>4.  Processor</h2><p>MIPS是一种采取RISC的架构。MIPS 处理器的指令执行过程被分为<strong>五个主要阶段。</strong> 通过流水线的设计，MIPS 能够在每个时钟周期执行多个指令阶段，从而提升性能。以下是每个阶段的详细说明：</p><h3 id="4-1-指令周期分解"><a href="#4-1-指令周期分解" class="headerlink" title="4.1 指令周期分解"></a>4.1 指令周期分解</h3><ol><li><p><strong>取指令（IF，Instruction Fetch）</strong></p><ul><li>从指令存储器中读取当前指令，将其载入到指令寄存器（IR，Instruction Register）中。</li><li>将程序计数器（PC）更新为下一条指令的地址，一般为当前 PC 值加 4（因为每条指令长度固定为 4 字节）。</li><li>在这个阶段，通常也会将 PC 的值保存，以备后续的跳转或分支指令使用。</li></ul></li><li><p><strong>指令译码（ID，Instruction Decode）</strong></p><ul><li>解析指令的操作码（opcode），以确定指令类型和具体的操作。</li><li>从寄存器文件中读取操作数（源寄存器数据）。在 R 型指令中读取两个寄存器，而 I 型和 J 型指令则根据需求读取一个或不读取。</li><li>进行分支地址的计算（PC + 偏移量），以备可能的跳转或分支指令使用。</li><li>根据指令类型生成控制信号，控制信号会影响后续各个阶段的具体操作。</li></ul></li><li><p><strong>执行（EX，Execute）</strong></p><ul><li><strong>算术或逻辑操作</strong>：如果是算术或逻辑指令，ALU（算术逻辑单元）执行相应操作，例如加法、减法、与或非等。</li><li><strong>内存地址计算</strong>：若是加载或存储指令，ALU 计算内存访问的目标地址（基地址 + 偏移量）。</li><li><strong>分支判断</strong>：若是分支指令，在 ALU 进行判断后决定是否采用分支地址。</li><li>这一阶段的结果（例如运算结果或目标地址）将传递给下一阶段。</li></ul></li><li><p><strong>访存（MEM，Memory Access）</strong></p><ul><li><strong>加载指令</strong>：如果是加载指令（如 <code>lw</code>），从内存中读取数据，并将其存入一个临时寄存器。</li><li><strong>存储指令</strong>：如果是存储指令（如 <code>sw</code>），将寄存器中的数据写入指定的内存地址。</li><li>其他指令在这一阶段不做任何操作，直接进入下一个阶段。</li></ul></li><li><p><strong>写回（WB，Write Back）</strong></p><ul><li>将执行结果写回到寄存器文件中（如 <code>R</code> 型和 <code>I</code> 型指令）。</li><li>对于加载指令，将从内存读取的数据写入目标寄存器。</li><li>此阶段完成后，处理器准备进入下一条指令的执行。</li></ul></li></ol><h3 id="4-2-Pipeline-Basics"><a href="#4-2-Pipeline-Basics" class="headerlink" title="4.2 Pipeline Basics"></a>4.2 Pipeline Basics</h3><p>在指令周期的五个阶段，可以把数据通路分为5个阶段，形成流水线(pipeline)。<br><img src="/img/CA/pipeline.png" alt="流水线" style="max-width: 100%; height: auto;" /><br>根据上图，可以很直观的给出流水线相关计算公式：</p><center>$时钟周期数 = 指令数 + 流水级级数 - 1 = IC + n - 1$</center><center>$理想加速比 = 流水线级数 = n$</center><blockquote><p>注意⚠️：时钟周期取5个阶段中最慢的阶段作为时钟周期（木桶效应）</p></blockquote><h3 id="4-3-Pipeline-Hazards"><a href="#4-3-Pipeline-Hazards" class="headerlink" title="4.3 Pipeline Hazards"></a>4.3 Pipeline Hazards</h3><p><strong>流水线冒险（Pipeline Hazards）</strong> 是在指令流水线中可能导致流水线停顿或性能下降的问题。主要有三种类型的流水线冒险：数据冒险、控制冒险和结构冒险。下面是对每种冒险的详细讲解：</p><h4 id="4-3-1-数据冒险-Data-Hazard"><a href="#4-3-1-数据冒险-Data-Hazard" class="headerlink" title="4.3.1 数据冒险 (Data Hazard)"></a>4.3.1 数据冒险 (Data Hazard)</h4><p>数据冒险是由于指令之间的数据依赖性导致的。例如，一条指令需要使用前一条指令的计算结果，如果在计算结果尚未写回寄存器时就使用该结果，流水线会因为缺少数据而停顿。常见的数据冒险有以下几种类型：</p><ul><li><p><strong>RAW（Read After Write，读后写）</strong>：最常见的数据冒险类型。假设有指令 A 和指令 B，A 先于 B 执行。如果 B 读取 A 的结果而 A 还未写回寄存器，则会产生数据冒险。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A: R1 &#x3D; R2 + R3B: R4 &#x3D; R1 + R5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>指令 B 在 A 的结果写回之前读取了 R1，造成数据冒险。</p></li><li><p><strong>WAR（Write After Read，写后读）</strong>：较少见，发生在指令先读取了寄存器的值，而后续指令修改了该寄存器的值。这种冒险通常在特定的流水线架构中才会发生。</p></li><li><p><strong>WAW（Write After Write，写后写）</strong>：如果流水线支持多发射或指令乱序执行，就可能发生这种冒险。即先有一条指令写一个寄存器，后续指令也写相同寄存器，但乱序执行导致后面的指令先写完。</p></li></ul><p>解决方法：</p><ul><li>数据转发 (Data Forwarding)或旁路（bypass）：将未写回寄存器的数据直接转发给下一条指令的执行单元，从而避免等待写回寄存器的过程。</li><li>插入气泡 (Bubble)：让流水线停顿一个或多个周期，直到所需数据准备就绪。</li></ul><h4 id="4-3-2-控制冒险-Control-Hazard"><a href="#4-3-2-控制冒险-Control-Hazard" class="headerlink" title="4.3.2 控制冒险 (Control Hazard)"></a>4.3.2 控制冒险 (Control Hazard)</h4><p>控制冒险是因为分支指令或跳转指令的出现，使得流水线不能确定下一条要执行的指令，从而导致流水线停顿。分支指令可能改变程序执行的路径，而在确定跳转目标前，流水线并不知道应该继续取哪条指令。</p><p>例如，以下代码段中，当执行<code>if</code>判断时，可能会发生控制冒险：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span>    <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token function">do_something_else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在判断 <code>a &gt; b</code> 之前，流水线不知道下一步应该执行 <code>do_something</code> 还是 <code>do_something_else</code>。</p><p>解决方法：</p><ul><li>分支预测 (Branch Prediction)：利用硬件预测分支指令的执行路径。现代处理器使用动态分支预测，根据历史执行情况预测下一步操作。</li><li>延迟槽 (Delay Slot)：将分支指令后的指令提前执行，即使分支结果不确定也先执行下一条指令，从而减少停顿，但这种方法需要编译器支持。</li><li>分支目标缓冲区 (Branch Target Buffer, BTB)：缓存分支指令的目标地址，减少分支跳转的停顿时间。</li></ul><h4 id="4-3-3-结构冒险-Structural-Hazard"><a href="#4-3-3-结构冒险-Structural-Hazard" class="headerlink" title="4.3.3 结构冒险 (Structural Hazard)"></a>4.3.3 结构冒险 (Structural Hazard)</h4><p>结构冒险是由于硬件资源的竞争导致的。在指令执行过程中，如果两个或多个指令同时需要访问同一硬件资源（例如，内存、寄存器或 ALU 单元），但硬件资源不能同时支持多个访问请求，则会产生结构冒险。</p><p>例如，如果处理器的内存访问和取指令共享相同的内存端口，且一个指令在内存中读取数据的同时，另一个指令需要从内存中取指令，就会产生结构冒险。</p><p>解决方法：</p><ul><li>增加硬件资源：在流水线设计时，增加必要的硬件资源。例如，为指令存储和数据存储提供独立的内存端口，避免资源竞争。</li><li>流水线停顿：当资源不可用时，让流水线停顿一个周期，以等待资源的释放。</li></ul><div class="note note-primary">            <p>流水线在修考里面是非常非常重要的存在‼️我更希望用经典的例题讲解然后来帮助理解。</p>          </div><p>经典流水线问题：<a href="https://toutou.zeabur.app/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">九州大学2022年夏季计算机组成过去问</a></p><h2 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h2><p>本章主要讲解存储器的层次和局部性原理。这一章和操作系统的重合度非常高，建议配合操作系统复习。本章的Cache映射和TLB映射在修考题中出现的频率非常高。</p><h3 id="5-1-Memory-Hierachy"><a href="#5-1-Memory-Hierachy" class="headerlink" title="5.1 Memory Hierachy"></a>5.1 Memory Hierachy</h3><p>如标题所见，这是计算机8大设计思想之一，采用层次结构将存储器主要分为4个层次，从顶层到底层依次是：寄存器，高速缓存，主存，外存。<br><img src="/img/CA/memory.svg" alt="存储器层次" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-Register"><a href="#5-1-1-Register" class="headerlink" title="5.1.1 Register"></a>5.1.1 Register</h4><p>寄存器是 CPU 中的高速存储单元，用于暂时存储指令和数据，帮助 CPU 进行快速计算。它们是 CPU 中访问速度最快的存储器，因为它们直接位于 CPU 内核中，靠近运算单元（如算术逻辑单元，ALU）。</p><p><strong>寄存器的特点</strong></p><ul><li><strong>速度快</strong>：寄存器的访问速度比 Cache 和主存（RAM）都要快，能满足 CPU 的即时需求。</li><li><strong>容量小</strong>：寄存器数量有限，通常每个寄存器只有几个字节或几十个字节的容量。</li><li><strong>功能明确</strong>：寄存器根据用途被分为不同类型，每种寄存器在特定的指令或运算中起特定的作用。</li></ul><p><strong>常见的寄存器类型</strong></p><ol><li><strong>通用寄存器</strong>：用于临时存储数据，支持基本的加、减、乘、除等运算。</li><li><strong>程序计数器 (PC)</strong> ：保存下一条要执行指令的地址，用于控制程序执行的顺序。</li><li><strong>状态寄存器&#x2F;标志寄存器</strong>：存储运算结果的状态信息，如是否为零、是否有溢出等，用于条件判断。</li><li><strong>堆栈指针 (SP)</strong> ：指向栈顶位置，用于函数调用和返回的管理。</li><li><strong>地址寄存器</strong>：存储内存地址，用于快速访问特定的内存位置。</li></ol><p><strong>寄存器的作用</strong><br>寄存器用于 CPU 执行指令时的临时数据存储，避免频繁访问较慢的内存单元。它们直接与 CPU 核心连接，确保计算快速、高效。</p><h4 id="5-1-2-Cache"><a href="#5-1-2-Cache" class="headerlink" title="5.1.2 Cache"></a>5.1.2 Cache</h4><p><strong>Cache</strong>（缓存）是位于 CPU 和主存（RAM）之间的高速存储器，用于缓解 CPU 与主存之间的速度差异。Cache 通过暂时存储常用的数据和指令，减少 CPU 访问主存的次数，从而提高整体运算速度。Cache 通常是由 <strong>SRAM（静态随机存取存储器）</strong> 组成的；SRAM是易失性存储器，尽管 SRAM 的数据不需要周期性刷新，但一旦电源关闭，存储在其中的数据就会丢失。这是因为 SRAM 的存储原理基于晶体管的电状态，当电源断开时，这些状态会消失。<strong>DRAM</strong>则有些许不同，需要定期刷新以维持数据，刷新操作会耗费一定时间和电力，但也是易失性存储器(volatile memory)。</p><p><strong>Cache 的特点</strong></p><ul><li><strong>访问速度快</strong>：Cache 的访问速度比主存快，仅次于寄存器，能快速提供数据。</li><li><strong>层级结构</strong>：Cache 通常分为多级，包括 L1、L2 和 L3 缓存，分别位于不同的 CPU 层次上，L1 速度最快但容量最小，L3 容量最大但速度相对较慢。</li><li><strong>自动管理</strong>：Cache 由硬件自动管理，CPU 根据访问数据的频率和规律自动将数据加载到 Cache 中，无需程序员手动干预。</li></ul><p><strong>Cache 的作用</strong><br>Cache 主要用于存储 CPU 经常访问的数据或指令，以减少访问主存的延迟，提升 CPU 的执行效率。现代处理器通常会采用多级缓存结构，以平衡容量与速度之间的需求。</p><h4 id="5-1-3-Main-Memory"><a href="#5-1-3-Main-Memory" class="headerlink" title="5.1.3 Main Memory"></a>5.1.3 Main Memory</h4><p><strong>内存</strong>（Memory）一般称为主存(Main Memory)，是计算机中用于临时存储数据和程序的部件，CPU 可以快速访问其中的数据。内存的主要作用是为 CPU 提供运行时的工作区，用于存放操作系统、应用程序和当前处理的数据。</p><p><strong>内存的特点</strong></p><ul><li><strong>速度适中</strong>：内存的访问速度介于 Cache 和硬盘之间。尽管比硬盘快很多，但比不上 CPU 内部的寄存器和缓存。</li><li><strong>容量较大</strong>：内存容量一般较大，能够存储多个程序和大量数据，以满足系统的多任务需求。</li><li><strong>易失性</strong>：内存（RAM）通常由 DRAM（动态随机存取存储器）组成。DRAM 由于容量大、成本相对较低，也是一种易失性存储器，断电后数据会丢失。</li></ul><p><strong>内存的作用</strong></p><p>内存用于临时存放正在执行的程序和正在处理的数据，起到了 CPU 与硬盘之间的缓冲作用，使得系统运行更加高效。计算机在开机后，将程序从硬盘加载到内存中，CPU 再从内存中读取指令执行。</p><h4 id="5-1-4-Secondary-Memory"><a href="#5-1-4-Secondary-Memory" class="headerlink" title="5.1.4 Secondary Memory"></a>5.1.4 Secondary Memory</h4><p><strong>Secondary Memory</strong>（二级存储器）是计算机的外部存储，用于长期存储数据和程序，断电后数据不会丢失。常见的二级存储器包括硬盘驱动器 (HDD)、固态硬盘 (SSD)、光盘、以及 USB 闪存等。</p><p><strong>辅助存储器的特点</strong></p><ul><li><strong>非易失性(nonvolatile)</strong> ：辅助存储器断电后仍能保留数据，适合长期存储文件、程序和系统数据。</li><li><strong>大容量</strong>：相比于主存，辅助存储器容量更大，能够存储大量的数据和文件。</li><li><strong>较慢的访问速度</strong>：辅助存储器的读写速度比内存慢，因此用于存储不需要频繁访问的数据。</li></ul><p><strong>辅助存储器的作用</strong></p><p>辅助存储器用于存储计算机的操作系统、应用程序、用户文件和其他数据，提供数据的长期保存。计算机在启动时会将操作系统和相关程序从辅助存储器加载到内存中，以便 CPU 处理。</p><h3 id="5-2-Principle-of-Locality"><a href="#5-2-Principle-of-Locality" class="headerlink" title="5.2 Principle of Locality"></a>5.2 Principle of Locality</h3><p>局部性原理(principle of locality)是计算机组成中的一个关键概念，用来描述程序在执行过程中，访问内存地址或存储单元的一种倾向。局部性原理主要分为以下两类：</p><p><strong>时间局部性（Temporal Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么在不久的将来它很可能会再次被访问。</li><li><strong>例子</strong>：在循环中多次访问某个变量。比如循环计数器，每次迭代都会访问该变量。</li></ul><p><strong>空间局部性（Spatial Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么它附近的数据也很可能会在不久的将来被访问。</li><li><strong>例子</strong>：遍历数组时，逐个访问数组中的元素。比如访问数组<code>arr[0]</code>后，很可能访问<code>arr[1]</code>。</li></ul><blockquote><p>局部性原理在设计计算机缓存（Cache）时尤为重要。因为缓存利用局部性原理，通过临时存储经常访问的数据或地址来减少访问主内存的次数，提高整体系统性能。</p></blockquote><h3 id="5-3-Cache’s-Performance"><a href="#5-3-Cache’s-Performance" class="headerlink" title="5.3 Cache’s Performance"></a>5.3 Cache’s Performance</h3><p>Cache的主要考点围绕在命中率和缺失率的计算；在Cache映射中也有非常多的改进策略。</p><h4 id="5-3-1-Cache-Hit-Miss"><a href="#5-3-1-Cache-Hit-Miss" class="headerlink" title="5.3.1 Cache Hit &amp; Miss"></a>5.3.1 Cache Hit &amp; Miss</h4><p><strong>Cache命中（Cache Hit）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据在缓存中找到时，就称为Cache命中。命中率（Hit Rate）是命中次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它已经在缓存中，直接读取数据，避免了访问慢速的主内存，从而提高了整体性能。</li></ul><p><strong>Cache缺失（Cache Miss）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据不在缓存中，必须从主内存中读取时，就称为Cache缺失。缺失率（Miss Rate）是缺失次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它不在缓存中，处理器需要从主内存中读取该数据块，并将其放入缓存中。这个过程比直接从缓存读取要慢得多。</li></ul><p>命中率(Hit Rate)和缺失率(Miss Rate)的计算方法非常直观，分别是命中&#x2F;缺失的次数占访存次数的比例。</p><h4 id="5-3-2-命中时间、缺失代价和访存阻塞周期"><a href="#5-3-2-命中时间、缺失代价和访存阻塞周期" class="headerlink" title="5.3.2 命中时间、缺失代价和访存阻塞周期"></a>5.3.2 命中时间、缺失代价和访存阻塞周期</h4><p><strong>命中时间（Hit Time）</strong></p><ul><li><strong>定义</strong>：命中时间是指CPU在缓存中找到数据所需的时间，包括地址翻译、缓存访问和数据返回给处理器的时间。通常只有1个时钟周期长度。</li><li><strong>计算</strong>：命中时间通常由缓存访问的硬件特性决定，具体时间取决于缓存的层级和设计。</li></ul><p><strong>缺失代价（Miss Penalty）</strong></p><ul><li><strong>定义</strong>：缺失代价是指当数据不在缓存中，需要从较低层级的缓存或主存中加载数据所需的时间。</li><li><strong>计算</strong>：缺失代价 &#x3D; 低层级缓存或主存的访问时间 + 将数据传送到缓存中的时间。</li></ul><p><strong>访存阻塞周期（Memory Stall Cycles）</strong></p><ul><li><strong>定义</strong>：访存阻塞周期是指由于缓存缺失导致处理器需要等待数据加载而停顿的周期数。</li><li><strong>计算</strong>：访存阻塞周期 &#x3D; 缺失率 × 缺失代价</li></ul><p>假设：</p><ul><li>命中时间为1个周期。</li><li>缺失代价为50个周期。</li><li>缺失率为5%。</li></ul><p>那么：访存阻塞周期 &#x3D; 5% × 50个周期 &#x3D; 2.5个周期。</p><p>普适性的衡量会给上一个缺失率(Miss Rate), 那么</p><center>$访存阻塞周期 = 访存次数 \times 缺失率 \times 缺失代价$</center><h3 id="5-4-Cache的三种映射方式"><a href="#5-4-Cache的三种映射方式" class="headerlink" title="5.4 Cache的三种映射方式"></a>5.4 Cache的三种映射方式</h3><p><strong>1. 直接映射（Direct Mapped Cache）</strong></p><ul><li><strong>定义</strong>：每个内存块都映射到缓存的一个特定位置。缓存中的每个位置可以存储多个内存块，但在任意时间只能存储一个。</li><li><strong>优点</strong>：实现简单且成本低。</li><li><strong>缺点</strong>：冲突较多，即不同内存块可能会映射到同一个缓存位置，导致频繁替换。</li></ul><p><strong>2. 全关联映射（Fully Associative Cache）</strong></p><ul><li><strong>定义</strong>：内存块可以映射到缓存的任何位置。缓存中的每个位置都可以存储任何内存块。</li><li><strong>优点</strong>：减少了冲突，因为任何内存块都可以放到任何缓存位置。</li><li><strong>缺点</strong>：实现复杂且成本高，需要比较所有缓存位置以找到匹配的块。</li></ul><p><strong>3. 组关联映射（Set Associative Cache）</strong></p><ul><li><strong>定义</strong>：缓存分成多个组，每个组包含若干个位置。内存块首先映射到某个组，然后可以存储在该组的任意位置。</li><li><strong>优点</strong>：在复杂度和性能之间取得平衡，减少了直接映射中的冲突，同时实现比全关联映射更简单。</li><li><strong>缺点</strong>：组的选择可能会导致一些复杂度，但总的来说，比全关联映射低。<img src="/img/CA/cache_map.svg" alt="Cache三种映射方式" style="max-width: 100%; height: auto;" /></li></ul><h4 id="5-4-1-直接映射"><a href="#5-4-1-直接映射" class="headerlink" title="5.4.1 直接映射"></a>5.4.1 直接映射</h4><p>映射规则：Cache块号 &#x3D; 内存块号 % Cache块数</p><blockquote><p>比如，Cache共有8块，内存的十号块映射在Cache的块号是：10 % 8 &#x3D; 2</p></blockquote><p>直接映射缓存（Direct Mapped Cache）内存地址通常被分成三个字段：块内字节偏移、索引位和标记位。</p><p><strong>1. 块内字节偏移（Block Offset）</strong></p><ul><li><strong>定义</strong>：块内字节偏移用于定位一个块中的具体字节。</li><li><strong>计算</strong>：偏移位的数量取决于块的大小。例如，如果块大小为4个字节，则需要2位来表示块内字节偏移。<ul><li>例子：对于一个块大小为4个字节的缓存，偏移位可能是<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>。</li></ul></li></ul><p><strong>2. 索引位（Index Bits）</strong></p><ul><li><strong>定义</strong>：索引位用于定位缓存中的具体行（块）。</li><li><strong>计算</strong>：索引位的数量取决于缓存的行数。例如，如果缓存有8行，需要3位索引位来标识具体的行。<ul><li>例子：对于一个有8行的缓存，索引位可能是<code>000</code>到<code>111</code>。</li></ul></li></ul><p><strong>3. 标记位（Tag Bits）</strong></p><ul><li><strong>定义</strong>：标记位用于区分不同内存块，它们映射到同一个缓存行。</li><li><strong>计算</strong>：标记位的数量 &#x3D; 内存地址总位数 - 索引位数量 - 块内字节偏移位数量。<ul><li>例子：假设内存地址总位数为16位，块大小为4字节（2位块内偏移），缓存有8行（3位索引），那么标记位数量为11（16-3-2&#x3D;11）。</li></ul></li></ul><blockquote><p><strong>示例</strong> ：假设有一个16位的内存地址，缓存有8行，每行块大小为4字节。</p></blockquote><p>内存地址：<code>1010110010101110</code></p><ul><li><strong>块内字节偏移</strong>：2位（最右边的2位），<code>10</code> 表示块内的某个字节。</li><li><strong>索引位</strong>：3位（次右边的3位），<code>110</code> 表示缓存的具体行。</li><li><strong>标记位</strong>：11位（剩余左边的位），<code>10101100101</code> 用于区分不同的内存块。</li></ul><p><strong>内存地址分解</strong>：</p><ul><li>标记位（Tag）：<code>10101100101</code></li><li>索引位（Index）：<code>110</code></li><li>块内字节偏移（Block Offset）：<code>10</code></li></ul><center>$Cache容量 = （标记位 + 数据位）\times 行数 $</center>补充：如果题目强调了有效位的存在，那么Cache的每一行需要多1bit的有效位，则<center>$Cache容量 = （1 + 标记位 + 数据位）\times 行数 $</center><p>有效位是缓存系统中的一个重要概念，用于指示缓存块中的数据是否有效。具体来说，有效位帮助确定当前缓存块是否包含可以被处理器使用的有效数据。</p><ol><li><strong>指示数据有效性</strong>：有效位为1表示缓存块中的数据有效且可用；为0表示缓存块中的数据无效，可能未被使用或需要更新。</li><li><strong>管理缓存块</strong>：当一个新的内存块被加载到缓存时，会设置有效位为1。当缓存块的数据被替换或失效时，有效位被设置为0。</li></ol><p><strong>实现原理</strong></p><ul><li><strong>检查有效位</strong>：每次缓存访问时，首先检查有效位。如果有效位为0，即使缓存地址匹配，数据也不被使用，因为它无效。</li><li><strong>缓存替换</strong>：在缓存替换时，新的数据块写入缓存，并将对应的有效位设置为1。被替换的数据块的有效位通常被设置为0，表示数据无效。</li></ul><p><strong>示例</strong><br>假设一个缓存系统有4个块，每个块都有一个有效位：</p><ul><li>块0：有效位&#x3D;1（数据有效）</li><li>块1：有效位&#x3D;0（数据无效）</li><li>块2：有效位&#x3D;1（数据有效）</li><li>块3：有效位&#x3D;0（数据无效）</li></ul><p>当处理器访问一个地址时，它首先检查缓存块的有效位。如果有效位为1，它会进一步检查地址是否匹配；如果有效位为0，则直接从主存获取数据。</p><h4 id="5-4-2-直接映射缺失的3C模型"><a href="#5-4-2-直接映射缺失的3C模型" class="headerlink" title="5.4.2 直接映射缺失的3C模型"></a>5.4.2 直接映射缺失的3C模型</h4><p><strong>1. 冷缺失（Cold Miss）</strong></p><ul><li><strong>定义</strong>：也称为强制缺失或首次缺失。这种情况发生在缓存首次加载数据块时，因为缓存中还没有存储该数据块。</li><li><strong>示例</strong>：程序第一次访问一个数据块时，缓存中还没有该数据块，导致冷缺失。</li></ul><p><strong>2. 容量缺失（Capacity Miss）</strong></p><ul><li><strong>定义</strong>：由于缓存容量有限，即使缓存中所有块都被充分利用，仍然无法容纳所有需要的数据块，从而导致缺失。</li><li><strong>示例</strong>：程序需要访问的数据块数量超过了缓存容量，导致一些较早访问的数据块被驱逐，再次访问时需要重新加载。</li></ul><p><strong>3. 冲突缺失（Conflict Miss）</strong></p><ul><li><strong>定义</strong>：也称为干扰缺失。这种情况发生在直接映射缓存中，不同的数据块映射到同一个缓存块位置，导致频繁替换，即使缓存容量足够也会出现缺失。</li><li><strong>示例</strong>：两个或多个数据块映射到同一个缓存位置，导致数据块被替换，从而产生冲突缺失。</li></ul><img src="/img/CA/map_miss.svg" alt="3C模型" style="max-width: 100%; height: auto;" />  <p>直接映射在应对上面的Cache缺失的时候有三种处理方式：</p><p><strong>1.写直达（Write Through）：</strong></p><ul><li>CPU同时向Cache和主存写入数据</li><li>实现简单，但写入速度慢</li><li>保持了Cache和主存的一致性</li></ul><p><strong>写缓冲（Write Buffer）：</strong></p><ul><li>CPU先写入Cache</li><li>数据暂存在写缓冲区</li><li>后台异步写入主存</li><li>提高了写入效率</li></ul><p><strong>写回（Write Back）：</strong></p><ul><li>CPU只写入Cache</li><li>使用脏位(Dirty Bit)标记修改</li><li>仅在数据被替换时才写回主存</li><li>最高效但实现复杂</li></ul><img src="/img/CA/map_strategy.svg" alt="Cache缺失策略" style="max-width: 100%; height: auto;" /><h4 id="5-4-3-多级缓存机制"><a href="#5-4-3-多级缓存机制" class="headerlink" title="5.4.3 多级缓存机制"></a>5.4.3 多级缓存机制</h4><p>多级缓存（Multilevel Cache）是一种在计算机系统中提高处理器访问数据速度的技术，通常将缓存分为多个层次，如 L1、L2 和 L3 缓存。这些缓存层次的设置能够平衡存取速度、容量和成本，确保 CPU 能更快地获取需要的数据。</p><p><strong>多级缓存的主要特点</strong></p><ol><li><p><strong>L1缓存</strong>（一级缓存）：通常集成在 CPU 内核中，速度最快，容量较小（一般为几十KB）。L1缓存分为指令缓存（I-Cache）和数据缓存（D-Cache），分别用于存储指令和数据，帮助 CPU 快速访问常用数据。</p></li><li><p><strong>L2缓存</strong>（二级缓存）：相比 L1 缓存稍慢，但容量更大（几百KB到几MB），通常也集成在处理器中。L2 缓存为 L1 提供数据支援，命中率高，进一步减少了 CPU 对主存（RAM）的访问需求。</p></li><li><p><strong>L3缓存</strong>（三级缓存）：用于共享多个 CPU 内核的数据，容量较大（几MB到几十MB），但访问速度比 L2 缓慢。L3缓存作为所有内核的公共缓存，提升了多核处理器的并行性能。</p></li><li><p><strong>工作原理</strong>：CPU 会首先查找 L1 缓存，如果未命中则依次查找 L2 和 L3 缓存，直到最后访问主存。这样的分级缓存结构可以减少主存访问次数，从而提高系统性能。</p></li><li><p><strong>优点</strong>：多级缓存结构能显著降低数据访问延迟，提高处理器的执行效率；而且它能有效利用缓存的层级特性，合理分配存取速度和容量。</p></li></ol><p><strong>多级缓存背景下的平均 CPI 计算</strong></p><p>在多级缓存系统中，平均每条指令的周期数（CPI，Cycles Per Instruction）可以通过考虑每一级缓存的缺失率和缺失代价来计算。这里的缺失率指的是每一级缓存未命中（缺失）的概率，缺失代价则是缓存未命中时所需要的额外处理周期数。平均 CPI 的计算可以按以下步骤进行。</p><p>假设：</p><ul><li>$\text{CPI}_{\text{ideal}}$ 是理想情况下（没有缓存缺失）的 CPI，即不考虑缓存缺失时每条指令的周期数。</li><li>L1、L2、L3 分别是一级、二级和三级缓存。</li><li>$\text{MR}_n$ 表示第 $n$ 级缓存的缺失率（Miss Rate）。</li><li>$\text{MC}_n$ 表示第 $n$ 级缓存的缺失代价（Miss Penalty），即在第 $n$ 级缓存缺失时需要的额外周期数。</li></ul><p>平均 CPI 的计算可以分为以下步骤：</p><ol><li><p><strong>L1 缓存的贡献</strong>：L1 缓存缺失的情况下，需要访问 L2 缓存，因此 L1 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L1}} = \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}}$ </center></li><li><p><strong>L2 缓存的贡献</strong>：L1 缓存缺失时会访问 L2 缓存，如果 L2 缓存也缺失，则需要访问 L3 缓存。L2 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L2}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$ </center></li><li><p><strong>L3 缓存的贡献</strong>：当 L1 和 L2 都缺失时，才会访问 L3 缓存。如果 L3 缓存也缺失，就会访问主存，因此 L3 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L3}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}}$ </center></li><li><p><strong>主存的贡献</strong>：当 L1、L2 和 L3 缓存都缺失时，才会访问主存。因此主存的平均贡献为：</p><center> $\text{CPI}_{\text{memory}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$ </center></li></ol><p>把各级缓存和主存的贡献相加，再加上理想情况下的 CPI，得到总的平均 CPI：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{CPI}_{\text{L1}} + \text{CPI}_{\text{L2}} + \text{CPI}_{\text{L3}} + \text{CPI}_{\text{memory}}$ </center><p>展开后，即：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$$+ \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$</center><blockquote><ul><li>每一级缓存的贡献都是基于它前一级缓存的缺失率和自身的缺失代价递归计算的。</li><li>这个公式综合了各级缓存的缺失率和缺失代价，提供了一个较为准确的平均 CPI 估计。</li></ul></blockquote><h3 id="5-5-Virtual-Memory"><a href="#5-5-Virtual-Memory" class="headerlink" title="5.5 Virtual Memory"></a>5.5 Virtual Memory</h3><p>虚拟存储器通过地址映射机制，将操作系统使用的虚拟地址转换为不同的物理地址。这个过程涉及多层缓存和映射关系，例如：</p><ul><li>Cache 将处理器寄存器访问的地址映射到内存中的物理地址，以加速数据读取。</li><li>主存（内存）充当磁盘的缓存，从磁盘读取数据时，常用的数据会保存在内存中以加快访问速度。</li><li>TLB（快表）是页表的缓存，用于快速查找虚拟地址到物理地址的映射，减少页表查找的开销。</li></ul><p>将虚拟地址转换为物理地址的过程通常涉及几个关键步骤：</p><ol><li><p>地址生成：当程序访问某个内存位置时，它会生成一个虚拟地址。</p></li><li><p>页号和偏移量：虚拟地址被分为两个部分：页号和偏移量。页号用于识别该地址所属的页，而偏移量则指定了在该页内的具体位置。</p></li><li><p>快速表 (Translation Lookaside Buffer, TLB)：在检查页表之前，系统首先检查快速表 (TLB)，这是一个小而快速的缓存，存储最近的虚拟到物理地址的转换。如果在 TLB 中找到转换（TLB 命中），则可以快速检索物理地址。</p></li><li><p>页表查找：如果在 TLB 中未找到转换（TLB 未命中），系统将访问页表。页表包含条目，将每个虚拟页号映射到内存中相应的物理页框号。</p></li><li><p>物理地址形成：一旦访问了页表，就可以获得物理页框号。然后，物理地址通过将该页框号与原虚拟地址中的偏移量结合来形成。</p></li><li><p>访问内存：系统现在使用物理地址访问 RAM 中的数据。</p></li><li><p>页面缺失处理：如果所需的页面不在内存中（页面缺失），操作系统将从磁盘存储中检索该页面，并相应地更新页表。</p></li></ol><img src="/img/CA/address.svg" alt="Address Translation" style="max-width: 100%; height: auto;" /><p>关于虚拟地址和物理地址还有更多的考点内容，比如各种替换策略和写策略，这里的内容我更愿意放到操作系统的对应章节来讲解😈马不停蹄更新中🐎</p><div class="note note-primary">            <p>完结撒花🎉<br>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語語彙まとめ</title>
    <link href="/2024/09/28/JPN-Words/"/>
    <url>/2024/09/28/JPN-Words/</url>
    
    <content type="html"><![CDATA[<h1 id="日语单词自测"><a href="#日语单词自测" class="headerlink" title="日语单词自测"></a>日语单词自测</h1><p><em>配合moji插件查看中文释义👀</em></p><h2 id="1-動詞"><a href="#1-動詞" class="headerlink" title="1. 動詞"></a>1. 動詞</h2><p>欺く「あざむく」、覗く「のぞく」、湧く「わく」、逃れる「のがれる」、挑む「いどむ」、固める「かためる」、奪う「うばう」、紛れ込む「まぎれ込む」、仕掛ける「しかける」、強引「ごういん」、溢れる「あふれる」、謙る「へりくだる」、絡み合う「からみあう」、仰ぐ「あおぐ」、耽る「ふける」、眩む「くらむ」、紡ぐ「つむぐ」、辿り着く「たどりつく」、戒める「いましめる」、親しむ「したしむ」、身構える「みがまえる」、草臥れる「くたびれる」、勤める「つとめる」、睨む「にらむ」、濁る「にごる」、融合「ゆうごう」、襲う「おそう」、押し込む「おしこむ」、焚く「たく」、惑う「まどう」、傾ける「かたむける」、金縛り「かなしばり」、軋む「きしむ」、免れる「まぬかれる」、与かる「あずかる」、炙る「あぶる」、嘆く「なげく」、誂える「あつらえる」、埋める「うずめる」、頷く「うなずく」、貫く「つらぬく」、授ける「さずける」、値する「あたいする」、省みる「かえりみる」、打ち明ける「うちあける」、押し寄せる「おしよせる」、呆れる「あきれる」、綴る「つずる」、攫う「さらう」、専ら「もっぱら」、呟く「つぶやく」、呼び掛ける「よびかける」、見なす「みなす」、戸惑う「とまどう」、透き通る「すきとおる」、怒鳴る「どなる」、齎す「もたらす」、富む「とむ」、拗ねる「すねる」、威張る「いばる」、凌ぐ「しのぐ」、弁償「べんしょう」、安らぐ「やすらぐ」、見合わせる「みあわせる」、気軽「きがる」、見込む「みこむ」、奉る「たてまつる」、緩める「ゆるめる」、磨く「みがく」、充ちる「みちる」、跨る「またがる」、覆う「おおう」、吹き出す「ふきだす」、交じる「まじる」、紡ぐ「つむぐ」、慰める「なぐさめる」、実る「みのる」、叱る「しかる」、馳せる「はせる」、愚か「おろか」、疑う「うたがう」、探る「さぐる」、痺れる「しびれる」、食い違う「くいちがう」、窺う「うかがう」、揃う「そろう」、報いる「むくいる」、撒く「まく」、拘る「こだわる」、気に障る「きにさわる」、押し切る「おしきる」、立ち寄る「たちよる」、蹴る「ける」、除去「じょきょ」、囁く「ささやく」、志す「こころざす」、伏せる「ふせる」、巫山戯る「ふざける」、奢る「おごる」、褪せる「あせる」、記す「しるす」、絶る「たえる」、背く「そむく」、取り払う「とりはらう」、俯く「うつむく」、照れる「てれる」、掲げる「かかげる」、仕上げる「しあげる」、映える「はえる」、乱れる「みだれる」、惜しむ「おしむ」、呼び寄せる「よびよせる」、衰える「おとろえる」、慣らす「ならす」、治る「なおる」、遂げる「とげる」、費やす「ついやす」、励ます「はげます」、滞る「とどこおる」、隔てる「へだてる」、謝る「あやまる」、昇進「しょうしん」、睨む「にらむ」、急かす「せかす」、帯びる「おびる」、冷やす「ひやす」、潤す「うるおす」、狼狽える「うろたえる」、濡らす「ぬらす」、庇う「かばう」、抱え込む「かかえこむ」、秘める「ひめる」、割り当てる「わりあてる」、思い詰める「おもいつめる」、練る「ねる」、持て成す「もてなす」、賄う「まかなう」、跳ねる「はねる」、募る「つのる」、絡める「からめる」、転がる「ころがる」、労わる「いたわる」、復旧「ふっきゅう」、薄まる「うすまる」、遠ざける「とおざける」、お詫び「おわび」、躊躇う「ためらう」、潰れる「つぶれる」、断る「ことわる」、舞う「まう」、絡む「からむ」、切り出す「きりだす」、排卵「はいらん」、収まる「おさまる」、治する「じする」、狭める「せばめる」、覆す「くつがえす」、滅びる「ほろびる」、翻す「ひるがえす」、立て替える「たてかえる」、弾く「はじく」、養う「やしなう」、鈍る「にぶる」、唱える「となえる」、蓄える「たくわえる」、損なう「そこなう」、培う「つちかう」、見失う「みうしなう」、避ける「よける」、讃る「たたえる」、掘る「ほる」、怠る「おこたる」、敬う「うやまう」、臨む「のぞむ」、目論む「もくろむ」、偽る「いつわる」、了承「りょうしょう」、賑わう「にぎわう」、遮る「さえぎる」、取り消す「とりけす」、愛着「あいちゃく」、駆使「くし」、儲かる「もうかる」、縮まる「ちぢまる」、怯える「おびえる」、逸らす「そらす」、癒す「いやす」、差し引く「さしひく」、項垂れる「うなだれる」、拒む「こばむ」、担う「になう」、催す「もよおす」、引き返す「ひきかえす」、解ける「ほどける」、妨げる「さまたげる」、築く「きずく」、弾む「はずむ」、商う「あきなう」、食い止める「くいとめる」、訴える「うったえる」、辿る「たどる」、打ち切る「うちきる」、潤う「うるおう」、究明「きゅうめい」、立ち直る「たちなおる」、倒す「たおす」、削る「けずる」、言い張る「いいはる」、劣る「おとる」、偏る「かたよる」、阻む「はばむ」、遡る「さかのぼる」、冷え込む「ひえこむ」、取り払う「とりはらう」、収拾「しゅうしゅう」、出揃う「でそろう」、洗う「あらう」、仕込む「しこむ」、囃す「はやす」、見惚れる「みとれる」、馴染む「なじむ」、見落とす「みおとす」、仕入れる「しいれる」、扱う「あつかう」、搾る「しぼる」、見通す「みとおす」、費やす「ついやす」、座が白ける「ざがしらける」、讃える「たたえる」、持て余す「もてあます」、補う「おぎなう」、煉る「ねる」、清澄「せいちょう」、訪れる「おとずれる」、眺める「ながめる」、見積もる「みつもる」</p><h2 id="2-名詞"><a href="#2-名詞" class="headerlink" title="2. 名詞"></a>2. 名詞</h2><p>物語「ものがたり」、非難「ひなん」、靄「もや」、競技「きょうぎ」、過労「かろう」、振る舞い「ふるまい」、倹約「けんやく」、氏神「うじがみ」、大木「たいぼく」、復興「ふっこう」、亭主関白「ていしゅかんぱく」、畑「はたけ」、役割「やくわり」、脇「わき」、残酷「ざんこく」、稼業「かぎょう」、木立「きだち」、愛想「あいそ」、苦情「くじょう」、良し悪し「よしあし」、苛め「いじめ」、腰「こし」、当選「とうせん」、目論見「もくろみ」、冒頭「ぼうとう」、羽目「はめ」、下駄「げた」、屋敷「やしき」、一昨年「おととし」、照明「しょうめい」、虚ろ「うつろ」、合否「ごうひ」、私邸「してい」、扱い「あつかい」、神秘「しんぴ」、琴「こと」、里「さと」、猥褻「わいせつ」、暮れ「くれ」、醍醐味「だいごみ」、蓄積「ちくせき」、臥床「がしょう」、山懐「やまふところ」、生涯「しょうがい」、跡地「あとち」、味方「みかた」、取材「しゅざい」、発祥地「はっしょうち」、出入り「でいり」、達者「たっしゃ」、原動力「げんどうりょく」、拘束「こうそく」、融通「ゆうずう」、手際「てぎわ」、立食「りっしょく」、善悪「ぜんあく」、境地「きょうち」、人並み「人なみ」、裸足「はだし」、身内「みうち」、無礼「ぶれい」、懇談「こんだん」、試し「ためし」、公平「こうへい」、魅了「みりょう」、霧「きり」、合間「あいま」、顎「あご」、野生「やせい」、険悪「けんあく」、垢「あか」、庵「いおり」、吟味「ぎんみ」、修復「しゅうふく」、迫真「はくしん」、証「あかし」、話題「わだい」、転がし「ころがし」、干物「ひもの」、過誤「かご」、有頂天「うちょうてん」、懲戒「ちょうかい」、規制「きせい」、文献「ぶんけん」、猿「さる」、霞「かすみ」、叡智「えいち」、神話「しんわ」、賃金「ちんぎん」、密輸入「みつゆにゅう」、賭ける「かける」、育ち「そだち」、割れ目「われめ」、大人「おとな」、ありのまま、細菌「さいきん」、応募「おうぼ」、煮物「にもの」、潮流「ちょうりゅう」、焦る「あせる」、取り上げる「とりあげる」、昨年「さくねん」、贅沢「ぜいたく」、真骨頂「しんこっちょう」、争い「あらそい」、女房「にょうぼう」、足場「あしば」、要請「ようせい」、無難「ぶなん」、水着「みずぎ」、車窓「しゃそう」、合致「がっち」、外見「がいけん」、獣「けもの」、代物「しろもの」、田舎者「いなかもの」、趣「おもむき」、束縛「そくばく」、いらいら、緩和「かんわ」、芽「め」、幾分「いくぶん」、最善「さいぜん」、軽蔑「けいべつ」、日取り「ひどり」、無事「ぶじ」、糧「かて」、厄介「やっかい」、手渡し「てわたし」、一見「いっけん」、マスコミ、気の毒「きのどく」、埋立地「うめたてち」、窮屈「きゅうくつ」、勢い良く「いきおいよく」、触れ合い「ふれあい」、青二才「あおにさい」、怪我「けが」、辺鄙「へんぴ」、発端「ほったん」、跋扈「ばっこ」、ゆとり、最期「さいご」、作風「さくふう」、証拠「しょうこ」、生垣「いけがき」、用心棒「ようじんぼう」、安らぐ「やすらぐ」、折節「おりふし」、言及「げんきゅう」、風見鶏「かざみどり」、居眠り「いぬむり」、崖「がけ」、臆病「おくびょう」、一斉「いっせい」、断言「だんげん」、稲光「いなびかり」、勘定「かんじょう」、気前「きまえ」、気立「きだて」、箇条書き「かじょうがき」、編集「へんしゅう」、皆無「かいむ」、当たり「あたり」、漬物「つけもの」、拍手「はくしゅ」、節約「せつやく」、妄想「もうそう」、割合「わりあい」、壁際「かべぎわ」、出鱈目「でたらめ」、納期「のうき」、重体「じゅうたい」、理不尽「りふじん」、弁解「べんかい」、心構え「こころがまえ」、気配「きはい」、変遷「へんせん」、敏捷「びんしょう」、発足「はっそく」、加味「かみ」、内訳「うちわけ」、無造作「むぞうさ」、伴奏「ばんそう」、本筋「ほんすじ」、拠点「きょてん」、需要「じゅよう」、重複「ちょうふく」、積立金「つみたてきん」、軌道「きどう」、群衆「ぐんしゅう」、巧妙「こうみょう」、大筋「おおすじ」、主催「しゅさい」、督促「とくそく」、印「しるし」、配布「はいふ」、枠「わく」、決意「けつい」、質素「しっそ」、憤り「いきどおり」、統合「とうごう」、意気込み「いきごみ」、粘り「ねばり」、中枢「ちゅうすう」、厳正「げんせい」、優勝「ゆうしょう」、陳列「ちんれつ」、樹木「じゅもく」、照合「しょうごう」、証「あかし」、繁盛「はんじょう」、網羅「もうら」、念頭「ねんとう」、安堵「あんど」、由緒「ゆいしょ」、添付「てんぷ」、巡り「めぐり」、憩い「いこい」、廃れる「すたれる」、緊密「きんみつ」、強制「きょうせい」、役名「やくめい」、利子「りし」、難点「なんてん」、満喫「まんきつ」、合意「ごうい」、格段「かくだん」、把握「はあく」、競り合い「せりあい」、煩雑「はんざつ」、利潤「りじゅん」、趣旨「しゅし」、仰天「ぎょうてん」、裏腹「うらはら」、閲覧「えつらん」、兆し「きざし」、該当「がいとう」、先方「せんぽう」、目先「めさき」、改革「かいかく」、打診「だしん」、破損「はそん」、素ぶり「そぶり」、多岐「たき」、手間「てま」、緩和「かんわ」、貧富「ひんぷ」、合併「がっぺい」、概略「がいりゃく」、予断「よだん」、真っ先「まっさき」、人手「ひとで」、抜粋「ばっすい」、嫌味「いやみ」、朦朧「もうろう」、携わる「たずさわる」、食い違い「くいちがい」、怒り「いかり」、提起「ていき」、重宝「ちょうほう」、入念「にゅうねん」、工面「くめん」、推理「すいり」、淵「ふち」、遂行「すいこう」、鑑定「かんてい」、仕組み「しくみ」、口出し「くちだし」、腕前「うでまえ」、ゆとり、抱負「ほうふ」、人脈「じんみゃく」、手分け「てわけ」、逸材「いつざい」、踏襲「とうしゅう」、仕業「しわざ」、雑踏「ざっとう」、契約「けいやく」、相場「そうば」、異色「いしょく」、言い訳「いいわけ」、凝縮「ぎょうしゅく」、逸れる「それる」、収支「しゅうし」、有数「ゆうすう」、興奮「こうふん」、指図「さしず」、日夜「にちや」、逸脱「いつだつ」、処置「しょち」、概ね「おおむね」、拍子「ひょうし」、探り「さぐり」、可決「かけつ」、合致「がっち」、何れ「いずれ」、考慮「こうりょ」、経歴「けいれき」、傾斜「けいしゃ」、圧迫「あっぱく」、張り合う「はりあう」、利息「りそく」、起伏「きふく」、根拠「こんきょ」、ノルマ、手がかり「てがかり」、ウエイト、皮肉「ひにく」、固執「こしゅう」、お手上げ「おてあげ」、辞任「じにん」、躍進「やくしん」、裏付け「うらずけ」、帰結「きけつ」、名誉「めいよ」、互角「ごかく」、合弁「ごうべん」、釈明「しゃくめい」、溝「みぞ」、宿命「しゅくめい」、区々「まちまち」、暴露「ばくろ」、開拓「かいたく」、日差し「ひざし」、慣習「かんしゅう」、殺菌「さっきん」、落胆「らくたん」、会心「かいしん」、寄与「きよ」、承諾「しょうだく」、拠り所「よりどころ」、忍耐「にんたい」、大義「だいぎ」、贖罪「しょくざい」、倦怠「けんたい」、戒律「かいりつ」、途方「とほう」、土台「どだい」、分離「ぶんり」、卑怯「ひきょう」、下着「したぎ」、由緒「ゆいしょ」、珍重「ちんちょう」、奉公「ほうこう」、挙式「きょしき」、戦争「せんそう」、基「もとい」、乱発「らんぱつ」、零落「れいらく」、上映「じょうえい」、カオス、座敷「ざしき」、領域「りょういき」、碌「ろく」、内向「ないこう」、一命「いちめい」、贔屓「ひいき」、処分「しょぶん」、潤沢「じゅんたく」、流行「りゅうこう」、息吹「いぶき」、獲物「えもの」、妙「みょう」、幕府「ばくふ」、重荷「おもに」、道連れ「みちずれ」、高潔「こうけつ」、厳正「げんせい」、薬酒「やくしゅ」、気晴らし「きばらし」、報知「ほうち」、悪ふざけ「わるふざけ」、恍惚「こうこつ」、妥協「だきょう」、不思議「ふしぎ」、節目「ふしめ」、ニュアンス、</p><h2 id="3-形容詞"><a href="#3-形容詞" class="headerlink" title="3. 形容詞"></a>3. 形容詞</h2><p>鋭い「するどい」、甚だしい「はなはだしい」、朗らか「ほがらか」、等しい「ひとしい」、素っ気無い「そっけない」、雄大「ゆうだい」、騒がしい「さわがしい」、ぶかぶか「ぶかぶか」、逞しい「たくましい」、所謂「いわゆる」、緩やか「ゆるやか」、惨め「みじめ」、煌々「こうこう」、滑らか「なめらか」、無茶苦茶「むちゃくちゃ」、微か「かすか」、きまぐれ「きまぐれ」、目覚ましい「めざましい」、物足りない「ものたりない」、つれない、申し分ない「もうしぶんない」、べたべた、忌まわしい「いまわしい」、煩わしい「わずらわしい」、頼もしい「たのもしい」、気障「きざ」、切ない「せつない」、密接「みっせつ」、冥冥「めいめい」、見苦しい「みぐるしい」、あっかない、飛び飛び「とびとび」、達観「たっかん」、うざい、閑静「かんせい」、台無し「だいなし」、望ましい「のぞましい」、細やか「ささやか」、淑やか「しとやか」、真面「まとも」、煌々「こうこう」、淡々「たんたん」、厳密「げんみつ」、出しゃばり「でしゃばり」、刺々しい「とげとげしい」、厳か「おごそか」、乏しい「とぼしい」、疎ら「まばら」、慌ただしい「あわただしい」、待ち遠しい「まちどおしい」、疎か「疎か」、和やか「なごやか」、漠然「ばくぜん」、もどかしい、腹立たしい「はらだたしい」、怪しい「あやしい」、呆気ない「あっけない」、仄か「ほのか」、華やか「はなやか」、特異「とくい」、喧しい「やかましい」、無闇「むやみ」、鬱陶しい「うっとうしい」、おっちょこちょい、卑しい「いやしい」、速やか「すみやか」、浅ましい「あさましい」、勇ましい「いさましい」、穏やか「おだやか」、風情「ふぜい」、あくどい、虚しい「むなしい」、潔い「いさぎよい」、健やか「すこやか」、歴然「れきぜん」、悩ましい「なやましい」、画一的「かくいつてき」、広大「こうだい」、紛らわしい「まぎらわしい」、図々しい「ずうずうしい」、夥しい「おびただしい」、呆然「ぼうぜん」、しなやか、在り来り「ありきたり」、頑な「かたくな」、手薄「てうす」、目まぐるしい「めまぐるしい」、素直「すなお」、粘り強い「ねばりずよい」、容易い「たやすい」、爽やか「さわやか」、清々しい「すがすがしい」、柔い「やわい」、不備「ふび」、強か「したたか」、心地よい「ここちよい」、凄まじい「すさまじい」、紛れる「まぎれる」、弱い「よわい」、幅広い「はばひろい」、克明「こくめい」、重厚「じゅうこう」、端的「たんてき」、顕著「けんちょ」、分厚い「ぶあつい」、淡い「あわい」、密か「ひそか」、閑静「かんせい」、肝心「かんじん」、あり得ない「ありえない」、愕然「がくぜん」、口惜しい「くちおしい」、手ごろ「てごろ」、朗らか「ほがらか」、あやふや、立派「りっぱ」、だらしない、</p><h2 id="4-副詞"><a href="#4-副詞" class="headerlink" title="4. 副詞"></a>4. 副詞</h2><p>ぶらぶら、こそこそ、じろじろ、たっぷり、はらはら、がさがさ、がっしり、がやがや、さっぱり、しみじみ、のんびり、ゆったり、すやすや、ぎょうぎょう、めらめら、そっと、益々「ますます」、すらすら、尚更「なおさら」、ちらほら、いよいよ、めちゃくちゃ、ひんやり、ドキドキ、伸び伸び「のびのび」、にこにこ、ぞろぞろ、もやもや、ひっそり、そわそわ、ひょっとして、のっそり、とにかく、わくわく、うっかり、ごろごろ、めそめそ、ぞっと、僅か「わずか」、どっしり、ぐったり、嘸「さぞ」、いやいや、ちょいちょい、如何「いかん」、しっかり、ひたすら、予め「あらかじめ」、差し当たって、からから、ヘラヘラ、ぐっすり、ぐるぐる、のんびり、ひらひら、如何にも「いかにも」、ぼんやり、がっかり、ズルズル、偶々「たまたま」、きっちり、しっとり、元来「がんらい」、あっさり、びっくり、うっとり、丸ごと「まるごと」、すっかり、直に「じかに」、頻りに「しきりに」、バッチリ、ぎっしり、あたかも、すかすか、せっかく、きっかり、最早「もはや」、因みに「ちなみに」、こっそり、悠々「ゆうゆう」、ぼろぼろ、ハキハキ、ぺこぺこ、ふっくら、さっさと、にっこり、ギリギリ、すくすく、じめじめ、果たして「はたして」、至って「いたって」、敢えて「あえて」、からっと、いっそ、ぬるぬる、せめて、隈なく「くまなく」、とっくに、ぎっしり、くよくよ、悉く「ことごとく」、いとも、自ずと「おのずと」、ぐらぐら、ぶらぶら、猛然「もうぜん」、ぼうっと、てきぱき、俄かに「にわかに」、正しく「まさしく」、予々「かねがね」、ふんわり、どうやら、うんざり、不意に「ふいに」、改めて「あらためて」、辛うじて「かろうじて」、急遽「きゅうきょ」、丸で「まるで」、めきめき、随時「ずいじ」、即刻「そっこく」、へとへと、ざっと、しんなり、若干「じゃっかん」、一先ず「ひとまず」、すんなり、無性に「むしょうに」、さらさら、ちらっと、強いて「しいて」、何となく「なんとなく」、取り分け「とりわけ」、且つ「かつ」、はっきり、逐一「ちくいち」、言わば「いわば」、少しずつ「すこしずつ」、どんどん、ちやほや、全く「まったく」、些か「いささか」</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年8月东大情理CS算法题解读</title>
    <link href="/2024/09/15/UTO-DSA-2021-8/"/>
    <url>/2024/09/15/UTO-DSA-2021-8/</url>
    
    <content type="html"><![CDATA[<h1 id="Author-偷偷"><a href="#Author-偷偷" class="headerlink" title="Author: 偷偷  "></a><center>Author: 偷偷  </center></h1><h1 id="尊重原创，偷偷wx-LifeGoesOn-Rio"><a href="#尊重原创，偷偷wx-LifeGoesOn-Rio" class="headerlink" title="尊重原创，偷偷wx:LifeGoesOn_Rio  "></a><center>尊重原创，偷偷wx:LifeGoesOn_Rio  </center></h1><div class="note note-success">            <p>这道题的场景是实现一个排序算法，目的是优化时间复杂度。题目的策略是使用分治递归(Divide &amp; Conquer),在深度理解题目的场景下可以解决这道题目。</p>          </div><p>Firstly, read the pseudocode.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// return the least value that is >= kl/m</span><span class="token keyword">int</span> <span class="token function">multfrac</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// *q &lt;= *p</span><span class="token keyword">void</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">></span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>        <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>        <span class="token operator">*</span>q <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// sort in ascending order</span><span class="token keyword">void</span> <span class="token function">mysort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>  <span class="token comment">// number of elements</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">/** fill in the  blanks **/</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>(1) 当k &lt; 4, 即元素个数小于4时做升序排序，分类讨论即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>   <span class="token comment">// 元素个数不多于1时，不做任何处理</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比较交换一次</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token comment">// 依次比较三次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>算法详细过程如下：<br><img src="/img/DSA/swap_compare.jpg" alt="交换流程演示" style="max-width: 100%; height: auto;" /></p><p>(2) </p><p>$$<br>T(n)&#x3D;<br>\begin{cases}<br>1,\quad n\leq 3 \\<br>n^{\log_{4&#x2F;3}{3}}, \quad n&gt;3<br>\end{cases}<br>$$</p><p>这里也是分类讨论：</p><p>当n &lt;&#x3D; 3时，比较次数不随输入规模变化，因此为1；</p><p>当n &gt; 3时，代入分析：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort后3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><img src="/img/DSA/swap_compare2.jpg" alt="递归树演示" style="max-width: 100%; height: auto;" /><p>根据递归树可以写出主定理公式(Master theorem):<br>$$T(n) &#x3D; 3T(3n&#x2F;4) + O(n) $$<br>根据套路：这里b &#x3D; 4&#x2F;3, a &#x3D; 3.<br>$$O(n ^{\log_{b}{a}}) &#x3D; O(n^{log_{4&#x2F;3}{3}}) &gt; O(n) $$<br>所以有<br>$$T(n) &#x3D; O(n^{\log_{4&#x2F;3}{3}})$$</p><p>(3) (4, 2, 3, 3), (4, 3, 2, 3), (4, 3, 3, 2) can always work properly. (4, 2, 3, 2) can’t always work properly.</p><blockquote><p>可以看下图演示：前两次的sort调用的交集部分是排好数组最大的部分，第三次sort调用要覆盖剩余没有排好的部分；对于(4, 2, 3, 2), 前两次调用排好了数组最大的1&#x2F;4部分，所以第三次调用至少要覆盖数组前3&#x2F;4的大小，而第三次调用只覆盖了前1&#x2F;2，所以这个组合不行。</p></blockquote><img src="/img/DSA/swap_compare3.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>(4)<br>$$<br>\begin{cases}<br>    x + y &gt; w \\<br>    x + y + z &gt;&#x3D; 2w<br>\end{cases}<br>$$</p><blockquote><p>在解决第三题后，第四题就非常容易了。</p></blockquote><img src="/img/DSA/swap_compare4.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>视数组的大小为1，第一次调用排好前x&#x2F;w部分的元素，第二次大小排好后y&#x2F;w部分的元素。所以排序需满足：</p><ol><li>前两次调用的范围必须要有交集</li><li>第三次调用必须要覆盖完前两次调用的没有排好的部分。因此有：<br>$$ x&#x2F; w + y &#x2F; w &gt; 1$$<br>$$ z &#x2F; w &gt;&#x3D;  1 - (x + y - w) &#x2F; w $$</li></ol>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>数据结构与算法</category>
      
      <category>东京大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
      <tag>东京大学</tag>
      
      <tag>修考答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure &amp; Algorithms</title>
    <link href="/2024/09/10/DSA/"/>
    <url>/2024/09/10/DSA/</url>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure-Algorithms"><a href="#Data-Structure-Algorithms" class="headerlink" title="Data Structure &amp; Algorithms"></a>Data Structure &amp; Algorithms</h1><p>This is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(<strong>偷偷</strong>).The main language is in Chinese but you can see some concepts in English &amp; Japanese. And the pseudocode is in the style of <strong>C++</strong>. Let’s quickly review this subject!</p><p>这是偷偷刷了很多修考题之后总结出来的修考秘籍，全文都是考点，彻底高能。</p><h2 id="1-Introduction-to-Algorithms"><a href="#1-Introduction-to-Algorithms" class="headerlink" title="1. Introduction to Algorithms"></a>1. Introduction to Algorithms</h2><p>这一章主要计划复习<strong>时间复杂度(Time Complexity)</strong> 和 <strong>空间复杂度(Space Complexity)</strong> 两个概念，然后再仔细回顾 <strong>分治递归(DIvide &amp; Conquer)</strong> 这一重要的概念。最后再给出解决时间复杂度常用的分析方法和万能的<strong>主定理公式（Master Theorem）</strong></p><h3 id="1-1-时间复杂度与空间复杂度"><a href="#1-1-时间复杂度与空间复杂度" class="headerlink" title="1.1 时间复杂度与空间复杂度"></a>1.1 时间复杂度与空间复杂度</h3><div class="note note-success">            <p><strong>Space Complexity</strong>: 空间复杂度描述的是算法运行时所需的额外内存空间。通俗解释就是算法在运行的时候需要开辟多少空间的大小。O(1)指一个点集；O(n)就是开辟一个一维空间；O(n^2)开辟二维空间；O(n^3)开辟三维空间。在第二章讲解排序算法的时候，也会用到本章非常多的前置知识。</p>          </div><p>O(1): 常数空间复杂度，表示算法所需的额外空间是固定的，不随输入规模变化。例如，一个固定大小的变量。</p><p>O(n): 线性空间复杂度，表示算法所需的额外空间与输入规模成正比。例如，一个长度为 n 的数组。</p><p>O(n^2): 平方空间复杂度，表示算法所需的额外空间与输入规模的平方成正比。例如，一个 n x n 的二维数组。</p><p>O(n^3): 立方空间复杂度，表示算法所需的额外空间与输入规模的立方成正比。例如，一个 n x n x n 的三维数组。</p><p>一些常见的数据结构的空间复杂度：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> nums <span class="token comment">// 三维数组：O(n^3)</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> nums <span class="token comment">// 二维数组：O(n^2)</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>      <span class="token comment">// 栈：O(n)</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token comment">// 双端队列：O(n)</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> linkedList<span class="token punctuation">;</span>   <span class="token comment">// 链表：O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p><strong>Time complexity</strong>: 时间复杂度是衡量算法效率的重要指标之一，它描述了算法执行所需时间随输入规模增长的变化情况。这是修考中必考的一个地方：（1）如分析给出的代码的时间复杂度（Hint：关注for，while循环）（2）根据源代码优化时间复杂度设计新的算法（Hint：空间换时间）</p>          </div><p>常见的时间复杂度有以下几种：</p><p>O(1): <strong>常数时间复杂度</strong>，算法的执行时间不随输入规模变化。例如，访问数组中的某个元素。</p><p><code>int a = nums[10]  // 给a赋值数组下标为10的元素</code></p><p>O(n): <strong>线性时间复杂度</strong>，算法的执行时间与输入规模成正比。例如，遍历一个长度为 n 的数组。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; /* 操作 */ &#125;</code></p><p>O(log n): 对数时间复杂度，算法的执行时间随输入规模的对数增长。例如，二分查找(Binary Search)算法。</p><p><code>int binarySearch(int[] arr, int target) &#123; /* 二分查找逻辑 */ &#125;</code></p><p> O(n^2) : <strong>平方时间复杂度</strong>，算法的执行时间与输入规模的平方成正比。例如，冒泡排序(Bubble Sort)算法。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; /* 冒泡排序逻辑 */ &#125; &#125;</code></p><p>O(2^n): <strong>指数时间复杂度</strong>，算法的执行时间随输入规模的指数增长。例如，解决所有子集问题的递归算法。</p><p><code>void subsets(int[] nums) &#123; /* 递归逻辑 */ &#125;</code></p><p>在描述使劲复杂度的时候，有三种表示需要注意一下：</p><p>$O$: 表示渐进上界； $\Omega$: 表示渐进下界； $\Theta$: 渐进紧确界</p><h3 id="1-2-分治递归-Divide-Conquer"><a href="#1-2-分治递归-Divide-Conquer" class="headerlink" title="1.2 分治递归(Divide &amp; Conquer)"></a>1.2 分治递归(Divide &amp; Conquer)</h3><div class="note note-success">            <p>分治递归(Divide &amp; conquer)的思想是将原问题分割成更小的子问题，自顶向下地解决每个子问题，并最终自底向上合并它们的解来解决主问题。</p>          </div><p>常见的分治递归有：二分查找(Binary Search) 和归并排序(Merge Sort).</p><h4 id="1-2-1-二分查找-Binary-Search"><a href="#1-2-1-二分查找-Binary-Search" class="headerlink" title="1.2.1 二分查找(Binary Search)"></a>1.2.1 二分查找(Binary Search)</h4><img src="/img/DSA/binary_search.svg" alt="二分查找演示" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 前提nums是有序数组</span><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// (避免left + right) / 2 的溢出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>   <span class="token comment">// 找到目标，返回索引</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 目标在左半部分</span>        <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 目标在右半部分</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>根据上图我们得出递归表达式：<br>$T(n) &#x3D; T(n &#x2F; 2) + O(1)$， 得出$T(n) &#x3D; O(log_{2}{n})$</p><h4 id="1-2-2-归并排序-Merge-Sort"><a href="#1-2-2-归并排序-Merge-Sort" class="headerlink" title="1.2.2 归并排序(Merge Sort)"></a>1.2.2 归并排序(Merge Sort)</h4><img src="/img/DSA/merge_sort.svg" alt="归并排序演示" style="max-width: 100%; height: auto;" />这个图像有效地展示了归并排序的"分而治之"策略： 1.将大问题（排序整个数组）分解成小问题（排序子数组） 2.解决小问题（对小数组排序） 3.将小问题的解合并成大问题的解（合并有序子数组）<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 合并两个有序的子数组</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子数组的长度</span>    <span class="token keyword">int</span> n2 <span class="token operator">=</span> right <span class="token operator">-</span> mid<span class="token punctuation">;</span>     <span class="token comment">// 右子数组的长度</span>    <span class="token comment">// 创建临时数组存储左右子数组</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftArr</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rightArr</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 复制数据到临时数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> rightArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token comment">// i是左子数组指针，j是右子数组指针，k是合并后数组的指针</span>    <span class="token comment">// 合并左右子数组</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的左子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的右子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 递归实现归并排序</span><span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 递归排序左右两部分</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 合并已排序的部分</span>        <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>递归式：$T(n) &#x3D; 2T(n &#x2F; 2) + O(n)$, 所以$T(n) &#x3D; O(nlog_{2}{n})$</p><h3 id="1-3-主定理-Master-Theorem"><a href="#1-3-主定理-Master-Theorem" class="headerlink" title="1.3 主定理(Master Theorem)"></a>1.3 主定理(Master Theorem)</h3><p>递归方程形式如：<br>$$T(n) &#x3D; aT(n &#x2F; b) + O(n^d)$$</p><div class="note note-success">            <p>其中，$a$表示子问题的数量，b表示每个子问题是原问题规模的$1&#x2F;b$, $O(n^d)$ 表示在每一层分治过程之外，解决问题所需的额外代价，通常是合并或分割的代价。</p>          </div><p><strong>情况 1：</strong><br>如果$log_{b}{a} &gt; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(\log_{b}{a}) $$</p><p><strong>解释：</strong> 在这种情况下，分治产生的子问题数量增长得更快，主导时间复杂度的是递归中的分治部分。</p><p><strong>情况 2：</strong><br>如果$log_{b}{a} &#x3D; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(n^d\log{n}) $$</p><p><strong>解释：</strong> 在这种情况下，分治和额外开销的增长速度相同，因此总的时间复杂度是 $n^d\log{n}$。</p><p><strong>情况 3：</strong><br>如果 $log_{b}{a} &lt; d$，则递归式的解为：<br>$$T(n) &#x3D; O(n^d)$$<br><strong>解释：</strong> 在这种情况下，额外的开销主导时间复杂度，因此复杂度主要由 $n^d$决定。</p><p><strong>斯特林近似公式（Stirling’s Formula）:</strong> $n! \approx \sqrt{2 \pi n} \left( \frac{n}{e} \right)^n$</p><h2 id="2-Sorting-Algorithm"><a href="#2-Sorting-Algorithm" class="headerlink" title="2.Sorting Algorithm"></a>2.Sorting Algorithm</h2><p>再时间复杂度和空间复杂度的概念后，并引入了分治递归和归并排序算法；接下来这一章就主要回顾常见的一些排序算法，然后分析他们的时间复杂度和空间复杂度。</p><h3 id="2-1-插入排序-Insertion-Sort"><a href="#2-1-插入排序-Insertion-Sort" class="headerlink" title="2.1 插入排序(Insertion Sort)"></a>2.1 <strong>插入排序(Insertion Sort)</strong></h3><p>这个算法的过程也很直观：插入排序的核心思想是将一个新元素插入到已经排好序的子序列中的适当位置。<br><img src="/img/DSA/insertation_sort.svg" alt="插入排序演示" style="max-width: 100%; height: auto;" /><br>最好的情况下是：原数组规模小或者大部分数据有序，那么我们一次遍历就可以完成好排序。 最坏的情况下是：原数组是降序排列的，意思是每一次插入新元素的时候，都要遍历一遍已排好序的子数组。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 从第二个元素开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 回溯检查并交换</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最坏情况：$T(n) &#x3D; T(n - 1) + O(n)$,  $T(n) &#x3D; O(n^2)$</p><p>最好情况：$T(n) &#x3D; T(n - 1) + O(1)$,  $T(n) &#x3D; O(n)$</p><h3 id="2-2冒泡排序-Bubble-Sort"><a href="#2-2冒泡排序-Bubble-Sort" class="headerlink" title="2.2冒泡排序(Bubble Sort)"></a>2.2冒泡排序(Bubble Sort)</h3><p>冒泡排序是一个直观的算法，通过重复地遍历数组来工作。在每次遍历中，它比较相邻的元素并在需要时交换它们，这样每次迭代都会将当前未排序部分中的最大元素’冒泡’到数组的末尾正确位置。这个过程从左到右重复进行，直到整个数组排序完成。一句话概括就是：不断的进行两两比较。<br><img src="/img/DSA/bubble_sort.svg" alt="冒泡排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 控制循环的轮数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 内层循环，相邻比较</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 交换元素</span>                std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>冒泡排序平均时间复杂度</strong>：$T(n) &#x3D; O(n^2)$</p><h3 id="2-3选择排序-Selection-Sort"><a href="#2-3选择排序-Selection-Sort" class="headerlink" title="2.3选择排序(Selection Sort)"></a>2.3选择排序(Selection Sort)</h3><p>选择排序的基本思想是分阶段地将数组划分为两部分：已排序部分和未排序部分。每一轮从未排序部分中找到最小（或最大）的元素，放到已排序部分的末尾，直到整个数组排序完成。<br><img src="/img/DSA/selection_sort.svg" alt="选择排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 已排序数组末尾</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 找未排序数组中的最小元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIdx <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>选择排序时间复杂度：</strong> $T(n) &#x3D; O(n^2)$</p><h3 id="2-4快速排序-Quick-Sort"><a href="#2-4快速排序-Quick-Sort" class="headerlink" title="2.4快速排序(Quick Sort)"></a>2.4快速排序(Quick Sort)</h3><p>快速排序的本质是分治法。它通过选择一个基准元素，将原数组划分为小于基准元素和大于基准元素的两个子数组，然后对这两个子数组进行递归排序。<br><img src="/img/DSA/quick_sort.svg" alt="快速排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分区函数</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 选择最后一个元素作为基准</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 小于基准的元素的索引</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果当前元素小于或等于基准</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 增加小于基准的元素索引</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 快速排序函数</span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// pi是分区索引，arr[pi]现在在正确的位置</span>        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 分别对左右子数组进行递归排序</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在最坏情况下，基准元素可能是最大或最小值，这会导致一个子数组为空，另一个子数组的大小为 $n-1$，此时的时间复杂度为 $T(n) &#x3D; T(n-1) + O(n) &#x3D;O(n^2)$。而在平均情况下，基准元素能够较好地划分数组，时间复杂度为 $T(n) &#x3D; 2T(n&#x2F;2) + O(n)&#x3D;O(n\log{n})$ 。</p><h3 id="2-5堆排序-Heap-Sort"><a href="#2-5堆排序-Heap-Sort" class="headerlink" title="2.5堆排序(Heap Sort)"></a>2.5堆排序(Heap Sort)</h3><p>这个考点应该是修考最爱考的一个了！（敲重点）堆排序的基本思想是不断维护一个最大堆。在每次排序过程中，首先将最大堆的根节点（最大值）与堆的最后一个元素交换，然后缩小堆的范围（排除最后一个元素），并对新的根节点进行下沉操作，以恢复最大堆的性质。重复这一过程，直到所有元素都被排序。<br><img src="/img/DSA/heap_sort.svg" alt="堆排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 堆化函数，用于维护最大堆性质</span><span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 初始化最大值为根</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子节点</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 右子节点</span>    <span class="token comment">// 如果左子节点大于根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token comment">// 如果右子节点大于当前最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token comment">// 如果最大值不是根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 递归地堆化受影响的子树</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 堆排序函数</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 构建最大堆（从最后一个非叶子节点开始）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 一个个从堆顶取出元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前根移到末尾</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在减小的堆上调用 max heapify</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>建堆的时间复杂度为$O(n)$,每个节点的调整最多为$O(\log{n})$次。在排序的过程中需要建堆$O(n)$次，并且每次需要$O(logn)$来维护堆(heapify),因此对排序总的时间复杂度为$O(n\log{n})$</p><h2 id="3-Data-Structure"><a href="#3-Data-Structure" class="headerlink" title="3.Data Structure"></a>3.Data Structure</h2><p>这一章主要讲解常见的数据结构,如栈(stack),队列(queue),链表(linked list),哈希表(hash map),以及字符串(string)。二叉树考点众多我会单独做成一章并且和图算法一块复习。</p><h3 id="3-1-Stack-Queue"><a href="#3-1-Stack-Queue" class="headerlink" title="3.1 Stack &amp; Queue"></a>3.1 Stack &amp; Queue</h3><p><strong>栈(stack)</strong> :后进先出(LIFO), <strong>队列</strong> :先进先出(FIFO)。另外，栈和队列是可以相互实现的，了解到这个程度，我认为就掌握到栈和队列的基本性质了。</p><p><em>Q1: 如何用栈实现队列？</em></p><div class="note note-success">            <p>A: 开两个栈，一个负责栈负责放入元素，另一个栈负责弹出元素</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个栈负责放入元素，一个栈负责弹出元素</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>      <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟入队过程</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟弹出队首元素过程</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取队首元素的值</span>    <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取队首元素的值</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 放回</span>        out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>Q2：如何用队列实现栈？</em></p><div class="note note-success">            <p>A：开两个队列，一个模拟入栈，一个模拟出栈。更优化的方式是直接开一个队列即可,不断的出队入队就可以实现栈的性质。</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个队列负责入栈，一个负责出栈</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 把in队列的元素不断出队只剩一个，即时栈顶</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶的元素</span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取弹出后的值</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 再放入队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 弹出栈顶元素</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      n<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 把对位元素调整到队首</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶元素  </span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> ans<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="3-2-Linked-List"><a href="#3-2-Linked-List" class="headerlink" title="3.2 Linked List"></a>3.2 Linked List</h3><p>常见的链表有单链表和双链表。<em>单链表</em>：每个节点只包含一个指向下一个节点的指针，访问节点时只能从头节点开始向后遍历。<em>双链表</em>：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。这使得可以在链表中向前和向后遍历。<br><img src="/img/DSA/linkedlist.svg" alt="链表演示" style="max-width: 100%; height: auto;" /></p><p><strong>链表的优缺点</strong></p><p><em>优点</em>：1)动态大小：链表的大小可以动态调整，不像数组那样需要预先定义大小。2)方便插入和删除：在链表中插入或删除节点的时间复杂度为 O(1)，只需调整指针，而数组则可能需要移动大量元素。</p><p><em>缺点</em>：1)内存占用：每个节点需要额外的存储空间来存储指针，导致比数组更高的内存开销。2)随机访问困难：链表不支持快速随机访问，查找元素的时间复杂度为 O(n)。</p><h3 id="3-3-Hash-Map"><a href="#3-3-Hash-Map" class="headerlink" title="3.3 Hash Map"></a>3.3 Hash Map</h3><p><strong>哈希映射（Hash Map）</strong> 是一种数据结构，用于以键值对（key-value pairs）形式存储数据。它通过一个哈希函数将键映射到数组中的索引，从而实现快速的数据访问。主要特点有：</p><p>1）快速查找：平均情况下，哈希映射可以在 O(1) 时间内进行查找、插入和删除操作。</p><p>2）键值对存储：每个元素都由一个唯一的键和与之关联的值组成，可以通过键快速访问对应的值。</p><p>3）哈希函数：将键转换为数组索引的函数，好的哈希函数可以减少冲突（不同键映射到相同索引）。</p><p>4）处理冲突：常用的方法包括<strong>链式法(chaining)<strong>和</strong>开放寻址法（open addressing）</strong>。<br><img src="/img/DSA/hash.svg" alt="哈希表处理冲突演示" style="max-width: 100%; height: auto;" /></p><p>为了减少哈希冲突，哈希映射的函数要尽量将不同的输入键均匀地映射到哈希表的不同索引，以减少冲突（即不同键映射到相同索引的情况）。</p><h3 id="3-4-string"><a href="#3-4-string" class="headerlink" title="3.4 string"></a>3.4 string</h3><p>字符串这个数据结构直观易懂，主要涉及到的考点有KMP算法和sequence alignment算法。这里主要回顾一下KMP算法，关于string类型的其他考点：最长子序列问题和序列比对(Sequence Alignment)，会在后面动态规划章节中仔细讲解。</p><h4 id="3-4-1-KMP算法"><a href="#3-4-1-KMP算法" class="headerlink" title="3.4.1 KMP算法"></a>3.4.1 KMP算法</h4><p>KMP算法可以说是学一次忘一次……建议考前一定要临时报佛脚记一下。这个算法的美妙之处就是在于优化了暴力匹配，用前缀表来跳过重复的匹配过程。前缀表就是模式串中每个位置的最长相等前缀和后缀的长度。在发生不匹配的情况下，将子串移动前一个字符串的前缀表的具体值。（感觉京大最喜欢考KMP算法了）<br><img src="/img/DSA/KMP.svg" alt="KMP算法演示" style="max-width: 100%; height: auto;" /></p><h2 id="4-Binary-Tree"><a href="#4-Binary-Tree" class="headerlink" title="4.Binary Tree"></a>4.Binary Tree</h2><p>关于二叉树的考点有许多，像是考二叉树的遍历，二叉搜索树（Binary Search Tree），最小生成树（MST），以及AVL树。首先需要了解二叉树的一些基本性质，例如每个节点的下标，以及二叉树的多种遍历方式。</p><h3 id="4-1-Concepts-of-Binary-Tree"><a href="#4-1-Concepts-of-Binary-Tree" class="headerlink" title="4.1 Concepts of Binary Tree"></a>4.1 Concepts of Binary Tree</h3><img src="/img/DSA/binary_tree.svg" alt="常见的二叉树" style="max-width: 100%; height: auto;" /><p><strong>完全二叉树（complete binary tree）</strong>：是一种二叉树，其中每一层都是满的，除了可能是最后一层，且最后一层的节点从左到右排列。在完全二叉树中，所有的节点都尽可能地靠左排列，这种结构使得它在存储和操作上更为高效。与全二叉树不同，完全二叉树允许最后一层不满，但仍需保持左侧填充。</p><p>对于一个完全二叉树，如果节点的索引为$i$,节点数为$n$那么：</p><ol><li>左孩子节点索引: $2i$</li><li>右孩子节点索引: $2i + 1$</li><li>父亲节点索引: $[i&#x2F;2]$  </li><li>二叉树高度: $ceil(log_{2}{(n+1)})$ 或 $floor(log_{2}{n}) + 1$</li></ol><p><strong>全二叉树（full binary tree）</strong>：是指每个节点要么没有子节点，要么恰好有两个子节点的二叉树。在这种树中，除了叶子节点外，所有节点都有两个子节点。这样的结构确保了树的每一层都被完全填满，只有最后一层可能不满。</p><p><strong>二叉搜索树（Binary Search Tree, BST）</strong>: 是一种二叉树，其中每个节点都包含一个键值，左子树的所有节点键值小于该节点，右子树的所有节点键值大于该节点。这种结构使得查找、插入和删除操作的平均时间复杂度为 O(log n)。其主要性质包括：每个节点最多有两个子节点，左子树和右子树都是二叉搜索树，且没有重复的键值。</p><p>二叉搜索树的搜索迭代实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">></span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="4-2-Tree-Traversal"><a href="#4-2-Tree-Traversal" class="headerlink" title="4.2 Tree Traversal"></a>4.2 Tree Traversal</h3><p><strong>层序遍历（Level Order Traversal）：</strong> 开一个队列处理一层的节点并放入下一层的节点。这个遍历也属于<strong>广度优先遍历（BFS）</strong>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">auto</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>二叉树的<strong>深度优先遍历（DFS）</strong> 可以分为三种：前序遍历，中序遍历和后序遍历。</p><p><strong>前序遍历（Preorder Traversal）：</strong>  <em>根-&gt;左-&gt;右</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然也可以开一个栈来实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>后序遍历（Postorder Traversal）：</strong>  <em>左-&gt;右-&gt;根</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>后序遍历同样可以开一个栈来实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>中序遍历（Inorder Traversal）：</strong>  <em>左-&gt;根-&gt;右</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然也可以开一个栈来实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token operator">-></span> right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>二叉树的中序遍历还有一个重要的考点是<em>逆波兰表达式</em>,这个曾经在京大的过去问中出现过。<strong>逆波兰表达式（Reverse Polish Notation, RPN）</strong> 是一种后缀表示法，用于表示算术表达式。在这种表示法中，运算符跟在操作数之后，而不是在它们之间。这种形式的好处是消除了括号的需要，因为操作的顺序总是由操作符的位置决定。具体的实现方法可以开一个栈轻松解决。<br><img src="/img/DSA/rpn.svg" alt="逆波兰表达式" style="max-width: 70%; height: auto;" /></p><h3 id="4-3-AVL-Tree"><a href="#4-3-AVL-Tree" class="headerlink" title="4.3 AVL Tree"></a>4.3 AVL Tree</h3><p><strong>AVL树</strong>是一种自平衡的二叉搜索树，确保每个节点的左右子树高度差（平衡因子）最多为1。这样可以保证树的高度在 $O(log{n})$ 范围内，确保高效的插入、删除和查找操作。AVL树通过旋转操作来维持平衡，从而优化性能，特别是在频繁修改的场景中。东工有一年考到了这个点，但我认为了解到AVL树的工作原理就ok了,主要聚焦在节点的添加和删除以及树的旋转。<br><img src="/img/DSA/avl_tree_insert.svg" alt="AVL树增加节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_delete.svg" alt="AVL树删除节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_rotate.svg" alt="AVL树左旋和右旋" style="max-width: 100%; height: auto;" /></p><h2 id="5-Graph-Theory"><a href="#5-Graph-Theory" class="headerlink" title="5.Graph Theory"></a>5.Graph Theory</h2><p>本章主要讲解图的基本算法，最小生成树，单源最短路径算法，单源最短路径算法和多源最短路径算法，以及最大流问题。修考题的图算法都是套的模版，因此了解算法的核心思想非常关键。</p><h3 id="5-1图的基本算法"><a href="#5-1图的基本算法" class="headerlink" title="5.1图的基本算法"></a>5.1图的基本算法</h3><p>对于图的表示，我们需要建立一个<strong>邻接矩阵(adjacency matrix)</strong>,简单图的邻接矩阵是(0,1)矩阵并且对角线元素都为0。无向图的邻接矩阵是对称矩阵。<br><img src="/img/DSA/adjacency_matrix.svg" alt="邻接矩阵" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-BFS"><a href="#5-1-1-BFS" class="headerlink" title="5.1.1 BFS"></a>5.1.1 BFS</h4><p>在二叉树章节中讲解了树的深度遍历算法，在图中，我们可以同样的利用邻接链表（也就是建一个数组）来获取当前遍历的节点的邻接节点，开一个数组记录已访问的节点，最后利用队列实现层序遍历。<br><img src="/img/DSA/bfs.svg" alt="广度优先算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// BFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Create a queue for BFS</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> queue<span class="token punctuation">;</span>        <span class="token comment">// Mark the source node as visited and enqueue it</span>        visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Dequeue a vertex from queue and print it</span>            s <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Get all adjacent vertices of the dequeued vertex s</span>            <span class="token comment">// If an adjacent has not been visited, then mark it visited</span>            <span class="token comment">// and enqueue it</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-1-2-DFS"><a href="#5-1-2-DFS" class="headerlink" title="5.1.2 DFS"></a>5.1.2 DFS</h4><p>DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索图形或树数据结构的算法。它尽可能深地访问节点，然后回溯，寻找未访问过的节点。</p><p><strong>基本原理：</strong></p><ol><li>初始化：从起始节点出发，将其标记为访问过。之后开始递归或使用栈</li><li><em>递归</em>：对每个未访问的邻接节点，递归调用DFS。（递归的实现方式就是利用栈来记录每一次函数调用的状态）<br><em>栈</em>：将节点压入栈中，访问节点时将其出栈，继续访问其未访问的邻接节点，并将这些邻接节点压入栈。</li><li><em>回溯</em>：如果当前节点的所有邻接节点都访问过，则回溯到上一个节点，继续这个过程，直到所有节点都访问完。<img src="/img/DSA/dfs.svg" alt="深度优先算法" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">&amp;</span>visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark the current node as visited and print it</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token comment">// Recur for all the vertices adjacent to this vertex</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// DFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all the vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Call the recursive helper function to print DFS traversal</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p>BFS和DFS对比非常鲜明。BFS的性格是保守，害怕风险，尽量做到“广撒网，细收鱼”；而DFS则是奔放，秉持着一颗“不撞南墙不回头”，“不到黄河不死心”的感觉。</p>          </div></li></ol><h4 id="5-1-3-Topological-Sort"><a href="#5-1-3-Topological-Sort" class="headerlink" title="5.1.3 Topological Sort"></a>5.1.3 Topological Sort</h4><p><strong>拓扑排序（Topological Sorting）</strong>是图论中的一种线性排序方法，主要用于对<strong>有向无环图（Directed Acyclic Graph, DAG</strong> 中的顶点进行排序，使得对于图中的每一条有向边 (u → v)，顶点 u 在排序中都出现在顶点 v 的前面。<br><img src="/img/DSA/topo_sort.svg" alt="拓扑排序算法" style="max-width: 100%; height: auto;" /><br><strong>拓扑排序算法步骤：</strong></p><ol><li>计算每个顶点的入度：统计每个顶点被其他顶点指向的次数（即入度, inDegree）。</li><li>将所有入度为 0 的顶点加入队列：这些顶点没有任何前置依赖。</li><li>重复以下步骤直到队列为空：（1）从队列中取出一个顶点 u，将其加入拓扑排序结果中。（2）遍历 u 的所有邻接顶点 v，将 v 的入度减 1；如果 v 的入度变为 0，则将 v 加入队列。</li><li>检查结果：如果所有顶点都被处理过，则返回拓扑排序；否则，图中有环，无法进行拓扑排序。</li></ol><p>在初始化时，需要遍历所有顶点计算入度，耗时$O(V)$；然后遍历所有边来更新入度并处理顶点，耗时$O(E)$。因此总的时间复杂度是$O(V + E)$。最终的排序顺序是: $1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7$。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span>  <span class="token comment">// 顶点数</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span>  <span class="token comment">// 邻接表</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inDegree<span class="token punctuation">;</span>  <span class="token comment">// 入度数组</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inDegree</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        <span class="token comment">// 将所有入度为0的顶点加入队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 对于所有相邻的顶点，将其入度减1</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 检查是否存在环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"图中存在环，无法进行拓扑排序"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-1-4-Union-Find"><a href="#5-1-4-Union-Find" class="headerlink" title="5.1.4 Union Find"></a>5.1.4 Union Find</h4><p><strong>并查集（Union-Find）</strong> 算法，又称为不相交集数据结构，是一种用于处理元素分组及查询元素所属组的高效数据结构。它广泛应用于图论（如判断图的连通性、<em>Kruskal算法</em>求最小生成树）并查集主要支持<strong>两种操作</strong>：</p><ol><li>查找（Find）：确定某个元素属于哪个集合（即找到该元素所在集合的代表元素或根节点）。</li><li>合并（Union）：将两个不同的集合合并为一个集合。</li></ol><p>为了提高并查集的效率，通常结合以下两种优化策略：</p><ol><li>路径压缩（Path Compression）：在 Find 操作中，将访问过的所有节点直接连接到根节点，从而降低树的高度。</li><li>按秩合并（Union by Rank）或按大小合并（Union by Size）：在 Union 操作中，总是将较小的树挂到较大的树下，保持树的平衡。</li></ol><p>结合这两种优化后，并查集的时间复杂度几乎接近于常数时间，具体为 反阿克曼函数 的时间复杂度，几乎可以认为是 $O(1)$。<br><img src="/img/DSA/union_find.svg" alt="并查集算法" style="max-width: 100%; height: auto;" /><br>以下是一个使用路径压缩和按秩合并优化的并查集实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 存储每个节点的父节点</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rank<span class="token punctuation">;</span>    <span class="token comment">// 存储每个节点的秩（树的高度）</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数：初始化每个节点的父节点为自身，秩为1</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        rank<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作：查找元素x所在集合的根节点，并进行路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 路径压缩</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作：将元素x和元素y所在的集合合并</span>    <span class="token keyword">void</span> <span class="token function">unionSets</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 已经在同一个集合中</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 按秩合并：将秩较小的树挂到秩较大的树下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-2-Minimum-Spanning-Tree"><a href="#5-2-Minimum-Spanning-Tree" class="headerlink" title="5.2 Minimum Spanning Tree"></a>5.2 Minimum Spanning Tree</h3><p><strong>最小生成树（Minimum Spanning Tree, MST）</strong> 是指在一个带权无向图中，连接所有顶点的一个子图，使得：</p><ol><li>这个子图是一个树（即没有环，并且连通所有顶点）。</li><li>这个树的总边权和最小。</li></ol><p><strong>特点</strong>：</p><ol><li>最小生成树包含图中所有的顶点，但只包含连接这些顶点的最少数量的边（即 $V - 1$条边，$V$为顶点数）。</li><li>它保证生成的树的边权总和最小。</li></ol><p>常见的MST生成算法有2种：<em>Kruskal算法</em>和<em>Prim算法</em>。简单来说，Kruskal是基于边的选择，而Prim算法是从某个顶点开始构建最小生成树的，逐步扩展树的边界。</p><h4 id="5-2-1-Kruskal"><a href="#5-2-1-Kruskal" class="headerlink" title="5.2.1 Kruskal"></a>5.2.1 Kruskal</h4><p>具体步骤为：</p><ol><li>首先对所有边按权重从小到大排序。</li><li>然后依次利用<strong>并查集（Union Find）</strong>检查每条边的两个顶点是否属于不同的集合，如果是，则将它们合并，并将该边加入最小生成树。</li><li>重复这个过程，直到最小生成树中包含了$V−1$条边。</li></ol><p><strong>时间复杂度：</strong> 边排序耗时$O(ElogE)$，并查集操作近似为$O(1)$，因此总时间复杂度为$O(ElogE)$。<br><img src="/img/DSA/kruskal.svg" alt="Kruskal算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含起点、终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 比较函数，按照权重升序排序</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> weight <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 并查集（Union-Find）结构体</span><span class="token keyword">struct</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">,</span> rank<span class="token punctuation">;</span>    <span class="token comment">// 初始化并查集，所有节点的父节点初始化为自己，秩(rank)初始化为0</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作，使用路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作，按秩合并</span>    <span class="token keyword">void</span> <span class="token function">unite</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootU <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootV <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootU <span class="token operator">!=</span> rootV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">=</span> rootV<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>                rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Kruskal算法实现</span><span class="token keyword">int</span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 按权重升序排序所有边(至关重要的一环)</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edges<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UnionFind <span class="token function">uf</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> edgesUsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已经加入生成树的边数</span>    <span class="token comment">// 遍历所有边</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 查找两个顶点是否属于不同的集合（不同的连通分量）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">)</span> <span class="token operator">!=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">,</span> edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将它们合并到同一个集合</span>            mstWeight <span class="token operator">+=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span> <span class="token comment">// 将这条边的权重加入总权重</span>            edgesUsed<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 如果已经加入V-1条边，生成树构建完毕</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>edgesUsed <span class="token operator">==</span> numVertices <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-2-2-Prim算法"><a href="#5-2-2-Prim算法" class="headerlink" title="5.2.2 Prim算法"></a>5.2.2 Prim算法</h4><p>Prim算法的基本思想是从一个顶点开始，逐步将与当前生成树相连的最小边加入到树中，直到包含图中所有顶点为止。不同于Kruskal算法选择的是边，Prim算法在每一步选择的是<em>与已连接的顶点相连的最小权重边</em>。</p><p>算法步骤：</p><ol><li>初始化：选择一个起始顶点，标记为生成树的一部分。<br>使用一个数组&#x2F;优先队列来记录所有尚未加入生成树的顶点到当前生成树的最小边的权重。</li><li>选择最小边：<br>在每一步中，从所有与生成树相连的边中选择权重最小的边（维护一个优先队列），确保这个边不会形成环。</li><li>更新距离：将选择的边的顶点加入生成树<u>并更新尚未加入树的顶点到新生成树的最小边的权重。</u></li><li>重复上述步骤，直到所有顶点都被加入生成树。</li></ol><p>对每条边的操作（插入、删除、更新最小边权重）是$O(logV)$的，因此总的时间复杂度为$O(ElogV)$，其中$E$是边的数量，$V$是顶点的数量。<br><img src="/img/DSA/prim.svg" alt="Prim算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Prim算法的实现</span><span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 标记每个顶点是否在生成树中</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">inMST</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录最小权重的边的权重，初始化为无穷大(敲重点)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">minEdgeWeight</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 优先队列（最小堆），存储&#123;边的权重，顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    <span class="token comment">// 从第0号顶点开始</span>    minEdgeWeight<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 取出权重最小的边</span>        <span class="token keyword">int</span> weight <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果顶点u已经在MST中，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 将顶点u加入MST</span>        inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        mstWeight <span class="token operator">+=</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 更新与顶点u相连的其他顶点的最小边权重</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inMST<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">&lt;</span> minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>w<span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-3-单源最短路径算法"><a href="#5-3-单源最短路径算法" class="headerlink" title="5.3 单源最短路径算法"></a>5.3 单源最短路径算法</h3><p>单源最短路径算法（Single-Source Shortest Path, SSSP）用于从图中的一个指定起点（源点）出发，找到该点到图中所有其他顶点的最短路径。常用的单源路径算法为<strong>Dijkstra算法</strong>和<strong>Bellman-Ford算法</strong>。Dijkstra算法只能用于无负权边的图。如果图中存在负权边，Dijkstra算法的结果可能不正确。Bellman-Ford算法可以处理带负权边的图，且能够检测负权环（如果存在负权环，则说明不存在最短路径）。</p><h4 id="5-3-1-Dijkstra’s-algorithm"><a href="#5-3-1-Dijkstra’s-algorithm" class="headerlink" title="5.3.1 Dijkstra’s algorithm"></a>5.3.1 Dijkstra’s algorithm</h4><p><strong>Dijkstra算法</strong>的基本思想是：每次贪心地从当前未处理的顶点中选择一个距离源点最近的顶点，标记其最短路径为确定，然后通过该顶点更新其邻接点的最短路径。过反复选择距离最小的顶点，并更新邻接点的路径长度，最终能确定所有顶点的最短路</p><p><strong>时间复杂度</strong>：在使用优先队列（最小堆）的情况下，Dijkstra算法的时间复杂度为$O(ElogV)$，其中E是图中边的数量，V是顶点的数量。取出当前最小距离顶点的操作需要$O(logV)$时间。每条边被检查一次，更新时需要$O(logV)$的时间来调整优先队列。在稠密图中，算法的效率略低，因为每次更新都需要重新维护优先队列，但在稀疏图中性能良好。<br><img src="/img/DSA/dijkstra.svg" alt="Dijkstra算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 存储从源点到每个顶点的最短距离</span>    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 源点到自身的距离为0</span>        <span class="token comment">// 优先队列：最小堆，存储的是&#123;距离, 顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> source<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>  <span class="token comment">// 取出距离源点最近的顶点</span>        <span class="token keyword">int</span> d <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>   <span class="token comment">// 当前顶点的最短距离</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果当前距离已经不是最优解，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 更新顶点 u 的邻接点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> weight <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token comment">// 如果通过 u 到 v 的路径更短，更新路径</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 v 插入优先队列</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-3-2-Bellman-Ford-Algorithm"><a href="#5-3-2-Bellman-Ford-Algorithm" class="headerlink" title="5.3.2 Bellman-Ford Algorithm"></a>5.3.2 Bellman-Ford Algorithm</h4><p><strong>Bellman-Ford算法</strong>是一种经典的算法，用于解决单源最短路径问题（Single Source Shortest Path, SSSP），即从图中的某个源点到其他所有顶点的最短路径。它与Dijkstra算法的不同之处在于，Bellman-Ford可以处理权值为负数的边，并且能够检测出图中是否存在负权环（negative-weight cycle）。</p><p>Bellman-Ford算法的核心思想是通过<strong>松弛（relaxation）</strong> 操作逐步更新每个顶点的最短路径估计值。松弛操作的含义是，如果从某条边可以得到比当前已知更短的路径，则更新路径长度。算法通过多次迭代更新路径，确保找到全局的最短路径。</p><p><strong>算法步骤：</strong></p><ol><li>初始化：将源点到源点的距离设为0（即$dist[source] &#x3D; 0$），其他所有顶点到源点的距离初始设为正无穷大（$dist[v] &#x3D; ∞$）。设定前驱节点为None或相应的初始值。</li><li>松弛所有边：对于图中的所有边$(u,v)$，检查是否可以通过$u$达到$v$的更短路径，即$dist[v] &gt; dist[u] + weight(u, v)$。如果是，则更新$dist[v] &#x3D; dist[u] + weight(u, v)$。重复这个过程最多$n−1$次，其中$n$是顶点的数量。因为最短路径最多包含$n−1$条边。</li><li>检测负权环（可选步骤）：在完成$n−1$次松弛操作后，再对所有边执行一次松弛操作。如果此时还能继续更新某个顶点的最短路径值，则说明图中存在负权环，因为在无负权环的情况下，经过$n−1$次松弛操作后，所有最短路径应该已经收敛。</li></ol><p>边的松弛操作需要对每条边执行，图中一共有𝑚条边。算法需要对所有边重复𝑛−1次（因为最短路径最多包含𝑛−1条边），因此时间复杂度为𝑂(𝑛⋅𝑚)</p><img src="/img/DSA/bellman_ford.svg" alt="松弛操作" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> Bellmanford算法伪代码function BellmanFord<span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> Step <span class="token number">1</span><span class="token punctuation">:</span> Initialize distances    <span class="token keyword">for</span> each vertex v <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> ∞  <span class="token operator">//</span> Set <span class="token builtin">all</span> distances to infinity        predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> null  <span class="token operator">//</span> No predecessors initially    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token operator">//</span> The distance <span class="token keyword">from</span> the source to itself <span class="token keyword">is</span> zero    <span class="token operator">//</span> Step <span class="token number">2</span><span class="token punctuation">:</span> Relax <span class="token builtin">all</span> edges n<span class="token operator">-</span><span class="token number">1</span> times    <span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">1</span> to <span class="token operator">|</span>V<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>            <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>                predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u    <span class="token operator">//</span> Step <span class="token number">3</span><span class="token punctuation">:</span> Check <span class="token keyword">for</span> negative<span class="token operator">-</span>weight cycles    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>            error <span class="token string">"Graph contains a negative-weight cycle"</span>        <span class="token keyword">return</span> dist<span class="token punctuation">,</span> predecessor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-4-多源最短路径算法"><a href="#5-4-多源最短路径算法" class="headerlink" title="5.4 多源最短路径算法"></a>5.4 多源最短路径算法</h3><h4 id="5-4-1-Floyd-Wallshall’s-Algorithm"><a href="#5-4-1-Floyd-Wallshall’s-Algorithm" class="headerlink" title="5.4.1 Floyd-Wallshall’s Algorithm"></a>5.4.1 Floyd-Wallshall’s Algorithm</h4><p><strong>Floyd-Warshall算法</strong> 是一种经典的动态规划算法，用于解决所有点对最短路径问题。它可以在加权图中找出每一对顶点之间的最短路径，<em>即使图中包含负权重边</em>，只要没有负权重环路（即从某个顶点出发经过一些边又回到该顶点且路径总权重为负）。<u>京大知能</u>的一年过去问就考了这道题的手动迭代推理，在复习这个题的时候建议和京大的过去问配合看。</p><p><strong>算法步骤：</strong></p><ol><li><p>初始化：将距离矩阵$dist[][]$初始化为图的邻接矩阵。如果$i &#x3D;&#x3D; j$，则$dist[i][j] &#x3D; 0$，表示从节点$i$到节点$j$的路径距离为$0$。如果$i ≠ j$且两点之间有边，则$dist[i][j] &#x3D; weight(i, j)$，否则$dist[i][j]设为∞$（表示两点不直接相连）。</p></li><li><p>动态规划：通过三重循环逐步更新每对顶点之间的最短距离。外层循环选取一个中间顶点$k$，中间两层循环更新每一对顶点$i$和$j$之间的最短路径，判断是否通过$k$可以得到更短的路径。如果$dist[i][k] + dist[k][j] &lt; dist[i][j]$，则更新$dist[i][j]$。公式为：</p><div style="text-align: center;">$$dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])$$</div></li></ol><p><strong>时间复杂度：</strong><br>Floyd-Warshall算法的时间复杂度为$O(V³)$，其中$V$是图中顶点的数量。三重嵌套循环的每一层都依赖于顶点的数量，因此该算法适合顶点较少的图。对于边多（稠密图）且顶点数量不多的情况，它是一个有效的算法。<br><img src="/img/DSA/floyd.svg" alt="Floyd算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">floydWarshall</span><span class="token punctuation">(</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储最短路径</span>    <span class="token comment">// 初始化距离矩阵，将其设为输入图的邻接矩阵</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 三重循环：i是起点，j是终点，k是中间节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果从i通过k到j的路径更短，则更新dist[i][j]</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span>                     dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-5-Maximum-FLow-Problem"><a href="#5-5-Maximum-FLow-Problem" class="headerlink" title="5.5 Maximum FLow Problem"></a>5.5 Maximum FLow Problem</h3><p><strong>最大流问题</strong>是网络流理论中的一个经典问题，旨在寻找在一个流网络（或称为容量网络）中，从源点到汇点的最大可能流量。这个问题可以应用于很多实际场景，比如交通网络、物流系统、通信网络等。</p><p><strong>最大流问题</strong>的定义：</p><ol><li><p>流网络：由顶点集和边集组成的有向图，其中每条边都有一个非负的容量，表示能通过该边的最大流量。这个网络中有一个特定的顶点被称为源点（source），另一个顶点称为汇点（sink）。</p></li><li><p>流量：从源点到汇点传输的流称为流量。流量需要遵守以下两个条件：</p></li><li><p>容量限制：每条边上的流量不能超过该边的容量。</p></li><li><p>流量守恒：除了源点和汇点，其他顶点的流入流量与流出流量相等。</p></li></ol><p>本章只讲解Ford-Fulkerson算法，有余力可以再了解一下Edmonds-Karp算法和Push-Relabel算法。</p><h4 id="5-5-1-Ford-Fulkerson-Algorithm"><a href="#5-5-1-Ford-Fulkerson-Algorithm" class="headerlink" title="5.5.1 Ford-Fulkerson Algorithm"></a>5.5.1 Ford-Fulkerson Algorithm</h4><p>福特-福尔克森算法的核心思想是利用增广路径（Augmenting Path）来增加网络中的流量。增广路径是指在残余网络（Residual Network）中，从源点到汇点的一条路径，且路径上的每条边都有剩余容量（Residual Capacity）大于零。算法通过反复寻找这样的路径，并沿路径增加流量，直到没有增广路径为止。<br><img src="/img/DSA/ford.svg" alt="Ford-Fulkerson算法演示" style="max-width: 100%; height: auto;" /><br><strong>初始状态：</strong></p><p>如图所示，所有边的初始流量都为 0。我们的目标是找到从源点 S 到汇点 T 的最大流。</p><p><strong>第一次迭代：</strong></p><ul><li><strong>a.</strong> 找一条增广路径，例如：S -&gt; A -&gt; C -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 5（A 到 C 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 0&#x2F;10 \rightarrow 5&#x2F;10 \\<br>A \to C: &amp;\ 0&#x2F;5 \rightarrow 5&#x2F;5 \\<br>C \to T: &amp;\ 0&#x2F;9 \rightarrow 5&#x2F;9<br>\end{aligned}<br>$$</li></ul><p><strong>第二次迭代：</strong></p><ul><li><strong>a.</strong> 找另一条增广路径，例如：S -&gt; B -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 6（D 到 T 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to B: &amp;\ 0&#x2F;8 \rightarrow 6&#x2F;8 \\<br>B \to D: &amp;\ 0&#x2F;7 \rightarrow 6&#x2F;7 \\<br>D \to T: &amp;\ 0&#x2F;6 \rightarrow 6&#x2F;6<br>\end{aligned}<br>$$</li></ul><p><strong>第三次迭代：</strong></p><ul><li><strong>a.</strong> 找下一条增广路径，例如：S -&gt; A -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 3（A 到 D 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 5&#x2F;10 \rightarrow 8&#x2F;10 \\<br>A \to D: &amp;\ 0&#x2F;3 \rightarrow 3&#x2F;3 \\<br>D \to T: &amp;\ 6&#x2F;6 \text{（已满，无法增加）}<br>\end{aligned}<br>$$</li></ul><p><strong>算法终止：</strong><br>此时，我们无法找到从 S 到 T 的更多增广路径。所有通向 T 的边都已经满了：</p><ul><li>$C \to T: 5&#x2F;9$</li><li>$D \to T: 6&#x2F;6$</li></ul><p><strong>计算最大流：</strong><br>最大流等于从源点出发的所有流量之和：<br>$$<br>8\ (\text{S} \to \text{A}) + 6\ (\text{S} \to \text{B}) &#x3D; 14<br>$$<br>也等于进入汇点的所有流量之和：<br>$$<br>5\ (\text{C} \to \text{T}) + 6\ (\text{D} \to \text{T}) &#x3D; 11<br>$$</p><p><strong>最终结果：</strong></p><ul><li>最大流值为 14</li><li>S -&gt; A -&gt; C -&gt; T 路径上流量为 5</li><li>S -&gt; B -&gt; D -&gt; T 路径上流量为 6</li><li>S -&gt; A -&gt; D -&gt; T 路径上流量为 3</li></ul><p>Ford-Fulkerson 算法的核心思想是不断寻找增广路径并增加流量，直到无法找到更多的增广路径为止。每次找到增广路径后，我们都会更新网络中的流量，直到达到最大流。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">function FordFulkerson<span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 初始化残余图    ResidualGraph Gf <span class="token operator">=</span> CreateResidualGraph<span class="token punctuation">(</span>G<span class="token punctuation">)</span>        <span class="token operator">//</span> 初始化最大流为<span class="token number">0</span>    maxFlow <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> true<span class="token punctuation">:</span>        <span class="token operator">//</span> 在残余图中寻找增广路径        Path augmentingPath <span class="token operator">=</span> FindAugmentingPath<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>                <span class="token operator">//</span> 如果没有找到增广路径，算法终止        <span class="token keyword">if</span> augmentingPath <span class="token keyword">is</span> empty<span class="token punctuation">:</span>            <span class="token keyword">break</span>                <span class="token operator">//</span> 找到增广路径上的最小残余容量        minResidualCapacity <span class="token operator">=</span> FindMinResidualCapacity<span class="token punctuation">(</span>augmentingPath<span class="token punctuation">)</span>                <span class="token operator">//</span> 更新残余图        UpdateResidualGraph<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> augmentingPath<span class="token punctuation">,</span> minResidualCapacity<span class="token punctuation">)</span>                <span class="token operator">//</span> 增加最大流        maxFlow <span class="token operator">=</span> maxFlow <span class="token operator">+</span> minResidualCapacity        <span class="token keyword">return</span> maxFlowfunction FindAugmentingPath<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 使用DFS或BFS寻找从source到sink的路径    <span class="token operator">//</span> 返回找到的路径，如果没有路径则返回空function FindMinResidualCapacity<span class="token punctuation">(</span>Path augmentingPath<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 遍历路径，找到最小的残余容量    <span class="token operator">//</span> 返回最小残余容量function UpdateResidualGraph<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Path augmentingPath<span class="token punctuation">,</span> <span class="token builtin">int</span> minResidualCapacity<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> augmentingPath<span class="token punctuation">:</span>        <span class="token operator">//</span> 减少正向边的残余容量        Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-</span> minResidualCapacity        <span class="token operator">//</span> 增加反向边的残余容量        Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> minResidualCapacityfunction CreateResidualGraph<span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 创建一个与原图结构相同的残余图    <span class="token operator">//</span> 初始化残余容量等于原图的容量    <span class="token operator">//</span> 为每条边添加一条初始容量为<span class="token number">0</span>的反向边    <span class="token operator">//</span> 返回创建的残余图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="6-Greedy-Algorithm"><a href="#6-Greedy-Algorithm" class="headerlink" title="6. Greedy Algorithm"></a>6. Greedy Algorithm</h2><p><strong>贪心算法</strong>是一种算法设计范式，其核心思想是：在解决问题时，总是做出在当前状态下看起来最优的选择，即局部最优解，希望通过一系列这样的选择能够最终得到全局最优解。这个算法理解起来非常直观，但是合理性证明的话需要严格的数学证明。本章着重讲解最经典的<strong>最大子序和问题（Maximum Subarray）</strong> 和<strong>合并区间问题（Merge Intervals）</strong></p><h3 id="6-1-Maximum-Subarray"><a href="#6-1-Maximum-Subarray" class="headerlink" title="6.1 Maximum Subarray"></a>6.1 Maximum Subarray</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/maximum-subarray/description/">Leetcode 53题</a>练习。</p><blockquote><p>问题描述是：Given an integer array nums, find the subarray with the largest sum, and return its sum.</p></blockquote><p><strong>Example 1:</strong></p><ul><li><p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p></li><li><p>Output: 6</p></li><li><p>Explanation: The subarray [4,-1,2,1] has the largest sum 6.</p></li></ul><p>解决这个问题的贪心算法也叫Kadane算法：算法从左到右遍历一次数组，在每一步，它都计算当前位置结束的子数组的最大和（Current Sum）同时，它保持追踪全局的最大和（Max Sum）。最终，Max Sum的最后一个值就是整个问题的解。<br><img src="/img/DSA/kadane.svg" alt="kadane算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            curSum <span class="token operator">+=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> curSum <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 贪心地取子数组最大值</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> maxSum <span class="token operator">=</span> curSum<span class="token punctuation">;</span> <span class="token comment">// 不断更新结果</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="6-2-Merge-Intervals"><a href="#6-2-Merge-Intervals" class="headerlink" title="6.2 Merge Intervals"></a>6.2 Merge Intervals</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/merge-intervals/description/">Leetcode 56题</a>练习。</p><blockquote><p>题目描述：Given an array of intervals where $\text{intervals}[i] &#x3D; [\text{start}_i, \text{end}_i]$, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p></blockquote><p><strong>Example 1:</strong></p><p>Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</p><p>Output: [[1,6],[8,10],[15,18]]</p><p>Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</p><p>解决这道题的思路是：先排序让所有相邻的区间尽可能重合在一起(以开端最小优先，其次结尾最小次之)，然后一次遍历贪心地选择局部最优解。<br><img src="/img/DSA/merge.svg" alt="合并区间算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 重载cmp函数，让区间的排列以开端最小优先，其次结尾最小优先</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 贪心地选择是否合并区间</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 若不重合，则加入结果数组</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 若重合，则合并区间并贪心的选择区间结尾</span>            <span class="token keyword">else</span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="7-Dynamic-Programming"><a href="#7-Dynamic-Programming" class="headerlink" title="7. Dynamic Programming"></a>7. Dynamic Programming</h2><p><strong>动态规划（Dynamic Programming, DP）</strong> 是一种用于解决最优化问题的算法设计技巧。它通过将问题分解为更小的子问题，并记录其解来<u>避免重复计算</u>，从而提高算法的效率。本章主要讲解5个经典DP问题：<em>斐波那契数列</em>，<em>背包问题</em>，<em>股票问题</em>，<em>最长公共子序列</em>，以及<em>序列比对问题</em>。</p><h3 id="7-1-Fibonacci-Sequence"><a href="#7-1-Fibonacci-Sequence" class="headerlink" title="7.1 Fibonacci Sequence"></a>7.1 Fibonacci Sequence</h3><p>形如：$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ….$的数列称之为斐波那契数，我们可以很轻易地得到递归式：$dp[n] &#x3D; dp[n-1] + dp[n-2]$,然后我们再对递归式子进行初始化：$dp[0] &#x3D; 1, dp[1] &#x3D; 1$, 我们就可以利用递归式求得所有的斐波那契数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-2-Knapsack-Problem"><a href="#7-2-Knapsack-Problem" class="headerlink" title="7.2 Knapsack Problem"></a>7.2 Knapsack Problem</h3><p>关于背包问题有三种：0-1背包，完全背包，多重背包。应对修考我认为掌握0-1背包问题就足够了。关于0-1背包的问题描述是：</p><ol><li>一组物品，每个物品都有一个重量和一个价值。</li><li>一个背包，具有固定的容量。</li></ol><p>给定$n$个物品，每个物品$i$具有重量$w[i]$和价值$v[i]$，还有一个背包的最大容量$W$。目标是选择物品的组合，使得在不超过背包容量的情况下，背包中的物品总价值最大。</p><p><strong>1.定义状态：</strong> $dp[i][j]$表示在考虑前$i$个物品，且背包容量为$j$时的最大价值。</p><p><strong>2.状态转移方程：</strong> 对于每个物品$i$，有两个选择：</p><ul><li>不放入背包：此时最大价值为$dp[i-1][j]$。</li><li>放入背包：此时最大价值为$dp[i-1][j - w[i]] + v[i]$，前提是当前物品的重量不超过背包容量 $j &gt;&#x3D; w[i]$。</li></ul><p>因此，状态转移方程为：<br>$$<br>dp[i][j] &#x3D; \begin{cases}<br>dp[i-1][j] &amp; \text{if } j &lt; w[i] \\<br>\max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]) &amp; \text{if } j \geq w[i]<br>\end{cases}<br>$$</p><p><strong>3.边界条件：</strong></p><ul><li>当没有物品可选时，最大价值为$0$，即 $(dp[0][j] &#x3D; 0)$。</li><li>当背包容量为$0$时，最大价值也为$0$，即 $(dp[i][0] &#x3D; 0)$。</li></ul><p><strong>4.计算顺序：</strong></p><p>先遍历物品再遍历背包更容易理解，从 $(i &#x3D; 1)$到 $(n)$，对于每个物品，再从 $(j &#x3D; 0)$到$(W)$计算。当然也可以先遍历背包再遍历物品，这里不过多赘述。</p><p><strong>5.返回结果：</strong> 最终的最大价值为 $(dp[n][W])$。</p><p>假设有以下物品和背包容量：</p><ul><li>物品 1：重量 &#x3D; 2，价值 &#x3D; 3</li><li>物品 2：重量 &#x3D; 3，价值 &#x3D; 4</li><li>物品 3：重量 &#x3D; 4，价值 &#x3D; 5</li><li>物品 4：重量 &#x3D; 5，价值 &#x3D; 6</li></ul><p>背包容量为 5。<br><img src="/img/DSA/01knapsnack.svg" alt="01背包遍历演示" style="max-width: 100%; height: auto;" /></p><p>遍历的核心代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> W<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 装不下的情况</span>            <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装下的情况</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-3-Stock-Problem"><a href="#7-3-Stock-Problem" class="headerlink" title="7.3 Stock Problem"></a>7.3 Stock Problem</h3><p>股票问题有很多种，这里介绍一种，参考<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">Leetcode 122题</a>。题目描述是：</p><blockquote><p>You are given an integer array $prices$ where $prices[i]$ is the price of a given stock on the ith day. On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold <u>at most one share </u> of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: prices &#x3D; [7,1,5,3,6,4]</li><li>Output: 7</li><li>Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.<br>Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.<br>Total profit is 4 + 3 &#x3D; 7.<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// have the stock on the day 0;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token comment">// no stock on the day 0;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// no stock on the day n - 1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul><p><strong>初始状态：</strong></p><p><code>dp[0][0] = -prices[0]</code>：表示在第$0$天买入股票后的利润，利润为负的股票价格。<br><code>dp[0][1] = 0</code>：表示在第$0$天没有持有股票，利润为$0$。</p><p><strong>状态转移：</strong></p><blockquote><p><strong>对于第$i$天，持有股票的状态 <code>dp[i][0]</code>，有两种可能：</strong></p></blockquote><ul><li>前一天已经持有股票，保持不动：<code>dp[i-1][0]</code>。  </li><li>前一天没有持有股票，但今天买入：<code>dp[i-1][1] - prices[i]</code>（买入股票，减去当天股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])</code>。</p><blockquote><p><strong>对于第$i$天，不持有股票的状态 <code>dp[i][1]</code>，也有两种可能：</strong></p></blockquote><ul><li>前一天已经不持有股票，保持不动：<code>dp[i-1][1]</code>。  </li><li>前一天持有股票，但今天卖出：<code>dp[i-1][0] + prices[i]</code>（卖出股票，得到当前股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</code>。</p><p><strong>最终结果：</strong> 返回 <code>dp[n-1][1]</code>，表示最后一天不持有股票的最大利润。</p><h3 id="7-4-Longest-Common-Subsequence"><a href="#7-4-Longest-Common-Subsequence" class="headerlink" title="7.4 Longest Common Subsequence"></a>7.4 Longest Common Subsequence</h3><p><strong>最长公共子序列（LCS）</strong> 也是修考的一个常考点，具体参考：<a href="https://leetcode.com/problems/longest-common-subsequence/description/">Leetcode 1143</a></p><blockquote><p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”. A common subsequence of two strings is a subsequence that is common to both strings.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: text1 &#x3D; “abcde”, text2 &#x3D; “ace” </li><li>Output: 3  </li><li>Explanation: The longest common subsequence is “ace” and its length is 3.</li></ul><p><strong>定义状态：</strong></p><p>$$<br>dp[i][j] \text{ 表示在考虑前 } i \text{ 个字符的 } \text{text1} \text{ 和前 } j \text{ 个字符的 } \text{text2} \text{ 时的最长公共子序列的长度。}<br>$$</p><p><strong>状态转移方程：</strong></p><p>对于每个字符对<code>text1[i-1] </code> 和<code>text2[j-1]</code>，有两种情况：</p><ul><li>如果 <code>&#39;text1[i-1] == text2[j-1]&#39;</code>，说明这两个字符相同，最长公共子序列可以延长 1，此时 <code>&#39;dp[i][j] = dp[i-1][j-1] + 1&#39;</code>。</li><li>如果 <code>&#39;text1[i-1] != text2[j-1]&#39;</code>，则取决于之前的子问题结果，最长公共子序列为：<ul><li>不包括当前字符：<code>&#39;dp[i][j] = max(dp[i][j-1], dp[i-1][j])&#39;</code>。</li></ul></li></ul><p><strong>边界条件：</strong></p><ul><li>当 <code>&#39;i = 0&#39;</code> 或 <code>&#39;j = 0&#39;</code> 时，即有一个字符串为空，最长公共子序列长度为 0，所以初始化时 <code>&#39;dp[0][j] = 0&#39;</code> 和 <code>&#39;dp[i][0] = 0&#39;</code>。</li></ul><p><strong>计算顺序：</strong></p><p>从 <code>&#39;i = 1&#39;</code> 到 <code>&#39;n&#39;</code>，对于每个字符，再从 <code>&#39;j = 1&#39;</code> 到 <code>&#39;m&#39;</code> 计算 <code>&#39;dp[i][j]&#39;</code>，逐步构建整个表。</p><p><strong>返回结果：</strong></p><p>最终结果为 <code>&#39;dp[n][m]&#39;</code>，即考虑所有字符的最长公共子序列的长度。<br><img src="/img/DSA/lcs.svg" alt="LCS遍历演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-5-Sequence-Alignment"><a href="#7-5-Sequence-Alignment" class="headerlink" title="7.5 Sequence Alignment"></a>7.5 Sequence Alignment</h3><p><strong>序列比对（Sequence Alignment）</strong> 是生物信息学中的一个核心问题，用于比较两个或多个生物序列（如DNA、RNA或蛋白质）的相似性。其目的是通过对比序列中的元素（碱基或氨基酸）找出它们之间的最优匹配方式，进而揭示它们的进化关系、功能相似性或结构上的保守性。</p><h4 id="7-5-1-Needleman–Wunsch-algorithm"><a href="#7-5-1-Needleman–Wunsch-algorithm" class="headerlink" title="7.5.1 Needleman–Wunsch algorithm"></a>7.5.1 Needleman–Wunsch algorithm</h4><p>Needleman-Wunsch算法是用于进行全局序列比对的经典算法，特别适用于对比两个生物序列（如DNA、RNA或蛋白质）时，将它们的整个序列进行对齐。它采用动态规划的思想来寻找两个序列的最优对齐方式。<br><img src="/img/DSA/needle.svg" alt="序列比对算法演示" style="max-width: 100%; height: auto;" /></p><p><strong>Needleman-Wunsch算法步骤：</strong></p><p><strong>定义状态：</strong></p><p>设有两个序列 <code>A</code> 和 <code>B</code>，长度分别为 <code>n</code> 和 <code>m</code>。<br>创建一个大小为 <code>(n+1) x (m+1)</code> 的二维矩阵 <code>dp</code>，其中 <code>dp[i][j]</code> 表示序列 <code>A</code> 的前 <code>i</code> 个字符与序列 <code>B</code> 的前 <code>j</code> 个字符的最优对齐得分。</p><p><strong>罚分机制：</strong></p><ul><li><strong>匹配</strong>：当 <code>A[i-1] == B[j-1]</code> 时，表示两个字符相同，得分为 <code>match score</code>。</li><li><strong>不匹配</strong>：当 <code>A[i-1] != B[j-1]</code> 时，表示两个字符不同，得分为 <code>mismatch penalty</code>。</li><li><strong>Gap</strong>：当在序列 <code>A</code> 或 <code>B</code> 中插入一个字符时，得分为 <code>gap penalty</code>。</li></ul><p><strong>初始化：</strong></p><ul><li>第一行和第一列表示序列与空序列的比对。比对空序列时，每个字符都需要插入或删除，因此使用缺口罚分（gap penalty）。</li><li>初始化 <code>dp[0][0] = 0</code>，代表两个空序列的得分为 0。</li><li>初始化第一行：<code>dp[0][j] = j * gap penalty</code>，表示序列 <code>B</code> 的前 <code>j</code> 个字符与空序列的比对得分。</li><li>初始化第一列：<code>dp[i][0] = i * gap penalty</code>，表示序列 <code>A</code> 的前 <code>i</code> 个字符与空序列的比对得分。</li></ul><p><strong>状态转移方程：</strong>对于矩阵中的每个 <code>dp[i][j]</code>，有三种可能的情况：</p><ol><li><strong>匹配</strong>：如果 <code>A[i-1] == B[j-1]</code>，即两个字符相同，则可以匹配，得分为 <code>dp[i-1][j-1] + match score</code>。</li><li><strong>不匹配</strong>：如果 <code>A[i-1] != B[j-1]</code>，则可以进行替换，得分为 <code>dp[i-1][j-1] + mismatch penalty</code>。</li><li><strong>插入&#x2F;删除（Gap）</strong>：在序列 <code>A</code> 或 <code>B</code> 中插入一个字符，得分为 <code>dp[i][j-1] + gap penalty</code> 或 <code>dp[i-1][j] + gap penalty</code>。</li></ol><p>取这三种操作中的最大值更新 <code>dp[i][j]</code>，即：</p><p>$$<br>dp[i][j] &#x3D; \max\left(dp[i-1][j-1] + \text{(match&#x2F;mismatch score)}, dp[i-1][j] + \text{gap penalty}, dp[i][j-1] + \text{gap penalty}\right)<br>$$</p><p><strong>回溯：</strong>填完矩阵后，从右下角 <code>dp[n][m]</code> 开始回溯，找出最优路径，从而得到序列 <code>A</code> 和 <code>B</code> 的最优全局对齐方案。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化：处理空序列的情况</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一列，表示A的前i个字符和空序列的比对</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一行，表示B的前j个字符和空序列的比对</span><span class="token comment">// 填充 dp 表</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 匹配或不匹配的情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符相等，则进行匹配，加上 match_score</span>            <span class="token keyword">int</span> match <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> match_score<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符不相等，则进行替换，加上 mismatch_penalty</span>            <span class="token keyword">int</span> mismatch <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> mismatch_penalty<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 2. 插入的情况</span>        <span class="token keyword">int</span> insert <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 在序列 A 中插入 gap</span>        <span class="token comment">// 3. 删除的情况</span>        <span class="token keyword">int</span> del <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>     <span class="token comment">// 在序列 B 中插入 gap</span>                <span class="token comment">// 取三种操作的最大值来更新 dp[i][j]</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> match_score <span class="token operator">:</span> mismatch_penalty<span class="token punctuation">)</span><span class="token punctuation">,</span> insert<span class="token punctuation">,</span> del<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 最终结果是 dp[n][m]，表示A和B的最优全局比对得分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="8-P-NP-problem"><a href="#8-P-NP-problem" class="headerlink" title="8. P&#x2F;NP problem"></a>8. P&#x2F;NP problem</h2><p><strong>P&#x2F;NP问题</strong> 是计算机科学中的一个核心难题，涉及确定哪些问题可以在合理的时间内（多项式时间）被解决，和哪些问题的解可以在合理的时间内被验证。它是理论计算机科学和数学中最著名、最重要的未解决问题之一。</p><p><strong>P类问题</strong></p><p>P类问题（Polynomial time）指的是那些可以在多项式时间内被解决的问题。也就是说，给定一个问题实例，使用某种算法可以在输入规模为 $n$ 时，用 $n^k$（其中 $k$ 是一个常数）次运算步骤就可以得到结果。</p><ul><li><p>例如，常见的排序算法（如快速排序）和图论中的最短路径算法（如Dijkstra算法）都是 <strong>P类问题</strong>。它们的时间复杂度是多项式级别的。</p></li><li><p><strong>直观理解</strong>：如果一个问题属于P类，那么它是“容易”解决的，因为我们可以用有效的算法在合理的时间内求解。</p></li></ul><p><strong>NP类问题</strong></p><p>NP类问题（Nondeterministic Polynomial time）是指那些解可以在多项式时间内被验证的问题，尽管可能没有已知的多项式时间算法来找到这个解。</p><ul><li><p>也就是说，如果我们猜测出一个解，可以在多项式时间内检查这个解是否正确。但是，要找到这个解可能会很难，甚至没有已知的多项式时间算法来求解。</p></li><li><p><strong>经典的NP问题</strong> 包括旅行商问题（TSP）、背包问题和布尔可满足性问题（SAT）。这些问题的特点是验证解很容易，但找到最优解可能非常耗时。</p></li></ul><p><strong>P与NP的关系</strong></p><ul><li><p><strong>P是否属于NP？</strong></p><ul><li><p>P类问题显然也是NP类问题。如果我们能够在多项式时间内求解一个问题，那我们一定也能在多项式时间内验证这个解。</p></li><li><p>因此可以得出结论：<strong>P是NP的一个子集</strong>，即 $P \subseteq NP$。</p></li></ul></li><li><p><strong>P与NP的区别</strong></p><ul><li>关键在于我们还不确定 <strong>P类问题</strong> 和 <strong>NP类问题</strong> 是否是同一个集合。这就是 <strong>P vs NP</strong> 问题的核心所在：<ul><li>如果 $P &#x3D; NP$，那么所有能在多项式时间内验证的解也可以在多项式时间内求解。</li><li>如果 $P \neq NP$，那么有一些问题能在多项式时间内验证解，但没有已知的多项式时间算法来求解它们。</li></ul></li></ul></li></ul><p><strong>NP完全问题（NP-Complete）</strong></p><p>NP完全问题（NP-Complete, NPC）是NP类问题中的一个特殊子集，它们有两个重要的特性：</p><ol><li>它们本身是NP类问题。</li><li>任何一个NP类问题都可以通过多项式时间的归约（转换）转换为这个NP完全问题。</li></ol><ul><li><p><strong>重要性</strong>：如果你能找到一个NP完全问题的多项式时间解法，那么所有的NP问题都可以在多项式时间内解决。因此，NP完全问题是NP类问题中的“最难问题”。</p></li><li><p><strong>典型的NP完全问题</strong>：</p><ul><li>旅行商问题（TSP）：寻找一条经过每个城市恰好一次且路径最短的旅行路线。</li><li>3-SAT问题：判断一个布尔公式是否有解。</li><li>顶点覆盖问题：在一个图中找到最小的顶点集合，使得每条边至少有一个顶点被覆盖。</li></ul></li></ul><p><strong>P vs NP问题</strong></p><p>P vs NP问题是指：<strong>P是否等于NP？</strong></p><ul><li><p>如果 <strong>P &#x3D; NP</strong>，意味着所有NP问题都有多项式时间的求解算法。这将意味着大量的难问题（如密码学中的问题）可以被快速解决。</p></li><li><p>如果 <strong>P ≠ NP</strong>，那么一些问题的解可以快速验证，但无法快速求解。</p></li></ul><p>目前，这个问题尚未解决，它是 <strong>“千禧年大奖问题”</strong> 之一，美国克雷数学研究所为解决这个问题悬赏 <strong>100万美元</strong>。</p><p><strong>总结</strong></p><ul><li><strong>P类问题</strong>：可以在多项式时间内求解。</li><li><strong>NP类问题</strong>：可以在多项式时间内验证解，但不一定能在多项式时间内求解。</li><li><strong>P vs NP问题</strong>：我们不知道所有可以快速验证的解是否也可以快速求解，即是否 $P &#x3D; NP$。</li></ul><h2 id="9-偷偷说"><a href="#9-偷偷说" class="headerlink" title="9.偷偷说"></a>9.偷偷说</h2><p>本文应该囊括了修考绝大部分的考点了，当然还有双指针和滑动窗口，哈希之类的算法技巧我觉得就不用大费周章地写下来了。做修考题我认为最重要的是阅读伪代码的能力！希望这篇文章可以帮助到修考受验生们。完结撒花🎉</p><div class="note note-success">            <p>偷偷目前兼任私塾班主任，如果需要1对1辅导，请联系：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語勉強</title>
    <link href="/2024/09/10/JPN/"/>
    <url>/2024/09/10/JPN/</url>
    
    <content type="html"><![CDATA[<h3 id="1-〜あっての"><a href="#1-〜あっての" class="headerlink" title="1.〜あっての"></a>1.〜あっての</h3><div class="note note-success">            <p>説明：あるものが存在するのは他のもののおかげであることを強調する表現です。名詞 + あっての + 名詞</p>          </div><p>健康あっての人生なんだから、体調管理には十分気をつけなさい。</p><p>家族の支えがあったからこそ成功できた。</p><h3 id="2-以外の何ものでもない。"><a href="#2-以外の何ものでもない。" class="headerlink" title="2.~以外の何ものでもない。"></a>2.~以外の何ものでもない。</h3><div class="note note-success">            <p>「Aが唯一の理由・原因である」という意味になります。</p>          </div><p>この結果は偶然以外の何ものでもない。</p><h3 id="3-〜いかんで-いかんでは"><a href="#3-〜いかんで-いかんでは" class="headerlink" title="3.〜いかんで&#x2F;いかんでは"></a>3.〜いかんで&#x2F;いかんでは</h3><div class="note note-success">            <p>どちらも「〜によって」「〜次第で」という意味を持ち、前の事柄によって後の結果が変わることを示す表現です。ただし、微妙なニュアンスの違いがあります。</p>          </div><p>天候いかんでは、収穫は全てできないこともある。</p><h3 id="4-～いかんに関わらず・いかんによらず・いかんをとわず"><a href="#4-～いかんに関わらず・いかんによらず・いかんをとわず" class="headerlink" title="4.～いかんに関わらず・いかんによらず・いかんをとわず"></a>4.～いかんに関わらず・いかんによらず・いかんをとわず</h3><div class="note note-success">            <p>「〜に関係なく」や「〜にかかわらず」と同じ意味で使われます。つまり、ある条件や状況に影響されずに、という意味です。</p>          </div><p>成績いかんに関わらず、全員が参加できます。</p><h3 id="5-いざ〜となると・いざ〜となれば・いざ〜となったら"><a href="#5-いざ〜となると・いざ〜となれば・いざ〜となったら" class="headerlink" title="5.いざ〜となると・いざ〜となれば・いざ〜となったら"></a>5.いざ〜となると・いざ〜となれば・いざ〜となったら</h3><div class="note note-success">            <p>いずれも「実際にその状況になったら」という意味で使われます。これらの表現は、ある状況が現実になったときにどうなるか、ということを強調するために使われます。</p>          </div><p>いざ出発となれば、準備が整っていないことに気づく。</p><h3 id="6-〜言わずもがな"><a href="#6-〜言わずもがな" class="headerlink" title="6.〜言わずもがな"></a>6.〜言わずもがな</h3><div class="note note-success">            <p>「〜言わずもがな」という表現は、「言うまでもなく」や「言わなくてもわかる」という意味で使われます。つまり、あることが非常に明白であるため、わざわざ言う必要がないということを強調する表現です。</p>          </div><p>彼の才能は言わずもがな、誰もが認めるところだ。</p><h3 id="7-限りだ"><a href="#7-限りだ" class="headerlink" title="7. ~限りだ"></a>7. ~限りだ</h3><div class="note note-success">            <p>「〜限りだ」という表現は、感情や感覚を強調するために使われます。特に、感動や驚き、悲しみなどの強い感情を表現する際に用いられます。</p>          </div><p>嬉しい限りだ。</p><h3 id="8-かたがた"><a href="#8-かたがた" class="headerlink" title="8.~かたがた"></a>8.~かたがた</h3><div class="note note-success">            <p>「〜しながら」「〜と同時に」という意味：<br>ある行動をしながら、同時に別の目的も果たすことを表します。<br>例：</p>          </div><p>散歩かたがた買い物に行く。<br>(散歩をしながら買い物もする)</p><div class="note note-success">            <p>「〜のついでに」「〜を機会に」という意味：<br>ある行動や状況を利用して、ついでに別のことも行うことを表します。</p>          </div><p>東京出張かたがた友人に会ってきた。<br>(東京への出張を機会に友人にも会った)</p><h3 id="9-かたわら"><a href="#9-かたわら" class="headerlink" title="9. ~かたわら"></a>9. ~かたわら</h3><div class="note note-success">            <p>主な活動や仕事をしながら、同時に別の活動も行うことを表します。</p>          </div><p>教師のかたわら、小説を執筆している。</p><h3 id="10-がてら"><a href="#10-がてら" class="headerlink" title="10.~がてら"></a>10.~がてら</h3><div class="note note-success">            <p>「〜のついでに」「〜と同時に」<br>ある行動をする際に、ついでに別の行動も同時に行うことを表します。主な目的とは別の、副次的な行動を示すのに使われます。</p>          </div><p>散歩がてら、近所の様子を見て回りました。</p><h3 id="11-からある・からする・からの"><a href="#11-からある・からする・からの" class="headerlink" title="11.~からある・からする・からの"></a>11.~からある・からする・からの</h3><div class="note note-success">            <p>强调大，多，重，长等。<br>「からある」前面表示数量，长度，大小，高矮等数量名词；[からする]前面多用表示金额的量词；[からの]前面多表示人物的数量词。</p>          </div><p>１００キロからある荷物を三階まで運ぶには、足腰の強い人が三人は必要だ。</p><p>彼女は４０億からする遺産を相続したそうだ。</p><p>今日のスピーチ大会は５００人からの人が集まった。</p><h3 id="12-始末だ"><a href="#12-始末だ" class="headerlink" title="12.~始末だ"></a>12.~始末だ</h3><div class="note note-success">            <p>「ひどい状態だ」「困った事態だ」「始末に負えない」といった否定的な状況を表現します。<br>話者の失望、困惑、あるいは軽蔑の気持ちを含むことが多いです。</p>          </div><p>彼は借金を重ね、今では家も売らなければならない始末だ。</p><h3 id="13-～ずくめ"><a href="#13-～ずくめ" class="headerlink" title="13.～ずくめ"></a>13.～ずくめ</h3><div class="note note-success">            <p>「～ずくめ」は日本語の文法表現で、「全て～ばかりである」という意味を表します。この表現は、ある特定の性質や状態が全体的に存在することを強調するために使われます。</p>          </div><p>この本は難しい言葉ずくめで、読むのが大変だ。</p><p>彼女の服装は黒ずくめだった。</p><h3 id="14-〜ずじまいだ"><a href="#14-〜ずじまいだ" class="headerlink" title="14.〜ずじまいだ"></a>14.〜ずじまいだ</h3><div class="note note-success">            <p>「〜ずじまいだ」は「〜ずじまい」という表現の丁寧な形です。この表現は、ある行動や状態が最後まで続いて終わることを意味します。主に否定的なニュアンスで使われることが多いです。</p>          </div><p>忙しいくて、結局休暇を取る図じまいだった。</p><p>締め切りに追われて、計画を見直すずじまいだった。</p><h3 id="15-ずにはおかない"><a href="#15-ずにはおかない" class="headerlink" title="15.~ずにはおかない"></a>15.~ずにはおかない</h3><div class="note note-success">            <p>「必ず〜する」「〜せずにはいられない」という強い意志や必然性を表します。</p>          </div><p>この素晴らしい景色を見たら、誰も感動せずにはおかない。</p><p>彼女の熱意は、周りの人々に影響を与えずにはおかないだろう。</p><h3 id="16-術がない"><a href="#16-術がない" class="headerlink" title="16.~術がない"></a>16.~術がない</h3><div class="note note-success">            <p>意味:<br>「〜する方法がない」「〜する手段がない」「〜するすべがない」</p>          </div><p>締め切りに間に合わせる術がなく、締めるしかなっかた。</p><p>彼女を説得する術がないので、このまま計画を進めるしかない。</p><h3 id="17-そびれる"><a href="#17-そびれる" class="headerlink" title="17.~そびれる"></a>17.~そびれる</h3><div class="note note-success">            <p>意味:<br>「〜するチャンスを逃す」「〜し損ねる」「うっかり〜し忘れる」</p>          </div><p>興味深い展覧会があったのに、行きそびれてしまった。</p><p>大切な約束を確認しそびれて、すっかり忘れてしまった。</p><h3 id="18-たところで"><a href="#18-たところで" class="headerlink" title="18.~たところで"></a>18.~たところで</h3><div class="note note-success">            <p>意味:「〜たところで」は「〜しても、結局」や「〜したとしても、それでも」という意味を表します。</p>          </div><p>急いだところで、もう間に合わないだろう。</p><p>お金をたくさん持っているところで、幸せになれるとは限らない。</p><h3 id="19-てしかるべきだ"><a href="#19-てしかるべきだ" class="headerlink" title="19.~てしかるべきだ"></a>19.~てしかるべきだ</h3><div class="note note-success">            <p>意味：「〜するのが当然だ」「〜するのが適切だ」という意味を表します。話者の強い意見や判断を示す表現です。</p>          </div><p>法律を守ってしかるべきだ。</p><p>その問題については、専門家に相談してしかるべきだ。</p><h3 id="20-て憚らない"><a href="#20-て憚らない" class="headerlink" title="20.~て憚らない"></a>20.~て憚らない</h3><div class="note note-success">            <p>意味：遠慮せずに～する」「ためらわずに～する」「大胆に～する」</p>          </div><p>意見を述べて憚らない。</p><p>新しいアイデアを提案して憚らない。</p><h3 id="21-てはかなわない"><a href="#21-てはかなわない" class="headerlink" title="21.~てはかなわない"></a>21.~てはかなわない</h3><div class="note note-success">            <p>「〜するのは困る」や「〜するのは耐えられない」という意味を表す表現です。「かなわない」は「対抗できない」「負ける」「耐えられない」といったニュアンスを持ちます。</p>          </div><p>この騒音では寝てはかなわない。</p><p>彼女は泣かれてはかなわない。</p><h3 id="22-ても差し支えない"><a href="#22-ても差し支えない" class="headerlink" title="22.~ても差し支えない"></a>22.~ても差し支えない</h3><div class="note note-success">            <p>「問題ない」や「大丈夫」といった意味を表します。</p>          </div><p>書類は明日提出しても差し支えありません。</p><p>会議中に退席しても差し支えないでしょうか。</p><h3 id="23-てもともとだ"><a href="#23-てもともとだ" class="headerlink" title="23.~てもともとだ"></a>23.~てもともとだ</h3><div class="note note-success">            <p>「~てもともとだ」は、ある状況や条件が変わっても、結果は変わらないことを強調するときに使われます。つまり、何かが起こったとしても、本質的には何も変わらないという意味合いを持ちます。</p>          </div><p>彼が来なくてもともとだ。</p><p>だめでもともとだから、思い切って彼女に告白してみた。</p><h3 id="24-ても始まらない"><a href="#24-ても始まらない" class="headerlink" title="24.~ても始まらない"></a>24.~ても始まらない</h3><div class="note note-success">            <p>「たとえ〜をしても、何も良い結果は生まれない」「〜をしても意味がない」</p>          </div><p>今から後悔しても始まらない。</p><p>言い訳をしても始まらないよ。</p><h3 id="25-～てやまない"><a href="#25-～てやまない" class="headerlink" title="25.～てやまない"></a>25.～てやまない</h3><div class="note note-success">            <p>ある行動や状態が継続的に行われていることを強調する表現です。</p>          </div><p>結婚する二人の今後の幸せを願ってやまない。</p><p>真実を追求してやまない。</p><h3 id="26-か-と思いきや"><a href="#26-か-と思いきや" class="headerlink" title="26.~(か)と思いきや"></a>26.~(か)と思いきや</h3><div class="note note-success">            <p>「予想や期待とは異なり、意外な結果になって」</p>          </div><p>晴れると思いきや、突然雨が降り出した。</p><p>彼女は怒ると思いきや、意外にも笑顔で許してくれた。</p><h3 id="27-〜ともなく"><a href="#27-〜ともなく" class="headerlink" title="27.〜ともなく"></a>27.〜ともなく</h3><div class="note note-success">            <p>「〜ともなく」という表現は、意識せずに行動をしている様子や、特定の対象や理由がないことを表す日本語の文法表現です。</p>          </div><p>聞くともなく隣の会話が耳に入った。</p><p>電車の窓から外を見るともなく、高校時代の同級生の姿が目に入った。</p><h3 id="28-〜ならいざしらず"><a href="#28-〜ならいざしらず" class="headerlink" title="28.〜ならいざしらず"></a>28.〜ならいざしらず</h3><div class="note note-success">            <p>「〜なら問題ないが、そうでないなら問題だ」「〜なら仕方がないが、そうでないなら受け入れられない」といった意味で使います。</p>          </div><p>小学生ならいざしらず、大学生はこの漢字を知らないのは問題だ。</p><p>新入社員ならいざしらず、入社8年にもなる君がこんなミスをするとは信じられない。</p><h3 id="29-にはあたらない"><a href="#29-にはあたらない" class="headerlink" title="29.~にはあたらない"></a>29.~にはあたらない</h3><div class="note note-success">            <p>意味: 「〜する必要はない」「〜するほどのことではない」といった意味で使われ、感情的な反応や評価を避けるときに用います。</p>          </div><p>彼なりにできるだけの努力をしたのだから、いい結果を出せなかったとしても、非難するには当たらない。</p><p>優秀な田中君のことだから、論文を１週間で仕上げたと聞いても驚くにはあたらない。</p><h3 id="30-におかれましては"><a href="#30-におかれましては" class="headerlink" title="30.~におかれましては"></a>30.~におかれましては</h3><div class="note note-success">            <p>意味: 「〜に関しては」「〜については」の丁寧な形で、相手を非常に敬った形で、その人の状況や状態を指す。</p>          </div><p>社長におかれましては、お元気でご活躍のことと存じます。</p><p>最近のご状況におかれましては、いかがでしょうか。お忙しいことと存じますが、くれぐれもご自愛ください。</p><h3 id="31-にかこつけて"><a href="#31-にかこつけて" class="headerlink" title="31.~にかこつけて"></a>31.~にかこつけて</h3><div class="note note-success">            <p>意味: 「〜を口実にして」「〜を理由にして」といった意味で、表向きの理由を使って、実際は別の意図や目的があることを示します。</p>          </div><p>彼は仕事にかこつけて、頻繁に出張し、観光地を回っている。</p><p>天気にかこつけて、今日の会議は延期されたが、実は準備が間に合わなかったらしい。</p><h3 id="32-にかまけて"><a href="#32-にかまけて" class="headerlink" title="32.~にかまけて"></a>32.~にかまけて</h3><div class="note note-success">            <p>「〜に気を取られて他のことができない」「〜に夢中になって他のことを疎かにする」といった意味で、何かに集中しすぎて、他のことをやる余裕がなくなる状況を表します。</p>          </div><p>彼は仕事にかまけて、家族との時間を全然取っていない。</p><p>スマホにかまけて、勉強が疎かになっている。</p><h3 id="33-にかたくない"><a href="#33-にかたくない" class="headerlink" title="33.~にかたくない"></a>33.~にかたくない</h3><div class="note note-success">            <p>意味: 「〜するのは難しくない」「〜を簡単に理解できる」「〜を容易に想像できる」といった意味を表します。</p>          </div><p>長年に努力してきたことが報われた時の彼の喜びは、想像に難くない。</p><p>異国の地で生活する彼女の苦労は、理解にかたくない。</p><h3 id="34-にしくはない"><a href="#34-にしくはない" class="headerlink" title="34.~にしくはない"></a>34.~にしくはない</h3><div class="note note-success">            <p>意味としては、「〜が一番よい」、「〜が最善である」、「〜するに越したことはない」という考えを表現するものです。</p>          </div><p>安全な道を選ぶにしくはない。</p><p>事前に準備しておくにしくはない。</p><h3 id="35-に忍びない"><a href="#35-に忍びない" class="headerlink" title="35.~に忍びない"></a>35.~に忍びない</h3><div class="note note-success">            <p>「〜に忍びない」という表現は、感情的に耐えられず、ある行為をするのがつらい、または心苦しいと感じるときに使います。</p>          </div><p>彼の写真を捨てるに忍びない。</p><p>その小説の最後の場面はあまりに悲しくて、読むに忍びない。</p><h3 id="36-にたえる"><a href="#36-にたえる" class="headerlink" title="36.~にたえる"></a>36.~にたえる</h3><div class="note note-success">            <p>「〜にたえる（〜に堪える）」は、「〜する価値がある」「〜に耐えられる」という意味を持つ日本語の表現です。主に二つの使い方があります。</p>          </div><p>この映画は見るにたえる作品だ。</p><p>この痛みは堪えるに堪えない。</p><h3 id="37-にとどまらず"><a href="#37-にとどまらず" class="headerlink" title="37.~にとどまらず"></a>37.~にとどまらず</h3><div class="note note-success">            <p>「〜にとどまらず」という表現は、何かが特定の範囲や状況に「とどまる（留まる）」ことなく、さらに広がっている、または影響を及ぼしていることを示す表現です。つまり、「〜だけではなく、さらに」という意味を持ちます。</p>          </div><p>彼の影響は国内にとどまらず、海外にも広がっている。</p><p>この技術は企業内にとどまらず、一般家庭にも普及している。</p><h3 id="38-にひきかえ"><a href="#38-にひきかえ" class="headerlink" title="38.~にひきかえ"></a>38.~にひきかえ</h3><div class="note note-success">            <p>意味：「〜に対して」、「〜と比べて」</p>          </div><p>彼の努力しているにひきかえ、結果が出ていない。</p><p>新製品の売上が好調なにひきかえ、旧製品は苦戦している。</p><h3 id="39-にも増して"><a href="#39-にも増して" class="headerlink" title="39.~にも増して"></a>39.~にも増して</h3><div class="note note-success">            <p>「〜にも増して」は、「〜以上に」と同じ意味で、ある状況や程度がより強く、またはより重要であることを表します。</p>          </div><p>今年の夏は、去年にも増して暑い。</p><p>いつにも増して彼は元気そうだ。</p><h3 id="40-の至りだ"><a href="#40-の至りだ" class="headerlink" title="40.~の至りだ"></a>40.~の至りだ</h3><div class="note note-success">            <p>「非常に〜だ」「極めて〜だ」</p>          </div><p>このような賞をいただき、光栄の至りです。</p><p>皆様の温かいご支援に対し、感激の至りです。</p><h3 id="41-にさておいて・はさておき"><a href="#41-にさておいて・はさておき" class="headerlink" title="41.~にさておいて・はさておき"></a>41.~にさておいて・はさておき</h3><div class="note note-success">            <p>「〜はさておいて」は、何かを一旦脇に置いて、別のことに話題や焦点を移す際に使われる表現です。話の流れの中で、前に述べた内容や問題を一時的に保留して、別の重要なことについて言及したい場合に使います。</p>          </div><p>実現できるかとうかはさておき、まずは新商品のアイディアをみんなで出してみよう。</p><p>社員旅行の件ですが、費用のことはさておいて、まず日程について検討してみましょう。</p><h3 id="42-はそっちのけで・をそっちのけで"><a href="#42-はそっちのけで・をそっちのけで" class="headerlink" title="42.~はそっちのけで・をそっちのけで"></a>42.~はそっちのけで・をそっちのけで</h3><div class="note note-success">            <p>「そっちのけ」とは「そのことを無視する」「放っておく」という意味で、主に否定的なニュアンスで使われます。</p>          </div><p>宿題はそっちのけで、ゲームばかりしている。</p><p>大学4年生の弟は就職のことはそっちのけで、毎日パソコンゲームに没頭している。</p><h3 id="43-羽目になる・羽目に陥る"><a href="#43-羽目になる・羽目に陥る" class="headerlink" title="43.~羽目になる・羽目に陥る"></a>43.~羽目になる・羽目に陥る</h3><div class="note note-success">            <p>「〜羽目になる」や「〜羽目に陥る」は、意図しない結果や不幸な状況に陥ることを表す表現です。</p>          </div><p>遅刻してしまい、会議に出られない羽目になった。</p><p>お金を借りたことが原因で、返済のプレッシャーに陥る羽目になった。</p><h3 id="44-べからず"><a href="#44-べからず" class="headerlink" title="44.~べからず"></a>44.~べからず</h3><div class="note note-success">            <p>意味としては「〜してはならない」「〜すべきではない」という禁止や戒めを表します。形式は動詞の辞書形に「べからず」を付けて作られます。</p>          </div><p>企業から多額のお金を受け取るなんて、政治家としてゆるすべからざる行為だ。</p><p>彼はうちの会社にとって欠くべからざる人材だ。</p><h3 id="45-まじき"><a href="#45-まじき" class="headerlink" title="45.~まじき"></a>45.~まじき</h3><div class="note note-success">            <p>主に道徳的・社会的に「〜してはならない」「〜ふさわしくない」という意味を表します。具体的には、「あるべきではない」「許されない行為や態度」を強調する際に使われます。</p>          </div><p>彼の言動は社会人としてあるまじきもので、とうてい許すことはできない。</p><p>彼のやったことは、人としてあるまじき残酷な行為だ。</p><h3 id="46-めく・めいて・めいた"><a href="#46-めく・めいて・めいた" class="headerlink" title="46.~めく・めいて・めいた"></a>46.~めく・めいて・めいた</h3><div class="note note-success">            <p>「〜めく」「〜めいて」「〜めいた」は、物事や人の様子、性質を表現する際に使われる言葉です。</p>          </div><p>そんな皮肉めいた言い方をしないでください。</p><p>雪が溶けて、野の花が咲き始め、日差しも春めいてきた。</p><h3 id="47-もさることながら"><a href="#47-もさることながら" class="headerlink" title="47.~もさることながら"></a>47.~もさることながら</h3><div class="note note-success">            <p>「〜もさることながら」は、ある事柄を強調しつつ、その上で別の事柄も重要であることを示す表現です。通常、前半に言及したことが重要であると認めつつ、後半でそれに劣らず重要なことを追加します。</p>          </div><p>彼の実力もさることながら、努力も評価されるべきだ。</p><p>両親は、息子に病院の跡を継いで医者になって欲しいと思っているようだ。だが、親の希望もさることながら、やはり本人の気持ちが第一だろう。</p><h3 id="48-を皮切りに"><a href="#48-を皮切りに" class="headerlink" title="48.~を皮切りに"></a>48.~を皮切りに</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>このプロジェクトは、会議を皮切りに始まりました。</p><p>旅行を皮切りに、さまざまな国を訪れました。</p><h3 id="49-を蔑ろにする"><a href="#49-を蔑ろにする" class="headerlink" title="49.~を蔑ろにする"></a>49.~を蔑ろにする</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>彼はチームの意見を蔑ろにして、自分の考えだけを押し通した。</p><p>友人の気持ちを蔑ろにするような行動は避けるべきだ。</p><h3 id="50-をなおざりにして"><a href="#50-をなおざりにして" class="headerlink" title="50.~をなおざりにして"></a>50.~をなおざりにして</h3><div class="note note-success">            <p>何かをいい加減に扱ったり、手を抜いたりすることを意味する表現です。このフレーズは、重要な事柄を怠ったり、十分に注意を払わないことを示します。</p>          </div><p>どんなことがあっても、仕事をなおざりにしてはいけない。</p><p>彼は仕事をなおざりにして、結果的にトラブルを引き起こした。</p><h3 id="51-を控え"><a href="#51-を控え" class="headerlink" title="51.~を控え"></a>51.~を控え</h3><div class="note note-success">            <p>「~を控えて」は、特定の行動や状況を踏まえて、それに関連する行動や注意を促す際に使われる表現です。</p>          </div><p>試験を控えて、しっかり勉強する必要があります。</p><p>引越しを控えて、整理整頓を始めました。</p><h3 id="52-を振り出しに"><a href="#52-を振り出しに" class="headerlink" title="52.~を振り出しに"></a>52.~を振り出しに</h3><div class="note note-success">            <p>ある出来事や行動をきっかけとして、その後の展開や進展が始まることを示す表現です。</p>          </div><p>彼女は転職を振り出しに、キャリアは一新しました。</p><p>彼は小学校の教師を振り出しに社会に出た。</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学公式用法整理</title>
    <link href="/2024/09/08/Math-formula/"/>
    <url>/2024/09/08/Math-formula/</url>
    
    <content type="html"><![CDATA[<h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><blockquote><p>升级后的插件需要双反斜杠“\\\\”，网页才能正确渲染下来</p></blockquote><p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x\leq 0 \\<br>x, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p><h1 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h1><blockquote><p>array和aligned都不适配当前需求，直接用cases环境</p></blockquote><p>$$<br>\begin{cases}<br>    a_1x + b_1y + c_1z &#x3D; d_1 \\<br>    a_2x + b_2y + c_2z &#x3D; d_2 \\<br>    a_3x + b_3y + c_3z &#x3D; d_3<br>\end{cases}<br>$$</p><h1 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h1><p>$$<br>J(\theta) &#x3D; \frac{1}{2m}\sum_{i &#x3D; 0} ^m(y^i - h_\theta (x^i))^2<br>$$</p><h1 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h1><p>$$<br>\frac{\partial J(\theta)}{\partial\theta_j}&#x3D;-\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>$$</p><h1 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h1><p>$$<br>\begin{aligned}<br>\frac{\partial J(\theta)}{\partial\theta_j}<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j&#x3D;0}^n\theta_jx_j^i-y^i) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>\end{aligned}<br>$$</p><h1 id="case环境的使用"><a href="#case环境的使用" class="headerlink" title="case环境的使用"></a>case环境的使用</h1><p>$$<br>a &#x3D;<br>   \begin{cases}<br>     \int x, \mathrm{d} x\\<br>     b^2<br>   \end{cases}<br>$$</p><h1 id="带方框的等式"><a href="#带方框的等式" class="headerlink" title="带方框的等式"></a>带方框的等式</h1><p>$$<br>\begin{aligned}<br> \boxed{x^2+y^2 &#x3D; z^2}<br>\end{aligned}<br>$$</p><h1 id="最大（最小）操作符"><a href="#最大（最小）操作符" class="headerlink" title="最大（最小）操作符"></a>最大（最小）操作符</h1><p>$$<br>\begin{gathered}<br>\operatorname{arg,max}_a f(a)<br> &#x3D; \operatorname*{arg,max}_b f(b) \\<br> \operatorname{arg,min}_c f(c)<br> &#x3D; \operatorname*{arg,min}_d f(d)<br>\end{gathered}<br>$$</p><h1 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h1><p>$$<br>\begin{aligned}<br>  \lim_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \lim\nolimits_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$</p><h1 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h1><p>$$<br>\begin{aligned}<br>   \int_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \int\limits_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$</p><h1 id="多行表达公式"><a href="#多行表达公式" class="headerlink" title="多行表达公式"></a>多行表达公式</h1><p>$$<br>\begin{aligned}<br>J(\mathbf{w})&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m(f(\mathbf{x_i})-y_i)^2\\<br>&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m [f(\mathbf{x_i})]^2-2f(\mathbf{x_i)}y_i+y_i^2<br>\end{aligned}<br>$$</p><h1 id="小括号矩阵"><a href="#小括号矩阵" class="headerlink" title="小括号矩阵"></a>小括号矩阵</h1><p>$$\left(<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right)<br>\tag{2}<br>$$</p><h1 id="中括号矩阵"><a href="#中括号矩阵" class="headerlink" title="中括号矩阵"></a>中括号矩阵</h1><p>$$\left[<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right]<br>\tag{3}<br>$$</p><h1 id="带省略号的矩阵"><a href="#带省略号的矩阵" class="headerlink" title="带省略号的矩阵"></a>带省略号的矩阵</h1><p>$$<br>\left[<br>\begin{matrix}<br>a &amp; b &amp; \cdots &amp; a\\<br>b &amp; b &amp; \cdots &amp; b\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>c &amp; c &amp; \cdots &amp; c<br>\end{matrix}<br>\right]<br>\tag{5}<br>$$</p><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p>$\sin^2\alpha+\cos^2\alpha&#x3D;1$</p><p>$\cfrac{\sin\alpha}{\cos\alpha}&#x3D;\tan\alpha$</p><p>$\sin(2k\pi+\alpha)&#x3D;\sin\alpha(k\in Z)$</p><p>$\cos(2k\pi+\alpha)&#x3D;\cos\alpha(k\in Z)$</p><p>$\tan(2k\pi+\alpha)&#x3D;\tan\alpha(k\in Z)$</p><p>$\cot(2k\pi+\alpha)&#x3D;\cot\alpha(k\in Z)$</p><p>$\sin(\pi+\alpha)&#x3D;-\sin\alpha$</p><p>$\cos(\pi+\alpha)&#x3D;-\cos\alpha$</p><p>$\tan(\pi+\alpha)&#x3D;\tan\alpha$</p><p>$\cot(\pi+\alpha)&#x3D;\cot\alpha$</p><p>$\sin(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\sin\alpha(n为偶数)\\<br>(-1)^{\cfrac{n-1}{2}}\cos\alpha(n为奇数)\end{cases}$</p><p>$\cos(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\cos\alpha(n为偶数)\\(-1)^{\cfrac{n+1}{2}}\sin\alpha(n为奇数)\end{cases}$</p><p>$$<br>\left[<br>    \begin{array}{c|cc}<br>    1 &amp; 2 &amp; 3 \\ \hline<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>    \end{array}<br>\right]<br>\tag{7}<br>$$</p><p>$$x&#x3D;a_0 + \frac{1^2}{a_ 1+\frac{2^2}{a_2+\frac{3^2}{a_3+ \frac{4^2}{a_4+…}}}}$$</p><p>$a \equiv b \pmod n$</p><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>$$<br>e^{i\pi} + 1 &#x3D; 0<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/07/hello-world/"/>
    <url>/2024/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
