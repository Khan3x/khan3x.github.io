<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Digital Circuit</title>
    <link href="/2024/11/04/Digital-Circuit/"/>
    <url>/2024/11/04/Digital-Circuit/</url>
    
    <content type="html"><![CDATA[<h1 id="Digital-Circuit"><a href="#Digital-Circuit" class="headerlink" title="Digital Circuit"></a>Digital Circuit</h1><p>Credit to《Digital Design and Computer Architecture, Second Edition》🤯 Let’s quickly review this subject. The diagram is powered by <a href="https://github.com/jgraph/drawio-desktop">@drawio</a></p><blockquote><p> 催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Logic-Gates"><a href="#1-Logic-Gates" class="headerlink" title="1. Logic Gates"></a>1. Logic Gates</h2><p>第一章主要认识最基础的逻辑门元件，然后熟悉其对应的真值表(Truth Table),主要是为第二章的组合电路(combinational circuit)做铺垫。</p><p><strong>NOT 门（非门）:</strong> 输出是输入的逻辑反， $Y = \neg A$</p><p><strong>BUF 门（缓冲器）:</strong> 输出与输入相同，用于信号强化。$Y = A$</p><p><strong>AND 门（与门）:</strong> 所有输入均为1时，输出才为1。$Y = A \cap B$</p><p><strong>OR 门（或门）:</strong> 任意输入为1时，输出为1。$Y = A \cup B$</p><p><img src="/img/DC/add.svg" alt="逻辑门1" style="max-width: 100%; height: auto;" /></p><p><strong>NAND 门（与非门）:</strong> 与门输出取反。 $ Y = \neg (A \cap B) $</p><p><strong>NOR 门（或非门）:</strong> 或门输出取反。 $ Y = \neg (A \cup B) $</p><p><strong>XOR 门（异或门）:</strong> 相异为1，相同为0。 $ Y = A \oplus B $</p><p><strong>XNOR 门（同或门）:</strong> 相同为0，相异为1。 $ Y = \neg (A \oplus B) $</p><p><img src="/img/DC/nand.svg" alt="逻辑门2" style="max-width: 100%; height: auto;" /></p><p><strong>三态缓冲器（tristate buffer）</strong> 是一种数字电路元件，其输出可以处于三种状态之一：高电平（1）、低电平（0）或高阻态（Z）。高阻态表示输出像断开一样，不驱动任何电流，可以用于总线控制等应用。</p><p><strong>高水平有效（Active High）</strong></p><p>在高水平有效的三态缓冲器中，当控制信号为高电平（1）时，缓冲器输出有效，即输出输入信号的值。当控制信号为低电平（0）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 = 1：输出 = 输入信号</li><li>控制信号 = 0：输出 = 高阻态（Z）</li></ul><p><strong>低水平有效（Active Low）</strong></p><p>在低水平有效的三态缓冲器中，当控制信号为低电平（0）时，缓冲器输出有效，即输出输入信号的值。当控制信号为高电平（1）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 = 0：输出 = 输入信号</li><li>控制信号 = 1：输出 = 高阻态（Z）</li></ul><p align="center">  <img src="/img/DC/buffer.svg" alt="逻辑门3" style="max-width: 110%; height: auto;" /></p><h2 id="2-Combinational-Circuit"><a href="#2-Combinational-Circuit" class="headerlink" title="2. Combinational Circuit"></a>2. Combinational Circuit</h2><p>组合电路（Combinational Circuit）是一种数字电路，其中输出仅依赖于当前输入，而不依赖于之前的输入状态。这意味着组合电路没有存储元件，因此它没有记忆功能。其主要特性包括：</p><ul><li><p>无记忆功能：输出<strong>仅由当前输入决定</strong>，与之前的输入无关。</p></li><li><p>固定的逻辑功能：根据输入信号的组合，输出信号以确定的方式变化。</p></li><li><p>构建简单：组合电路通常由基本逻辑门（如AND、OR、NOT、NAND、NOR、XOR、XNOR）构建，可以用来实现任意逻辑功能。</p></li></ul><p>在有逻辑门的基础知识下，还需要有布尔表达式以及卡诺图的基础下才能完成组合电路的设计。</p><h3 id="2-1-Boolean-Equation"><a href="#2-1-Boolean-Equation" class="headerlink" title="2.1 Boolean Equation"></a>2.1 Boolean Equation</h3><p><strong>与或式（Sum of Products, SOP）</strong> 是一种布尔表达式形式，表示多个与项（积项）之间的或操作。每个积项由一个或多个变量通过与操作连接而成。与或式通常用于表达布尔函数的标准形式之一。例如：</p> <center>$ Y = A \cdot B + \overline{A}  \cdot C + B \cdot \overline{C} $</center><p><strong>或与式（Product of Sums, POS）</strong> 是布尔表达式的另一种形式，表示多个或项（和项）之间的与操作。每个和项由一个或多个变量通过或操作连接而成。或与式也常用于表达布尔函数的标准形式之一。例如：</p><center> $ Y = (A + B) \cdot (\overline {A} + C) \cdot (B + \overline{C}) $</center><p><strong>最小项 (Minterms)</strong> 是布尔函数的标准形式之一，其中每个最小项对应一个输出为1的输入组合。最小项由所有变量的与运算构成，每个变量可能是原变量或其补变量。通俗解释就是输出为1对应积项为1的累加。</p><p>示例：考虑一个布尔函数 ( F(A, B, C) )：</p><ul><li>当 ( A = 1 ), ( B = 0 ), ( C = 1 ) 时，最小项为 $ ( A \cdot \overline{B} \cdot C )$ </li><li>当 ( A = 0 ), ( B = 1 ), ( C = 0 ) 时，最小项为 $ ( \overline{A} \cdot B \cdot \overline{C} )$ </li></ul><p>假设布尔函数在以下输入组合下输出为1：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td></tr></tbody></table></div><p>相应的最小项表示为：</p><center>$ F(A, B, C) = \overline{A} \cdot \overline{B} \cdot C + \overline{A} \cdot B \cdot \overline{C} + A \cdot \overline{B} \cdot C $</center><p><strong>最大项 (Maxterms)</strong> 是布尔函数的另一种标准形式，其中每个最大项对应一个输出为0的输入组合。最大项由所有变量的或运算构成，每个变量可能是原变量或其补变量。通俗解释就是输入为0所对应的和项为0的累乘</p><p>示例：同样考虑布尔函数 ( F(A, B, C) )：</p><p>这两个组合对应的最大项为：</p><ul><li>当 ( A = 0 ), ( B = 0 ), ( C = 0 ) 时，最大项为$ (A + B + C) $</li><li>当 ( A = 1 ), ( B = 0 ), ( C = 1 ) 时，最大项为$ (\overline{A} + B + \overline{C} ) $</li></ul><p>假设布尔函数 ( F(A, B, C) ) 在以下输入组合下输出为0：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><p>因此，相应的最大项表达式为：</p><center> \[F(A, B, C) = (A + B + C) \cdot (\overline{A} + \overline{B} + C)\] </center><p><strong>总结</strong></p><ul><li><strong>最小项</strong>：布尔函数输出为1时，对应输入组合的与运算。</li><li><strong>最大项</strong>：布尔函数输出为0时，对应输入组合的或运算。</li></ul><blockquote><p>这些概念在布尔代数和数字电路设计中非常有用，也是这门课的高频考点</p></blockquote><h3 id="2-2-Boolean-Operation-Rules"><a href="#2-2-Boolean-Operation-Rules" class="headerlink" title="2.2 Boolean Operation Rules"></a>2.2 Boolean Operation Rules</h3><p>布尔运算的基本定律，和卡诺图一样，是逻辑电路化简的主要手段</p><h4 id="2-2-1-交换律（Commutative-Law）"><a href="#2-2-1-交换律（Commutative-Law）" class="headerlink" title="2.2.1 交换律（Commutative Law）"></a>2.2.1 交换律（Commutative Law）</h4><p>交换律表示在布尔运算中，操作数的位置可以互换。</p><ul><li><strong>与运算</strong>：$ A \cdot B = B \cdot A $</li><li><strong>或运算</strong>：$ A + B = B + A $</li></ul><h4 id="2-2-2-结合律（Associative-Law）"><a href="#2-2-2-结合律（Associative-Law）" class="headerlink" title="2.2.2 结合律（Associative Law）"></a>2.2.2 结合律（Associative Law）</h4><p>结合律表示在布尔运算中，操作数的组合方式不影响运算结果。</p><ul><li><strong>与运算</strong>：$ (A \cdot B) \cdot C = A \cdot (B \cdot C) $</li><li><strong>或运算</strong>：$ (A + B) + C = A + (B + C) $</li></ul><h4 id="2-2-3-分配律（Distributive-Law）"><a href="#2-2-3-分配律（Distributive-Law）" class="headerlink" title="2.2.3 分配律（Distributive Law）"></a>2.2.3 分配律（Distributive Law）</h4><p>分配律表示一种运算可以分配到另一种运算上。</p><ul><li><strong>与对或</strong>：$ A \cdot (B + C) = (A \cdot B) + (A \cdot C) $</li><li><strong>或对与</strong>：$ A + (B \cdot C) = (A + B) \cdot (A + C) $</li></ul><h4 id="2-2-4-吸收律（Absorption-Law）"><a href="#2-2-4-吸收律（Absorption-Law）" class="headerlink" title="2.2.4 吸收律（Absorption Law）"></a>2.2.4 吸收律（Absorption Law）</h4><p>吸收律表示通过某些布尔运算可以简化表达式。</p><ul><li>$ A + (A \cdot B) = A $</li><li>$ A \cdot (A + B) = A $</li></ul><h4 id="2-2-5-合并律（Combining-Law）"><a href="#2-2-5-合并律（Combining-Law）" class="headerlink" title="2.2.5 合并律（Combining Law）"></a>2.2.5 合并律（Combining Law）</h4><p>合并律表示布尔变量和其补变量的某些组合具有特定的结果。</p><ul><li>$ A + \overline{A} = 1 $</li><li>$ A \cdot \overline{A} = 0 $</li></ul><h4 id="2-2-6-一致律（Identity-Law）"><a href="#2-2-6-一致律（Identity-Law）" class="headerlink" title="2.2.6 一致律（Identity Law）"></a>2.2.6 一致律（Identity Law）</h4><p>一致律表示布尔变量与1和0的运算结果。</p><ul><li><strong>与1</strong>：$ A \cdot 1 = A $</li><li><strong>与0</strong>：$ A \cdot 0 = 0 $</li><li><strong>或1</strong>：$ A + 1 = 1 $</li><li><strong>或0</strong>：$ A + 0 = A $</li></ul><h4 id="2-2-7-德摩根律（De-Morgan’s-Laws）"><a href="#2-2-7-德摩根律（De-Morgan’s-Laws）" class="headerlink" title="2.2.7 德摩根律（De Morgan’s Laws）"></a>2.2.7 德摩根律（De Morgan’s Laws）</h4><p>德摩根律表示对布尔表达式取反的规则。</p><ul><li>$ \overline{A \cdot B} = \overline{A} + \overline{B} $</li><li>$ \overline{A + B} = \overline{A} \cdot \overline{B} $</li></ul><h4 id="2-2-8-部分二级公式推导"><a href="#2-2-8-部分二级公式推导" class="headerlink" title="2.2.8 部分二级公式推导"></a>2.2.8 部分二级公式推导</h4><ul><li>$ A + \overline{A}B = A + B$</li></ul><p>证明: $A(1 + B) + {A}B = A + AB + \overline{A}B = A + B $ </p><ul><li>$ (A + B) \cdot (A + C) = A + (B \cdot C) $</li></ul><p>证明: $ AA + AC + AB + BC = A + AB + AC + BC = A(1 + B + C) + BC = A + BC $</p><ul><li>$A \cdot (A + B) = A$</li></ul><p>证明: $AA + AB = A + AB = A(1 + B) = A$</p><ul><li>$BC + B\overline{C} = B$</li></ul><p>证明: $B \cdot (C + \overline{C}) = B \cdot 1 = B$</p><ul><li>$(A + B) \cdot (A + \overline{B}) = A$</li></ul><p>证明: $AA + A\overline{B} + AB + B\overline{B} = A + A(B + \overline{B}) = A + A = A$</p><ul><li>$AB + \overline{A}C + BC = AB + \overline{A}C$</li></ul><p>证明关键：使用吸收律 $A + AB = A$, 推广为$AB + ABC = AB$</p><script type="math/tex; mode=display">\begin{aligned}&AB + \overline{A}C + BC \\\\&= AB + \overline{A}C + (A + \overline{A})BC \\\\&= AB + \overline{A}C + ABC + \overline{A}CB \\\\&= AB + ABC + \overline{A}C + \overline{A}CB \text{(使用推广公式)} \\\\&= AB + \overline{A}C\end{aligned}</script><p>根据吸收律可继续推广下去：</p><script type="math/tex; mode=display">AB + \overline{A}C + BC\cdot(\text{其他任何项}) = AB + \overline{A}C</script><p>在表达式中，无论包含 $B$ 和 $C$ 的项如何复杂（例如 $BCDEFGH$），它都不会改变整个表达式的最终结果。</p><div class="note note-primary">            <p>渲染上述公式太折磨了！修考一般不考如此复杂的化简，一般掌握K-Map化简足够应付</p>          </div><h3 id="2-3-K-Map"><a href="#2-3-K-Map" class="headerlink" title="2.3 K-Map"></a>2.3 K-Map</h3><p>在绘制卡诺图的时候需要用到格雷码的表格。首先引入一个格雷码的概念。</p><h4 id="2-3-1-Gray-Code"><a href="#2-3-1-Gray-Code" class="headerlink" title="2.3.1 Gray Code"></a>2.3.1 Gray Code</h4><p>格雷码（Gray Code）是一种<strong>特殊的二进制编码方式</strong>，其特点是<strong>相邻的两个数码之间仅有一位二进制数不同</strong>。格雷码的发明即是用来将误差之可能性缩减至最小，编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码，可以使装置做数字步进时只更动最少的位元数以提高稳定性。</p><p><strong>格雷码的特性</strong></p><ul><li><strong>相邻差一位</strong>：每个相邻编码仅一位不同，减少了转换时的误差风险。</li><li><strong>非权重编码</strong>：格雷码不按照传统二进制编码的权值（如 $1, 2, 4, 8, \dots$）累加。</li></ul><p><strong>2 位格雷码卡诺图</strong></p><div class="table-container"><table><thead><tr><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>01</td></tr><tr><td>1</td><td>11</td><td>10</td></tr></tbody></table></div><p><strong>3 位格雷码卡诺图</strong></p><div class="table-container"><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>001</td><td>011</td><td>010</td></tr><tr><td>1</td><td>110</td><td>111</td><td>101</td><td>100</td></tr></tbody></table></div><p><strong>4 位格雷码卡诺图</strong></p><div class="table-container"><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>00</td><td>0000</td><td>0001</td><td>0011</td><td>0010</td></tr><tr><td>01</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td></tr><tr><td>11</td><td>1110</td><td>1111</td><td>1101</td><td>1100</td></tr><tr><td>10</td><td>1010</td><td>1011</td><td>1001</td><td>1000</td></tr></tbody></table></div><blockquote><p>上述表格，无论是以x轴对称，或者y轴对称，或者中心对称，均只有1位的差异</p></blockquote><h4 id="2-3-2-卡诺图化简步骤"><a href="#2-3-2-卡诺图化简步骤" class="headerlink" title="2.3.2 卡诺图化简步骤"></a>2.3.2 卡诺图化简步骤</h4><ol><li><p>构建 K 图：根据布尔函数的输入变量数量，构建相应大小的 K 图：</p><ul><li>2 位变量：4 格（2×2）</li><li>3 位变量：8 格（2×4）</li><li>4 位变量：16 格（4×4）</li></ul></li></ol><p>横轴和纵轴的变量顺序需按照<strong>格雷码</strong>排列，以确保相邻格子之间只有一个变量不同。</p><ol><li><p>填写真值表和无关项：</p><ul><li>根据逻辑函数或真值表，在 K 图中标记输出为 1 的位置。</li><li>将无关项标(Don’t Care Conditions)记为 X。无关项是那些对最终结果没有影响的输入组合，可以被自由选择为 1 或 0，以帮助扩大合并区域。</li></ul></li><li><p>寻找最大合并区域：</p><ul><li>在 K 图中，寻找可以合并的 1 和 X 区域。合并的目标是形成2 的幂次方大小的区域（例如 1、2、4、8 等格），并使每个 1 尽量包含在最大的区域中。</li><li>合并时遵循以下规则：<ul><li>只允许合并相邻的 1 和 X（上下、左右、包围环绕相邻）。</li><li>尽量优先选择包含更多无关项 X 的区域，以增加合并区域的大小。</li><li>合并区域可以是矩形、正方形，甚至是环绕 K 图的封闭区域。</li></ul></li></ul></li><li><p>合并相邻项：</p><ul><li>每个合并区域中的变量中，如果某个变量在区域内既有 0 又有 1，则忽略该变量（因为它在该区域中无关紧要）。</li><li>将每个合并区域的共同变量提取为一个积项。对于每个变量：<ul><li>如果变量在区域内始终为 1，则使用原变量（如 $A$）。</li><li>如果变量在区域内始终为 0，则使用其反码（如 $\overline{A}$）。</li></ul></li></ul></li><li><p>写出最简化表达式：</p><ul><li>将所有合并区域的积项求和，得到逻辑函数的最简化形式。</li><li>所有包含在化简表达式中的项应尽量少，以确保表达式是最简形式。</li></ul></li></ol><blockquote><p>多练多化简就行了，没什么难度</p></blockquote><h3 id="2-4-常见数字模块"><a href="#2-4-常见数字模块" class="headerlink" title="2.4 常见数字模块"></a>2.4 常见数字模块</h3><p>这一小节跟计算机组成中的算术运算关联度很高，数字电路就是来讲解计算机所呈现出来的算术运算在底层是如何用逻辑元器件实现的。</p><h4 id="2-4-1-Half-Adder"><a href="#2-4-1-Half-Adder" class="headerlink" title="2.4.1 Half Adder"></a>2.4.1 Half Adder</h4><p><strong>半加器 (Half Adder)</strong> 是一个基本的数字电路，用于计算两个单比特二进制数的和。它的功能是执行二进制加法，并且产生两个输出：</p><ul><li>Sum：表示两个输入二进制数加法的结果（不考虑进位）。这里用$S$来表示和。</li><li>Carry：表示加法结果中<strong>产生的进位</strong>。这里用$Cout$来表示产生的进位了。</li></ul><p>根据如下K-Map我们可以得出和与进位的表达式，分别为：$S = A \oplus B$ , $Cout = A\cdot B$，再把组合电路进行封装📦(encapsulation)可以得到半加器这个电路元件<br><img src="/img/DC/half_adder.svg" alt="半加器" style="max-width: 100%; height: auto;" />  </p><h4 id="2-4-2-Full-Adder"><a href="#2-4-2-Full-Adder" class="headerlink" title="2.4.2 Full Adder"></a>2.4.2 Full Adder</h4><p><strong>全加器 (Full Adder)</strong> 是数字电路中的一种基本元件，用于对二进制数进行加法运算。与半加器（Half Adder）相比，全加器可以对两个二进制数和一个进位位进行加法运算，并输出结果和新的进位位。</p><p>全加器的输入包括三个位：</p><ul><li><p>A（第一个加数位）</p></li><li><p>B（第二个加数位）</p></li><li><p>Cin（输入进位位）</p></li></ul><p>全加器的输出包括两个位：</p><ul><li><p>S（和位）：表示加法结果的当前位。</p></li><li><p>Cout（输出进位位）：表示加法结果的进位位。</p></li></ul><p><img src="/img/DC/full_adder.svg" alt="全加器" style="max-width: 100%; height: auto;" />  </p><p>首先分析真值表写出最小项表达式，对于$S$有：</p><script type="math/tex; mode=display">\begin{aligned}S &= \overline{A} \cdot B \cdot \overline{C_{in}} + A \cdot\overline{B} \cdot \overline{C_{in}} + \overline{A} \cdot \overline{B} \cdot C_{in} + A \cdot B \cdot C_{in} \\\\&= \overline{C_{in}}(A \oplus B) + C_{in} \overline{(A \oplus B)} \\\\&= A \oplus B \oplus C_{in}\end{aligned}</script><p>对于$C_{out}$有：</p><script type="math/tex; mode=display">\begin{aligned}C_{out} &= AB \overline{C_{in}} + \overline{A}BC_{in} + A \overline{B}C_{in} + ABC_{in} \\\\&= AB + C_{in}(A \oplus B)\end{aligned}</script><p><strong>思考🤔</strong> ：为什么黑书给的是 $C<em>{out} = AB + AC</em>{in} + BC_{in}$ , 这时候可以借助K-Map化简：如下图所示<br><img src="/img/DC/fa1.svg" alt="k-map" style="max-width: 100%; height: auto;" /><br>根据K-Map化简，我们的全加器的画法会得出上图的电路，而如果根据真值表进行表达式化简，我们会得到下图的全加器。<br><img src="/img/DC/fa2.svg" alt="Full Adder" style="max-width: 100%; height: auto;" /><br>我们可以用2个半加器和一个或门封装成一个全加器,具体的计算过程就不赘述了，这是修考重点！<br><img src="/img/DC/fa3.svg" alt="全加器封装" style="max-width: 100%; height: auto;" />  </p><h4 id="2-4-3-Ripple-Carry-Adder"><a href="#2-4-3-Ripple-Carry-Adder" class="headerlink" title="2.4.3 Ripple-Carry Adder"></a>2.4.3 Ripple-Carry Adder</h4><p>🐎🐎🐎</p>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Digital Circuit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Architecture</title>
    <link href="/2024/10/21/Computer-Architecture/"/>
    <url>/2024/10/21/Computer-Architecture/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h1><p>This for test takers to quickly review Computer Architecture. The whole notes contain 5 parts and I try to make it clear and simple. Credit to《Computer Organization and Design : The Hardware/Software Interface, 5th Edition》目前我也在<a href="https://www.xly-edu.com/">@新领域理工塾</a>，讲授这门课😇</p><blockquote><p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>在本章中，主要引入一下计算机组成的概念然后讲解衡量计算机的性能指标，并着重讲解涉及到的计量单位和公式。</p><h3 id="1-1-常用单位"><a href="#1-1-常用单位" class="headerlink" title="1.1 常用单位"></a>1.1 常用单位</h3><p>容量单位常用<strong>字节(Byte)</strong> ,衡量单位是<em>2进制(Binary)</em> ,容量之间的数量级关系是：$2^{10}$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如： $1TB=2^{10} GB= 1024GB$; $1GB=2^{10}MB=1024MB$</p></blockquote><p>衡量传输速度常用<strong>位每秒(bps,bit per secod)</strong> ,衡量单位是<em>10进制(Decimal)</em> ,传输速度之间的数量级关系是：$10^3$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如：$1kbit/s=1000bit/s$, $1mbit/s=1000kbit/s$</p></blockquote><p>另外需要注意的单位换算是：</p><ul><li>$bit/s$记作$bps$</li><li>$1 Byte = 8 bit$</li><li>$1 Bps = 1 Byte/second = 8 bit/second = 8 bps$</li></ul><h3 id="1-2-计算机结构中的8个伟大思想"><a href="#1-2-计算机结构中的8个伟大思想" class="headerlink" title="1.2 计算机结构中的8个伟大思想"></a>1.2 计算机结构中的8个伟大思想</h3><ul><li>Moore’s Law: 芯片上的集成度每18～24个月翻一番</li><li>Abstraction：使用抽象来表示不同设计层次，化繁为简</li><li>Common Case Fast: 加速大概率事件远比优化小概率事件更能提高性能，即抓住主要矛盾</li><li>Parallel Performance: 并行操作来提高性能，说白了就是<del>打工人能做多少做多少</del></li><li>Pipeline: 这是一个并行场景的具体实现，后面章节会详细讲解🔎</li><li>Prediction：通过猜测的方式提前启动某些操作，提高性能，投资人讲究一个增收降本的策略。</li><li>Hierachy of memory: 用存储器层次来解决容量，速度，成本之间的相互矛盾需求。小而精则贵，大而糙则贱</li><li>Dependable：任何一个物理器件都有可能失效，使用冗余部件的方式来提高系统的可靠性，即备胎🛞</li></ul><p>在加速大概率事件中有一个定量分析的<strong>Amdahl定律</strong>：</p><center>$改进后的执行时间 = 改进影响的执行时间 / 加速比 + 改进不影响的执行时间$</center><center>$t_{\text{改进}} = t_{\text{相关}} / S + t_{\text{无关}}$</center><h3 id="1-3-计算机语言"><a href="#1-3-计算机语言" class="headerlink" title="1.3 计算机语言"></a>1.3 计算机语言</h3><p>计算机语言主要分为三类：<strong>高级语言</strong>、<strong>汇编语言</strong>和<strong>机器语言</strong>。程序执行的过程是先将高级语言编译为汇编语言，然后通过汇编，将汇编语言转化为相应的机器语言。</p><h4 id="1-3-1-高级语言-High-level-programming-language"><a href="#1-3-1-高级语言-High-level-programming-language" class="headerlink" title="1.3.1 高级语言(High-level programming language)"></a>1.3.1 高级语言(High-level programming language)</h4><p>最接近人类自然语言的编程语言。常见的高级语言包括C++, Java, Python, 和JavaScript。</p><h4 id="1-3-2-汇编语言-Assembly-language"><a href="#1-3-2-汇编语言-Assembly-language" class="headerlink" title="1.3.2 汇编语言(Assembly language)"></a>1.3.2 汇编语言(Assembly language)</h4><p>汇编语言是一种低级编程语言，它直接对应于机器语言，但使用人类更易理解的符号和短语来表示。每条汇编指令通常都对应一条机器语言指令，因此汇编语言被认为是机器语言的符号表示。汇编语言需要使用汇编器（Assembler）将代码转换为机器语言。这种语言通常用于编写需要精确控制硬件的程序，如操作系统内核和驱动程序。汇编语言的分类一般有两种主要类型：<strong>RISC指令集（Reduced Instruction Set Computing）</strong> 和 <strong>CISC指令集（Complex Instruction Set Computing）</strong>。</p><ul><li><strong>RISC指令集：</strong> 即简化指令集计算（Reduced Instruction Set Computing）：这种类型的指令集特点是<em>指令集较为简单，每条指令执行时间固定而短，通常在一个时钟周期内完成</em>。这使得RISC处理器能够更快速地执行大量简单的指令。代表性的RISC架构包括<u>ARM、MIPS和SPARC。</u></li><li><strong>CISC指令集：</strong>即复杂指令集计算（Complex Instruction Set Computing），这种类型的指令集特点是指令集复杂，每条指令可能<em>需要多个时钟周期</em>才能完成执行。CISC处理器通过一个复杂的指令集试图降低编程的复杂性，使得某些复杂操作能通过一条指令完成。典型的CISC架构包括<u>x86和VAX。</u></li></ul><div class="note note-success">            <p>在修考中，出现的汇编语言是RISC指令集，因此在后序章节只讲解RISC指令</p>          </div><h4 id="1-3-3-机器语言-Machine-language"><a href="#1-3-3-机器语言-Machine-language" class="headerlink" title="1.3.3 机器语言(Machine language)"></a>1.3.3 机器语言(Machine language)</h4><p>机器语言是计算机能够直接执行的最底层编程语言。它由二进制代码组成，每条指令由一串0和1表示（eg. 00000111111010001），直接控制计算机的硬件操作。由于其复杂性和难以阅读，人类很少直接编写机器语言程序。</p><blockquote><p>总结：高级语言编译为汇编语言，然后汇编语言通过汇编转化为由01串组成的机器语言</p></blockquote><h3 id="1-4-冯·诺伊曼结构-Von-Neumann-architecture"><a href="#1-4-冯·诺伊曼结构-Von-Neumann-architecture" class="headerlink" title="1.4 冯·诺伊曼结构(Von Neumann architecture)"></a>1.4 冯·诺伊曼结构(Von Neumann architecture)</h3><p><img src="/img/CA/von.svg" alt="冯诺伊曼结构" style="max-width: 100%; height: auto;" /></p><p><strong>输入设备(Input Devices)</strong> 是用于向计算机输入数据和指令的硬件。例如，键盘（Keyboard）、鼠标（Mouse）、扫描仪（Scanner）、话筒（Microphone）等。它们将用户的操作转化为计算机能够理解的信号。</p><p><strong>输出设备(Output Devices)</strong> 是用于从计算机输出数据和结果的硬件。例如，显示器（Monitor）、打印机（Printer）、扬声器（Speakers）等。它们将计算机处理后的数据转化为用户可以理解的信息。</p><p><strong>控制器(Control Unit, CU)</strong> 是负责从存储器读取指令，并解释和执行指令的计算机部件。它管理和协调计算机的各个部分，以确保指令被按顺序执行。</p><p><strong>运算器(Arithmetic Logic Unit, ALU)</strong> 是执行算术运算和逻辑运算的核心部件。它能处理整数和浮点数的加、减、乘、除等运算，也能进行与、或、非等逻辑运算。</p><p><strong>存储器(Memory)</strong> 是存储数据和指令的地方。分为主存储器（Main Memory）和辅助存储器（Secondary Storage）。主存储器（如RAM，随机存取存储器，Random Access Memory）用于存储当前正在使用的数据和指令；辅助存储器（如硬盘，Hard Disk Drive）用于长期存储数据。</p><p><strong>中央处理器(Central Processing Unit, CPU)</strong> 是计算机的“大脑”，负责解释和执行指令。它由控制器（Control Unit, CU）和运算器（Arithmetic Logic Unit, ALU）组成，管理并处理所有的计算任务。</p><h3 id="1-5-计算机性能指标"><a href="#1-5-计算机性能指标" class="headerlink" title="1.5 计算机性能指标"></a>1.5 计算机性能指标</h3><p><strong>响应时间（Response Time）：</strong> 响应时间，又称执行时间，是指系统从接收到请求到开始产生输出结果所经过的时间。</p><p><strong>吞吐率（Throughput）：</strong> 吞吐率是指在单位时间内系统能够处理的请求数量。它衡量的是系统的处理能力。高吞吐率意味着在同样的时间内，系统能够处理更多的请求或完成更多的工作。</p><p><strong>CPU性能公式(Performance)：</strong></p><center>$CPU性能 = 1 / 执行时间$</center><p>A的性能比B的性能高$X$倍计算：  $X=t<em>{B执行时间}/t</em>{A执行时间}$</p><p><strong>时钟周期长度(Clock Cycle Length):</strong><br>是指计算机时钟信号中相邻两个相同状态（如两个上升沿）之间的时间间隔。CPU做的任何动作所消耗的时间都是一个时钟周期的整数倍。通常以纳秒（ns）为单位,记作 $T$</p><p><strong>时钟周期频率(Clock Cycle Frequency):</strong><br>则是时钟信号每秒钟振荡的次数，通常以赫兹（Hz）为单位。它是时钟周期长度的倒数。例如，如果时钟周期长度是2纳秒，那么时钟频率就是0.5 GHz,记作 $f$</p><p>两者之间的关系是：</p><ul><li><p>时钟周期长度 = 1 / 时钟周期频率, 即 $T = 1 / f$</p></li><li><p>时钟周期频率 = 1 / 时钟周期长度, 即 $f = 1 / T$</p></li></ul><p><strong>CPI(Cycles Per Instruction):</strong><br>是计算机性能指标，用于衡量每条指令所需的平均时钟周期数。它反映了CPU执行指令的效率。CPI的计算公式是：</p><center>$ \text{CPI} = \frac{\text{总时钟周期数}}{\text{指令数}} $</center><p><strong>时钟周期数计算公式(Clock Cycle):</strong></p><center>$Clock Cycle=指令数\times平均每条指令所需周期数 = IC \times CPI$</center><blockquote><p>注：指令数(Instruction Count, IC)是指CPU在执行一个程序时，需要执行的指令总数。</p></blockquote><p><strong>CPU执行时间：</strong></p><center>$ \text{CPU Time} = \text{指令数} \times \text{CPI} \times \text{时钟周期长度} = IC \times CPI \times T = IC \times CPI / f$</center><p>还有一个衡量指标<strong>是MIPS(million instructions per second)</strong>:</p><center>$ MIPS = IC / (\text{CPU Time} \times 10^{6}) = f / (CPI \times 10^{6})$</center><p><strong>功耗计算公式：</strong> 记住就行</p><center> $P = \frac{1}{2} \times U^2 \times f$</center><blockquote><p>注： $P$ 是功耗，$C$ 是负载电容， $U$ 是电压， $f$ 是开关频率</p></blockquote><h2 id="2-Instructions-The-Language-of-Computers"><a href="#2-Instructions-The-Language-of-Computers" class="headerlink" title="2. Instructions: The Language of Computers"></a>2. Instructions: The Language of Computers</h2><p>这一章非常重要，因为修考题目中经常出现理解汇编语言的题目。本章主要讲解RISC-V指令集架构还有五种寻址方式</p><h3 id="2-1-Instrcucton"><a href="#2-1-Instrcucton" class="headerlink" title="2.1 Instrcucton"></a>2.1 Instrcucton</h3><p>计算机在底层执行程序时，通过读取由0和1组成的机器指令来执行命令。在RISC-V指令集中，所有的机器指令都是32位长，也就是32位的二进制串。这些32位的机器指令对应的汇编语言指令通常由操作码和两个地址码组成（形式：操作码 + 地址码 + 地址码）。规定：</p><ul><li>程序中的变量存放在保存寄存器（store reg）中：$s0~$s7共8个</li><li>临时变量，中间变量存放在临时寄存器（temp reg）中：$t0~$t7共8个</li><li>零寄存器，永远存放32位的0，记作$zero</li></ul><h3 id="2-2-RISC-V-Instruction-Set"><a href="#2-2-RISC-V-Instruction-Set" class="headerlink" title="2.2 RISC-V Instruction Set"></a>2.2 RISC-V Instruction Set</h3><h4 id="2-2-1-基本指令"><a href="#2-2-1-基本指令" class="headerlink" title="2.2.1 基本指令"></a>2.2.1 基本指令</h4><p><strong>加法，减法指令(add, sub):</strong><br><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; c &#x3D; a + b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; badd $s2, $s0, $s1  &#x2F;&#x2F; c &#x3D; a - b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; bsub $s2, $s0, $s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br><strong>加立即数指令(addi):</strong><br><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; i &#x3D; i + 1, i存放在$s0寄存器中addi $s0, $s0, 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><br><strong>逻辑运算指令:</strong> and(与)，or(或)，nor（或非）</p><p><strong>逻辑左移(shift left logic, sll)和右移(shift right logic, srl):</strong><br><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sll $to, $s2, 2 &#x2F;&#x2F; 将$s2寄存器的值左移2位，即变为4倍，存放在$t0中srl $to, $s2, 1 &#x2F;&#x2F; 将$s2寄存器的值右移1位，即变为1&#x2F;2倍，存放在$t0中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><br><strong>取字指令(load word, lw)和存字指令(save word, sw):</strong><br>因为寄存器是按字(Word)存储，而内存是按字节(Byte)编址,在RISC-V指令集中，约定：1 Word = 32 bit = 4 Byte。</p><blockquote><p>举个例子：已知a[0]的地址存放在寄存器s0中，现在需要取a[2]的值存放在寄存器t0中；a[2]和a[0]之间的字节偏移有 2 * 4 = 8 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw $t0, 8($s0)  &#x2F;&#x2F; 取出$s0偏移8字节的位置的值，存放在$t0寄存器中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><blockquote><p>同理，如果我们要把t0寄存器的值存到a[4]中去，可以知道a[4]与a[0]的字节偏移有 4 * 4 = 16 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw $t0, 16($s0) &#x2F;&#x2F; 注意操作的方向和lw相反<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="2-2-2-装载32位立即数到寄存器"><a href="#2-2-2-装载32位立即数到寄存器" class="headerlink" title="2.2.2 装载32位立即数到寄存器"></a>2.2.2 装载32位立即数到寄存器</h4><p>因为装载的32位立即数不能完全放进32位的机器指令中，因此寄存器可以通过两条指令来完成：LUI (Load Upper Immediate) 和 ORI (OR Immediate)。比如将立即数 0xF7EE57AD 装载到寄存器中这个两个指令需要完成的动作是：</p><blockquote><p>0xF7EE57AD 对应的 32 位二进制数是：1111 0111 1110 1110 0101 0111 1010 1101</p><ul><li>LUI 指令：取0xF7EE57AD的高16位数（1111 0111 1110 1110) 放入寄存器的高16位</li></ul></blockquote><ul><li>ORI 指令：将寄存器和剩下的低16位数做立即与的动作(0101 0111 1010 1101)<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $s1, 63470 &#x2F;&#x2F; 1111 0111 1110 1110 对应的十进制数是 63470ori $s1, 22957 &#x2F;&#x2F; 0101 0111 1010 1101 对应的十进制数是 22957&#x2F;* 整个动作如下：step1: 取到高16位数，$s1的值为 1111 0111 1110 1110 0000 0000 0000 0000step2: $s1的值与低16位数立即与 0000 0000 0000 0000 0101 0111 1010 1101最终$s1的值为 1111 0111 1110 1110 0101 0111 1010 1101*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>当然还有其他写法：比如lui和addi。例如，要将立即数 0x12345678 装载到寄存器 t0 中<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $t0, 0x12345 &#x2F;&#x2F; 将高20位0x12345装载到t0addi $t0, $t0, 0x678 &#x2F;&#x2F; 将剩余的12位0x678添加到t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><h4 id="2-2-3-判断和决策指令"><a href="#2-2-3-判断和决策指令" class="headerlink" title="2.2.3 判断和决策指令"></a>2.2.3 判断和决策指令</h4><strong>BEQ（Branch if Equal） 指令：</strong></li><li><strong>功能</strong>：比较两个寄存器的值，如果它们相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>beq rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">beq $t0, $t1, label &#x2F;&#x2F; 如果t0和t1相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>BNE（Branch if Not Equal） 指令：</strong></li></ul></li><li><strong>功能</strong>：比较两个寄存器的值，如果它们不相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>bne rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">bne $t0, $t1, label &#x2F;&#x2F; 如果t0和t1不相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>小于则置位(set less than, slt)：</strong></li></ul></li></ul><p><strong>功能</strong>：将两个寄存器中的值进行比较，如果第一个寄存器的值小于第二个寄存器的值，则将目标寄存器设为1，否则设为0。</p><ul><li><strong>格式</strong>：<code>slt rd, rs1, rs2</code><ul><li><code>rd</code>：目标寄存器</li><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">slt $t0, $t1, $t2 &#x2F;&#x2F; 如果t1 &lt; t2，则将t0设为1；否则设为0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>J指令(JUMP)</strong></p><ul><li><strong>功能</strong>：无条件跳转到指定的目标地址。这个指令改变了程序的执行流程，立即将控制转移到指定的地址。</li><li><strong>格式</strong>：<code>j offset</code><ul><li><code>offset</code>：相对当前地址的跳转偏移量</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j label &#x2F;&#x2F; 无条件跳转到label标记的位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-3-Assembly-language-and-High-level-programming-language"><a href="#2-3-Assembly-language-and-High-level-programming-language" class="headerlink" title="2.3 Assembly language and High-level programming language"></a>2.3 Assembly language and High-level programming language</h3><p>举个例子，有C++代码<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value3 <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t0 <span class="token operator">=</span> value1<span class="token punctuation">;</span>    <span class="token keyword">int</span> t1 <span class="token operator">=</span> value2<span class="token punctuation">;</span>    <span class="token keyword">int</span> t2 <span class="token operator">=</span> t0 <span class="token operator">+</span> t1<span class="token punctuation">;</span> <span class="token comment">// t2 = t0 + t1</span>    <span class="token keyword">int</span> t3 <span class="token operator">=</span> t1 <span class="token operator">-</span> t0<span class="token punctuation">;</span> <span class="token comment">// t3 = t1 - t0</span>    <span class="token keyword">int</span> t4 <span class="token operator">=</span> t0 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment">// t4 = t0 + 4</span>    <span class="token keyword">int</span> t5 <span class="token operator">=</span> t0 <span class="token operator">&amp;</span> t1<span class="token punctuation">;</span> <span class="token comment">// t5 = t0 AND t1</span>    <span class="token keyword">int</span> t6 <span class="token operator">=</span> t0 <span class="token operator">|</span> t1<span class="token punctuation">;</span> <span class="token comment">// t6 = t0 OR t1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t0 <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> ELSE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> main<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>ELSE<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于 nop)</span>    <span class="token keyword">goto</span> EXIT<span class="token punctuation">;</span>main<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于循环到 main)</span>EXIT<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于结束)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>其对应的汇编语言是<br><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.datavalue1: .word 5value2: .word 10value3: .word 15.textmain:    lw $t0, value1      # 将value1的值加载到$t0    lw $t1, value2      # 将value2的值加载到$t1    add $t2, $t0, $t1     # $t2 &#x3D; $t0 + $t1    sub $t3, $t1, $t0     # $t3 &#x3D; $t1 - $t0    addi $t4, $t0, 4     # $t4 &#x3D; $t0 + 4    and $t5, $t0, $t1     # $t5 &#x3D; $t0 AND $t1    or $t6, $t0, $t1      # $t6 &#x3D; $t0 OR $t1    beq $t0, $t1, ELSE   # 如果$t0 &#x3D;&#x3D; $t1，则跳转到ELSE    bne $t0, $t1, main   # 如果$t0 !&#x3D; $t1，则跳转到mainELSE:    j EXIT             # 无条件跳转到EXITEXIT:    nop                # 无操作（用于占位）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="2-4-Three-Instruction-Formats"><a href="#2-4-Three-Instruction-Formats" class="headerlink" title="2.4 Three Instruction Formats"></a>2.4 Three Instruction Formats</h3><p>在汇编语言中，主要有三种指令格式：R型指令、I型指令和J型指令。每种格式有特定的结构，用于不同类型的操作。</p><h4 id="2-4-1-R-type-Register-Instructions"><a href="#2-4-1-R-type-Register-Instructions" class="headerlink" title="2.4.1 R-type (Register) Instructions"></a>2.4.1 R-type (Register) Instructions</h4><ul><li><strong>目的</strong>：用于需要三个寄存器的算术和逻辑操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：第一个源寄存器。</li><li><code>rs2</code>：第二个源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>funct3</code> 和 <code>funct7</code>：附加功能代码，用于指定具体操作。</li></ul></li><li><strong>例子</strong>：<code>add rd, rs1, rs2</code> <ul><li>将 <code>rs1</code> 和 <code>rs2</code> 中的内容相加，并将结果存储在 <code>rd</code> 中。</li></ul></li></ul><h4 id="2-4-2-I-type-Immediate-Instructions"><a href="#2-4-2-I-type-Immediate-Instructions" class="headerlink" title="2.4.2 I-type (Immediate) Instructions"></a>2.4.2 I-type (Immediate) Instructions</h4><ul><li><strong>目的</strong>：用于带有立即数（嵌入指令中的常数）的操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>imm</code>：立即数（常数）。</li><li><code>funct3</code>：附加功能代码。</li></ul></li><li><strong>例子</strong>：<code>addi rd, rs1, imm</code><ul><li>将 <code>rs1</code> 和 <code>imm</code> 的内容相加，并将结果存储在 <code>rd</code></li></ul></li></ul><h4 id="2-4-3-J-type-Jump-Instructions"><a href="#2-4-3-J-type-Jump-Instructions" class="headerlink" title="2.4.3 J-type (Jump) Instructions"></a>2.4.3 J-type (Jump) Instructions</h4><ul><li><strong>目的</strong>：用于修改程序控制流的跳转操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>offset</code>：跳转偏移量。</li></ul></li><li><strong>例子</strong>：<code>j offset</code><ul><li>跳转到通过将 <code>offset</code> 添加到当前程序计数器（PC）计算出的地址。</li></ul></li></ul><h3 id="2-5-Five-Addressing-Modes"><a href="#2-5-Five-Addressing-Modes" class="headerlink" title="2.5 Five Addressing Modes"></a>2.5 Five Addressing Modes</h3><h4 id="2-5-1-立即寻址（Immediate-Addressing）"><a href="#2-5-1-立即寻址（Immediate-Addressing）" class="headerlink" title="2.5.1 立即寻址（Immediate Addressing）"></a>2.5.1 立即寻址（Immediate Addressing）</h4><ul><li><strong>定义</strong>：操作数直接在指令中给出。</li><li><strong>例子</strong>：<code>MOV AL, 5</code><ul><li>这里，数值 <code>5</code> 直接被移动到寄存器 <code>AL</code> 中。</li></ul></li></ul><h4 id="2-5-2-直接寻址（Direct-Addressing）"><a href="#2-5-2-直接寻址（Direct-Addressing）" class="headerlink" title="2.5.2 直接寻址（Direct Addressing）"></a>2.5.2 直接寻址（Direct Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址在指令中明确给出。</li><li><strong>例子</strong>：<code>MOV AX, [1234H]</code><ul><li>该指令将内存地址 <code>1234H</code> 的值移动到寄存器 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-3-间接寻址（Indirect-Addressing）"><a href="#2-5-3-间接寻址（Indirect-Addressing）" class="headerlink" title="2.5.3 间接寻址（Indirect Addressing）"></a>2.5.3 间接寻址（Indirect Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址存储在寄存器或内存位置中。</li><li><strong>例子</strong>：<code>MOV AX, [BX]</code><ul><li>内存位置 <code>[BX]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-4-索引寻址（Indexed-Addressing）"><a href="#2-5-4-索引寻址（Indexed-Addressing）" class="headerlink" title="2.5.4 索引寻址（Indexed Addressing）"></a>2.5.4 索引寻址（Indexed Addressing）</h4><ul><li><strong>定义</strong>：操作数的最终地址由寄存器内容与常数相加生成。</li><li><strong>例子</strong>：<code>MOV AX, [SI+20H]</code><ul><li>内存位置 <code>[SI + 20H]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-5-寄存器寻址（Register-Addressing）"><a href="#2-5-5-寄存器寻址（Register-Addressing）" class="headerlink" title="2.5.5 寄存器寻址（Register Addressing）"></a>2.5.5 寄存器寻址（Register Addressing）</h4><ul><li><strong>定义</strong>：操作数位于寄存器中，寄存器在指令中直接指定。</li><li><strong>例子</strong>：<code>MOV AX, BX</code><ul><li><code>BX</code> 中的值被移动到 <code>AX</code> </li></ul></li></ul><div class="note note-primary">            <p>程序计数器PC在取指令时会自增4（每条指令是4字节），因此，下一条指令的地址是PC + 4。若当前指令需要进行跳转或分支，字地址偏移量则用于计算目标地址。具体来说，如果你有一个偏移量offset，在跳转指令中，你通常会将其左移2位（因为地址是字节为单位的），然后加到PC + 4上来获得目标地址。</p>          </div><h2 id="3-Arithmetic-Operations-in-Computers"><a href="#3-Arithmetic-Operations-in-Computers" class="headerlink" title="3. Arithmetic Operations in Computers"></a>3. Arithmetic Operations in Computers</h2><p>本章主要讲解的知识点有，计算机是如何表示整数和进行整数运算的，以及浮点数的表示规范。本章在修考的考察非常精细，一定要理清每种数的表示。下面的例子都用8bit来表示并且给出对应的表示范围。</p><h3 id="3-1-Integer-Representation"><a href="#3-1-Integer-Representation" class="headerlink" title="3.1 Integer Representation"></a>3.1 Integer Representation</h3><p>本小节介绍无符号整数、原码、反码和补码的表示方法。</p><h4 id="3-1-1-无符号整数（Unsigned-Integer）"><a href="#3-1-1-无符号整数（Unsigned-Integer）" class="headerlink" title="3.1.1 无符号整数（Unsigned Integer）"></a>3.1.1 无符号整数（Unsigned Integer）</h4><p><strong>表示方法</strong>：<br>无符号整数只表示<strong>非负数</strong>，使用所有位表示数值，不用负号。8位无符号整数的取值范围是从0到255。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$0$</li><li>最大值：$2^8 - 1 = 255$</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的无符号表示：<code>00000101</code></li><li>十进制数255的无符号表示：<code>11111111</code></li></ul><h4 id="3-1-2-原码（Sign-Magnitude）"><a href="#3-1-2-原码（Sign-Magnitude）" class="headerlink" title="3.1.2 原码（Sign-Magnitude）"></a>3.1.2 原码（Sign-Magnitude）</h4><p><strong>表示方法</strong>：<br>原码使用最高位作为符号位（0表示正数，1表示负数），其余位表示数值的绝对值。对于8位原码，正数的最高位是0，负数的最高位是1。因此原码有$+0$和$-0$两种表示方法，分别是$00000000$,$10000000$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>1111111</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的原码表示：<code>00000101</code></li><li>十进制数-5的原码表示：<code>10000101</code></li></ul><h4 id="3-1-3-反码（One’s-Complement）"><a href="#3-1-3-反码（One’s-Complement）" class="headerlink" title="3.1.3 反码（One’s Complement）"></a>3.1.3 反码（One’s Complement）</h4><p><strong>表示方法</strong>：<br>反码对正数和负数的表示方法稍有不同。正数的反码与原码相同，负数的反码是将其绝对值的原码的每一位取反（0变1，1变0）。因此反码有也有$+0$和$-0$两种表示方法，分别是$00000000$和$11111111$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>10000000</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的反码表示：<code>00000101</code></li><li>十进制数-5的反码表示：<code>11111010</code>（原码<code>00000101</code>取反）</li></ul><h4 id="3-1-4-补码（Two’s-Complement）"><a href="#3-1-4-补码（Two’s-Complement）" class="headerlink" title="3.1.4 补码（Two’s Complement）"></a>3.1.4 补码（Two’s Complement）</h4><p><strong>表示方法</strong>：<br>补码是最常用的负数表示方法。正数的补码与原码相同，负数的补码是其绝对值的原码取反后加1。补码的意义是<em>消除原码和反码有2种零的表示方法</em>，可以用于直接计算。计算机都是用补码进行整数加减运算。因为补码只有一种$0$的表示方法，因此负数的表示范围会比整数多一个。</p><blockquote><p>补码非常爱考的一个点：$11111111$(-1), $10000000$(-128,因为超出8位范围), $00000000$(0)</p></blockquote><p><strong>表示范围</strong>：</p><ul><li>最小值：$-128$（<code>10000000</code>），🚨重中之重</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的补码表示：<code>00000101</code></li><li>十进制数-5的补码表示：<code>11111011</code>（原码<code>00000101</code>取反后加1）</li></ul><h4 id="3-1-5-表示方法总结"><a href="#3-1-5-表示方法总结" class="headerlink" title="3.1.5 表示方法总结"></a>3.1.5 表示方法总结</h4><div class="table-container"><table><thead><tr><th>表示法</th><th>最小值</th><th>最大值</th><th>示例 - 正数</th><th>示例 - 负数</th><th>0的表示个数</th></tr></thead><tbody><tr><td>无符号整数</td><td>0</td><td>255</td><td><code>00000101</code> (5)</td><td>N/A</td><td>1</td></tr><tr><td>原码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>10000101</code> (-5)</td><td>2</td></tr><tr><td>反码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111010</code> (-5)</td><td>2</td></tr><tr><td>补码</td><td>-128</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111011</code> (-5)</td><td>1</td></tr></tbody></table></div><h3 id="3-2-符号位扩展与大小端编址"><a href="#3-2-符号位扩展与大小端编址" class="headerlink" title="3.2 符号位扩展与大小端编址"></a>3.2 符号位扩展与大小端编址</h3><p>这几个考点经常出现在题目的开胃前菜，是很容易忽略的一个考点，切记切记。</p><h4 id="3-2-1-符号位扩展（sign-extension）"><a href="#3-2-1-符号位扩展（sign-extension）" class="headerlink" title="3.2.1 符号位扩展（sign extension）"></a>3.2.1 符号位扩展（sign extension）</h4><p><strong>符号位扩展（sign extension）</strong> 是指在将带符号的数从较小的位数扩展到较大位数时，保持其数值的正负性。这个过程通常在处理数值的运算或数据类型转换时使用。<br>填充高位：</p><ul><li>如果符号位为0，扩展时在左边填充0。</li><li>如果符号位为1，扩展时在左边填充1。<br>假设我们要将一个8位的补码数扩展到16位：</li></ul><p><strong>8位正数</strong></p><ul><li>原数：<code>00001010</code>（十进制10）</li><li>扩展后：<code>00000000 00001010</code>（仍然是十进制10）</li></ul><p><strong>8位负数</strong></p><ul><li>原数：<code>11111010</code>（十进制-6）</li><li>扩展后：<code>11111111 11111010</code>（仍然是十进制-6）</li></ul><h4 id="3-2-2-大端编址（Big-endian）和小端编址（Little-endian）"><a href="#3-2-2-大端编址（Big-endian）和小端编址（Little-endian）" class="headerlink" title="3.2.2 大端编址（Big-endian）和小端编址（Little-endian）"></a>3.2.2 大端编址（Big-endian）和小端编址（Little-endian）</h4><p>大端编址（Big-endian）和小端编址（Little-endian）是两种不同的数据存储方式，决定了多字节数据在内存中的排列顺序。</p><p><strong>大端编址（Big-endian）</strong></p><ul><li><strong>定义</strong>：在大端模式下，数据的高位字节存储在低地址，低位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>12</code></li><li>地址 <code>0x01</code>：<code>34</code></li><li>地址 <code>0x02</code>：<code>56</code></li><li>地址 <code>0x03</code>：<code>78</code></li></ul></li></ul><p><strong>小端编址（Little-endian）</strong></p><ul><li><strong>定义</strong>：在小端模式下，数据的低位字节存储在低地址，高位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>78</code></li><li>地址 <code>0x01</code>：<code>56</code></li><li>地址 <code>0x02</code>：<code>34</code></li><li>地址 <code>0x03</code>：<code>12</code></li></ul></li></ul><p><strong>应用</strong></p><ul><li><strong>大端</strong>：常用于网络协议（如TCP/IP），因为网络字节顺序采用大端。</li><li><strong>小端</strong>：通常用于个人电脑（如x86架构的处理器）。</li></ul><p><img src="/img/CA/endianness.svg" alt="大端和小端序" style="max-width: 100%; height: auto;" /></p><h3 id="3-3-Arithmetic-Operations-Logic"><a href="#3-3-Arithmetic-Operations-Logic" class="headerlink" title="3.3 Arithmetic Operations Logic"></a>3.3 Arithmetic Operations Logic</h3><p>参照数字电路笔记（🐎马不停蹄更新中）</p><h3 id="3-4-IEEE754-Float-Point-Number"><a href="#3-4-IEEE754-Float-Point-Number" class="headerlink" title="3.4 IEEE754 Float Point Number"></a>3.4 IEEE754 Float Point Number</h3><p><strong>IEEE 754 单精度浮点数</strong></p><p>IEEE 754 单精度浮点数总共32位：1位符号位（S），8位指数位（E），23位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为127，即实际的指数值是存储的指数值减去127。<ul><li>例如，如果指数部分存储的是10000001（二进制的129），实际的指数就是129-127=2。</li></ul></li><li><strong>尾数位（F）</strong>：23位，表示小数部分。注意尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 127)} \times 1.F$ </center><p><strong>IEEE 754 双精度浮点数</strong></p><p>IEEE 754 双精度浮点数总共64位：1位符号位（S），11位指数位（E），52位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为1023，即实际的指数值是存储的指数值减去1023。<ul><li>例如，如果指数部分存储的是10000000010（二进制的1026），实际的指数就是1026-1023=3。</li></ul></li><li><strong>尾数位（F）</strong>：52位，表示小数部分。尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 1023)} \times 1.F$ </center><p><img src="/img/CA/float.svg" alt="浮点数表示格式" style="max-width: 100%; height: auto;" /></p><blockquote><p>思考：为什么需要偏阶值(Bias)的存在？</p></blockquote><p>偏阶（Bias）的存在主要是为了简化浮点数的比较和计算过程。以下是几个具体原因：</p><ol><li><p><strong>简化比较操作</strong>：<br>通过使用偏阶，所有可能的指数值都被映射到一个非负范围内，使得比较浮点数时可以简单地比较其指数部分的数值。例如，对于单精度浮点数，偏阶127确保了指数范围从 -127 到 128 被映射到 0 到 255。</p></li><li><p><strong>标准化表示</strong>：<br>使用偏阶可以确保指数部分总是一个非负数，从而使浮点数表示更为统一和标准化。这对于硬件电路设计和算法实现有很大的便利性。</p></li><li><p><strong>处理负指数</strong>：<br>偏阶允许使用非负整数来表示负指数，这对表示非常小的浮点数（接近于0）尤其有用。通过偏阶值，可以直接在指数部分进行加法和减法，而不需要额外处理负数。</p></li></ol><p>举个例子，对于单精度浮点数，偏阶是127。这意味着：</p><ul><li>实际指数为0时，存储的指数值是127。</li><li>实际指数为-1时，存储的指数值是126。</li><li>实际指数为+1时，存储的指数值是128。</li></ul><p>这种设计大大简化了计算和比较过程，让浮点运算变得高效和准确。</p><h2 id="4-Processor"><a href="#4-Processor" class="headerlink" title="4.  Processor"></a>4.  Processor</h2><p>MIPS是一种采取RISC的架构。MIPS 处理器的指令执行过程被分为<strong>五个主要阶段。</strong> 通过流水线的设计，MIPS 能够在每个时钟周期执行多个指令阶段，从而提升性能。以下是每个阶段的详细说明：</p><h3 id="4-1-指令周期分解"><a href="#4-1-指令周期分解" class="headerlink" title="4.1 指令周期分解"></a>4.1 指令周期分解</h3><ol><li><p><strong>取指令（IF，Instruction Fetch）</strong></p><ul><li>从指令存储器中读取当前指令，将其载入到指令寄存器（IR，Instruction Register）中。</li><li>将程序计数器（PC）更新为下一条指令的地址，一般为当前 PC 值加 4（因为每条指令长度固定为 4 字节）。</li><li>在这个阶段，通常也会将 PC 的值保存，以备后续的跳转或分支指令使用。</li></ul></li><li><p><strong>指令译码（ID，Instruction Decode）</strong></p><ul><li>解析指令的操作码（opcode），以确定指令类型和具体的操作。</li><li>从寄存器文件中读取操作数（源寄存器数据）。在 R 型指令中读取两个寄存器，而 I 型和 J 型指令则根据需求读取一个或不读取。</li><li>进行分支地址的计算（PC + 偏移量），以备可能的跳转或分支指令使用。</li><li>根据指令类型生成控制信号，控制信号会影响后续各个阶段的具体操作。</li></ul></li><li><p><strong>执行（EX，Execute）</strong></p><ul><li><strong>算术或逻辑操作</strong>：如果是算术或逻辑指令，ALU（算术逻辑单元）执行相应操作，例如加法、减法、与或非等。</li><li><strong>内存地址计算</strong>：若是加载或存储指令，ALU 计算内存访问的目标地址（基地址 + 偏移量）。</li><li><strong>分支判断</strong>：若是分支指令，在 ALU 进行判断后决定是否采用分支地址。</li><li>这一阶段的结果（例如运算结果或目标地址）将传递给下一阶段。</li></ul></li><li><p><strong>访存（MEM，Memory Access）</strong></p><ul><li><strong>加载指令</strong>：如果是加载指令（如 <code>lw</code>），从内存中读取数据，并将其存入一个临时寄存器。</li><li><strong>存储指令</strong>：如果是存储指令（如 <code>sw</code>），将寄存器中的数据写入指定的内存地址。</li><li>其他指令在这一阶段不做任何操作，直接进入下一个阶段。</li></ul></li><li><p><strong>写回（WB，Write Back）</strong></p><ul><li>将执行结果写回到寄存器文件中（如 <code>R</code> 型和 <code>I</code> 型指令）。</li><li>对于加载指令，将从内存读取的数据写入目标寄存器。</li><li>此阶段完成后，处理器准备进入下一条指令的执行。</li></ul></li></ol><h3 id="4-2-Pipeline-Basics"><a href="#4-2-Pipeline-Basics" class="headerlink" title="4.2 Pipeline Basics"></a>4.2 Pipeline Basics</h3><p>在指令周期的五个阶段，可以把数据通路分为5个阶段，形成流水线(pipeline)。<br><img src="/img/CA/pipeline.png" alt="流水线" style="max-width: 100%; height: auto;" /><br>根据上图，可以很直观的给出流水线相关计算公式：</p><center>$时钟周期数 = 指令数 + 流水级级数 - 1 = IC + n - 1$</center><center>$理想加速比 = 流水线级数 = n$</center><blockquote><p>注意⚠️：时钟周期取5个阶段中最慢的阶段作为时钟周期（木桶效应）</p></blockquote><h3 id="4-3-Pipeline-Hazards"><a href="#4-3-Pipeline-Hazards" class="headerlink" title="4.3 Pipeline Hazards"></a>4.3 Pipeline Hazards</h3><p><strong>流水线冒险（Pipeline Hazards）</strong> 是在指令流水线中可能导致流水线停顿或性能下降的问题。主要有三种类型的流水线冒险：数据冒险、控制冒险和结构冒险。下面是对每种冒险的详细讲解：</p><h4 id="4-3-1-数据冒险-Data-Hazard"><a href="#4-3-1-数据冒险-Data-Hazard" class="headerlink" title="4.3.1 数据冒险 (Data Hazard)"></a>4.3.1 数据冒险 (Data Hazard)</h4><p>数据冒险是由于指令之间的数据依赖性导致的。例如，一条指令需要使用前一条指令的计算结果，如果在计算结果尚未写回寄存器时就使用该结果，流水线会因为缺少数据而停顿。常见的数据冒险有以下几种类型：</p><ul><li><p><strong>RAW（Read After Write，读后写）</strong>：最常见的数据冒险类型。假设有指令 A 和指令 B，A 先于 B 执行。如果 B 读取 A 的结果而 A 还未写回寄存器，则会产生数据冒险。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A: R1 &#x3D; R2 + R3B: R4 &#x3D; R1 + R5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>指令 B 在 A 的结果写回之前读取了 R1，造成数据冒险。</p></li><li><p><strong>WAR（Write After Read，写后读）</strong>：较少见，发生在指令先读取了寄存器的值，而后续指令修改了该寄存器的值。这种冒险通常在特定的流水线架构中才会发生。</p></li><li><strong>WAW（Write After Write，写后写）</strong>：如果流水线支持多发射或指令乱序执行，就可能发生这种冒险。即先有一条指令写一个寄存器，后续指令也写相同寄存器，但乱序执行导致后面的指令先写完。</li></ul><p>解决方法：</p><ul><li>数据转发 (Data Forwarding)或旁路（bypass）：将未写回寄存器的数据直接转发给下一条指令的执行单元，从而避免等待写回寄存器的过程。</li><li>插入气泡 (Bubble)：让流水线停顿一个或多个周期，直到所需数据准备就绪。<h4 id="4-3-2-控制冒险-Control-Hazard"><a href="#4-3-2-控制冒险-Control-Hazard" class="headerlink" title="4.3.2 控制冒险 (Control Hazard)"></a>4.3.2 控制冒险 (Control Hazard)</h4>控制冒险是因为分支指令或跳转指令的出现，使得流水线不能确定下一条要执行的指令，从而导致流水线停顿。分支指令可能改变程序执行的路径，而在确定跳转目标前，流水线并不知道应该继续取哪条指令。</li></ul><p>例如，以下代码段中，当执行<code>if</code>判断时，可能会发生控制冒险：<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span>    <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token function">do_something_else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>在判断 <code>a &gt; b</code> 之前，流水线不知道下一步应该执行 <code>do_something</code> 还是 <code>do_something_else</code>。</p><p>解决方法：</p><ul><li>分支预测 (Branch Prediction)：利用硬件预测分支指令的执行路径。现代处理器使用动态分支预测，根据历史执行情况预测下一步操作。</li><li>延迟槽 (Delay Slot)：将分支指令后的指令提前执行，即使分支结果不确定也先执行下一条指令，从而减少停顿，但这种方法需要编译器支持。</li><li>分支目标缓冲区 (Branch Target Buffer, BTB)：缓存分支指令的目标地址，减少分支跳转的停顿时间。<h4 id="4-3-3-结构冒险-Structural-Hazard"><a href="#4-3-3-结构冒险-Structural-Hazard" class="headerlink" title="4.3.3 结构冒险 (Structural Hazard)"></a>4.3.3 结构冒险 (Structural Hazard)</h4>结构冒险是由于硬件资源的竞争导致的。在指令执行过程中，如果两个或多个指令同时需要访问同一硬件资源（例如，内存、寄存器或 ALU 单元），但硬件资源不能同时支持多个访问请求，则会产生结构冒险。</li></ul><p>例如，如果处理器的内存访问和取指令共享相同的内存端口，且一个指令在内存中读取数据的同时，另一个指令需要从内存中取指令，就会产生结构冒险。</p><p>解决方法：</p><ul><li>增加硬件资源：在流水线设计时，增加必要的硬件资源。例如，为指令存储和数据存储提供独立的内存端口，避免资源竞争。</li><li>流水线停顿：当资源不可用时，让流水线停顿一个周期，以等待资源的释放。</li></ul><div class="note note-primary">            <p>流水线在修考里面是非常非常重要的存在‼️我更希望后续用经典的例题讲解。等待更新⌛️</p>          </div><h2 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h2><p>本章主要讲解存储器的层次和局部性原理。这一章和操作系统的重合度非常高，建议配合操作系统复习。本章的Cache映射和TLB映射在修考题中出现的频率非常高。</p><h3 id="5-1-Memory-Hierachy"><a href="#5-1-Memory-Hierachy" class="headerlink" title="5.1 Memory Hierachy"></a>5.1 Memory Hierachy</h3><p>如标题所见，这是计算机8大设计思想之一，采用层次结构将存储器主要分为4个层次，从顶层到底层依次是：寄存器，高速缓存，主存，外存。<br><img src="/img/CA/memory.svg" alt="存储器层次" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-Register"><a href="#5-1-1-Register" class="headerlink" title="5.1.1 Register"></a>5.1.1 Register</h4><p>寄存器是 CPU 中的高速存储单元，用于暂时存储指令和数据，帮助 CPU 进行快速计算。它们是 CPU 中访问速度最快的存储器，因为它们直接位于 CPU 内核中，靠近运算单元（如算术逻辑单元，ALU）。</p><p><strong>寄存器的特点</strong></p><ul><li><strong>速度快</strong>：寄存器的访问速度比 Cache 和主存（RAM）都要快，能满足 CPU 的即时需求。</li><li><strong>容量小</strong>：寄存器数量有限，通常每个寄存器只有几个字节或几十个字节的容量。</li><li><strong>功能明确</strong>：寄存器根据用途被分为不同类型，每种寄存器在特定的指令或运算中起特定的作用。</li></ul><p><strong>常见的寄存器类型</strong></p><ol><li><strong>通用寄存器</strong>：用于临时存储数据，支持基本的加、减、乘、除等运算。</li><li><strong>程序计数器 (PC)</strong> ：保存下一条要执行指令的地址，用于控制程序执行的顺序。</li><li><strong>状态寄存器/标志寄存器</strong>：存储运算结果的状态信息，如是否为零、是否有溢出等，用于条件判断。</li><li><strong>堆栈指针 (SP)</strong> ：指向栈顶位置，用于函数调用和返回的管理。</li><li><strong>地址寄存器</strong>：存储内存地址，用于快速访问特定的内存位置。</li></ol><p><strong>寄存器的作用</strong><br>寄存器用于 CPU 执行指令时的临时数据存储，避免频繁访问较慢的内存单元。它们直接与 CPU 核心连接，确保计算快速、高效。</p><h4 id="5-1-2-Cache"><a href="#5-1-2-Cache" class="headerlink" title="5.1.2 Cache"></a>5.1.2 Cache</h4><p><strong>Cache</strong>（缓存）是位于 CPU 和主存（RAM）之间的高速存储器，用于缓解 CPU 与主存之间的速度差异。Cache 通过暂时存储常用的数据和指令，减少 CPU 访问主存的次数，从而提高整体运算速度。Cache 通常是由 <strong>SRAM（静态随机存取存储器）</strong> 组成的；SRAM是易失性存储器，尽管 SRAM 的数据不需要周期性刷新，但一旦电源关闭，存储在其中的数据就会丢失。这是因为 SRAM 的存储原理基于晶体管的电状态，当电源断开时，这些状态会消失。<strong>DRAM</strong>则有些许不同，需要定期刷新以维持数据，刷新操作会耗费一定时间和电力，但也是易失性存储器(volatile memory)。</p><p><strong>Cache 的特点</strong></p><ul><li><strong>访问速度快</strong>：Cache 的访问速度比主存快，仅次于寄存器，能快速提供数据。</li><li><strong>层级结构</strong>：Cache 通常分为多级，包括 L1、L2 和 L3 缓存，分别位于不同的 CPU 层次上，L1 速度最快但容量最小，L3 容量最大但速度相对较慢。</li><li><strong>自动管理</strong>：Cache 由硬件自动管理，CPU 根据访问数据的频率和规律自动将数据加载到 Cache 中，无需程序员手动干预。</li></ul><p><strong>Cache 的作用</strong><br>Cache 主要用于存储 CPU 经常访问的数据或指令，以减少访问主存的延迟，提升 CPU 的执行效率。现代处理器通常会采用多级缓存结构，以平衡容量与速度之间的需求。</p><h4 id="5-1-3-Main-Memory"><a href="#5-1-3-Main-Memory" class="headerlink" title="5.1.3 Main Memory"></a>5.1.3 Main Memory</h4><p><strong>内存</strong>（Memory）一般称为主存(Main Memory)，是计算机中用于临时存储数据和程序的部件，CPU 可以快速访问其中的数据。内存的主要作用是为 CPU 提供运行时的工作区，用于存放操作系统、应用程序和当前处理的数据。</p><p><strong>内存的特点</strong></p><ul><li><strong>速度适中</strong>：内存的访问速度介于 Cache 和硬盘之间。尽管比硬盘快很多，但比不上 CPU 内部的寄存器和缓存。</li><li><strong>容量较大</strong>：内存容量一般较大，能够存储多个程序和大量数据，以满足系统的多任务需求。</li><li><strong>易失性</strong>：内存（RAM）通常由 DRAM（动态随机存取存储器）组成。DRAM 由于容量大、成本相对较低，也是一种易失性存储器，断电后数据会丢失。</li></ul><p><strong>内存的作用</strong></p><p>内存用于临时存放正在执行的程序和正在处理的数据，起到了 CPU 与硬盘之间的缓冲作用，使得系统运行更加高效。计算机在开机后，将程序从硬盘加载到内存中，CPU 再从内存中读取指令执行。</p><h4 id="5-1-4-Secondary-Memory"><a href="#5-1-4-Secondary-Memory" class="headerlink" title="5.1.4 Secondary Memory"></a>5.1.4 Secondary Memory</h4><p><strong>Secondary Memory</strong>（二级存储器）是计算机的外部存储，用于长期存储数据和程序，断电后数据不会丢失。常见的二级存储器包括硬盘驱动器 (HDD)、固态硬盘 (SSD)、光盘、以及 USB 闪存等。</p><p><strong>辅助存储器的特点</strong></p><ul><li><strong>非易失性(nonvolatile)</strong> ：辅助存储器断电后仍能保留数据，适合长期存储文件、程序和系统数据。</li><li><strong>大容量</strong>：相比于主存，辅助存储器容量更大，能够存储大量的数据和文件。</li><li><strong>较慢的访问速度</strong>：辅助存储器的读写速度比内存慢，因此用于存储不需要频繁访问的数据。</li></ul><p><strong>辅助存储器的作用</strong></p><p>辅助存储器用于存储计算机的操作系统、应用程序、用户文件和其他数据，提供数据的长期保存。计算机在启动时会将操作系统和相关程序从辅助存储器加载到内存中，以便 CPU 处理。</p><h3 id="5-2-Principle-of-Locality"><a href="#5-2-Principle-of-Locality" class="headerlink" title="5.2 Principle of Locality"></a>5.2 Principle of Locality</h3><p>局部性原理(principle of locality)是计算机组成中的一个关键概念，用来描述程序在执行过程中，访问内存地址或存储单元的一种倾向。局部性原理主要分为以下两类：</p><p><strong>时间局部性（Temporal Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么在不久的将来它很可能会再次被访问。</li><li><strong>例子</strong>：在循环中多次访问某个变量。比如循环计数器，每次迭代都会访问该变量。</li></ul><p><strong>空间局部性（Spatial Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么它附近的数据也很可能会在不久的将来被访问。</li><li><strong>例子</strong>：遍历数组时，逐个访问数组中的元素。比如访问数组<code>arr[0]</code>后，很可能访问<code>arr[1]</code>。</li></ul><blockquote><p>局部性原理在设计计算机缓存（Cache）时尤为重要。因为缓存利用局部性原理，通过临时存储经常访问的数据或地址来减少访问主内存的次数，提高整体系统性能。</p></blockquote><h3 id="5-3-Cache’s-Performance"><a href="#5-3-Cache’s-Performance" class="headerlink" title="5.3 Cache’s Performance"></a>5.3 Cache’s Performance</h3><p>Cache的主要考点围绕在命中率和缺失率的计算；在Cache映射中也有非常多的改进策略。</p><h4 id="5-3-1-Cache-Hit-amp-Miss"><a href="#5-3-1-Cache-Hit-amp-Miss" class="headerlink" title="5.3.1 Cache Hit &amp; Miss"></a>5.3.1 Cache Hit &amp; Miss</h4><p><strong>Cache命中（Cache Hit）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据在缓存中找到时，就称为Cache命中。命中率（Hit Rate）是命中次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它已经在缓存中，直接读取数据，避免了访问慢速的主内存，从而提高了整体性能。</li></ul><p><strong>Cache缺失（Cache Miss）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据不在缓存中，必须从主内存中读取时，就称为Cache缺失。缺失率（Miss Rate）是缺失次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它不在缓存中，处理器需要从主内存中读取该数据块，并将其放入缓存中。这个过程比直接从缓存读取要慢得多。</li></ul><p>命中率(Hit Rate)和缺失率(Miss Rate)的计算方法非常直观，分别是命中/缺失的次数占访存次数的比例。</p><h4 id="5-3-2-命中时间、缺失代价和访存阻塞周期"><a href="#5-3-2-命中时间、缺失代价和访存阻塞周期" class="headerlink" title="5.3.2 命中时间、缺失代价和访存阻塞周期"></a>5.3.2 命中时间、缺失代价和访存阻塞周期</h4><p><strong>命中时间（Hit Time）</strong></p><ul><li><strong>定义</strong>：命中时间是指CPU在缓存中找到数据所需的时间，包括地址翻译、缓存访问和数据返回给处理器的时间。通常只有1个时钟周期长度。</li><li><strong>计算</strong>：命中时间通常由缓存访问的硬件特性决定，具体时间取决于缓存的层级和设计。</li></ul><p><strong>缺失代价（Miss Penalty）</strong></p><ul><li><strong>定义</strong>：缺失代价是指当数据不在缓存中，需要从较低层级的缓存或主存中加载数据所需的时间。</li><li><strong>计算</strong>：缺失代价 = 低层级缓存或主存的访问时间 + 将数据传送到缓存中的时间。</li></ul><p><strong>访存阻塞周期（Memory Stall Cycles）</strong></p><ul><li><strong>定义</strong>：访存阻塞周期是指由于缓存缺失导致处理器需要等待数据加载而停顿的周期数。</li><li><strong>计算</strong>：访存阻塞周期 = 缺失率 × 缺失代价</li></ul><p>假设：</p><ul><li>命中时间为1个周期。</li><li>缺失代价为50个周期。</li><li>缺失率为5%。</li></ul><p>那么：访存阻塞周期 = 5% × 50个周期 = 2.5个周期。</p><p>普适性的衡量会给上一个缺失率(Miss Rate), 那么</p><center>$访存阻塞周期 = 访存次数 \times 缺失率 \times 缺失代价$</center><h3 id="5-4-Cache的三种映射方式"><a href="#5-4-Cache的三种映射方式" class="headerlink" title="5.4 Cache的三种映射方式"></a>5.4 Cache的三种映射方式</h3><p><strong>1. 直接映射（Direct Mapped Cache）</strong></p><ul><li><strong>定义</strong>：每个内存块都映射到缓存的一个特定位置。缓存中的每个位置可以存储多个内存块，但在任意时间只能存储一个。</li><li><strong>优点</strong>：实现简单且成本低。</li><li><strong>缺点</strong>：冲突较多，即不同内存块可能会映射到同一个缓存位置，导致频繁替换。</li></ul><p><strong>2. 全关联映射（Fully Associative Cache）</strong></p><ul><li><strong>定义</strong>：内存块可以映射到缓存的任何位置。缓存中的每个位置都可以存储任何内存块。</li><li><strong>优点</strong>：减少了冲突，因为任何内存块都可以放到任何缓存位置。</li><li><strong>缺点</strong>：实现复杂且成本高，需要比较所有缓存位置以找到匹配的块。</li></ul><p><strong>3. 组关联映射（Set Associative Cache）</strong></p><ul><li><strong>定义</strong>：缓存分成多个组，每个组包含若干个位置。内存块首先映射到某个组，然后可以存储在该组的任意位置。</li><li><strong>优点</strong>：在复杂度和性能之间取得平衡，减少了直接映射中的冲突，同时实现比全关联映射更简单。</li><li><strong>缺点</strong>：组的选择可能会导致一些复杂度，但总的来说，比全关联映射低。<br><img src="/img/CA/cache_map.svg" alt="Cache三种映射方式" style="max-width: 100%; height: auto;" /></li></ul><h4 id="5-4-1-直接映射"><a href="#5-4-1-直接映射" class="headerlink" title="5.4.1 直接映射"></a>5.4.1 直接映射</h4><p>映射规则：Cache块号 = 内存块号 % Cache块数</p><blockquote><p>比如，Cache共有8块，内存的十号块映射在Cache的块号是：10 % 8 = 2</p></blockquote><p>直接映射缓存（Direct Mapped Cache）内存地址通常被分成三个字段：块内字节偏移、索引位和标记位。</p><p><strong>1. 块内字节偏移（Block Offset）</strong></p><ul><li><strong>定义</strong>：块内字节偏移用于定位一个块中的具体字节。</li><li><strong>计算</strong>：偏移位的数量取决于块的大小。例如，如果块大小为4个字节，则需要2位来表示块内字节偏移。<ul><li>例子：对于一个块大小为4个字节的缓存，偏移位可能是<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>。</li></ul></li></ul><p><strong>2. 索引位（Index Bits）</strong></p><ul><li><strong>定义</strong>：索引位用于定位缓存中的具体行（块）。</li><li><strong>计算</strong>：索引位的数量取决于缓存的行数。例如，如果缓存有8行，需要3位索引位来标识具体的行。<ul><li>例子：对于一个有8行的缓存，索引位可能是<code>000</code>到<code>111</code>。</li></ul></li></ul><p><strong>3. 标记位（Tag Bits）</strong></p><ul><li><strong>定义</strong>：标记位用于区分不同内存块，它们映射到同一个缓存行。</li><li><strong>计算</strong>：标记位的数量 = 内存地址总位数 - 索引位数量 - 块内字节偏移位数量。<ul><li>例子：假设内存地址总位数为16位，块大小为4字节（2位块内偏移），缓存有8行（3位索引），那么标记位数量为11（16-3-2=11）。</li></ul></li></ul><blockquote><p><strong>示例</strong> ：假设有一个16位的内存地址，缓存有8行，每行块大小为4字节。</p></blockquote><p>内存地址：<code>1010110010101110</code></p><ul><li><strong>块内字节偏移</strong>：2位（最右边的2位），<code>10</code> 表示块内的某个字节。</li><li><strong>索引位</strong>：3位（次右边的3位），<code>110</code> 表示缓存的具体行。</li><li><strong>标记位</strong>：11位（剩余左边的位），<code>10101100101</code> 用于区分不同的内存块。</li></ul><p><strong>内存地址分解</strong>：</p><ul><li>标记位（Tag）：<code>10101100101</code></li><li>索引位（Index）：<code>110</code></li><li>块内字节偏移（Block Offset）：<code>10</code></li></ul><center>$Cache容量 = （标记位 + 数据位）\times 行数 $</center>补充：如果题目强调了有效位的存在，那么Cache的每一行需要多1bit的有效位，则<center>$Cache容量 = （1 + 标记位 + 数据位）\times 行数 $</center><p>有效位是缓存系统中的一个重要概念，用于指示缓存块中的数据是否有效。具体来说，有效位帮助确定当前缓存块是否包含可以被处理器使用的有效数据。</p><ol><li><strong>指示数据有效性</strong>：有效位为1表示缓存块中的数据有效且可用；为0表示缓存块中的数据无效，可能未被使用或需要更新。</li><li><strong>管理缓存块</strong>：当一个新的内存块被加载到缓存时，会设置有效位为1。当缓存块的数据被替换或失效时，有效位被设置为0。</li></ol><p><strong>实现原理</strong></p><ul><li><strong>检查有效位</strong>：每次缓存访问时，首先检查有效位。如果有效位为0，即使缓存地址匹配，数据也不被使用，因为它无效。</li><li><strong>缓存替换</strong>：在缓存替换时，新的数据块写入缓存，并将对应的有效位设置为1。被替换的数据块的有效位通常被设置为0，表示数据无效。</li></ul><p><strong>示例</strong><br>假设一个缓存系统有4个块，每个块都有一个有效位：</p><ul><li>块0：有效位=1（数据有效）</li><li>块1：有效位=0（数据无效）</li><li>块2：有效位=1（数据有效）</li><li>块3：有效位=0（数据无效）</li></ul><p>当处理器访问一个地址时，它首先检查缓存块的有效位。如果有效位为1，它会进一步检查地址是否匹配；如果有效位为0，则直接从主存获取数据。</p><h4 id="5-4-2-直接映射缺失的3C模型"><a href="#5-4-2-直接映射缺失的3C模型" class="headerlink" title="5.4.2 直接映射缺失的3C模型"></a>5.4.2 直接映射缺失的3C模型</h4><p><strong>1. 冷缺失（Cold Miss）</strong></p><ul><li><strong>定义</strong>：也称为强制缺失或首次缺失。这种情况发生在缓存首次加载数据块时，因为缓存中还没有存储该数据块。</li><li><strong>示例</strong>：程序第一次访问一个数据块时，缓存中还没有该数据块，导致冷缺失。</li></ul><p><strong>2. 容量缺失（Capacity Miss）</strong></p><ul><li><strong>定义</strong>：由于缓存容量有限，即使缓存中所有块都被充分利用，仍然无法容纳所有需要的数据块，从而导致缺失。</li><li><strong>示例</strong>：程序需要访问的数据块数量超过了缓存容量，导致一些较早访问的数据块被驱逐，再次访问时需要重新加载。</li></ul><p><strong>3. 冲突缺失（Conflict Miss）</strong></p><ul><li><strong>定义</strong>：也称为干扰缺失。这种情况发生在直接映射缓存中，不同的数据块映射到同一个缓存块位置，导致频繁替换，即使缓存容量足够也会出现缺失。</li><li><strong>示例</strong>：两个或多个数据块映射到同一个缓存位置，导致数据块被替换，从而产生冲突缺失。</li></ul><p><img src="/img/CA/map_miss.svg" alt="3C模型" style="max-width: 100%; height: auto;" /></p><p>直接映射在应对上面的Cache缺失的时候有三种处理方式：</p><p><strong>1.写直达（Write Through）：</strong></p><ul><li>CPU同时向Cache和主存写入数据</li><li>实现简单，但写入速度慢</li><li>保持了Cache和主存的一致性</li></ul><p><strong>写缓冲（Write Buffer）：</strong></p><ul><li>CPU先写入Cache</li><li>数据暂存在写缓冲区</li><li>后台异步写入主存</li><li>提高了写入效率</li></ul><p><strong>写回（Write Back）：</strong></p><ul><li>CPU只写入Cache</li><li>使用脏位(Dirty Bit)标记修改</li><li>仅在数据被替换时才写回主存</li><li>最高效但实现复杂</li></ul><p><img src="/img/CA/map_strategy.svg" alt="Cache缺失策略" style="max-width: 100%; height: auto;" /></p><h4 id="5-4-3-多级缓存机制"><a href="#5-4-3-多级缓存机制" class="headerlink" title="5.4.3 多级缓存机制"></a>5.4.3 多级缓存机制</h4><p>多级缓存（Multilevel Cache）是一种在计算机系统中提高处理器访问数据速度的技术，通常将缓存分为多个层次，如 L1、L2 和 L3 缓存。这些缓存层次的设置能够平衡存取速度、容量和成本，确保 CPU 能更快地获取需要的数据。</p><p><strong>多级缓存的主要特点</strong></p><ol><li><p><strong>L1缓存</strong>（一级缓存）：通常集成在 CPU 内核中，速度最快，容量较小（一般为几十KB）。L1缓存分为指令缓存（I-Cache）和数据缓存（D-Cache），分别用于存储指令和数据，帮助 CPU 快速访问常用数据。</p></li><li><p><strong>L2缓存</strong>（二级缓存）：相比 L1 缓存稍慢，但容量更大（几百KB到几MB），通常也集成在处理器中。L2 缓存为 L1 提供数据支援，命中率高，进一步减少了 CPU 对主存（RAM）的访问需求。</p></li><li><p><strong>L3缓存</strong>（三级缓存）：用于共享多个 CPU 内核的数据，容量较大（几MB到几十MB），但访问速度比 L2 缓慢。L3缓存作为所有内核的公共缓存，提升了多核处理器的并行性能。</p></li><li><p><strong>工作原理</strong>：CPU 会首先查找 L1 缓存，如果未命中则依次查找 L2 和 L3 缓存，直到最后访问主存。这样的分级缓存结构可以减少主存访问次数，从而提高系统性能。</p></li><li><p><strong>优点</strong>：多级缓存结构能显著降低数据访问延迟，提高处理器的执行效率；而且它能有效利用缓存的层级特性，合理分配存取速度和容量。</p></li></ol><p><strong>多级缓存背景下的平均 CPI 计算</strong></p><p>在多级缓存系统中，平均每条指令的周期数（CPI，Cycles Per Instruction）可以通过考虑每一级缓存的缺失率和缺失代价来计算。这里的缺失率指的是每一级缓存未命中（缺失）的概率，缺失代价则是缓存未命中时所需要的额外处理周期数。平均 CPI 的计算可以按以下步骤进行。</p><p>假设：</p><ul><li>$\text{CPI}_{\text{ideal}}$ 是理想情况下（没有缓存缺失）的 CPI，即不考虑缓存缺失时每条指令的周期数。</li><li>L1、L2、L3 分别是一级、二级和三级缓存。</li><li>$\text{MR}_n$ 表示第 $n$ 级缓存的缺失率（Miss Rate）。</li><li>$\text{MC}_n$ 表示第 $n$ 级缓存的缺失代价（Miss Penalty），即在第 $n$ 级缓存缺失时需要的额外周期数。</li></ul><p>平均 CPI 的计算可以分为以下步骤：</p><ol><li><p><strong>L1 缓存的贡献</strong>：L1 缓存缺失的情况下，需要访问 L2 缓存，因此 L1 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L1}} = \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}}$ </center></li><li><p><strong>L2 缓存的贡献</strong>：L1 缓存缺失时会访问 L2 缓存，如果 L2 缓存也缺失，则需要访问 L3 缓存。L2 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L2}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$ </center></li><li><p><strong>L3 缓存的贡献</strong>：当 L1 和 L2 都缺失时，才会访问 L3 缓存。如果 L3 缓存也缺失，就会访问主存，因此 L3 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L3}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}}$ </center></li><li><p><strong>主存的贡献</strong>：当 L1、L2 和 L3 缓存都缺失时，才会访问主存。因此主存的平均贡献为：</p><center> $\text{CPI}_{\text{memory}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$ </center></li></ol><p>把各级缓存和主存的贡献相加，再加上理想情况下的 CPI，得到总的平均 CPI：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{CPI}_{\text{L1}} + \text{CPI}_{\text{L2}} + \text{CPI}_{\text{L3}} + \text{CPI}_{\text{memory}}$ </center><p>展开后，即：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$$+ \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$</center><blockquote><ul><li>每一级缓存的贡献都是基于它前一级缓存的缺失率和自身的缺失代价递归计算的。</li><li>这个公式综合了各级缓存的缺失率和缺失代价，提供了一个较为准确的平均 CPI 估计。</li></ul></blockquote><h3 id="5-5-Virtual-Memory"><a href="#5-5-Virtual-Memory" class="headerlink" title="5.5 Virtual Memory"></a>5.5 Virtual Memory</h3><p>虚拟存储器通过地址映射机制，将操作系统使用的虚拟地址转换为不同的物理地址。这个过程涉及多层缓存和映射关系，例如：</p><ul><li>Cache 将处理器寄存器访问的地址映射到内存中的物理地址，以加速数据读取。</li><li>主存（内存）充当磁盘的缓存，从磁盘读取数据时，常用的数据会保存在内存中以加快访问速度。</li><li>TLB（快表）是页表的缓存，用于快速查找虚拟地址到物理地址的映射，减少页表查找的开销。</li></ul><p>将虚拟地址转换为物理地址的过程通常涉及几个关键步骤：</p><ol><li><p>地址生成：当程序访问某个内存位置时，它会生成一个虚拟地址。</p></li><li><p>页号和偏移量：虚拟地址被分为两个部分：页号和偏移量。页号用于识别该地址所属的页，而偏移量则指定了在该页内的具体位置。</p></li><li><p>快速表 (Translation Lookaside Buffer, TLB)：在检查页表之前，系统首先检查快速表 (TLB)，这是一个小而快速的缓存，存储最近的虚拟到物理地址的转换。如果在 TLB 中找到转换（TLB 命中），则可以快速检索物理地址。</p></li><li><p>页表查找：如果在 TLB 中未找到转换（TLB 未命中），系统将访问页表。页表包含条目，将每个虚拟页号映射到内存中相应的物理页框号。</p></li><li><p>物理地址形成：一旦访问了页表，就可以获得物理页框号。然后，物理地址通过将该页框号与原虚拟地址中的偏移量结合来形成。</p></li><li><p>访问内存：系统现在使用物理地址访问 RAM 中的数据。</p></li><li><p>页面缺失处理：如果所需的页面不在内存中（页面缺失），操作系统将从磁盘存储中检索该页面，并相应地更新页表。</p></li></ol><p><img src="/img/CA/address.svg" alt="Address Translation" style="max-width: 100%; height: auto;" /></p><p>关于虚拟地址和物理地址还有更多的考点内容，比如各种替换策略和写策略，这里的内容我更愿意放到操作系统的对应章节来讲解😈马不停蹄更新中🐎</p><div class="note note-primary">            <p>完结撒花🎉<br>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語語彙まとめ</title>
    <link href="/2024/09/28/JPN-Words/"/>
    <url>/2024/09/28/JPN-Words/</url>
    
    <content type="html"><![CDATA[<h1 id="日语单词自测"><a href="#日语单词自测" class="headerlink" title="日语单词自测"></a>日语单词自测</h1><p><em>配合moji插件查看中文释义👀</em></p><h2 id="1-動詞"><a href="#1-動詞" class="headerlink" title="1. 動詞"></a>1. 動詞</h2><p>欺く「あざむく」、覗く「のぞく」、湧く「わく」、逃れる「のがれる」、挑む「いどむ」、固める「かためる」、奪う「うばう」、紛れ込む「まぎれ込む」、仕掛ける「しかける」、強引「ごういん」、溢れる「あふれる」、謙る「へりくだる」、絡み合う「からみあう」、仰ぐ「あおぐ」、耽る「ふける」、眩む「くらむ」、紡ぐ「つむぐ」、辿り着く「たどりつく」、戒める「いましめる」、親しむ「したしむ」、身構える「みがまえる」、ムカ痛「むかつく」、草臥れる「くたびれる」、勤める「つとめる」、節目「ふしめ」、睨む「にらむ」、濁る「にごる」、融合「ゆうごう」、襲う「おそう」、押し込む「おしこむ」、焚く「たく」、惑う「まどう」、傾ける「かたむける」、金縛り「かなしばり」、軋む「きしむ」、免れる「まぬかれる」、与かる「あずかる」、炙る「あぶる」、嘆く「なげく」、誂える「あつらえる」、埋める「うずめる」、頷く「うなずく」、貫く「つらぬく」、授ける「さずける」、値する「あたいする」、省みる「かえりみる」、打ち明ける「うちあける」、押し寄せる「おしよせる」、呆れる「あきれる」、綴る「つずる」、攫う「さらう」、専ら「もっぱら」、呟く「つぶやく」、呼び掛ける「よびかける」、見なす「みなす」、戸惑う「とまどう」、透き通る「好きとおる」、怒鳴る「どなる」、齎す「もたらす」、富む「とむ」、拗ねる「すねる」、威張る「いばる」、凌ぐ「しのぐ」、弁償「べんしょう」、安らぐ「やすらぐ」、見合わせる「みあわせる」、気軽「きがる」、見込む「みこむ」、奉る「たてまつる」、緩める「ゆるめる」、磨く「みがく」、充ちる「みちる」、跨る「またがる」、覆う「おおう」、吹き出す「ふきだす」、交じる「まじる」、紡ぐ「つむぐ」、慰める「なぐさめる」、実る「みのる」、叱る「しかる」、馳せる「はせる」、愚か「おろか」、疑う「うたがう」、探る「さぐる」、痺れる「しびれる」、食い違う「くいちがう」、窺う「うかがう」、揃う「そろう」、報いる「むくいる」、撒く「まく」、拘る「こだわる」、気に障る「きにさわる」、押し切る「おしきる」、立ち寄る「たちよる」、蹴る「ける」、除去「じょきょ」、囁く「ささやく」、志す「こころざす」、伏せる「ふせる」、巫山戯る「ふざける」</p><h2 id="2-名詞"><a href="#2-名詞" class="headerlink" title="2. 名詞"></a>2. 名詞</h2><p>物語「ものがたり」、非難「ひなん」、靄「もや」、競技「きょうぎ」、過労「かろう」、振る舞い「ふるまい」、倹約「けんやく」、氏神「うじがみ」、大木「たいぼく」、復興「ふっこう」、亭主関白「ていしゅかんぱく」、畑「はたけ」、役割「やくわり」、脇「わき」、残酷「ざんこく」、稼業「かぎょう」、木立「きだち」、愛想「あいそ」、苦情「くじょう」、良し悪し「よしあし」、苛め「いじめ」、腰「こし」、当選「とうせん」、目論見「もくろみ」、冒頭「ぼうとう」、羽目「はめ」、下駄「げた」、屋敷「やしき」、一昨年「おととし」、照明「しょうめい」、虚ろ「うつろ」、合否「ごうひ」、私邸「してい」、扱い「あつかい」、神秘「しんぴ」、琴「こと」、里「さと」、猥褻「わいせつ」、暮れ「くれ」、醍醐味「だいごみ」、蓄積「ちくせき」、臥床「がしょう」、山懐「やまふところ」、生涯「しょうがい」、跡地「あとち」、味方「みかた」、取材「しゅざい」、発祥地「はっしょうち」、出入り「でいり」、達者「たっしゃ」、原動力「げんどうりょく」、拘束「こうそく」、融通「ゆうずう」、手際「てぎわ」、立食「りっしょく」、善悪「ぜんあく」、境地「きょうち」、人並み「人なみ」、裸足「はだし」、身内「みうち」、無礼「ぶれい」、懇談「こんだん」、試し「ためし」、公平「こうへい」、魅了「みりょう」、霧「きり」、合間「あいま」、顎「あご」、野生「やせい」、険悪「けんあく」、垢「あか」、庵「いおり」、吟味「ぎんみ」、修復「しゅうふく」、迫真「はくしん」、証「あかし」、話題「わだい」、転がし「ころがし」、干物「ひもの」、過誤「かご」、有頂天「うちょうてん」、懲戒「ちょうかい」、規制「きせい」、文献「ぶんけん」、猿「さる」、霞「かすみ」、叡智「えいち」、神話「しんわ」、賃金「ちんぎん」、密輸入「みつゆにゅう」、賭ける「かける」、育ち「そだち」、割れ目「われめ」、大人「おとな」、ありのまま、細菌「さいきん」、応募「おうぼ」、煮物「にもの」、潮流「ちょうりゅう」、焦る「あせる」、取り上げる「とりあげる」、昨年「さくねん」、贅沢「ぜいたく」、真骨頂「しんこっちょう」、争い「あらそい」、女房「にょうぼう」、足場「あしば」、要請「ようせい」、無難「ぶなん」、水着「みずぎ」、車窓「しゃそう」、合致「がっち」、外見「がいけん」、獣「けもの」、代物「しろもの」、田舎者「いなかもの」、趣「おもむき」、束縛「そくばく」、いらいら、緩和「かんわ」、芽「め」、幾分「いくぶん」、最善「さいぜん」、軽蔑「けいべつ」、日取り「ひどり」、無事「ぶじ」、糧「かて」、厄介「やっかい」、手渡し「てわたし」、一見「いっけん」、マスコミ、気の毒「きのどく」、埋立地「うめたてち」、窮屈「きゅうくつ」、勢い良く「いきおいよく」、触れ合い「ふれあい」、青二才「あおにさい」、怪我「けが」、辺鄙「へんぴ」、発端「ほったん」、跋扈「ばっこ」、ゆとり、最期「さいご」、作風「さくふう」、証拠「しょうこ」、生垣「いけがき」、用心棒「ようじんぼう」、安らぐ「やすらぐ」、</p><h2 id="3-形容詞"><a href="#3-形容詞" class="headerlink" title="3. 形容詞"></a>3. 形容詞</h2><p>鋭い「するどい」、甚だしい「甚だしい」、朗らか「ほがらか」、等しい「ひとしい」、素っ気無い「そっけない」、雄大「ゆうだい」、騒がしい「さわがしい」、ぶかぶか「ぶかぶか」、逞しい「たくましい」、所謂「いわゆる」、緩やか「ゆるやか」、惨め「みじめ」、煌々「こうこう」、滑らか「なめらか」、無茶苦茶「むちゃくちゃ」、微か「かすか」、きまぐれ「きまぐれ」、目覚ましい「めざましい」、物足りない「ものたりない」、つれない、申し分ない「もうしぶんない」、べたべた、忌まわしい「いまわしい」、煩わしい「わずらわしい」、頼もしい「たのもしい」、気障「きざ」、切ない「せつない」、密接「みっせつ」、冥冥「めいめい」、見苦しい「みぐるしい」、あっかない、飛び飛び「とびとび」、達観「たっかん」、うざい、閑静「かんせい」、台無し「だいなし」、望ましい「のぞましい」、細やか「ささやか」、淑やか「しとやか」、真面「まとも」、煌々「こうこう」、淡々「たんたん」、厳密「げんみつ」、出しゃばり「でしゃばり」、刺々しい「とげとげしい」、厳か「おごそか」、乏しい「とぼしい」、疎ら「まばら」、慌ただしい「あわただしい」、待ち遠しい「まちどおしい」、疎か「疎か」、和やか「なごやか」、漠然「ばくぜん」、もどかしい、腹立たしい「はらだたしい」、怪しい「あやしい」、呆気ない「あっけない」、仄か「ほのか」、華やか「はなやか」、</p><h2 id="4-副詞"><a href="#4-副詞" class="headerlink" title="4. 副詞"></a>4. 副詞</h2><p>ぶらぶら、こそこそ、じろじろ、たっぷり、はらはら、がさがさ、がっしり、がやがや、さっぱり、しみじみ、のんびり、ゆったり、すやすや、ぎょうぎょう、めらめら、そっと、益々「ますます」、すらすら、尚更「なおさら」、ちらほら、いよいよ、めちゃくちゃ、ひんやり、ドキドキ、伸び伸び「のびのび」、にこにこ、ぞろぞろ、もやもや、ひっそり、そわそわ、ひょっとして、のっそり、とにかく、わくわく、うっかり、ごろごろ、めそめそ、ぞっと、僅か「わずか」、どっしり、ぐったり、嘸「さぞ」、いやいや、ちょいちょい、如何「いかん」、しっかり、ひたすら、予め「あらかじめ」、差し当たって、からから、ヘラヘラ、ぐっすり、ぐるぐる、のんびり、ひらひら、如何にも「いかにも」、ぼんやり、がっかり、ズルズル、偶々「たまたま」、きっちり、しっとり、元来「がんらい」、あっさり、びっくり、うっとり、丸ごと「まるごと」、すっかり、直に「じかに」、頻りに「しきりに」、バッチリ、ぎっしり、あたかも、</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年8月东大情理CS算法题解读</title>
    <link href="/2024/09/15/UTO-DSA-2021-8/"/>
    <url>/2024/09/15/UTO-DSA-2021-8/</url>
    
    <content type="html"><![CDATA[<h1 id="Author-偷偷"><a href="#Author-偷偷" class="headerlink" title="Author: 偷偷  "></a><center>Author: 偷偷  </center></h1><h1 id="尊重原创，偷偷wx-LifeGoesOn-Rio"><a href="#尊重原创，偷偷wx-LifeGoesOn-Rio" class="headerlink" title="尊重原创，偷偷wx:LifeGoesOn_Rio  "></a><center>尊重原创，偷偷wx:LifeGoesOn_Rio  </center></h1><div class="note note-success">            <p>这道题的场景是实现一个排序算法，目的是优化时间复杂度。题目的策略是使用分治递归(Divide &amp; Conquer),在深度理解题目的场景下可以解决这道题目。</p>          </div><p>Firstly, read the pseudocode.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// return the least value that is >= kl/m</span><span class="token keyword">int</span> <span class="token function">multfrac</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// *q &lt;= *p</span><span class="token keyword">void</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">></span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>        <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>        <span class="token operator">*</span>q <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// sort in ascending order</span><span class="token keyword">void</span> <span class="token function">mysort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>  <span class="token comment">// number of elements</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">/** fill in the  blanks **/</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>(1) 当k &lt; 4, 即元素个数小于4时做升序排序，分类讨论即可。<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>   <span class="token comment">// 元素个数不多于1时，不做任何处理</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比较交换一次</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token comment">// 依次比较三次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>算法详细过程如下：<br><img src="/img/DSA/swap_compare.jpg" alt="交换流程演示" style="max-width: 100%; height: auto;" /></p><p>(2) </p><script type="math/tex; mode=display">T(n)=\begin{cases}1,\quad n\leq 3 \\\\n^{\log_{4/3}{3}}, \quad n>3\end{cases}</script><p>这里也是分类讨论：</p><p>当n &lt;= 3时，比较次数不随输入规模变化，因此为1；</p><p>当n &gt; 3时，代入分析：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort后3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p><img src="/img/DSA/swap_compare2.jpg" alt="递归树演示" style="max-width: 100%; height: auto;" /></p><p>根据递归树可以写出主定理公式(Master theorem):</p><script type="math/tex; mode=display">T(n) = 3T(3n/4) + O(n)</script><p>根据套路：这里b = 4/3, a = 3.</p><script type="math/tex; mode=display">O(n ^{\log_{b}{a}}) = O(n^{log_{4/3}{3}}) > O(n)</script><p>所以有</p><script type="math/tex; mode=display">T(n) = O(n^{\log_{4/3}{3}})</script><p>(3) (4, 2, 3, 3), (4, 3, 2, 3), (4, 3, 3, 2) can always work properly. (4, 2, 3, 2) can’t always work properly.</p><blockquote><p>可以看下图演示：前两次的sort调用的交集部分是排好数组最大的部分，第三次sort调用要覆盖剩余没有排好的部分；对于(4, 2, 3, 2), 前两次调用排好了数组最大的1/4部分，所以第三次调用至少要覆盖数组前3/4的大小，而第三次调用只覆盖了前1/2，所以这个组合不行。</p></blockquote><p><img src="/img/DSA/swap_compare3.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /></p><p>(4)</p><script type="math/tex; mode=display">\begin{cases}    x + y > w \\\\    x + y + z >= 2w\end{cases}</script><blockquote><p>在解决第三题后，第四题就非常容易了。</p></blockquote><p><img src="/img/DSA/swap_compare4.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /></p><p>视数组的大小为1，第一次调用排好前x/w部分的元素，第二次大小排好后y/w部分的元素。所以排序需满足：</p><ol><li>前两次调用的范围必须要有交集</li><li>第三次调用必须要覆盖完前两次调用的没有排好的部分。因此有：<script type="math/tex; mode=display">x/ w + y / w > 1</script><script type="math/tex; mode=display">z / w >=  1 - (x + y - w) / w</script></li></ol>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>数据结构与算法</category>
      
      <category>东京大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
      <tag>东京大学</tag>
      
      <tag>修考答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure &amp; Algorithms</title>
    <link href="/2024/09/10/DSA/"/>
    <url>/2024/09/10/DSA/</url>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure-amp-Algorithms"><a href="#Data-Structure-amp-Algorithms" class="headerlink" title="Data Structure &amp; Algorithms"></a>Data Structure &amp; Algorithms</h1><p>This is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(<strong>偷偷</strong>).The main language is in Chinese but you can see some concepts in English &amp; Japanese. And the pseudocode is in the style of <strong>C++</strong>. Let’s quickly review this subject!</p><p>这是偷偷刷了很多修考题之后总结出来的修考秘籍，全文都是考点，彻底高能。</p><h2 id="1-Introduction-to-Algorithms"><a href="#1-Introduction-to-Algorithms" class="headerlink" title="1. Introduction to Algorithms"></a>1. Introduction to Algorithms</h2><p>这一章主要计划复习<strong>时间复杂度(Time Complexity)</strong> 和 <strong>空间复杂度(Space Complexity)</strong> 两个概念，然后再仔细回顾 <strong>分治递归(DIvide &amp; Conquer)</strong> 这一重要的概念。最后再给出解决时间复杂度常用的分析方法和万能的<strong>主定理公式（Master Theorem）</strong></p><h3 id="1-1-时间复杂度与空间复杂度"><a href="#1-1-时间复杂度与空间复杂度" class="headerlink" title="1.1 时间复杂度与空间复杂度"></a>1.1 时间复杂度与空间复杂度</h3><div class="note note-success">            <p><strong>Space Complexity</strong>: 空间复杂度描述的是算法运行时所需的额外内存空间。通俗解释就是算法在运行的时候需要开辟多少空间的大小。O(1)指一个点集；O(n)就是开辟一个一维空间；O(n^2)开辟二维空间；O(n^3)开辟三维空间。在第二章讲解排序算法的时候，也会用到本章非常多的前置知识。</p>          </div><p>O(1): 常数空间复杂度，表示算法所需的额外空间是固定的，不随输入规模变化。例如，一个固定大小的变量。</p><p>O(n): 线性空间复杂度，表示算法所需的额外空间与输入规模成正比。例如，一个长度为 n 的数组。</p><p>O(n^2): 平方空间复杂度，表示算法所需的额外空间与输入规模的平方成正比。例如，一个 n x n 的二维数组。</p><p>O(n^3): 立方空间复杂度，表示算法所需的额外空间与输入规模的立方成正比。例如，一个 n x n x n 的三维数组。</p><p>一些常见的数据结构的空间复杂度：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> nums <span class="token comment">// 三维数组：O(n^3)</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> nums <span class="token comment">// 二维数组：O(n^2)</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>      <span class="token comment">// 栈：O(n)</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token comment">// 双端队列：O(n)</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> linkedList<span class="token punctuation">;</span>   <span class="token comment">// 链表：O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p><strong>Time complexity</strong>: 时间复杂度是衡量算法效率的重要指标之一，它描述了算法执行所需时间随输入规模增长的变化情况。这是修考中必考的一个地方：（1）如分析给出的代码的时间复杂度（Hint：关注for，while循环）（2）根据源代码优化时间复杂度设计新的算法（Hint：空间换时间）</p>          </div><p>常见的时间复杂度有以下几种：</p><p>O(1): <strong>常数时间复杂度</strong>，算法的执行时间不随输入规模变化。例如，访问数组中的某个元素。</p><p><code>int a = nums[10]  // 给a赋值数组下标为10的元素</code></p><p>O(n): <strong>线性时间复杂度</strong>，算法的执行时间与输入规模成正比。例如，遍历一个长度为 n 的数组。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; /* 操作 */ &#125;</code></p><p>O(log n): 对数时间复杂度，算法的执行时间随输入规模的对数增长。例如，二分查找(Binary Search)算法。</p><p><code>int binarySearch(int[] arr, int target) &#123; /* 二分查找逻辑 */ &#125;</code></p><p> O(n^2) : <strong>平方时间复杂度</strong>，算法的执行时间与输入规模的平方成正比。例如，冒泡排序(Bubble Sort)算法。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; /* 冒泡排序逻辑 */ &#125; &#125;</code></p><p>O(2^n): <strong>指数时间复杂度</strong>，算法的执行时间随输入规模的指数增长。例如，解决所有子集问题的递归算法。</p><p><code>void subsets(int[] nums) &#123; /* 递归逻辑 */ &#125;</code></p><p>在描述使劲复杂度的时候，有三种表示需要注意一下：</p><p>$O$: 表示渐进上界； $\Omega$: 表示渐进下界； $\Theta$: 渐进紧确界</p><h3 id="1-2-分治递归-Divide-amp-Conquer"><a href="#1-2-分治递归-Divide-amp-Conquer" class="headerlink" title="1.2 分治递归(Divide &amp; Conquer)"></a>1.2 分治递归(Divide &amp; Conquer)</h3><div class="note note-success">            <p>分治递归(Divide &amp; conquer)的思想是将原问题分割成更小的子问题，自顶向下地解决每个子问题，并最终自底向上合并它们的解来解决主问题。</p>          </div><p>常见的分治递归有：二分查找(Binary Search) 和归并排序(Merge Sort).</p><h4 id="1-2-1-二分查找-Binary-Search"><a href="#1-2-1-二分查找-Binary-Search" class="headerlink" title="1.2.1 二分查找(Binary Search)"></a>1.2.1 二分查找(Binary Search)</h4><p><img src="/img/DSA/binary_search.svg" alt="二分查找演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 前提nums是有序数组</span><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// (避免left + right) / 2 的溢出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>   <span class="token comment">// 找到目标，返回索引</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 目标在左半部分</span>        <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 目标在右半部分</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>根据上图我们得出递归表达式：<br>$T(n) = T(n / 2) + O(1)$， 得出$T(n) = O(log_{2}{n})$</p><h4 id="1-2-2-归并排序-Merge-Sort"><a href="#1-2-2-归并排序-Merge-Sort" class="headerlink" title="1.2.2 归并排序(Merge Sort)"></a>1.2.2 归并排序(Merge Sort)</h4><p><img src="/img/DSA/merge_sort.svg" alt="归并排序演示" style="max-width: 100%; height: auto;" /><br>这个图像有效地展示了归并排序的”分而治之”策略：<br> 1.将大问题（排序整个数组）分解成小问题（排序子数组）<br> 2.解决小问题（对小数组排序）<br> 3.将小问题的解合并成大问题的解（合并有序子数组）</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 合并两个有序的子数组</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子数组的长度</span>    <span class="token keyword">int</span> n2 <span class="token operator">=</span> right <span class="token operator">-</span> mid<span class="token punctuation">;</span>     <span class="token comment">// 右子数组的长度</span>    <span class="token comment">// 创建临时数组存储左右子数组</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftArr</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rightArr</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 复制数据到临时数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> rightArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token comment">// i是左子数组指针，j是右子数组指针，k是合并后数组的指针</span>    <span class="token comment">// 合并左右子数组</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的左子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的右子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 递归实现归并排序</span><span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 递归排序左右两部分</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 合并已排序的部分</span>        <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>递归式：$T(n) = 2T(n / 2) + O(n)$, 所以$T(n) = O(nlog_{2}{n})$</p><h3 id="1-3-主定理-Master-Theorem"><a href="#1-3-主定理-Master-Theorem" class="headerlink" title="1.3 主定理(Master Theorem)"></a>1.3 主定理(Master Theorem)</h3><p>递归方程形式如：</p><script type="math/tex; mode=display">T(n) = aT(n / b) + O(n^d)</script><div class="note note-success">            <p>其中，$a$表示子问题的数量，b表示每个子问题是原问题规模的$1/b$, $O(n^d)$ 表示在每一层分治过程之外，解决问题所需的额外代价，通常是合并或分割的代价。</p>          </div><p><strong>情况 1：</strong><br>如果$log_{b}{a} &gt; d$，则递归式的解为：</p><script type="math/tex; mode=display">T(n) = O(\log_{b}{a})</script><p><strong>解释：</strong> 在这种情况下，分治产生的子问题数量增长得更快，主导时间复杂度的是递归中的分治部分。</p><p><strong>情况 2：</strong><br>如果$log_{b}{a} = d$，则递归式的解为：</p><script type="math/tex; mode=display">T(n) = O(n^d\log{n})</script><p><strong>解释：</strong> 在这种情况下，分治和额外开销的增长速度相同，因此总的时间复杂度是 $n^d\log{n}$。</p><p><strong>情况 3：</strong><br>如果 $log_{b}{a} &lt; d$，则递归式的解为：</p><script type="math/tex; mode=display">T(n) = O(n^d)</script><p><strong>解释：</strong> 在这种情况下，额外的开销主导时间复杂度，因此复杂度主要由 $n^d$决定。</p><p><strong>斯特林近似公式（Stirling’s Formula）:</strong> $n! \approx \sqrt{2 \pi n} \left( \frac{n}{e} \right)^n$</p><h2 id="2-Sorting-Algorithm"><a href="#2-Sorting-Algorithm" class="headerlink" title="2.Sorting Algorithm"></a>2.Sorting Algorithm</h2><p>再时间复杂度和空间复杂度的概念后，并引入了分治递归和归并排序算法；接下来这一章就主要回顾常见的一些排序算法，然后分析他们的时间复杂度和空间复杂度。</p><h3 id="2-1-插入排序-Insertion-Sort"><a href="#2-1-插入排序-Insertion-Sort" class="headerlink" title="2.1 插入排序(Insertion Sort)"></a>2.1 <strong>插入排序(Insertion Sort)</strong></h3><p>这个算法的过程也很直观：插入排序的核心思想是将一个新元素插入到已经排好序的子序列中的适当位置。<br><img src="/img/DSA/insertation_sort.svg" alt="插入排序演示" style="max-width: 100%; height: auto;" /><br>最好的情况下是：原数组规模小或者大部分数据有序，那么我们一次遍历就可以完成好排序。 最坏的情况下是：原数组是降序排列的，意思是每一次插入新元素的时候，都要遍历一遍已排好序的子数组。<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 从第二个元素开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 回溯检查并交换</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>最坏情况：$T(n) = T(n - 1) + O(n)$,  $T(n) = O(n^2)$</p><p>最好情况：$T(n) = T(n - 1) + O(1)$,  $T(n) = O(n)$</p><h3 id="2-2冒泡排序-Bubble-Sort"><a href="#2-2冒泡排序-Bubble-Sort" class="headerlink" title="2.2冒泡排序(Bubble Sort)"></a>2.2冒泡排序(Bubble Sort)</h3><p>冒泡排序是一个直观的算法，通过重复地遍历数组来工作。在每次遍历中，它比较相邻的元素并在需要时交换它们，这样每次迭代都会将当前未排序部分中的最大元素’冒泡’到数组的末尾正确位置。这个过程从左到右重复进行，直到整个数组排序完成。一句话概括就是：不断的进行两两比较。<br><img src="/img/DSA/bubble_sort.svg" alt="冒泡排序演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 控制循环的轮数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 内层循环，相邻比较</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 交换元素</span>                std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br><strong>冒泡排序平均时间复杂度</strong>：$T(n) = O(n^2)$</p><h3 id="2-3选择排序-Selection-Sort"><a href="#2-3选择排序-Selection-Sort" class="headerlink" title="2.3选择排序(Selection Sort)"></a>2.3选择排序(Selection Sort)</h3><p>选择排序的基本思想是分阶段地将数组划分为两部分：已排序部分和未排序部分。每一轮从未排序部分中找到最小（或最大）的元素，放到已排序部分的末尾，直到整个数组排序完成。<br><img src="/img/DSA/selection_sort.svg" alt="选择排序演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 已排序数组末尾</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 找未排序数组中的最小元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIdx <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br><strong>选择排序时间复杂度：</strong> $T(n) = O(n^2)$</p><h3 id="2-4快速排序-Quick-Sort"><a href="#2-4快速排序-Quick-Sort" class="headerlink" title="2.4快速排序(Quick Sort)"></a>2.4快速排序(Quick Sort)</h3><p>快速排序的本质是分治法。它通过选择一个基准元素，将原数组划分为小于基准元素和大于基准元素的两个子数组，然后对这两个子数组进行递归排序。<br><img src="/img/DSA/quick_sort.svg" alt="快速排序演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分区函数</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 选择最后一个元素作为基准</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 小于基准的元素的索引</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果当前元素小于或等于基准</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 增加小于基准的元素索引</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 快速排序函数</span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// pi是分区索引，arr[pi]现在在正确的位置</span>        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 分别对左右子数组进行递归排序</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>在最坏情况下，基准元素可能是最大或最小值，这会导致一个子数组为空，另一个子数组的大小为 $n-1$，此时的时间复杂度为 $T(n) = T(n-1) + O(n) =O(n^2)$。而在平均情况下，基准元素能够较好地划分数组，时间复杂度为 $T(n) = 2T(n/2) + O(n)=O(n\log{n})$ 。</p><h3 id="2-5堆排序-Heap-Sort"><a href="#2-5堆排序-Heap-Sort" class="headerlink" title="2.5堆排序(Heap Sort)"></a>2.5堆排序(Heap Sort)</h3><p>这个考点应该是修考最爱考的一个了！（敲重点）堆排序的基本思想是不断维护一个最大堆。在每次排序过程中，首先将最大堆的根节点（最大值）与堆的最后一个元素交换，然后缩小堆的范围（排除最后一个元素），并对新的根节点进行下沉操作，以恢复最大堆的性质。重复这一过程，直到所有元素都被排序。<br><img src="/img/DSA/heap_sort.svg" alt="堆排序演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 堆化函数，用于维护最大堆性质</span><span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 初始化最大值为根</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子节点</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 右子节点</span>    <span class="token comment">// 如果左子节点大于根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token comment">// 如果右子节点大于当前最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token comment">// 如果最大值不是根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 递归地堆化受影响的子树</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 堆排序函数</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 构建最大堆（从最后一个非叶子节点开始）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 一个个从堆顶取出元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前根移到末尾</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在减小的堆上调用 max heapify</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><p>建堆的时间复杂度为$O(n)$,每个节点的调整最多为$O(\log{n})$次。在排序的过程中需要建堆$O(n)$次，并且每次需要$O(logn)$来维护堆(heapify),因此对排序总的时间复杂度为$O(n\log{n})$</p><h2 id="3-Data-Structure"><a href="#3-Data-Structure" class="headerlink" title="3.Data Structure"></a>3.Data Structure</h2><p>这一章主要讲解常见的数据结构,如栈(stack),队列(queue),链表(linked list),哈希表(hash map),以及字符串(string)。二叉树考点众多我会单独做成一章并且和图算法一块复习。</p><h3 id="3-1-Stack-amp-Queue"><a href="#3-1-Stack-amp-Queue" class="headerlink" title="3.1 Stack &amp; Queue"></a>3.1 Stack &amp; Queue</h3><p><strong>栈(stack)</strong> :后进先出(LIFO), <strong>队列</strong> :先进先出(FIFO)。另外，栈和队列是可以相互实现的，了解到这个程度，我认为就掌握到栈和队列的基本性质了。</p><p><em>Q1: 如何用栈实现队列？</em><br><div class="note note-success">            <p>A: 开两个栈，一个负责栈负责放入元素，另一个栈负责弹出元素</p>          </div><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个栈负责放入元素，一个栈负责弹出元素</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>      <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟入队过程</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟弹出队首元素过程</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取队首元素的值</span>    <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取队首元素的值</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 放回</span>        out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br><em>Q2：如何用队列实现栈？</em></p><div class="note note-success">            <p>A：开两个队列，一个模拟入栈，一个模拟出栈。更优化的方式是直接开一个队列即可,不断的出队入队就可以实现栈的性质。</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个队列负责入栈，一个负责出栈</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 把in队列的元素不断出队只剩一个，即时栈顶</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶的元素</span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取弹出后的值</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 再放入队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的实现：<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 弹出栈顶元素</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      n<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 把对位元素调整到队首</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶元素  </span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> ans<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="3-2-Linked-List"><a href="#3-2-Linked-List" class="headerlink" title="3.2 Linked List"></a>3.2 Linked List</h3><p>常见的链表有单链表和双链表。<em>单链表</em>：每个节点只包含一个指向下一个节点的指针，访问节点时只能从头节点开始向后遍历。<em>双链表</em>：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。这使得可以在链表中向前和向后遍历。<br><img src="/img/DSA/linkedlist.svg" alt="链表演示" style="max-width: 100%; height: auto;" /></p><p><strong>链表的优缺点</strong></p><p><em>优点</em>：1)动态大小：链表的大小可以动态调整，不像数组那样需要预先定义大小。2)方便插入和删除：在链表中插入或删除节点的时间复杂度为 O(1)，只需调整指针，而数组则可能需要移动大量元素。</p><p><em>缺点</em>：1)内存占用：每个节点需要额外的存储空间来存储指针，导致比数组更高的内存开销。2)随机访问困难：链表不支持快速随机访问，查找元素的时间复杂度为 O(n)。</p><h3 id="3-3-Hash-Map"><a href="#3-3-Hash-Map" class="headerlink" title="3.3 Hash Map"></a>3.3 Hash Map</h3><p><strong>哈希映射（Hash Map）</strong> 是一种数据结构，用于以键值对（key-value pairs）形式存储数据。它通过一个哈希函数将键映射到数组中的索引，从而实现快速的数据访问。主要特点有：</p><p>1）快速查找：平均情况下，哈希映射可以在 O(1) 时间内进行查找、插入和删除操作。</p><p>2）键值对存储：每个元素都由一个唯一的键和与之关联的值组成，可以通过键快速访问对应的值。</p><p>3）哈希函数：将键转换为数组索引的函数，好的哈希函数可以减少冲突（不同键映射到相同索引）。</p><p>4）处理冲突：常用的方法包括<strong>链式法(chaining)</strong>和<strong>开放寻址法（open addressing）</strong>。<br><img src="/img/DSA/hash.svg" alt="哈希表处理冲突演示" style="max-width: 100%; height: auto;" /></p><p>为了减少哈希冲突，哈希映射的函数要尽量将不同的输入键均匀地映射到哈希表的不同索引，以减少冲突（即不同键映射到相同索引的情况）。</p><h3 id="3-4-string"><a href="#3-4-string" class="headerlink" title="3.4 string"></a>3.4 string</h3><p>字符串这个数据结构直观易懂，主要涉及到的考点有KMP算法和sequence alignment算法。这里主要回顾一下KMP算法，关于string类型的其他考点：最长子序列问题和序列比对(Sequence Alignment)，会在后面动态规划章节中仔细讲解。</p><h4 id="3-4-1-KMP算法"><a href="#3-4-1-KMP算法" class="headerlink" title="3.4.1 KMP算法"></a>3.4.1 KMP算法</h4><p>KMP算法可以说是学一次忘一次……建议考前一定要临时报佛脚记一下。这个算法的美妙之处就是在于优化了暴力匹配，用前缀表来跳过重复的匹配过程。前缀表就是模式串中每个位置的最长相等前缀和后缀的长度。在发生不匹配的情况下，将子串移动前一个字符串的前缀表的具体值。（感觉京大最喜欢考KMP算法了）<br><img src="/img/DSA/KMP.svg" alt="KMP算法演示" style="max-width: 100%; height: auto;" /></p><h2 id="4-Binary-Tree"><a href="#4-Binary-Tree" class="headerlink" title="4.Binary Tree"></a>4.Binary Tree</h2><p>关于二叉树的考点有许多，像是考二叉树的遍历，二叉搜索树（Binary Search Tree），最小生成树（MST），以及AVL树。首先需要了解二叉树的一些基本性质，例如每个节点的下标，以及二叉树的多种遍历方式。</p><h3 id="4-1-Concepts-of-Binary-Tree"><a href="#4-1-Concepts-of-Binary-Tree" class="headerlink" title="4.1 Concepts of Binary Tree"></a>4.1 Concepts of Binary Tree</h3><p><img src="/img/DSA/binary_tree.svg" alt="常见的二叉树" style="max-width: 100%; height: auto;" /></p><p><strong>完全二叉树（complete binary tree）</strong>：是一种二叉树，其中每一层都是满的，除了可能是最后一层，且最后一层的节点从左到右排列。在完全二叉树中，所有的节点都尽可能地靠左排列，这种结构使得它在存储和操作上更为高效。与全二叉树不同，完全二叉树允许最后一层不满，但仍需保持左侧填充。</p><p>对于一个完全二叉树，如果节点的索引为$i$,节点数为$n$那么：</p><ol><li>左孩子节点索引: $2i$</li><li>右孩子节点索引: $2i + 1$</li><li>父亲节点索引: $[i/2]$  </li><li>二叉树高度: $ceil(log<em>{2}{(n+1)})$ 或 $floor(log</em>{2}{n}) + 1$</li></ol><p><strong>全二叉树（full binary tree）</strong>：是指每个节点要么没有子节点，要么恰好有两个子节点的二叉树。在这种树中，除了叶子节点外，所有节点都有两个子节点。这样的结构确保了树的每一层都被完全填满，只有最后一层可能不满。</p><p><strong>二叉搜索树（Binary Search Tree, BST）</strong>: 是一种二叉树，其中每个节点都包含一个键值，左子树的所有节点键值小于该节点，右子树的所有节点键值大于该节点。这种结构使得查找、插入和删除操作的平均时间复杂度为 O(log n)。其主要性质包括：每个节点最多有两个子节点，左子树和右子树都是二叉搜索树，且没有重复的键值。</p><p>二叉搜索树的搜索迭代实现：<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">></span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="4-2-Tree-Traversal"><a href="#4-2-Tree-Traversal" class="headerlink" title="4.2 Tree Traversal"></a>4.2 Tree Traversal</h3><p><strong>层序遍历（Level Order Traversal）：</strong> 开一个队列处理一层的节点并放入下一层的节点。这个遍历也属于<strong>广度优先遍历（BFS）</strong>。<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">auto</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>二叉树的<strong>深度优先遍历（DFS）</strong> 可以分为三种：前序遍历，中序遍历和后序遍历。</p><p><strong>前序遍历（Preorder Traversal）：</strong>  <em>根-&gt;左-&gt;右</em>，递归实现<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>当然也可以开一个栈来实现<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br><strong>后序遍历（Postorder Traversal）：</strong>  <em>左-&gt;右-&gt;根</em>，递归实现<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>后序遍历同样可以开一个栈来实现<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br><strong>中序遍历（Inorder Traversal）：</strong>  <em>左-&gt;根-&gt;右</em>，递归实现<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>当然也可以开一个栈来实现：<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token operator">-></span> right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><p>二叉树的中序遍历还有一个重要的考点是<em>逆波兰表达式</em>,这个曾经在京大的过去问中出现过。<strong>逆波兰表达式（Reverse Polish Notation, RPN）</strong> 是一种后缀表示法，用于表示算术表达式。在这种表示法中，运算符跟在操作数之后，而不是在它们之间。这种形式的好处是消除了括号的需要，因为操作的顺序总是由操作符的位置决定。具体的实现方法可以开一个栈轻松解决。<br><img src="/img/DSA/rpn.svg" alt="逆波兰表达式" style="max-width: 70%; height: auto;" /></p><h3 id="4-3-AVL-Tree"><a href="#4-3-AVL-Tree" class="headerlink" title="4.3 AVL Tree"></a>4.3 AVL Tree</h3><p><strong>AVL树</strong>是一种自平衡的二叉搜索树，确保每个节点的左右子树高度差（平衡因子）最多为1。这样可以保证树的高度在 $O(log{n})$ 范围内，确保高效的插入、删除和查找操作。AVL树通过旋转操作来维持平衡，从而优化性能，特别是在频繁修改的场景中。东工有一年考到了这个点，但我认为了解到AVL树的工作原理就ok了,主要聚焦在节点的添加和删除以及树的旋转。<br><img src="/img/DSA/avl_tree_insert.svg" alt="AVL树增加节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_delete.svg" alt="AVL树删除节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_rotate.svg" alt="AVL树左旋和右旋" style="max-width: 100%; height: auto;" /></p><h2 id="5-Graph-Theory"><a href="#5-Graph-Theory" class="headerlink" title="5.Graph Theory"></a>5.Graph Theory</h2><p>本章主要讲解图的基本算法，最小生成树，单源最短路径算法，单源最短路径算法和多源最短路径算法，以及最大流问题。修考题的图算法都是套的模版，因此了解算法的核心思想非常关键。</p><h3 id="5-1图的基本算法"><a href="#5-1图的基本算法" class="headerlink" title="5.1图的基本算法"></a>5.1图的基本算法</h3><p>对于图的表示，我们需要建立一个<strong>邻接矩阵(adjacency matrix)</strong>,简单图的邻接矩阵是(0,1)矩阵并且对角线元素都为0。无向图的邻接矩阵是对称矩阵。<br><img src="/img/DSA/adjacency_matrix.svg" alt="邻接矩阵" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-BFS"><a href="#5-1-1-BFS" class="headerlink" title="5.1.1 BFS"></a>5.1.1 BFS</h4><p>在二叉树章节中讲解了树的深度遍历算法，在图中，我们可以同样的利用邻接链表（也就是建一个数组）来获取当前遍历的节点的邻接节点，开一个数组记录已访问的节点，最后利用队列实现层序遍历。<br><img src="/img/DSA/bfs.svg" alt="广度优先算法" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// BFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Create a queue for BFS</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> queue<span class="token punctuation">;</span>        <span class="token comment">// Mark the source node as visited and enqueue it</span>        visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Dequeue a vertex from queue and print it</span>            s <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Get all adjacent vertices of the dequeued vertex s</span>            <span class="token comment">// If an adjacent has not been visited, then mark it visited</span>            <span class="token comment">// and enqueue it</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h4 id="5-1-2-DFS"><a href="#5-1-2-DFS" class="headerlink" title="5.1.2 DFS"></a>5.1.2 DFS</h4><p>DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索图形或树数据结构的算法。它尽可能深地访问节点，然后回溯，寻找未访问过的节点。</p><p><strong>基本原理：</strong></p><ol><li>初始化：从起始节点出发，将其标记为访问过。之后开始递归或使用栈</li><li><em>递归</em>：对每个未访问的邻接节点，递归调用DFS。（递归的实现方式就是利用栈来记录每一次函数调用的状态）<br><em>栈</em>：将节点压入栈中，访问节点时将其出栈，继续访问其未访问的邻接节点，并将这些邻接节点压入栈。</li><li><em>回溯</em>：如果当前节点的所有邻接节点都访问过，则回溯到上一个节点，继续这个过程，直到所有节点都访问完。<br><img src="/img/DSA/dfs.svg" alt="深度优先算法" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">&amp;</span>visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark the current node as visited and print it</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token comment">// Recur for all the vertices adjacent to this vertex</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// DFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all the vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Call the recursive helper function to print DFS traversal</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p>BFS和DFS对比非常鲜明。BFS的性格是保守，害怕风险，尽量做到“广撒网，细收鱼”；而DFS则是奔放，秉持着一颗“不撞南墙不回头”，“不到黄河不死心”的感觉。</p>          </div></li></ol><h4 id="5-1-3-Topological-Sort"><a href="#5-1-3-Topological-Sort" class="headerlink" title="5.1.3 Topological Sort"></a>5.1.3 Topological Sort</h4><p><strong>拓扑排序（Topological Sorting）</strong>是图论中的一种线性排序方法，主要用于对<strong>有向无环图（Directed Acyclic Graph, DAG</strong> 中的顶点进行排序，使得对于图中的每一条有向边 (u → v)，顶点 u 在排序中都出现在顶点 v 的前面。<br><img src="/img/DSA/topo_sort.svg" alt="拓扑排序算法" style="max-width: 100%; height: auto;" /><br><strong>拓扑排序算法步骤：</strong></p><ol><li>计算每个顶点的入度：统计每个顶点被其他顶点指向的次数（即入度, inDegree）。</li><li>将所有入度为 0 的顶点加入队列：这些顶点没有任何前置依赖。</li><li>重复以下步骤直到队列为空：（1）从队列中取出一个顶点 u，将其加入拓扑排序结果中。（2）遍历 u 的所有邻接顶点 v，将 v 的入度减 1；如果 v 的入度变为 0，则将 v 加入队列。</li><li>检查结果：如果所有顶点都被处理过，则返回拓扑排序；否则，图中有环，无法进行拓扑排序。</li></ol><p>在初始化时，需要遍历所有顶点计算入度，耗时$O(V)$；然后遍历所有边来更新入度并处理顶点，耗时$O(E)$。因此总的时间复杂度是$O(V + E)$。最终的排序顺序是: $1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7$。<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span>  <span class="token comment">// 顶点数</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span>  <span class="token comment">// 邻接表</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inDegree<span class="token punctuation">;</span>  <span class="token comment">// 入度数组</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inDegree</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        <span class="token comment">// 将所有入度为0的顶点加入队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 对于所有相邻的顶点，将其入度减1</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 检查是否存在环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"图中存在环，无法进行拓扑排序"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h4 id="5-1-4-Union-Find"><a href="#5-1-4-Union-Find" class="headerlink" title="5.1.4 Union Find"></a>5.1.4 Union Find</h4><p><strong>并查集（Union-Find）</strong> 算法，又称为不相交集数据结构，是一种用于处理元素分组及查询元素所属组的高效数据结构。它广泛应用于图论（如判断图的连通性、<em>Kruskal算法</em>求最小生成树）并查集主要支持<strong>两种操作</strong>：</p><ol><li>查找（Find）：确定某个元素属于哪个集合（即找到该元素所在集合的代表元素或根节点）。</li><li>合并（Union）：将两个不同的集合合并为一个集合。</li></ol><p>为了提高并查集的效率，通常结合以下两种优化策略：</p><ol><li>路径压缩（Path Compression）：在 Find 操作中，将访问过的所有节点直接连接到根节点，从而降低树的高度。</li><li>按秩合并（Union by Rank）或按大小合并（Union by Size）：在 Union 操作中，总是将较小的树挂到较大的树下，保持树的平衡。</li></ol><p>结合这两种优化后，并查集的时间复杂度几乎接近于常数时间，具体为 反阿克曼函数 的时间复杂度，几乎可以认为是 $O(1)$。<br><img src="/img/DSA/union_find.svg" alt="并查集算法" style="max-width: 100%; height: auto;" /><br>以下是一个使用路径压缩和按秩合并优化的并查集实现：<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 存储每个节点的父节点</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rank<span class="token punctuation">;</span>    <span class="token comment">// 存储每个节点的秩（树的高度）</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数：初始化每个节点的父节点为自身，秩为1</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        rank<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作：查找元素x所在集合的根节点，并进行路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 路径压缩</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作：将元素x和元素y所在的集合合并</span>    <span class="token keyword">void</span> <span class="token function">unionSets</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 已经在同一个集合中</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 按秩合并：将秩较小的树挂到秩较大的树下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="5-2-Minimum-Spanning-Tree"><a href="#5-2-Minimum-Spanning-Tree" class="headerlink" title="5.2 Minimum Spanning Tree"></a>5.2 Minimum Spanning Tree</h3><p><strong>最小生成树（Minimum Spanning Tree, MST）</strong> 是指在一个带权无向图中，连接所有顶点的一个子图，使得：</p><ol><li>这个子图是一个树（即没有环，并且连通所有顶点）。</li><li>这个树的总边权和最小。</li></ol><p><strong>特点</strong>：</p><ol><li>最小生成树包含图中所有的顶点，但只包含连接这些顶点的最少数量的边（即 $V - 1$条边，$V$为顶点数）。</li><li>它保证生成的树的边权总和最小。</li></ol><p>常见的MST生成算法有2种：<em>Kruskal算法</em>和<em>Prim算法</em>。简单来说，Kruskal是基于边的选择，而Prim算法是从某个顶点开始构建最小生成树的，逐步扩展树的边界。</p><h4 id="5-2-1-Kruskal"><a href="#5-2-1-Kruskal" class="headerlink" title="5.2.1 Kruskal"></a>5.2.1 Kruskal</h4><p>具体步骤为：</p><ol><li>首先对所有边按权重从小到大排序。</li><li>然后依次利用<strong>并查集（Union Find）</strong>检查每条边的两个顶点是否属于不同的集合，如果是，则将它们合并，并将该边加入最小生成树。</li><li>重复这个过程，直到最小生成树中包含了$V−1$条边。</li></ol><p><strong>时间复杂度：</strong> 边排序耗时$O(ElogE)$，并查集操作近似为$O(1)$，因此总时间复杂度为$O(ElogE)$。<br><img src="/img/DSA/kruskal.svg" alt="Kruskal算法" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含起点、终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 比较函数，按照权重升序排序</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> weight <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 并查集（Union-Find）结构体</span><span class="token keyword">struct</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">,</span> rank<span class="token punctuation">;</span>    <span class="token comment">// 初始化并查集，所有节点的父节点初始化为自己，秩(rank)初始化为0</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作，使用路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作，按秩合并</span>    <span class="token keyword">void</span> <span class="token function">unite</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootU <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootV <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootU <span class="token operator">!=</span> rootV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">=</span> rootV<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>                rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Kruskal算法实现</span><span class="token keyword">int</span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 按权重升序排序所有边(至关重要的一环)</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edges<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UnionFind <span class="token function">uf</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> edgesUsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已经加入生成树的边数</span>    <span class="token comment">// 遍历所有边</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 查找两个顶点是否属于不同的集合（不同的连通分量）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">)</span> <span class="token operator">!=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">,</span> edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将它们合并到同一个集合</span>            mstWeight <span class="token operator">+=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span> <span class="token comment">// 将这条边的权重加入总权重</span>            edgesUsed<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 如果已经加入V-1条边，生成树构建完毕</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>edgesUsed <span class="token operator">==</span> numVertices <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h4 id="5-2-2-Prim算法"><a href="#5-2-2-Prim算法" class="headerlink" title="5.2.2 Prim算法"></a>5.2.2 Prim算法</h4><p>Prim算法的基本思想是从一个顶点开始，逐步将与当前生成树相连的最小边加入到树中，直到包含图中所有顶点为止。不同于Kruskal算法选择的是边，Prim算法在每一步选择的是<em>与已连接的顶点相连的最小权重边</em>。</p><p>算法步骤：</p><ol><li>初始化：选择一个起始顶点，标记为生成树的一部分。<br>使用一个数组/优先队列来记录所有尚未加入生成树的顶点到当前生成树的最小边的权重。</li><li>选择最小边：<br>在每一步中，从所有与生成树相连的边中选择权重最小的边（维护一个优先队列），确保这个边不会形成环。</li><li>更新距离：将选择的边的顶点加入生成树<u>并更新尚未加入树的顶点到新生成树的最小边的权重。</u></li><li>重复上述步骤，直到所有顶点都被加入生成树。</li></ol><p>对每条边的操作（插入、删除、更新最小边权重）是$O(logV)$的，因此总的时间复杂度为$O(ElogV)$，其中$E$是边的数量，$V$是顶点的数量。<br><img src="/img/DSA/prim.svg" alt="Prim算法" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Prim算法的实现</span><span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 标记每个顶点是否在生成树中</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">inMST</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录最小权重的边的权重，初始化为无穷大(敲重点)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">minEdgeWeight</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 优先队列（最小堆），存储&#123;边的权重，顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    <span class="token comment">// 从第0号顶点开始</span>    minEdgeWeight<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 取出权重最小的边</span>        <span class="token keyword">int</span> weight <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果顶点u已经在MST中，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 将顶点u加入MST</span>        inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        mstWeight <span class="token operator">+=</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 更新与顶点u相连的其他顶点的最小边权重</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inMST<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">&lt;</span> minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>w<span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="5-3-单源最短路径算法"><a href="#5-3-单源最短路径算法" class="headerlink" title="5.3 单源最短路径算法"></a>5.3 单源最短路径算法</h3><p>单源最短路径算法（Single-Source Shortest Path, SSSP）用于从图中的一个指定起点（源点）出发，找到该点到图中所有其他顶点的最短路径。常用的单源路径算法为<strong>Dijkstra算法</strong>和<strong>Bellman-Ford算法</strong>。Dijkstra算法只能用于无负权边的图。如果图中存在负权边，Dijkstra算法的结果可能不正确。Bellman-Ford算法可以处理带负权边的图，且能够检测负权环（如果存在负权环，则说明不存在最短路径）。</p><h4 id="5-3-1-Dijkstra’s-algorithm"><a href="#5-3-1-Dijkstra’s-algorithm" class="headerlink" title="5.3.1 Dijkstra’s algorithm"></a>5.3.1 Dijkstra’s algorithm</h4><p><strong>Dijkstra算法</strong>的基本思想是：每次贪心地从当前未处理的顶点中选择一个距离源点最近的顶点，标记其最短路径为确定，然后通过该顶点更新其邻接点的最短路径。过反复选择距离最小的顶点，并更新邻接点的路径长度，最终能确定所有顶点的最短路</p><p><strong>时间复杂度</strong>：在使用优先队列（最小堆）的情况下，Dijkstra算法的时间复杂度为$O(ElogV)$，其中E是图中边的数量，V是顶点的数量。取出当前最小距离顶点的操作需要$O(logV)$时间。每条边被检查一次，更新时需要$O(logV)$的时间来调整优先队列。在稠密图中，算法的效率略低，因为每次更新都需要重新维护优先队列，但在稀疏图中性能良好。<br><img src="/img/DSA/dijkstra.svg" alt="Dijkstra算法" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 存储从源点到每个顶点的最短距离</span>    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 源点到自身的距离为0</span>        <span class="token comment">// 优先队列：最小堆，存储的是&#123;距离, 顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> source<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>  <span class="token comment">// 取出距离源点最近的顶点</span>        <span class="token keyword">int</span> d <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>   <span class="token comment">// 当前顶点的最短距离</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果当前距离已经不是最优解，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 更新顶点 u 的邻接点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> weight <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token comment">// 如果通过 u 到 v 的路径更短，更新路径</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 v 插入优先队列</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h4 id="5-3-2-Bellman-Ford-Algorithm"><a href="#5-3-2-Bellman-Ford-Algorithm" class="headerlink" title="5.3.2 Bellman-Ford Algorithm"></a>5.3.2 Bellman-Ford Algorithm</h4><p><strong>Bellman-Ford算法</strong>是一种经典的算法，用于解决单源最短路径问题（Single Source Shortest Path, SSSP），即从图中的某个源点到其他所有顶点的最短路径。它与Dijkstra算法的不同之处在于，Bellman-Ford可以处理权值为负数的边，并且能够检测出图中是否存在负权环（negative-weight cycle）。</p><p>Bellman-Ford算法的核心思想是通过<strong>松弛（relaxation）</strong> 操作逐步更新每个顶点的最短路径估计值。松弛操作的含义是，如果从某条边可以得到比当前已知更短的路径，则更新路径长度。算法通过多次迭代更新路径，确保找到全局的最短路径。</p><p><strong>算法步骤：</strong></p><ol><li>初始化：将源点到源点的距离设为0（即$dist[source] = 0$），其他所有顶点到源点的距离初始设为正无穷大（$dist[v] = ∞$）。设定前驱节点为None或相应的初始值。</li><li>松弛所有边：对于图中的所有边$(u,v)$，检查是否可以通过$u$达到$v$的更短路径，即$dist[v] &gt; dist[u] + weight(u, v)$。如果是，则更新$dist[v] = dist[u] + weight(u, v)$。重复这个过程最多$n−1$次，其中$n$是顶点的数量。因为最短路径最多包含$n−1$条边。</li><li>检测负权环（可选步骤）：在完成$n−1$次松弛操作后，再对所有边执行一次松弛操作。如果此时还能继续更新某个顶点的最短路径值，则说明图中存在负权环，因为在无负权环的情况下，经过$n−1$次松弛操作后，所有最短路径应该已经收敛。</li></ol><p>边的松弛操作需要对每条边执行，图中一共有𝑚条边。算法需要对所有边重复𝑛−1次（因为最短路径最多包含𝑛−1条边），因此时间复杂度为𝑂(𝑛⋅𝑚)</p><p><img src="/img/DSA/bellman_ford.svg" alt="松弛操作" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> Bellmanford算法伪代码function BellmanFord<span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> Step <span class="token number">1</span><span class="token punctuation">:</span> Initialize distances    <span class="token keyword">for</span> each vertex v <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> ∞  <span class="token operator">//</span> Set <span class="token builtin">all</span> distances to infinity        predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> null  <span class="token operator">//</span> No predecessors initially    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token operator">//</span> The distance <span class="token keyword">from</span> the source to itself <span class="token keyword">is</span> zero    <span class="token operator">//</span> Step <span class="token number">2</span><span class="token punctuation">:</span> Relax <span class="token builtin">all</span> edges n<span class="token operator">-</span><span class="token number">1</span> times    <span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">1</span> to <span class="token operator">|</span>V<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>            <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>                predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u    <span class="token operator">//</span> Step <span class="token number">3</span><span class="token punctuation">:</span> Check <span class="token keyword">for</span> negative<span class="token operator">-</span>weight cycles    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>            error <span class="token string">"Graph contains a negative-weight cycle"</span>        <span class="token keyword">return</span> dist<span class="token punctuation">,</span> predecessor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-4-多源最短路径算法"><a href="#5-4-多源最短路径算法" class="headerlink" title="5.4 多源最短路径算法"></a>5.4 多源最短路径算法</h3><h4 id="5-4-1-Floyd-Wallshall’s-Algorithm"><a href="#5-4-1-Floyd-Wallshall’s-Algorithm" class="headerlink" title="5.4.1 Floyd-Wallshall’s Algorithm"></a>5.4.1 Floyd-Wallshall’s Algorithm</h4><p><strong>Floyd-Warshall算法</strong> 是一种经典的动态规划算法，用于解决所有点对最短路径问题。它可以在加权图中找出每一对顶点之间的最短路径，<em>即使图中包含负权重边</em>，只要没有负权重环路（即从某个顶点出发经过一些边又回到该顶点且路径总权重为负）。<u>京大知能</u>的一年过去问就考了这道题的手动迭代推理，在复习这个题的时候建议和京大的过去问配合看。</p><p><strong>算法步骤：</strong></p><ol><li><p>初始化：将距离矩阵$dist[][]$初始化为图的邻接矩阵。如果$i == j$，则$dist[i][j] = 0$，表示从节点$i$到节点$j$的路径距离为$0$。如果$i ≠ j$且两点之间有边，则$dist[i][j] = weight(i, j)$，否则$dist[i][j]设为∞$（表示两点不直接相连）。</p></li><li><p>动态规划：通过三重循环逐步更新每对顶点之间的最短距离。外层循环选取一个中间顶点$k$，中间两层循环更新每一对顶点$i$和$j$之间的最短路径，判断是否通过$k$可以得到更短的路径。如果$dist[i][k] + dist[k][j] &lt; dist[i][j]$，则更新$dist[i][j]$。公式为：</p><div style="text-align: center;">$$dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])$$</div></li></ol><p><strong>时间复杂度：</strong><br>Floyd-Warshall算法的时间复杂度为$O(V³)$，其中$V$是图中顶点的数量。三重嵌套循环的每一层都依赖于顶点的数量，因此该算法适合顶点较少的图。对于边多（稠密图）且顶点数量不多的情况，它是一个有效的算法。<br><img src="/img/DSA/floyd.svg" alt="Floyd算法演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">floydWarshall</span><span class="token punctuation">(</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储最短路径</span>    <span class="token comment">// 初始化距离矩阵，将其设为输入图的邻接矩阵</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 三重循环：i是起点，j是终点，k是中间节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果从i通过k到j的路径更短，则更新dist[i][j]</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span>                     dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="5-5-Maximum-FLow-Problem"><a href="#5-5-Maximum-FLow-Problem" class="headerlink" title="5.5 Maximum FLow Problem"></a>5.5 Maximum FLow Problem</h3><p><strong>最大流问题</strong>是网络流理论中的一个经典问题，旨在寻找在一个流网络（或称为容量网络）中，从源点到汇点的最大可能流量。这个问题可以应用于很多实际场景，比如交通网络、物流系统、通信网络等。</p><p><strong>最大流问题</strong>的定义：</p><ol><li><p>流网络：由顶点集和边集组成的有向图，其中每条边都有一个非负的容量，表示能通过该边的最大流量。这个网络中有一个特定的顶点被称为源点（source），另一个顶点称为汇点（sink）。</p></li><li><p>流量：从源点到汇点传输的流称为流量。流量需要遵守以下两个条件：</p></li><li><p>容量限制：每条边上的流量不能超过该边的容量。</p></li><li>流量守恒：除了源点和汇点，其他顶点的流入流量与流出流量相等。</li></ol><p>本章只讲解Ford-Fulkerson算法，有余力可以再了解一下Edmonds-Karp算法和Push-Relabel算法。</p><h4 id="5-5-1-Ford-Fulkerson-Algorithm"><a href="#5-5-1-Ford-Fulkerson-Algorithm" class="headerlink" title="5.5.1 Ford-Fulkerson Algorithm"></a>5.5.1 Ford-Fulkerson Algorithm</h4><p>福特-福尔克森算法的核心思想是利用增广路径（Augmenting Path）来增加网络中的流量。增广路径是指在残余网络（Residual Network）中，从源点到汇点的一条路径，且路径上的每条边都有剩余容量（Residual Capacity）大于零。算法通过反复寻找这样的路径，并沿路径增加流量，直到没有增广路径为止。<br><img src="/img/DSA/ford.svg" alt="Ford-Fulkerson算法演示" style="max-width: 100%; height: auto;" /><br><strong>初始状态：</strong></p><p>如图所示，所有边的初始流量都为 0。我们的目标是找到从源点 S 到汇点 T 的最大流。</p><p><strong>第一次迭代：</strong></p><ul><li><strong>a.</strong> 找一条增广路径，例如：S -&gt; A -&gt; C -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 5（A 到 C 的边）</li><li><strong>c.</strong> 更新流量：<script type="math/tex; mode=display">\begin{aligned}S \to A: &\ 0/10 \rightarrow 5/10 \\\\A \to C: &\ 0/5 \rightarrow 5/5 \\\\C \to T: &\ 0/9 \rightarrow 5/9\end{aligned}</script></li></ul><p><strong>第二次迭代：</strong></p><ul><li><strong>a.</strong> 找另一条增广路径，例如：S -&gt; B -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 6（D 到 T 的边）</li><li><strong>c.</strong> 更新流量：<script type="math/tex; mode=display">\begin{aligned}S \to B: &\ 0/8 \rightarrow 6/8 \\\\B \to D: &\ 0/7 \rightarrow 6/7 \\\\D \to T: &\ 0/6 \rightarrow 6/6\end{aligned}</script></li></ul><p><strong>第三次迭代：</strong></p><ul><li><strong>a.</strong> 找下一条增广路径，例如：S -&gt; A -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 3（A 到 D 的边）</li><li><strong>c.</strong> 更新流量：<script type="math/tex; mode=display">\begin{aligned}S \to A: &\ 5/10 \rightarrow 8/10 \\\\A \to D: &\ 0/3 \rightarrow 3/3 \\\\D \to T: &\ 6/6 \text{（已满，无法增加）}\end{aligned}</script></li></ul><p><strong>算法终止：</strong><br>此时，我们无法找到从 S 到 T 的更多增广路径。所有通向 T 的边都已经满了：</p><ul><li>$C \to T: 5/9$</li><li>$D \to T: 6/6$</li></ul><p><strong>计算最大流：</strong><br>最大流等于从源点出发的所有流量之和：</p><script type="math/tex; mode=display">8\ (\text{S} \to \text{A}) + 6\ (\text{S} \to \text{B}) = 14</script><p>也等于进入汇点的所有流量之和：</p><script type="math/tex; mode=display">5\ (\text{C} \to \text{T}) + 6\ (\text{D} \to \text{T}) = 11</script><p><strong>最终结果：</strong></p><ul><li>最大流值为 14</li><li>S -&gt; A -&gt; C -&gt; T 路径上流量为 5</li><li>S -&gt; B -&gt; D -&gt; T 路径上流量为 6</li><li>S -&gt; A -&gt; D -&gt; T 路径上流量为 3</li></ul><p>Ford-Fulkerson 算法的核心思想是不断寻找增广路径并增加流量，直到无法找到更多的增广路径为止。每次找到增广路径后，我们都会更新网络中的流量，直到达到最大流。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">function FordFulkerson<span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 初始化残余图    ResidualGraph Gf <span class="token operator">=</span> CreateResidualGraph<span class="token punctuation">(</span>G<span class="token punctuation">)</span>        <span class="token operator">//</span> 初始化最大流为<span class="token number">0</span>    maxFlow <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> true<span class="token punctuation">:</span>        <span class="token operator">//</span> 在残余图中寻找增广路径        Path augmentingPath <span class="token operator">=</span> FindAugmentingPath<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>                <span class="token operator">//</span> 如果没有找到增广路径，算法终止        <span class="token keyword">if</span> augmentingPath <span class="token keyword">is</span> empty<span class="token punctuation">:</span>            <span class="token keyword">break</span>                <span class="token operator">//</span> 找到增广路径上的最小残余容量        minResidualCapacity <span class="token operator">=</span> FindMinResidualCapacity<span class="token punctuation">(</span>augmentingPath<span class="token punctuation">)</span>                <span class="token operator">//</span> 更新残余图        UpdateResidualGraph<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> augmentingPath<span class="token punctuation">,</span> minResidualCapacity<span class="token punctuation">)</span>                <span class="token operator">//</span> 增加最大流        maxFlow <span class="token operator">=</span> maxFlow <span class="token operator">+</span> minResidualCapacity        <span class="token keyword">return</span> maxFlowfunction FindAugmentingPath<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 使用DFS或BFS寻找从source到sink的路径    <span class="token operator">//</span> 返回找到的路径，如果没有路径则返回空function FindMinResidualCapacity<span class="token punctuation">(</span>Path augmentingPath<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 遍历路径，找到最小的残余容量    <span class="token operator">//</span> 返回最小残余容量function UpdateResidualGraph<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Path augmentingPath<span class="token punctuation">,</span> <span class="token builtin">int</span> minResidualCapacity<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> augmentingPath<span class="token punctuation">:</span>        <span class="token operator">//</span> 减少正向边的残余容量        Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-</span> minResidualCapacity        <span class="token operator">//</span> 增加反向边的残余容量        Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> minResidualCapacityfunction CreateResidualGraph<span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 创建一个与原图结构相同的残余图    <span class="token operator">//</span> 初始化残余容量等于原图的容量    <span class="token operator">//</span> 为每条边添加一条初始容量为<span class="token number">0</span>的反向边    <span class="token operator">//</span> 返回创建的残余图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="6-Greedy-Algorithm"><a href="#6-Greedy-Algorithm" class="headerlink" title="6. Greedy Algorithm"></a>6. Greedy Algorithm</h2><p><strong>贪心算法</strong>是一种算法设计范式，其核心思想是：在解决问题时，总是做出在当前状态下看起来最优的选择，即局部最优解，希望通过一系列这样的选择能够最终得到全局最优解。这个算法理解起来非常直观，但是合理性证明的话需要严格的数学证明。本章着重讲解最经典的<strong>最大子序和问题（Maximum Subarray）</strong> 和<strong>合并区间问题（Merge Intervals）</strong></p><h3 id="6-1-Maximum-Subarray"><a href="#6-1-Maximum-Subarray" class="headerlink" title="6.1 Maximum Subarray"></a>6.1 Maximum Subarray</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/maximum-subarray/description/">Leetcode 53题</a>练习。</p><blockquote><p>问题描述是：Given an integer array nums, find the subarray with the largest sum, and return its sum.</p></blockquote><p><strong>Example 1:</strong></p><ul><li><p>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</p></li><li><p>Output: 6</p></li><li><p>Explanation: The subarray [4,-1,2,1] has the largest sum 6.</p></li></ul><p>解决这个问题的贪心算法也叫Kadane算法：算法从左到右遍历一次数组，在每一步，它都计算当前位置结束的子数组的最大和（Current Sum）同时，它保持追踪全局的最大和（Max Sum）。最终，Max Sum的最后一个值就是整个问题的解。<br><img src="/img/DSA/kadane.svg" alt="kadane算法演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            curSum <span class="token operator">+=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> curSum <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 贪心地取子数组最大值</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> maxSum <span class="token operator">=</span> curSum<span class="token punctuation">;</span> <span class="token comment">// 不断更新结果</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="6-2-Merge-Intervals"><a href="#6-2-Merge-Intervals" class="headerlink" title="6.2 Merge Intervals"></a>6.2 Merge Intervals</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/merge-intervals/description/">Leetcode 56题</a>练习。</p><blockquote><p>题目描述：Given an array of intervals where $\text{intervals}[i] = [\text{start}_i, \text{end}_i]$, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p></blockquote><p><strong>Example 1:</strong></p><p>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]</p><p>Output: [[1,6],[8,10],[15,18]]</p><p>Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</p><p>解决这道题的思路是：先排序让所有相邻的区间尽可能重合在一起(以开端最小优先，其次结尾最小次之)，然后一次遍历贪心地选择局部最优解。<br><img src="/img/DSA/merge.svg" alt="合并区间算法演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 重载cmp函数，让区间的排列以开端最小优先，其次结尾最小优先</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 贪心地选择是否合并区间</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 若不重合，则加入结果数组</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 若重合，则合并区间并贪心的选择区间结尾</span>            <span class="token keyword">else</span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h2 id="7-Dynamic-Programming"><a href="#7-Dynamic-Programming" class="headerlink" title="7. Dynamic Programming"></a>7. Dynamic Programming</h2><p><strong>动态规划（Dynamic Programming, DP）</strong> 是一种用于解决最优化问题的算法设计技巧。它通过将问题分解为更小的子问题，并记录其解来<u>避免重复计算</u>，从而提高算法的效率。本章主要讲解5个经典DP问题：<em>斐波那契数列</em>，<em>背包问题</em>，<em>股票问题</em>，<em>最长公共子序列</em>，以及<em>序列比对问题</em>。</p><h3 id="7-1-Fibonacci-Sequence"><a href="#7-1-Fibonacci-Sequence" class="headerlink" title="7.1 Fibonacci Sequence"></a>7.1 Fibonacci Sequence</h3><p>形如：$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ….$的数列称之为斐波那契数，我们可以很轻易地得到递归式：$dp[n] = dp[n-1] + dp[n-2]$,然后我们再对递归式子进行初始化：$dp[0] = 1, dp[1] = 1$, 我们就可以利用递归式求得所有的斐波那契数。<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="7-2-Knapsack-Problem"><a href="#7-2-Knapsack-Problem" class="headerlink" title="7.2 Knapsack Problem"></a>7.2 Knapsack Problem</h3><p>关于背包问题有三种：0-1背包，完全背包，多重背包。应对修考我认为掌握0-1背包问题就足够了。关于0-1背包的问题描述是：</p><ol><li>一组物品，每个物品都有一个重量和一个价值。</li><li>一个背包，具有固定的容量。</li></ol><p>给定$n$个物品，每个物品$i$具有重量$w[i]$和价值$v[i]$，还有一个背包的最大容量$W$。目标是选择物品的组合，使得在不超过背包容量的情况下，背包中的物品总价值最大。</p><p><strong>1.定义状态：</strong> $dp[i][j]$表示在考虑前$i$个物品，且背包容量为$j$时的最大价值。</p><p><strong>2.状态转移方程：</strong> 对于每个物品$i$，有两个选择：</p><ul><li>不放入背包：此时最大价值为$dp[i-1][j]$。</li><li>放入背包：此时最大价值为$dp[i-1][j - w[i]] + v[i]$，前提是当前物品的重量不超过背包容量 $j &gt;= w[i]$。</li></ul><p>因此，状态转移方程为：</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases} dp[i-1][j] & \text{if } j < w[i] \\\\\max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]) & \text{if } j \geq w[i] \end{cases}</script><p><strong>3.边界条件：</strong></p><ul><li>当没有物品可选时，最大价值为$0$，即 $(dp[0][j] = 0)$。</li><li>当背包容量为$0$时，最大价值也为$0$，即 $(dp[i][0] = 0)$。</li></ul><p><strong>4.计算顺序：</strong></p><p>先遍历物品再遍历背包更容易理解，从 $(i = 1)$到 $(n)$，对于每个物品，再从 $(j = 0)$到$(W)$计算。当然也可以先遍历背包再遍历物品，这里不过多赘述。</p><p><strong>5.返回结果：</strong> 最终的最大价值为 $(dp[n][W])$。</p><p>假设有以下物品和背包容量：</p><ul><li>物品 1：重量 = 2，价值 = 3</li><li>物品 2：重量 = 3，价值 = 4</li><li>物品 3：重量 = 4，价值 = 5</li><li>物品 4：重量 = 5，价值 = 6</li></ul><p>背包容量为 5。<br><img src="/img/DSA/01knapsnack.svg" alt="01背包遍历演示" style="max-width: 100%; height: auto;" /></p><p>遍历的核心代码：<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> W<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 装不下的情况</span>            <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装下的情况</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="7-3-Stock-Problem"><a href="#7-3-Stock-Problem" class="headerlink" title="7.3 Stock Problem"></a>7.3 Stock Problem</h3><p>股票问题有很多种，这里介绍一种，参考<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">Leetcode 122题</a>。题目描述是：</p><blockquote><p>You are given an integer array $prices$ where $prices[i]$ is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold <u>at most one share </u> of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: prices = [7,1,5,3,6,4]</li><li>Output: 7</li><li>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.<br>Total profit is 4 + 3 = 7.<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// have the stock on the day 0;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token comment">// no stock on the day 0;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// no stock on the day n - 1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul><p><strong>初始状态：</strong></p><p><code>dp[0][0] = -prices[0]</code>：表示在第$0$天买入股票后的利润，利润为负的股票价格。<br><code>dp[0][1] = 0</code>：表示在第$0$天没有持有股票，利润为$0$。</p><p><strong>状态转移：</strong></p><blockquote><p><strong>对于第$i$天，持有股票的状态 <code>dp[i][0]</code>，有两种可能：</strong></p></blockquote><ul><li>前一天已经持有股票，保持不动：<code>dp[i-1][0]</code>。  </li><li>前一天没有持有股票，但今天买入：<code>dp[i-1][1] - prices[i]</code>（买入股票，减去当天股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])</code>。</p><blockquote><p><strong>对于第$i$天，不持有股票的状态 <code>dp[i][1]</code>，也有两种可能：</strong></p></blockquote><ul><li>前一天已经不持有股票，保持不动：<code>dp[i-1][1]</code>。  </li><li>前一天持有股票，但今天卖出：<code>dp[i-1][0] + prices[i]</code>（卖出股票，得到当前股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</code>。</p><p><strong>最终结果：</strong> 返回 <code>dp[n-1][1]</code>，表示最后一天不持有股票的最大利润。</p><h3 id="7-4-Longest-Common-Subsequence"><a href="#7-4-Longest-Common-Subsequence" class="headerlink" title="7.4 Longest Common Subsequence"></a>7.4 Longest Common Subsequence</h3><p><strong>最长公共子序列（LCS）</strong> 也是修考的一个常考点，具体参考：<a href="https://leetcode.com/problems/longest-common-subsequence/description/">Leetcode 1143</a></p><blockquote><p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”. A common subsequence of two strings is a subsequence that is common to both strings.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: text1 = “abcde”, text2 = “ace” </li><li>Output: 3  </li><li>Explanation: The longest common subsequence is “ace” and its length is 3.</li></ul><p><strong>定义状态：</strong></p><script type="math/tex; mode=display">dp[i][j] \text{ 表示在考虑前 } i \text{ 个字符的 } \text{text1} \text{ 和前 } j \text{ 个字符的 } \text{text2} \text{ 时的最长公共子序列的长度。}</script><p><strong>状态转移方程：</strong></p><p>对于每个字符对<code>text1[i-1]</code> 和<code>text2[j-1]</code>，有两种情况：</p><ul><li>如果 <code>&#39;text1[i-1] == text2[j-1]&#39;</code>，说明这两个字符相同，最长公共子序列可以延长 1，此时 <code>&#39;dp[i][j] = dp[i-1][j-1] + 1&#39;</code>。</li><li>如果 <code>&#39;text1[i-1] != text2[j-1]&#39;</code>，则取决于之前的子问题结果，最长公共子序列为：<ul><li>不包括当前字符：<code>&#39;dp[i][j] = max(dp[i][j-1], dp[i-1][j])&#39;</code>。</li></ul></li></ul><p><strong>边界条件：</strong></p><ul><li>当 <code>&#39;i = 0&#39;</code> 或 <code>&#39;j = 0&#39;</code> 时，即有一个字符串为空，最长公共子序列长度为 0，所以初始化时 <code>&#39;dp[0][j] = 0&#39;</code> 和 <code>&#39;dp[i][0] = 0&#39;</code>。</li></ul><p><strong>计算顺序：</strong></p><p>从 <code>&#39;i = 1&#39;</code> 到 <code>&#39;n&#39;</code>，对于每个字符，再从 <code>&#39;j = 1&#39;</code> 到 <code>&#39;m&#39;</code> 计算 <code>&#39;dp[i][j]&#39;</code>，逐步构建整个表。</p><p><strong>返回结果：</strong></p><p>最终结果为 <code>&#39;dp[n][m]&#39;</code>，即考虑所有字符的最长公共子序列的长度。<br><img src="/img/DSA/lcs.svg" alt="LCS遍历演示" style="max-width: 100%; height: auto;" /><br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h3 id="7-5-Sequence-Alignment"><a href="#7-5-Sequence-Alignment" class="headerlink" title="7.5 Sequence Alignment"></a>7.5 Sequence Alignment</h3><p><strong>序列比对（Sequence Alignment）</strong> 是生物信息学中的一个核心问题，用于比较两个或多个生物序列（如DNA、RNA或蛋白质）的相似性。其目的是通过对比序列中的元素（碱基或氨基酸）找出它们之间的最优匹配方式，进而揭示它们的进化关系、功能相似性或结构上的保守性。</p><h4 id="7-5-1-Needleman–Wunsch-algorithm"><a href="#7-5-1-Needleman–Wunsch-algorithm" class="headerlink" title="7.5.1 Needleman–Wunsch algorithm"></a>7.5.1 Needleman–Wunsch algorithm</h4><p>Needleman-Wunsch算法是用于进行全局序列比对的经典算法，特别适用于对比两个生物序列（如DNA、RNA或蛋白质）时，将它们的整个序列进行对齐。它采用动态规划的思想来寻找两个序列的最优对齐方式。<br><img src="/img/DSA/needle.svg" alt="序列比对算法演示" style="max-width: 100%; height: auto;" /></p><p><strong>Needleman-Wunsch算法步骤：</strong></p><p><strong>定义状态：</strong></p><p>设有两个序列 <code>A</code> 和 <code>B</code>，长度分别为 <code>n</code> 和 <code>m</code>。<br>创建一个大小为 <code>(n+1) x (m+1)</code> 的二维矩阵 <code>dp</code>，其中 <code>dp[i][j]</code> 表示序列 <code>A</code> 的前 <code>i</code> 个字符与序列 <code>B</code> 的前 <code>j</code> 个字符的最优对齐得分。</p><p><strong>罚分机制：</strong></p><ul><li><strong>匹配</strong>：当 <code>A[i-1] == B[j-1]</code> 时，表示两个字符相同，得分为 <code>match score</code>。</li><li><strong>不匹配</strong>：当 <code>A[i-1] != B[j-1]</code> 时，表示两个字符不同，得分为 <code>mismatch penalty</code>。</li><li><strong>Gap</strong>：当在序列 <code>A</code> 或 <code>B</code> 中插入一个字符时，得分为 <code>gap penalty</code>。</li></ul><p><strong>初始化：</strong></p><ul><li>第一行和第一列表示序列与空序列的比对。比对空序列时，每个字符都需要插入或删除，因此使用缺口罚分（gap penalty）。</li><li>初始化 <code>dp[0][0] = 0</code>，代表两个空序列的得分为 0。</li><li>初始化第一行：<code>dp[0][j] = j * gap penalty</code>，表示序列 <code>B</code> 的前 <code>j</code> 个字符与空序列的比对得分。</li><li>初始化第一列：<code>dp[i][0] = i * gap penalty</code>，表示序列 <code>A</code> 的前 <code>i</code> 个字符与空序列的比对得分。</li></ul><p><strong>状态转移方程：</strong>对于矩阵中的每个 <code>dp[i][j]</code>，有三种可能的情况：</p><ol><li><strong>匹配</strong>：如果 <code>A[i-1] == B[j-1]</code>，即两个字符相同，则可以匹配，得分为 <code>dp[i-1][j-1] + match score</code>。</li><li><strong>不匹配</strong>：如果 <code>A[i-1] != B[j-1]</code>，则可以进行替换，得分为 <code>dp[i-1][j-1] + mismatch penalty</code>。</li><li><strong>插入/删除（Gap）</strong>：在序列 <code>A</code> 或 <code>B</code> 中插入一个字符，得分为 <code>dp[i][j-1] + gap penalty</code> 或 <code>dp[i-1][j] + gap penalty</code>。</li></ol><p>取这三种操作中的最大值更新 <code>dp[i][j]</code>，即：</p><script type="math/tex; mode=display">dp[i][j] = \max\left(dp[i-1][j-1] + \text{(match/mismatch score)}, dp[i-1][j] + \text{gap penalty}, dp[i][j-1] + \text{gap penalty}\right)</script><p><strong>回溯：</strong>填完矩阵后，从右下角 <code>dp[n][m]</code> 开始回溯，找出最优路径，从而得到序列 <code>A</code> 和 <code>B</code> 的最优全局对齐方案。<br><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化：处理空序列的情况</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一列，表示A的前i个字符和空序列的比对</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一行，表示B的前j个字符和空序列的比对</span><span class="token comment">// 填充 dp 表</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 匹配或不匹配的情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符相等，则进行匹配，加上 match_score</span>            <span class="token keyword">int</span> match <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> match_score<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符不相等，则进行替换，加上 mismatch_penalty</span>            <span class="token keyword">int</span> mismatch <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> mismatch_penalty<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 2. 插入的情况</span>        <span class="token keyword">int</span> insert <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 在序列 A 中插入 gap</span>        <span class="token comment">// 3. 删除的情况</span>        <span class="token keyword">int</span> del <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>     <span class="token comment">// 在序列 B 中插入 gap</span>                <span class="token comment">// 取三种操作的最大值来更新 dp[i][j]</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> match_score <span class="token operator">:</span> mismatch_penalty<span class="token punctuation">)</span><span class="token punctuation">,</span> insert<span class="token punctuation">,</span> del<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 最终结果是 dp[n][m]，表示A和B的最优全局比对得分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h2 id="8-P-NP-problem"><a href="#8-P-NP-problem" class="headerlink" title="8. P/NP problem"></a>8. P/NP problem</h2><p><strong>P/NP问题</strong> 是计算机科学中的一个核心难题，涉及确定哪些问题可以在合理的时间内（多项式时间）被解决，和哪些问题的解可以在合理的时间内被验证。它是理论计算机科学和数学中最著名、最重要的未解决问题之一。</p><p><strong>P类问题</strong></p><p>P类问题（Polynomial time）指的是那些可以在多项式时间内被解决的问题。也就是说，给定一个问题实例，使用某种算法可以在输入规模为 $n$ 时，用 $n^k$（其中 $k$ 是一个常数）次运算步骤就可以得到结果。</p><ul><li><p>例如，常见的排序算法（如快速排序）和图论中的最短路径算法（如Dijkstra算法）都是 <strong>P类问题</strong>。它们的时间复杂度是多项式级别的。</p></li><li><p><strong>直观理解</strong>：如果一个问题属于P类，那么它是“容易”解决的，因为我们可以用有效的算法在合理的时间内求解。</p></li></ul><p><strong>NP类问题</strong></p><p>NP类问题（Nondeterministic Polynomial time）是指那些解可以在多项式时间内被验证的问题，尽管可能没有已知的多项式时间算法来找到这个解。</p><ul><li><p>也就是说，如果我们猜测出一个解，可以在多项式时间内检查这个解是否正确。但是，要找到这个解可能会很难，甚至没有已知的多项式时间算法来求解。</p></li><li><p><strong>经典的NP问题</strong> 包括旅行商问题（TSP）、背包问题和布尔可满足性问题（SAT）。这些问题的特点是验证解很容易，但找到最优解可能非常耗时。</p></li></ul><p><strong>P与NP的关系</strong></p><ul><li><p><strong>P是否属于NP？</strong></p><ul><li><p>P类问题显然也是NP类问题。如果我们能够在多项式时间内求解一个问题，那我们一定也能在多项式时间内验证这个解。</p></li><li><p>因此可以得出结论：<strong>P是NP的一个子集</strong>，即 $P \subseteq NP$。</p></li></ul></li><li><p><strong>P与NP的区别</strong></p><ul><li>关键在于我们还不确定 <strong>P类问题</strong> 和 <strong>NP类问题</strong> 是否是同一个集合。这就是 <strong>P vs NP</strong> 问题的核心所在：<ul><li>如果 $P = NP$，那么所有能在多项式时间内验证的解也可以在多项式时间内求解。</li><li>如果 $P \neq NP$，那么有一些问题能在多项式时间内验证解，但没有已知的多项式时间算法来求解它们。</li></ul></li></ul></li></ul><p><strong>NP完全问题（NP-Complete）</strong></p><p>NP完全问题（NP-Complete, NPC）是NP类问题中的一个特殊子集，它们有两个重要的特性：</p><ol><li>它们本身是NP类问题。</li><li>任何一个NP类问题都可以通过多项式时间的归约（转换）转换为这个NP完全问题。</li></ol><ul><li><p><strong>重要性</strong>：如果你能找到一个NP完全问题的多项式时间解法，那么所有的NP问题都可以在多项式时间内解决。因此，NP完全问题是NP类问题中的“最难问题”。</p></li><li><p><strong>典型的NP完全问题</strong>：</p><ul><li>旅行商问题（TSP）：寻找一条经过每个城市恰好一次且路径最短的旅行路线。</li><li>3-SAT问题：判断一个布尔公式是否有解。</li><li>顶点覆盖问题：在一个图中找到最小的顶点集合，使得每条边至少有一个顶点被覆盖。</li></ul></li></ul><p><strong>P vs NP问题</strong></p><p>P vs NP问题是指：<strong>P是否等于NP？</strong></p><ul><li><p>如果 <strong>P = NP</strong>，意味着所有NP问题都有多项式时间的求解算法。这将意味着大量的难问题（如密码学中的问题）可以被快速解决。</p></li><li><p>如果 <strong>P ≠ NP</strong>，那么一些问题的解可以快速验证，但无法快速求解。</p></li></ul><p>目前，这个问题尚未解决，它是 <strong>“千禧年大奖问题”</strong> 之一，美国克雷数学研究所为解决这个问题悬赏 <strong>100万美元</strong>。</p><p><strong>总结</strong></p><ul><li><strong>P类问题</strong>：可以在多项式时间内求解。</li><li><strong>NP类问题</strong>：可以在多项式时间内验证解，但不一定能在多项式时间内求解。</li><li><strong>P vs NP问题</strong>：我们不知道所有可以快速验证的解是否也可以快速求解，即是否 $P = NP$。</li></ul><h2 id="9-偷偷说"><a href="#9-偷偷说" class="headerlink" title="9.偷偷说"></a>9.偷偷说</h2><p>本文应该囊括了修考绝大部分的考点了，当然还有双指针和滑动窗口，哈希之类的算法技巧我觉得就不用大费周章地写下来了。做修考题我认为最重要的是阅读伪代码的能力！希望这篇文章可以帮助到修考受验生们。完结撒花🎉</p><div class="note note-success">            <p>偷偷目前兼任私塾班主任，如果需要1对1辅导，请联系：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語勉強</title>
    <link href="/2024/09/10/JPN/"/>
    <url>/2024/09/10/JPN/</url>
    
    <content type="html"><![CDATA[<h3 id="1-〜あっての"><a href="#1-〜あっての" class="headerlink" title="1.〜あっての"></a>1.〜あっての</h3><div class="note note-success">            <p>説明：あるものが存在するのは他のもののおかげであることを強調する表現です。名詞 + あっての + 名詞</p>          </div><p>健康あっての人生なんだから、体調管理には十分気をつけなさい。</p><p>家族の支えがあったからこそ成功できた。</p><h3 id="2-以外の何ものでもない。"><a href="#2-以外の何ものでもない。" class="headerlink" title="2.~以外の何ものでもない。"></a>2.~以外の何ものでもない。</h3><div class="note note-success">            <p>「Aが唯一の理由・原因である」という意味になります。</p>          </div><p>この結果は偶然以外の何ものでもない。</p><h3 id="3-〜いかんで-いかんでは"><a href="#3-〜いかんで-いかんでは" class="headerlink" title="3.〜いかんで/いかんでは"></a>3.〜いかんで/いかんでは</h3><div class="note note-success">            <p>どちらも「〜によって」「〜次第で」という意味を持ち、前の事柄によって後の結果が変わることを示す表現です。ただし、微妙なニュアンスの違いがあります。</p>          </div><p>天候いかんでは、収穫は全てできないこともある。</p><h3 id="4-～いかんに関わらず・いかんによらず・いかんをとわず"><a href="#4-～いかんに関わらず・いかんによらず・いかんをとわず" class="headerlink" title="4.～いかんに関わらず・いかんによらず・いかんをとわず"></a>4.～いかんに関わらず・いかんによらず・いかんをとわず</h3><div class="note note-success">            <p>「〜に関係なく」や「〜にかかわらず」と同じ意味で使われます。つまり、ある条件や状況に影響されずに、という意味です。</p>          </div><p>成績いかんに関わらず、全員が参加できます。</p><h3 id="5-いざ〜となると・いざ〜となれば・いざ〜となったら"><a href="#5-いざ〜となると・いざ〜となれば・いざ〜となったら" class="headerlink" title="5.いざ〜となると・いざ〜となれば・いざ〜となったら"></a>5.いざ〜となると・いざ〜となれば・いざ〜となったら</h3><div class="note note-success">            <p>いずれも「実際にその状況になったら」という意味で使われます。これらの表現は、ある状況が現実になったときにどうなるか、ということを強調するために使われます。</p>          </div><p>いざ出発となれば、準備が整っていないことに気づく。</p><h3 id="6-〜言わずもがな"><a href="#6-〜言わずもがな" class="headerlink" title="6.〜言わずもがな"></a>6.〜言わずもがな</h3><div class="note note-success">            <p>「〜言わずもがな」という表現は、「言うまでもなく」や「言わなくてもわかる」という意味で使われます。つまり、あることが非常に明白であるため、わざわざ言う必要がないということを強調する表現です。</p>          </div><p>彼の才能は言わずもがな、誰もが認めるところだ。</p><h3 id="7-限りだ"><a href="#7-限りだ" class="headerlink" title="7. ~限りだ"></a>7. ~限りだ</h3><div class="note note-success">            <p>「〜限りだ」という表現は、感情や感覚を強調するために使われます。特に、感動や驚き、悲しみなどの強い感情を表現する際に用いられます。</p>          </div><p>嬉しい限りだ。</p><h3 id="8-かたがた"><a href="#8-かたがた" class="headerlink" title="8.~かたがた"></a>8.~かたがた</h3><div class="note note-success">            <p>「〜しながら」「〜と同時に」という意味：<br>ある行動をしながら、同時に別の目的も果たすことを表します。<br>例：</p>          </div><p>散歩かたがた買い物に行く。<br>(散歩をしながら買い物もする)</p><div class="note note-success">            <p>「〜のついでに」「〜を機会に」という意味：<br>ある行動や状況を利用して、ついでに別のことも行うことを表します。</p>          </div><p>東京出張かたがた友人に会ってきた。<br>(東京への出張を機会に友人にも会った)</p><h3 id="9-かたわら"><a href="#9-かたわら" class="headerlink" title="9. ~かたわら"></a>9. ~かたわら</h3><div class="note note-success">            <p>主な活動や仕事をしながら、同時に別の活動も行うことを表します。</p>          </div><p>教師のかたわら、小説を執筆している。</p><h3 id="10-がてら"><a href="#10-がてら" class="headerlink" title="10.~がてら"></a>10.~がてら</h3><div class="note note-success">            <p>「〜のついでに」「〜と同時に」<br>ある行動をする際に、ついでに別の行動も同時に行うことを表します。主な目的とは別の、副次的な行動を示すのに使われます。</p>          </div><p>散歩がてら、近所の様子を見て回りました。</p><h3 id="11-からある・からする・からの"><a href="#11-からある・からする・からの" class="headerlink" title="11.~からある・からする・からの"></a>11.~からある・からする・からの</h3><div class="note note-success">            <p>强调大，多，重，长等。<br>「からある」前面表示数量，长度，大小，高矮等数量名词；[からする]前面多用表示金额的量词；[からの]前面多表示人物的数量词。</p>          </div><p>１００キロからある荷物を三階まで運ぶには、足腰の強い人が三人は必要だ。</p><p>彼女は４０億からする遺産を相続したそうだ。</p><p>今日のスピーチ大会は５００人からの人が集まった。</p><h3 id="12-始末だ"><a href="#12-始末だ" class="headerlink" title="12.~始末だ"></a>12.~始末だ</h3><div class="note note-success">            <p>「ひどい状態だ」「困った事態だ」「始末に負えない」といった否定的な状況を表現します。<br>話者の失望、困惑、あるいは軽蔑の気持ちを含むことが多いです。</p>          </div><p>彼は借金を重ね、今では家も売らなければならない始末だ。</p><h3 id="13-～ずくめ"><a href="#13-～ずくめ" class="headerlink" title="13.～ずくめ"></a>13.～ずくめ</h3><div class="note note-success">            <p>「～ずくめ」は日本語の文法表現で、「全て～ばかりである」という意味を表します。この表現は、ある特定の性質や状態が全体的に存在することを強調するために使われます。</p>          </div><p>この本は難しい言葉ずくめで、読むのが大変だ。</p><p>彼女の服装は黒ずくめだった。</p><h3 id="14-〜ずじまいだ"><a href="#14-〜ずじまいだ" class="headerlink" title="14.〜ずじまいだ"></a>14.〜ずじまいだ</h3><div class="note note-success">            <p>「〜ずじまいだ」は「〜ずじまい」という表現の丁寧な形です。この表現は、ある行動や状態が最後まで続いて終わることを意味します。主に否定的なニュアンスで使われることが多いです。</p>          </div><p>忙しいくて、結局休暇を取る図じまいだった。</p><p>締め切りに追われて、計画を見直すずじまいだった。</p><h3 id="15-ずにはおかない"><a href="#15-ずにはおかない" class="headerlink" title="15.~ずにはおかない"></a>15.~ずにはおかない</h3><div class="note note-success">            <p>「必ず〜する」「〜せずにはいられない」という強い意志や必然性を表します。</p>          </div><p>この素晴らしい景色を見たら、誰も感動せずにはおかない。</p><p>彼女の熱意は、周りの人々に影響を与えずにはおかないだろう。</p><h3 id="16-術がない"><a href="#16-術がない" class="headerlink" title="16.~術がない"></a>16.~術がない</h3><div class="note note-success">            <p>意味:<br>「〜する方法がない」「〜する手段がない」「〜するすべがない」</p>          </div><p>締め切りに間に合わせる術がなく、締めるしかなっかた。</p><p>彼女を説得する術がないので、このまま計画を進めるしかない。</p><h3 id="17-そびれる"><a href="#17-そびれる" class="headerlink" title="17.~そびれる"></a>17.~そびれる</h3><div class="note note-success">            <p>意味:<br>「〜するチャンスを逃す」「〜し損ねる」「うっかり〜し忘れる」</p>          </div><p>興味深い展覧会があったのに、行きそびれてしまった。</p><p>大切な約束を確認しそびれて、すっかり忘れてしまった。</p><h3 id="18-たところで"><a href="#18-たところで" class="headerlink" title="18.~たところで"></a>18.~たところで</h3><div class="note note-success">            <p>意味:「〜たところで」は「〜しても、結局」や「〜したとしても、それでも」という意味を表します。</p>          </div><p>急いだところで、もう間に合わないだろう。</p><p>お金をたくさん持っているところで、幸せになれるとは限らない。</p><h3 id="19-てしかるべきだ"><a href="#19-てしかるべきだ" class="headerlink" title="19.~てしかるべきだ"></a>19.~てしかるべきだ</h3><div class="note note-success">            <p>意味：「〜するのが当然だ」「〜するのが適切だ」という意味を表します。話者の強い意見や判断を示す表現です。</p>          </div><p>法律を守ってしかるべきだ。</p><p>その問題については、専門家に相談してしかるべきだ。</p><h3 id="20-て憚らない"><a href="#20-て憚らない" class="headerlink" title="20.~て憚らない"></a>20.~て憚らない</h3><div class="note note-success">            <p>意味：遠慮せずに～する」「ためらわずに～する」「大胆に～する」</p>          </div><p>意見を述べて憚らない。</p><p>新しいアイデアを提案して憚らない。</p><h3 id="21-てはかなわない"><a href="#21-てはかなわない" class="headerlink" title="21.~てはかなわない"></a>21.~てはかなわない</h3><div class="note note-success">            <p>「〜するのは困る」や「〜するのは耐えられない」という意味を表す表現です。「かなわない」は「対抗できない」「負ける」「耐えられない」といったニュアンスを持ちます。</p>          </div><p>この騒音では寝てはかなわない。</p><p>彼女は泣かれてはかなわない。</p><h3 id="22-ても差し支えない"><a href="#22-ても差し支えない" class="headerlink" title="22.~ても差し支えない"></a>22.~ても差し支えない</h3><div class="note note-success">            <p>「問題ない」や「大丈夫」といった意味を表します。</p>          </div><p>書類は明日提出しても差し支えありません。</p><p>会議中に退席しても差し支えないでしょうか。</p><h3 id="23-てもともとだ"><a href="#23-てもともとだ" class="headerlink" title="23.~てもともとだ"></a>23.~てもともとだ</h3><div class="note note-success">            <p>「~てもともとだ」は、ある状況や条件が変わっても、結果は変わらないことを強調するときに使われます。つまり、何かが起こったとしても、本質的には何も変わらないという意味合いを持ちます。</p>          </div><p>彼が来なくてもともとだ。</p><p>だめでもともとだから、思い切って彼女に告白してみた。</p><h3 id="24-ても始まらない"><a href="#24-ても始まらない" class="headerlink" title="24.~ても始まらない"></a>24.~ても始まらない</h3><div class="note note-success">            <p>「たとえ〜をしても、何も良い結果は生まれない」「〜をしても意味がない」</p>          </div><p>今から後悔しても始まらない。</p><p>言い訳をしても始まらないよ。</p><h3 id="25-～てやまない"><a href="#25-～てやまない" class="headerlink" title="25.～てやまない"></a>25.～てやまない</h3><div class="note note-success">            <p>ある行動や状態が継続的に行われていることを強調する表現です。</p>          </div><p>結婚する二人の今後の幸せを願ってやまない。</p><p>真実を追求してやまない。</p><h3 id="26-か-と思いきや"><a href="#26-か-と思いきや" class="headerlink" title="26.~(か)と思いきや"></a>26.~(か)と思いきや</h3><div class="note note-success">            <p>「予想や期待とは異なり、意外な結果になって」</p>          </div><p>晴れると思いきや、突然雨が降り出した。</p><p>彼女は怒ると思いきや、意外にも笑顔で許してくれた。</p><h3 id="27-〜ともなく"><a href="#27-〜ともなく" class="headerlink" title="27.〜ともなく"></a>27.〜ともなく</h3><div class="note note-success">            <p>「〜ともなく」という表現は、意識せずに行動をしている様子や、特定の対象や理由がないことを表す日本語の文法表現です。</p>          </div><p>聞くともなく隣の会話が耳に入った。</p><p>電車の窓から外を見るともなく、高校時代の同級生の姿が目に入った。</p><h3 id="28-〜ならいざしらず"><a href="#28-〜ならいざしらず" class="headerlink" title="28.〜ならいざしらず"></a>28.〜ならいざしらず</h3><div class="note note-success">            <p>「〜なら問題ないが、そうでないなら問題だ」「〜なら仕方がないが、そうでないなら受け入れられない」といった意味で使います。</p>          </div><p>小学生ならいざしらず、大学生はこの漢字を知らないのは問題だ。</p><p>新入社員ならいざしらず、入社8年にもなる君がこんなミスをするとは信じられない。</p><h3 id="29-にはあたらない"><a href="#29-にはあたらない" class="headerlink" title="29.~にはあたらない"></a>29.~にはあたらない</h3><div class="note note-success">            <p>意味: 「〜する必要はない」「〜するほどのことではない」といった意味で使われ、感情的な反応や評価を避けるときに用います。</p>          </div><p>彼なりにできるだけの努力をしたのだから、いい結果を出せなかったとしても、非難するには当たらない。</p><p>優秀な田中君のことだから、論文を１週間で仕上げたと聞いても驚くにはあたらない。</p><h3 id="30-におかれましては"><a href="#30-におかれましては" class="headerlink" title="30.~におかれましては"></a>30.~におかれましては</h3><div class="note note-success">            <p>意味: 「〜に関しては」「〜については」の丁寧な形で、相手を非常に敬った形で、その人の状況や状態を指す。</p>          </div><p>社長におかれましては、お元気でご活躍のことと存じます。</p><p>最近のご状況におかれましては、いかがでしょうか。お忙しいことと存じますが、くれぐれもご自愛ください。</p><h3 id="31-にかこつけて"><a href="#31-にかこつけて" class="headerlink" title="31.~にかこつけて"></a>31.~にかこつけて</h3><div class="note note-success">            <p>意味: 「〜を口実にして」「〜を理由にして」といった意味で、表向きの理由を使って、実際は別の意図や目的があることを示します。</p>          </div><p>彼は仕事にかこつけて、頻繁に出張し、観光地を回っている。</p><p>天気にかこつけて、今日の会議は延期されたが、実は準備が間に合わなかったらしい。</p><h3 id="32-にかまけて"><a href="#32-にかまけて" class="headerlink" title="32.~にかまけて"></a>32.~にかまけて</h3><div class="note note-success">            <p>「〜に気を取られて他のことができない」「〜に夢中になって他のことを疎かにする」といった意味で、何かに集中しすぎて、他のことをやる余裕がなくなる状況を表します。</p>          </div><p>彼は仕事にかまけて、家族との時間を全然取っていない。</p><p>スマホにかまけて、勉強が疎かになっている。</p><h3 id="33-にかたくない"><a href="#33-にかたくない" class="headerlink" title="33.~にかたくない"></a>33.~にかたくない</h3><div class="note note-success">            <p>意味: 「〜するのは難しくない」「〜を簡単に理解できる」「〜を容易に想像できる」といった意味を表します。</p>          </div><p>長年に努力してきたことが報われた時の彼の喜びは、想像に難くない。</p><p>異国の地で生活する彼女の苦労は、理解にかたくない。</p><h3 id="34-にしくはない"><a href="#34-にしくはない" class="headerlink" title="34.~にしくはない"></a>34.~にしくはない</h3><div class="note note-success">            <p>意味としては、「〜が一番よい」、「〜が最善である」、「〜するに越したことはない」という考えを表現するものです。</p>          </div><p>安全な道を選ぶにしくはない。</p><p>事前に準備しておくにしくはない。</p><h3 id="35-に忍びない"><a href="#35-に忍びない" class="headerlink" title="35.~に忍びない"></a>35.~に忍びない</h3><div class="note note-success">            <p>「〜に忍びない」という表現は、感情的に耐えられず、ある行為をするのがつらい、または心苦しいと感じるときに使います。</p>          </div><p>彼の写真を捨てるに忍びない。</p><p>その小説の最後の場面はあまりに悲しくて、読むに忍びない。</p><h3 id="36-にたえる"><a href="#36-にたえる" class="headerlink" title="36.~にたえる"></a>36.~にたえる</h3><div class="note note-success">            <p>「〜にたえる（〜に堪える）」は、「〜する価値がある」「〜に耐えられる」という意味を持つ日本語の表現です。主に二つの使い方があります。</p>          </div><p>この映画は見るにたえる作品だ。</p><p>この痛みは堪えるに堪えない。</p><h3 id="37-にとどまらず"><a href="#37-にとどまらず" class="headerlink" title="37.~にとどまらず"></a>37.~にとどまらず</h3><div class="note note-success">            <p>「〜にとどまらず」という表現は、何かが特定の範囲や状況に「とどまる（留まる）」ことなく、さらに広がっている、または影響を及ぼしていることを示す表現です。つまり、「〜だけではなく、さらに」という意味を持ちます。</p>          </div><p>彼の影響は国内にとどまらず、海外にも広がっている。</p><p>この技術は企業内にとどまらず、一般家庭にも普及している。</p><h3 id="38-にひきかえ"><a href="#38-にひきかえ" class="headerlink" title="38.~にひきかえ"></a>38.~にひきかえ</h3><div class="note note-success">            <p>意味：「〜に対して」、「〜と比べて」</p>          </div><p>彼の努力しているにひきかえ、結果が出ていない。</p><p>新製品の売上が好調なにひきかえ、旧製品は苦戦している。</p><h3 id="39-にも増して"><a href="#39-にも増して" class="headerlink" title="39.~にも増して"></a>39.~にも増して</h3><div class="note note-success">            <p>「〜にも増して」は、「〜以上に」と同じ意味で、ある状況や程度がより強く、またはより重要であることを表します。</p>          </div><p>今年の夏は、去年にも増して暑い。</p><p>いつにも増して彼は元気そうだ。</p><h3 id="40-の至りだ"><a href="#40-の至りだ" class="headerlink" title="40.~の至りだ"></a>40.~の至りだ</h3><div class="note note-success">            <p>「非常に〜だ」「極めて〜だ」</p>          </div><p>このような賞をいただき、光栄の至りです。</p><p>皆様の温かいご支援に対し、感激の至りです。</p><h3 id="41-にさておいて・はさておき"><a href="#41-にさておいて・はさておき" class="headerlink" title="41.~にさておいて・はさておき"></a>41.~にさておいて・はさておき</h3><div class="note note-success">            <p>「〜はさておいて」は、何かを一旦脇に置いて、別のことに話題や焦点を移す際に使われる表現です。話の流れの中で、前に述べた内容や問題を一時的に保留して、別の重要なことについて言及したい場合に使います。</p>          </div><p>実現できるかとうかはさておき、まずは新商品のアイディアをみんなで出してみよう。</p><p>社員旅行の件ですが、費用のことはさておいて、まず日程について検討してみましょう。</p><h3 id="42-はそっちのけで・をそっちのけで"><a href="#42-はそっちのけで・をそっちのけで" class="headerlink" title="42.~はそっちのけで・をそっちのけで"></a>42.~はそっちのけで・をそっちのけで</h3><div class="note note-success">            <p>「そっちのけ」とは「そのことを無視する」「放っておく」という意味で、主に否定的なニュアンスで使われます。</p>          </div><p>宿題はそっちのけで、ゲームばかりしている。</p><p>大学4年生の弟は就職のことはそっちのけで、毎日パソコンゲームに没頭している。</p><h3 id="43-羽目になる・羽目に陥る"><a href="#43-羽目になる・羽目に陥る" class="headerlink" title="43.~羽目になる・羽目に陥る"></a>43.~羽目になる・羽目に陥る</h3><div class="note note-success">            <p>「〜羽目になる」や「〜羽目に陥る」は、意図しない結果や不幸な状況に陥ることを表す表現です。</p>          </div><p>遅刻してしまい、会議に出られない羽目になった。</p><p>お金を借りたことが原因で、返済のプレッシャーに陥る羽目になった。</p><h3 id="44-べからず"><a href="#44-べからず" class="headerlink" title="44.~べからず"></a>44.~べからず</h3><div class="note note-success">            <p>意味としては「〜してはならない」「〜すべきではない」という禁止や戒めを表します。形式は動詞の辞書形に「べからず」を付けて作られます。</p>          </div><p>企業から多額のお金を受け取るなんて、政治家としてゆるすべからざる行為だ。</p><p>彼はうちの会社にとって欠くべからざる人材だ。</p><h3 id="45-まじき"><a href="#45-まじき" class="headerlink" title="45.~まじき"></a>45.~まじき</h3><div class="note note-success">            <p>主に道徳的・社会的に「〜してはならない」「〜ふさわしくない」という意味を表します。具体的には、「あるべきではない」「許されない行為や態度」を強調する際に使われます。</p>          </div><p>彼の言動は社会人としてあるまじきもので、とうてい許すことはできない。</p><p>彼のやったことは、人としてあるまじき残酷な行為だ。</p><h3 id="46-めく・めいて・めいた"><a href="#46-めく・めいて・めいた" class="headerlink" title="46.~めく・めいて・めいた"></a>46.~めく・めいて・めいた</h3><div class="note note-success">            <p>「〜めく」「〜めいて」「〜めいた」は、物事や人の様子、性質を表現する際に使われる言葉です。</p>          </div><p>そんな皮肉めいた言い方をしないでください。</p><p>雪が溶けて、野の花が咲き始め、日差しも春めいてきた。</p><h3 id="47-もさることながら"><a href="#47-もさることながら" class="headerlink" title="47.~もさることながら"></a>47.~もさることながら</h3><div class="note note-success">            <p>「〜もさることながら」は、ある事柄を強調しつつ、その上で別の事柄も重要であることを示す表現です。通常、前半に言及したことが重要であると認めつつ、後半でそれに劣らず重要なことを追加します。</p>          </div><p>彼の実力もさることながら、努力も評価されるべきだ。</p><p>両親は、息子に病院の跡を継いで医者になって欲しいと思っているようだ。だが、親の希望もさることながら、やはり本人の気持ちが第一だろう。</p><h3 id="48-を皮切りに"><a href="#48-を皮切りに" class="headerlink" title="48.~を皮切りに"></a>48.~を皮切りに</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>このプロジェクトは、会議を皮切りに始まりました。</p><p>旅行を皮切りに、さまざまな国を訪れました。</p><h3 id="49-を蔑ろにする"><a href="#49-を蔑ろにする" class="headerlink" title="49.~を蔑ろにする"></a>49.~を蔑ろにする</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>彼はチームの意見を蔑ろにして、自分の考えだけを押し通した。</p><p>友人の気持ちを蔑ろにするような行動は避けるべきだ。</p><h3 id="50-をなおざりにして"><a href="#50-をなおざりにして" class="headerlink" title="50.~をなおざりにして"></a>50.~をなおざりにして</h3><div class="note note-success">            <p>何かをいい加減に扱ったり、手を抜いたりすることを意味する表現です。このフレーズは、重要な事柄を怠ったり、十分に注意を払わないことを示します。</p>          </div><p>どんなことがあっても、仕事をなおざりにしてはいけない。</p><p>彼は仕事をなおざりにして、結果的にトラブルを引き起こした。</p><h3 id="51-を控え"><a href="#51-を控え" class="headerlink" title="51.~を控え"></a>51.~を控え</h3><div class="note note-success">            <p>「~を控えて」は、特定の行動や状況を踏まえて、それに関連する行動や注意を促す際に使われる表現です。</p>          </div><p>試験を控えて、しっかり勉強する必要があります。</p><p>引越しを控えて、整理整頓を始めました。</p><h3 id="52-を振り出しに"><a href="#52-を振り出しに" class="headerlink" title="52.~を振り出しに"></a>52.~を振り出しに</h3><div class="note note-success">            <p>ある出来事や行動をきっかけとして、その後の展開や進展が始まることを示す表現です。</p>          </div><p>彼女は転職を振り出しに、キャリアは一新しました。</p><p>彼は小学校の教師を振り出しに社会に出た。</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学公式用法整理</title>
    <link href="/2024/09/08/Math-formula/"/>
    <url>/2024/09/08/Math-formula/</url>
    
    <content type="html"><![CDATA[<h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><blockquote><p>升级后的插件需要双反斜杠“\\\\”，网页才能正确渲染下来</p></blockquote><script type="math/tex; mode=display">y=\begin{cases}-x,\quad x\leq 0 \\\\x, \quad x>0\end{cases}\tag{1}</script><h1 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h1><blockquote><p>array和aligned都不适配当前需求，直接用cases环境</p></blockquote><script type="math/tex; mode=display">\begin{cases}    a_1x + b_1y + c_1z = d_1 \\\\    a_2x + b_2y + c_2z = d_2 \\\\    a_3x + b_3y + c_3z = d_3\end{cases}</script><h1 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h1><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m}\sum_{i = 0} ^m(y^i - h_\theta (x^i))^2</script><h1 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h1><script type="math/tex; mode=display">\frac{\partial J(\theta)}{\partial\theta_j}=-\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j</script><h1 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h1><script type="math/tex; mode=display">\begin{aligned}\frac{\partial J(\theta)}{\partial\theta_j}& = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\\\& = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j=0}^n\theta_jx_j^i-y^i) \\\\& = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j\end{aligned}</script><h1 id="case环境的使用"><a href="#case环境的使用" class="headerlink" title="case环境的使用"></a>case环境的使用</h1><script type="math/tex; mode=display">a =   \begin{cases}     \int x\, \mathrm{d} x\\\\     b^2   \end{cases}</script><h1 id="带方框的等式"><a href="#带方框的等式" class="headerlink" title="带方框的等式"></a>带方框的等式</h1><script type="math/tex; mode=display">\begin{aligned} \boxed{x^2+y^2 = z^2}\end{aligned}</script><h1 id="最大（最小）操作符"><a href="#最大（最小）操作符" class="headerlink" title="最大（最小）操作符"></a>最大（最小）操作符</h1><script type="math/tex; mode=display">\begin{gathered}\operatorname{arg\,max}_a f(a)  = \operatorname*{arg\,max}_b f(b) \\\\ \operatorname{arg\,min}_c f(c)  = \operatorname*{arg\,min}_d f(d)\end{gathered}</script><h1 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h1><script type="math/tex; mode=display">\begin{aligned}  \lim_{a\to \infty} \tfrac{1}{a}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}   \lim\nolimits_{a\to \infty} \tfrac{1}{a}\end{aligned}</script><h1 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h1><script type="math/tex; mode=display">\begin{aligned}   \int_a^b x^2  \mathrm{d} x\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}   \int\limits_a^b x^2  \mathrm{d} x\end{aligned}</script><h1 id="多行表达公式"><a href="#多行表达公式" class="headerlink" title="多行表达公式"></a>多行表达公式</h1><script type="math/tex; mode=display">\begin{aligned}J(\mathbf{w})&=\frac{1}{2m}\sum_{i=1}^m(f(\mathbf{x_i})-y_i)^2\\\\&=\frac{1}{2m}\sum_{i=1}^m [f(\mathbf{x_i})]^2-2f(\mathbf{x_i)}y_i+y_i^2\end{aligned}</script><h1 id="小括号矩阵"><a href="#小括号矩阵" class="headerlink" title="小括号矩阵"></a>小括号矩阵</h1><script type="math/tex; mode=display">\left(\begin{matrix}1 & 2 & 3\\\\4 & 5 & 6 \\\\7 & 8 & 9\end{matrix}\right)\tag{2}</script><h1 id="中括号矩阵"><a href="#中括号矩阵" class="headerlink" title="中括号矩阵"></a>中括号矩阵</h1><script type="math/tex; mode=display">\left[\begin{matrix}1 & 2 & 3\\\\4 & 5 & 6 \\\\7 & 8 & 9\end{matrix}\right]\tag{3}</script><h1 id="带省略号的矩阵"><a href="#带省略号的矩阵" class="headerlink" title="带省略号的矩阵"></a>带省略号的矩阵</h1><script type="math/tex; mode=display">\left[\begin{matrix}a & b & \cdots & a\\\\b & b & \cdots & b\\\\\vdots & \vdots & \ddots & \vdots\\\\c & c & \cdots & c\end{matrix}\right]\tag{5}</script><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p>$\sin^2\alpha+\cos^2\alpha=1$</p><p>$\cfrac{\sin\alpha}{\cos\alpha}=\tan\alpha$</p><p>$\sin(2k\pi+\alpha)=\sin\alpha(k\in Z)$</p><p>$\cos(2k\pi+\alpha)=\cos\alpha(k\in Z)$</p><p>$\tan(2k\pi+\alpha)=\tan\alpha(k\in Z)$</p><p>$\cot(2k\pi+\alpha)=\cot\alpha(k\in Z)$</p><p>$\sin(\pi+\alpha)=-\sin\alpha$</p><p>$\cos(\pi+\alpha)=-\cos\alpha$</p><p>$\tan(\pi+\alpha)=\tan\alpha$</p><p>$\cot(\pi+\alpha)=\cot\alpha$</p><p>$\sin(\cfrac{n\pi}{2}+\alpha) = \begin{cases} (-1)^{\cfrac{n}{2}}\sin\alpha(n为偶数)\\<br>(-1)^{\cfrac{n-1}{2}}\cos\alpha(n为奇数)\end{cases}$</p><p>$\cos(\cfrac{n\pi}{2}+\alpha) = \begin{cases} (-1)^{\cfrac{n}{2}}\cos\alpha(n为偶数)\\(-1)^{\cfrac{n+1}{2}}\sin\alpha(n为奇数)\end{cases}$</p><script type="math/tex; mode=display">\left[    \begin{array}{c|cc}    1 & 2 & 3 \\\\ \hline    4 & 5 & 6 \\\\    7 & 8 & 9    \end{array}\right]\tag{7}</script><script type="math/tex; mode=display">x=a_0 + \frac{1^2}{a_ 1+\frac{2^2}{a_2+\frac{3^2}{a_3+ \frac{4^2}{a_4+...}}}}</script><p>$a \equiv b \pmod n$</p><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><script type="math/tex; mode=display">e^{i\pi} + 1 = 0</script>]]></content>
    
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/07/hello-world/"/>
    <url>/2024/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
