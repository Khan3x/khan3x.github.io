<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>日本語語彙まとめ</title>
    <link href="/2024/09/28/JPN-Words/"/>
    <url>/2024/09/28/JPN-Words/</url>
    
    <content type="html"><![CDATA[<h1 id="日语单词自测"><a href="#日语单词自测" class="headerlink" title="日语单词自测"></a>日语单词自测</h1><p><em>配合moji插件查看中文释义👀</em></p><h2 id="1-動詞"><a href="#1-動詞" class="headerlink" title="1. 動詞"></a>1. 動詞</h2><p>欺く「あざむく」、覗く「のぞく」、湧く「わく」、逃れる「のがれる」、挑む「いどむ」、固める「かためる」、奪う「うばう」、紛れ込む「まぎれ込む」、仕掛ける「しかける」、強引「ごういん」、溢れる「あふれる」、謙る「へりくだる」、絡み合う「からみあう」、仰ぐ「あおぐ」、耽る「ふける」、眩む「くらむ」、紡ぐ「つむぐ」、辿り着く「たどりつく」、戒める「いましめる」、親しむ「したしむ」、身構える「みがまえる」、ムカ痛「むかつく」、草臥れる「くたびれる」、勤める「つとめる」、節目「ふしめ」、睨む「にらむ」、</p><h2 id="2-名詞"><a href="#2-名詞" class="headerlink" title="2. 名詞"></a>2. 名詞</h2><p>物語「ものがたり」、非難「ひなん」、靄「もや」、競技「きょうぎ」、過労「かろう」、振る舞い「ふるまい」、倹約「けんやく」、氏神「うじがみ」、大木「たいぼく」、復興「ふっこう」、亭主関白「ていしゅかんぱく」、畑「はたけ」、役割「やくわり」、脇「わき」、残酷「ざんこく」、稼業「かぎょう」、木立「きだち」、愛想「あいそ」、苦情「くじょう」、良し悪し「よしあし」、苛め「いじめ」、腰「こし」、当選「とうせん」、目論見「もくろみ」、冒頭「ぼうとう」、羽目「はめ」、下駄「げた」、屋敷「やしき」、一昨年「おととし」、照明「しょうめい」、虚ろ「うつろ」、合否「ごうひ」、私邸「してい」、扱い「あつかい」、神秘「しんぴ」、琴「こと」、里「さと」、猥褻「わいせつ」、暮れ「くれ」、醍醐味「だいごみ」、蓄積「ちくせき」、臥床「がしょう」、山懐「やまふところ」、生涯「しょうがい」、</p><h2 id="3-形容詞"><a href="#3-形容詞" class="headerlink" title="3.形容詞"></a>3.形容詞</h2><p>鋭い「するどい」、甚だしい「甚だしい」、朗らか「ほがらか」、等しい「ひとしい」、素っ気無い「そっけない」、雄大「ゆうだい」、騒がしい「さわがしい」、ぶかぶか「ぶかぶか」、逞しい「たくましい」、所謂「いわゆる」、緩やか「ゆるやか」、惨め「みじめ」、煌々「こうこう」、滑らか「なめらか」、無茶苦茶「むちゃくちゃ」、</p><h2 id="4-副詞"><a href="#4-副詞" class="headerlink" title="4. 副詞"></a>4. 副詞</h2><p>ぶらぶら、こそこそ、じろじろ、たっぷり、はらはら、がさがさ、がっしり、がやがや、さっぱり、しみじみ、のんびり、ゆったり、すやすや、ぎょうぎょう、めらめら、</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年8月东大情理CS算法题解读</title>
    <link href="/2024/09/15/UTO-DSA-2021-8/"/>
    <url>/2024/09/15/UTO-DSA-2021-8/</url>
    
    <content type="html"><![CDATA[<h1 id="Author-偷偷"><a href="#Author-偷偷" class="headerlink" title="Author: 偷偷  "></a><center>Author: 偷偷  </center></h1><h1 id="尊重原创，偷偷wx-LifeGoesOn-Rio"><a href="#尊重原创，偷偷wx-LifeGoesOn-Rio" class="headerlink" title="尊重原创，偷偷wx:LifeGoesOn_Rio  "></a><center>尊重原创，偷偷wx:LifeGoesOn_Rio  </center></h1><div class="note note-success">            <p>这道题的场景是实现一个排序算法，目的是优化时间复杂度。题目的策略是使用分治递归(Divide &amp; Conquer),在深度理解题目的场景下可以解决这道题目。</p>          </div><p>Firstly, read the pseudocode.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// return the least value that is &gt;= kl/m</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">multfrac</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m)</span>&#123;<br>    <span class="hljs-keyword">return</span> (k * l + (m - <span class="hljs-number">1</span>)) / m;<br>&#125;<br><br><span class="hljs-comment">// *q &lt;= *p</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compare_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> *q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(*p &gt; *q)&#123;<br>        <span class="hljs-type">int</span> tmp = *p;<br>        *p = *q;<br>        *q = tmp;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// sort in ascending order</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mysort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    <span class="hljs-type">int</span> k = j - i;  <span class="hljs-comment">// number of elements</span><br>    <span class="hljs-keyword">if</span>(k &lt; <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-comment">/** fill in the  blanks **/</span> <br><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        mysort(a, i, i + multfrac(k, x, w));<br>        mysort(a, j - multfrac(k, y, w), j);<br>        mysort(a, i, i + multfrac(k, z, w));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(1) 当k &lt; 4, 即元素个数小于4时做升序排序，分类讨论即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(k &lt; <span class="hljs-number">4</span>)&#123;<br>    <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">// 元素个数不多于1时，不做任何处理</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == <span class="hljs-number">2</span>) <span class="hljs-built_in">compare_swap</span>(a[i], a[i + <span class="hljs-number">1</span>]); <span class="hljs-comment">// 比较交换一次</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k == <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-built_in">compare_swap</span>(a[i], a[i + <span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">compare_swap</span>(a[i + <span class="hljs-number">1</span>], a[i + <span class="hljs-number">2</span>]);<br>        <span class="hljs-built_in">compare_swap</span>(a[i], a[i + <span class="hljs-number">1</span>]);<br>    &#125;  <span class="hljs-comment">// 依次比较三次</span><br>&#125;<br></code></pre></td></tr></table></figure><p>算法详细过程如下：<br><img src="/img/DSA/swap_compare.jpg" alt="交换流程演示" style="max-width: 100%; height: auto;" /></p><p>(2) </p><p>$$<br>T(n)&#x3D;<br>\begin{cases}<br>1,\quad n\leq 3 \\<br>n^{\log_{4&#x2F;3}{3}}, \quad n&gt;3<br>\end{cases}<br>$$</p><p>这里也是分类讨论：</p><p>当n &lt;&#x3D; 3时，比较次数不随输入规模变化，因此为1；</p><p>当n &gt; 3时，代入分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">mysort</span>(a, i, i + <span class="hljs-built_in">multfrac</span>(k, x, w)); <span class="hljs-comment">// sort前3/4规模的数组</span><br><span class="hljs-built_in">mysort</span>(a, j - <span class="hljs-built_in">multfrac</span>(k, y, w), j); <span class="hljs-comment">// sort后3/4规模的数组</span><br><span class="hljs-built_in">mysort</span>(a, i, i + <span class="hljs-built_in">multfrac</span>(k, z, w)); <span class="hljs-comment">// sort前3/4规模的数组</span><br></code></pre></td></tr></table></figure><img src="/img/DSA/swap_compare2.jpg" alt="递归树演示" style="max-width: 100%; height: auto;" /><p>根据递归树可以写出主定理公式(Master theorem):<br>$$T(n) &#x3D; 3T(3n&#x2F;4) + O(n) $$<br>根据套路：这里b &#x3D; 4&#x2F;3, a &#x3D; 3.<br>$$O(n ^{\log_{b}{a}}) &#x3D; O(n^{log_{4&#x2F;3}{3}}) &gt; O(n) $$<br>所以有<br>$$T(n) &#x3D; O(n^{\log_{4&#x2F;3}{3}})$$</p><p>(3) (4, 2, 3, 3), (4, 3, 2, 3), (4, 3, 3, 2) can always work properly. (4, 2, 3, 2) can’t always work properly.</p><blockquote><p>可以看下图演示：前两次的sort调用的交集部分是排好数组最大的部分，第三次sort调用要覆盖剩余没有排好的部分；对于(4, 2, 3, 2), 前两次调用排好了数组最大的1&#x2F;4部分，所以第三次调用至少要覆盖数组前3&#x2F;4的大小，而第三次调用只覆盖了前1&#x2F;2，所以这个组合不行。</p></blockquote><img src="/img/DSA/swap_compare3.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>(4)<br>$$<br>\begin{cases}<br>    x + y &gt; w \\<br>    x + y + z &gt;&#x3D; 2w<br>\end{cases}<br>$$</p><blockquote><p>在解决第三题后，第四题就非常容易了。</p></blockquote><img src="/img/DSA/swap_compare4.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>视数组的大小为1，第一次调用排好前x&#x2F;w部分的元素，第二次大小排好后y&#x2F;w部分的元素。所以排序需满足：</p><ol><li>前两次调用的范围必须要有交集</li><li>第三次调用必须要覆盖完前两次调用的没有排好的部分。因此有：<br>$$ x&#x2F; w + y &#x2F; w &gt; 1$$<br>$$ z &#x2F; w &gt;&#x3D;  1 - (x + y - w) &#x2F; w $$</li></ol>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>数据结构与算法</category>
      
      <category>东京大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
      <tag>东京大学</tag>
      
      <tag>修考答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure &amp; Algorithms</title>
    <link href="/2024/09/10/DSA/"/>
    <url>/2024/09/10/DSA/</url>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure-Algorithms"><a href="#Data-Structure-Algorithms" class="headerlink" title="Data Structure &amp; Algorithms"></a>Data Structure &amp; Algorithms</h1><p>This is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(<strong>偷偷</strong>).The main language is in Chinese but you can see some concepts in English &amp; Japanese. And the pseudocode is in the style of <strong>C++</strong>. Let’s quickly review this subject!</p><p>这是偷偷刷了很多修考题之后总结出来的修考秘籍，全文都是考点，彻底高能。</p><h2 id="1-Introduction-to-Algorithms"><a href="#1-Introduction-to-Algorithms" class="headerlink" title="1. Introduction to Algorithms"></a>1. Introduction to Algorithms</h2><p>这一章主要计划复习<strong>时间复杂度(Time Complexity)</strong> 和 <strong>空间复杂度(Space Complexity)</strong> 两个概念，然后再仔细回顾 <strong>分治递归(DIvide &amp; Conquer)</strong> 这一重要的概念。最后再给出解决时间复杂度常用的分析方法和万能的<strong>主定理公式（Master Theorem）</strong></p><h3 id="1-1-时间复杂度与空间复杂度"><a href="#1-1-时间复杂度与空间复杂度" class="headerlink" title="1.1 时间复杂度与空间复杂度"></a>1.1 时间复杂度与空间复杂度</h3><div class="note note-success">            <p><strong>Space Complexity</strong>: 空间复杂度描述的是算法运行时所需的额外内存空间。通俗解释就是算法在运行的时候需要开辟多少空间的大小。O(1)指一个点集；O(n)就是开辟一个一维空间；O(n^2)开辟二维空间；O(n^3)开辟三维空间。在第二章讲解排序算法的时候，也会用到本章非常多的前置知识。</p>          </div><p>O(1): 常数空间复杂度，表示算法所需的额外空间是固定的，不随输入规模变化。例如，一个固定大小的变量。</p><p>O(n): 线性空间复杂度，表示算法所需的额外空间与输入规模成正比。例如，一个长度为 n 的数组。</p><p>O(n^2): 平方空间复杂度，表示算法所需的额外空间与输入规模的平方成正比。例如，一个 n x n 的二维数组。</p><p>O(n^3): 立方空间复杂度，表示算法所需的额外空间与输入规模的立方成正比。例如，一个 n x n x n 的三维数组。</p><p>一些常见的数据结构的空间复杂度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; nums <span class="hljs-comment">// 三维数组：O(n^3)</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; nums <span class="hljs-comment">// 二维数组：O(n^2)</span><br>stack&lt;<span class="hljs-type">int</span>&gt; st;      <span class="hljs-comment">// 栈：O(n)</span><br>deque&lt;<span class="hljs-type">int</span>&gt; que;    <span class="hljs-comment">// 双端队列：O(n)</span><br>list&lt;<span class="hljs-type">int</span>&gt; linkedList;   <span class="hljs-comment">// 链表：O(n)</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p><strong>Time complexity</strong>: 时间复杂度是衡量算法效率的重要指标之一，它描述了算法执行所需时间随输入规模增长的变化情况。这是修考中必考的一个地方：<br>（1）如分析给出的代码的时间复杂度（Hint：关注for，while循环）（2）根据源代码优化时间复杂度设计新的算法（Hint：空间换时间）</p>          </div><p>常见的时间复杂度有以下几种：</p><p>O(1): <strong>常数时间复杂度</strong>，算法的执行时间不随输入规模变化。例如，访问数组中的某个元素。</p><p><code>int a = nums[10]  // 给a赋值数组下标为10的元素</code></p><p>O(n): <strong>线性时间复杂度</strong>，算法的执行时间与输入规模成正比。例如，遍历一个长度为 n 的数组。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; /* 操作 */ &#125;</code></p><p>O(log n): 对数时间复杂度，算法的执行时间随输入规模的对数增长。例如，二分查找(Binary Search)算法。</p><p><code>int binarySearch(int[] arr, int target) &#123; /* 二分查找逻辑 */ &#125;</code></p><p> O(n^2) : <strong>平方时间复杂度</strong>，算法的执行时间与输入规模的平方成正比。例如，冒泡排序(Bubble Sort)算法。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; /* 冒泡排序逻辑 */ &#125; &#125;</code></p><p>O(2^n): <strong>指数时间复杂度</strong>，算法的执行时间随输入规模的指数增长。例如，解决所有子集问题的递归算法。</p><p><code>void subsets(int[] nums) &#123; /* 递归逻辑 */ &#125;</code></p><p>在描述使劲复杂度的时候，有三种表示需要注意一下：</p><p>$O$: 表示渐进上界； $\Omega$: 表示渐进下界； $\Theta$: 渐进紧确界</p><h3 id="1-2-分治递归-Divide-Conquer"><a href="#1-2-分治递归-Divide-Conquer" class="headerlink" title="1.2 分治递归(Divide &amp; Conquer)"></a>1.2 分治递归(Divide &amp; Conquer)</h3><div class="note note-success">            <p>分治递归(Divide &amp; conquer)的思想是将原问题分割成更小的子问题，自顶向下地解决每个子问题，并最终自底向上合并它们的解来解决主问题。</p>          </div><p>常见的分治递归有：二分查找(Binary Search) 和归并排序(Merge Sort).</p><h4 id="1-2-1-二分查找-Binary-Search"><a href="#1-2-1-二分查找-Binary-Search" class="headerlink" title="1.2.1 二分查找(Binary Search)"></a>1.2.1 二分查找(Binary Search)</h4><img src="/img/DSA/binary_search.svg" alt="二分查找演示" style="max-width: 100%; height: auto;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 前提nums是有序数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// (避免left + right) / 2 的溢出</span><br>        <span class="hljs-keyword">if</span>(nums[mid] == target) <span class="hljs-keyword">return</span> mid;   <span class="hljs-comment">// 找到目标，返回索引</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="hljs-number">1</span>;   <span class="hljs-comment">// 目标在左半部分</span><br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 目标在右半部分</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上图我们得出递归表达式：<br>$T(n) &#x3D; T(n &#x2F; 2) + O(1)$， 得出$T(n) &#x3D; O(log_{2}{n})$</p><h4 id="1-2-2-归并排序-Merge-Sort"><a href="#1-2-2-归并排序-Merge-Sort" class="headerlink" title="1.2.2 归并排序(Merge Sort)"></a>1.2.2 归并排序(Merge Sort)</h4><img src="/img/DSA/merge_sort.svg" alt="归并排序演示" style="max-width: 100%; height: auto;" />这个图像有效地展示了归并排序的"分而治之"策略： 1.将大问题（排序整个数组）分解成小问题（排序子数组） 2.解决小问题（对小数组排序） 3.将小问题的解合并成大问题的解（合并有序子数组）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 合并两个有序的子数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n1 = mid - left + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左子数组的长度</span><br>    <span class="hljs-type">int</span> n2 = right - mid;     <span class="hljs-comment">// 右子数组的长度</span><br><br>    <span class="hljs-comment">// 创建临时数组存储左右子数组</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftArr</span><span class="hljs-params">(n1)</span>, <span class="hljs-title">rightArr</span><span class="hljs-params">(n2)</span></span>;<br><br>    <span class="hljs-comment">// 复制数据到临时数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; ++i) leftArr[i] = nums[left + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n2; ++i) rightArr[i] = nums[mid + <span class="hljs-number">1</span> + i];<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = left;  <span class="hljs-comment">// i是左子数组指针，j是右子数组指针，k是合并后数组的指针</span><br><br>    <span class="hljs-comment">// 合并左右子数组</span><br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;<br>            nums[k] = leftArr[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums[k] = rightArr[j];<br>            j++;<br>        &#125;<br>        k++;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余的左子数组元素加入nums</span><br>    <span class="hljs-keyword">while</span> (i &lt; n1) &#123;<br>        nums[k] = leftArr[i];<br>        i++;<br>        k++;<br>    &#125;<br><br>    <span class="hljs-comment">// 将剩余的右子数组元素加入nums</span><br>    <span class="hljs-keyword">while</span> (j &lt; n2) &#123;<br>        nums[k] = rightArr[j];<br>        j++;<br>        k++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 递归实现归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 递归排序左右两部分</span><br>        <span class="hljs-built_in">mergeSort</span>(nums, left, mid);<br>        <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, right);<br><br>        <span class="hljs-comment">// 合并已排序的部分</span><br>        <span class="hljs-built_in">merge</span>(nums, left, mid, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归式：$T(n) &#x3D; 2T(n &#x2F; 2) + O(n)$, 所以$T(n) &#x3D; O(nlog_{2}{n})$</p><h3 id="1-3-主定理-Master-Theorem"><a href="#1-3-主定理-Master-Theorem" class="headerlink" title="1.3 主定理(Master Theorem)"></a>1.3 主定理(Master Theorem)</h3><p>递归方程形式如：<br>$$T(n) &#x3D; aT(n &#x2F; b) + O(n^d)$$</p><div class="note note-success">            <p>其中，$a$表示子问题的数量，b表示每个子问题是原问题规模的$1&#x2F;b$, $O(n^d)$ 表示在每一层分治过程之外，解决问题所需的额外代价，通常是合并或分割的代价。</p>          </div><p><strong>情况 1：</strong><br>如果$log_{b}{a} &gt; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(\log_{b}{a}) $$</p><p><strong>解释：</strong> 在这种情况下，分治产生的子问题数量增长得更快，主导时间复杂度的是递归中的分治部分。</p><p><strong>情况 2：</strong><br>如果$log_{b}{a} &#x3D; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(n^d\log{n}) $$</p><p><strong>解释：</strong> 在这种情况下，分治和额外开销的增长速度相同，因此总的时间复杂度是 $n^d\log{n}$。</p><p><strong>情况 3：</strong><br>如果 $log_{b}{a} &lt; d$，则递归式的解为：<br>$$T(n) &#x3D; O(n^d)$$<br><strong>解释：</strong> 在这种情况下，额外的开销主导时间复杂度，因此复杂度主要由 $n^d$决定。</p><p><strong>斯特林近似公式（Stirling’s Formula）:</strong> $n! \approx \sqrt{2 \pi n} \left( \frac{n}{e} \right)^n$</p><h2 id="2-Sorting-Algorithm"><a href="#2-Sorting-Algorithm" class="headerlink" title="2.Sorting Algorithm"></a>2.Sorting Algorithm</h2><p>再时间复杂度和空间复杂度的概念后，并引入了分治递归和归并排序算法；接下来这一章就主要回顾常见的一些排序算法，然后分析他们的时间复杂度和空间复杂度。</p><h3 id="2-1-插入排序-Insertion-Sort"><a href="#2-1-插入排序-Insertion-Sort" class="headerlink" title="2.1 插入排序(Insertion Sort)"></a>2.1 <strong>插入排序(Insertion Sort)</strong></h3><p>这个算法的过程也很直观：插入排序的核心思想是将一个新元素插入到已经排好序的子序列中的适当位置。<br><img src="/img/DSA/insertation_sort.svg" alt="插入排序演示" style="max-width: 100%; height: auto;" /><br>最好的情况下是：原数组规模小或者大部分数据有序，那么我们一次遍历就可以完成好排序。 最坏的情况下是：原数组是降序排列的，意思是每一次插入新元素的时候，都要遍历一遍已排好序的子数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>    <span class="hljs-comment">// 从第二个元素开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-comment">// 回溯检查并交换</span><br>        <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-built_in">swap</span>(nums[j], nums[j - <span class="hljs-number">1</span>]);<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最坏情况：$T(n) &#x3D; T(n - 1) + O(n)$,  $T(n) &#x3D; O(n^2)$</p><p>最好情况：$T(n) &#x3D; T(n - 1) + O(1)$,  $T(n) &#x3D; O(n)$</p><h3 id="2-2冒泡排序-Bubble-Sort"><a href="#2-2冒泡排序-Bubble-Sort" class="headerlink" title="2.2冒泡排序(Bubble Sort)"></a>2.2冒泡排序(Bubble Sort)</h3><p>冒泡排序是一个直观的算法，通过重复地遍历数组来工作。在每次遍历中，它比较相邻的元素并在需要时交换它们，这样每次迭代都会将当前未排序部分中的最大元素’冒泡’到数组的末尾正确位置。这个过程从左到右重复进行，直到整个数组排序完成。一句话概括就是：不断的进行两两比较。<br><img src="/img/DSA/bubble_sort.svg" alt="冒泡排序演示" style="max-width: 100%; height: auto;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 控制循环的轮数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 内层循环，相邻比较</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 交换元素</span><br>                std::<span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>冒泡排序平均时间复杂度</strong>：$T(n) &#x3D; O(n^2)$</p><h3 id="2-3选择排序-Selection-Sort"><a href="#2-3选择排序-Selection-Sort" class="headerlink" title="2.3选择排序(Selection Sort)"></a>2.3选择排序(Selection Sort)</h3><p>选择排序的基本思想是分阶段地将数组划分为两部分：已排序部分和未排序部分。每一轮从未排序部分中找到最小（或最大）的元素，放到已排序部分的末尾，直到整个数组排序完成。<br><img src="/img/DSA/selection_sort.svg" alt="选择排序演示" style="max-width: 100%; height: auto;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 已排序数组末尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> minIdx = i;<br>        <span class="hljs-comment">// 找未排序数组中的最小元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;<br>                minIdx = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minIdx != i) &#123;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>选择排序时间复杂度：</strong> $T(n) &#x3D; O(n^2)$</p><h3 id="2-4快速排序-Quick-Sort"><a href="#2-4快速排序-Quick-Sort" class="headerlink" title="2.4快速排序(Quick Sort)"></a>2.4快速排序(Quick Sort)</h3><p>快速排序的本质是分治法。它通过选择一个基准元素，将原数组划分为小于基准元素和大于基准元素的两个子数组，然后对这两个子数组进行递归排序。<br><img src="/img/DSA/quick_sort.svg" alt="快速排序演示" style="max-width: 100%; height: auto;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 分区函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[high];  <span class="hljs-comment">// 选择最后一个元素作为基准</span><br>    <span class="hljs-type">int</span> i = (low - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 小于基准的元素的索引</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = low; j &lt;= high - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-comment">// 如果当前元素小于或等于基准</span><br>        <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>            i++;    <span class="hljs-comment">// 增加小于基准的元素索引</span><br>            <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[high]);<br>    <span class="hljs-keyword">return</span> (i + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 快速排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-comment">// pi是分区索引，arr[pi]现在在正确的位置</span><br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, low, high);<br><br>        <span class="hljs-comment">// 分别对左右子数组进行递归排序</span><br>        <span class="hljs-built_in">quickSort</span>(arr, low, pi - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pi + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在最坏情况下，基准元素可能是最大或最小值，这会导致一个子数组为空，另一个子数组的大小为 $n-1$，此时的时间复杂度为 $T(n) &#x3D; T(n-1) + O(n) &#x3D;O(n^2)$。而在平均情况下，基准元素能够较好地划分数组，时间复杂度为 $T(n) &#x3D; 2T(n&#x2F;2) + O(n)&#x3D;O(n\log{n})$ 。</p><h3 id="2-5堆排序-Heap-Sort"><a href="#2-5堆排序-Heap-Sort" class="headerlink" title="2.5堆排序(Heap Sort)"></a>2.5堆排序(Heap Sort)</h3><p>这个考点应该是修考最爱考的一个了！（敲重点）堆排序的基本思想是不断维护一个最大堆。在每次排序过程中，首先将最大堆的根节点（最大值）与堆的最后一个元素交换，然后缩小堆的范围（排除最后一个元素），并对新的根节点进行下沉操作，以恢复最大堆的性质。重复这一过程，直到所有元素都被排序。<br><img src="/img/DSA/heap_sort.svg" alt="堆排序演示" style="max-width: 100%; height: auto;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 堆化函数，用于维护最大堆性质</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = i;  <span class="hljs-comment">// 初始化最大值为根</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左子节点</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 右子节点</span><br><br>    <span class="hljs-comment">// 如果左子节点大于根</span><br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])<br>        largest = left;<br><br>    <span class="hljs-comment">// 如果右子节点大于当前最大值</span><br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])<br>        largest = right;<br><br>    <span class="hljs-comment">// 如果最大值不是根</span><br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[i], arr[largest]);<br><br>        <span class="hljs-comment">// 递归地堆化受影响的子树</span><br>        <span class="hljs-built_in">heapify</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 堆排序函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 构建最大堆（从最后一个非叶子节点开始）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">heapify</span>(arr, n, i);<br><br>    <span class="hljs-comment">// 一个个从堆顶取出元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 将当前根移到末尾</span><br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br><br>        <span class="hljs-comment">// 在减小的堆上调用 max heapify</span><br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>建堆的时间复杂度为$O(n)$,每个节点的调整最多为$O(\log{n})$次。在排序的过程中需要建堆$O(n)$次，并且每次需要$O(logn)$来维护堆(heapify),因此对排序总的时间复杂度为$O(n\log{n})$</p><h2 id="3-Data-Structure"><a href="#3-Data-Structure" class="headerlink" title="3.Data Structure"></a>3.Data Structure</h2><p>这一章主要讲解常见的数据结构,如栈(stack),队列(queue),链表(linked list),哈希表(hash map),以及字符串(string)。二叉树考点众多我会单独做成一章并且和图算法一块复习。</p><h3 id="3-1-Stack-Queue"><a href="#3-1-Stack-Queue" class="headerlink" title="3.1 Stack &amp; Queue"></a>3.1 Stack &amp; Queue</h3><p><strong>栈(stack)</strong> :后进先出(LIFO), <strong>队列</strong> :先进先出(FIFO)。另外，栈和队列是可以相互实现的，了解到这个程度，我认为就掌握到栈和队列的基本性质了。</p><p><em>Q1: 如何用栈实现队列？</em></p><div class="note note-success">            <p>A: 开两个栈，一个负责栈负责放入元素，另一个栈负责弹出元素</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 一个栈负责放入元素，一个栈负责弹出元素</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; in, out;  <br>    <span class="hljs-built_in">MyQueue</span>() &#123;&#125;<br>    <span class="hljs-comment">// 模拟入队过程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        in.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 模拟弹出队首元素过程</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(out.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(!in.<span class="hljs-built_in">empty</span>())&#123;<br>                out.<span class="hljs-built_in">push</span>(in.<span class="hljs-built_in">top</span>());<br>                in.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = out.<span class="hljs-built_in">top</span>();<br>        out.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 获取队首元素的值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 获取队首元素的值</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 放回</span><br>        out.<span class="hljs-built_in">push</span>(ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> in.<span class="hljs-built_in">empty</span>() &amp;&amp; out.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><em>Q2：如何用队列实现栈？</em></p><div class="note note-success">            <p>A：开两个队列，一个模拟入栈，一个模拟出栈。更优化的方式是直接开一个队列即可,不断的出队入队就可以实现栈的性质。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 一个队列负责入栈，一个负责出栈</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; in, out;<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;    <br>    <span class="hljs-comment">// 放入元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        in.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 把in队列的元素不断出队只剩一个，即时栈顶</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(in.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;<br>            out.<span class="hljs-built_in">push</span>(in.<span class="hljs-built_in">front</span>());<br>            in.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> ans = in.<span class="hljs-built_in">front</span>();<br>        in.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-built_in">swap</span>(in, out); <span class="hljs-comment">// 交换两个队列</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// 获取栈顶的元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 获取弹出后的值</span><br>        in.<span class="hljs-built_in">push</span>(ans);  <span class="hljs-comment">// 再放入队列</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> in.<span class="hljs-built_in">empty</span>() &amp;&amp; out.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化后的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <span class="hljs-comment">// 放入元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-comment">// 弹出栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-type">int</span> n = que.<span class="hljs-built_in">size</span>();<br>      n--;  <span class="hljs-comment">// 把对位元素调整到队首</span><br>      <span class="hljs-keyword">while</span>(n--)&#123;<br>        que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());<br>        que.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>      <span class="hljs-type">int</span> ans = que.<span class="hljs-built_in">front</span>();<br>      que.<span class="hljs-built_in">pop</span>();<br>      <span class="hljs-keyword">return</span> ans;  <br>    &#125;<br>    <span class="hljs-comment">// 获取栈顶元素  </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-type">int</span> ans = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>();<br>       que.<span class="hljs-built_in">push</span>(ans);<br>       <span class="hljs-keyword">return</span> ans; <br>    &#125;<br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>();     <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-2-Linked-List"><a href="#3-2-Linked-List" class="headerlink" title="3.2 Linked List"></a>3.2 Linked List</h3><p>常见的链表有单链表和双链表。<em>单链表</em>：每个节点只包含一个指向下一个节点的指针，访问节点时只能从头节点开始向后遍历。<em>双链表</em>：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。这使得可以在链表中向前和向后遍历。<br><img src="/img/DSA/linkedlist.svg" alt="链表演示" style="max-width: 100%; height: auto;" /></p><p><strong>链表的优缺点</strong></p><p><em>优点</em>：1)动态大小：链表的大小可以动态调整，不像数组那样需要预先定义大小。2)方便插入和删除：在链表中插入或删除节点的时间复杂度为 O(1)，只需调整指针，而数组则可能需要移动大量元素。</p><p><em>缺点</em>：1)内存占用：每个节点需要额外的存储空间来存储指针，导致比数组更高的内存开销。2)随机访问困难：链表不支持快速随机访问，查找元素的时间复杂度为 O(n)。</p><h3 id="3-3-Hash-Map"><a href="#3-3-Hash-Map" class="headerlink" title="3.3 Hash Map"></a>3.3 Hash Map</h3><p><strong>哈希映射（Hash Map）</strong> 是一种数据结构，用于以键值对（key-value pairs）形式存储数据。它通过一个哈希函数将键映射到数组中的索引，从而实现快速的数据访问。主要特点有：</p><p>1）快速查找：平均情况下，哈希映射可以在 O(1) 时间内进行查找、插入和删除操作。</p><p>2）键值对存储：每个元素都由一个唯一的键和与之关联的值组成，可以通过键快速访问对应的值。</p><p>3）哈希函数：将键转换为数组索引的函数，好的哈希函数可以减少冲突（不同键映射到相同索引）。</p><p>4）处理冲突：常用的方法包括<strong>链式法(chaining)<strong>和</strong>开放寻址法（open addressing）</strong>。<br><img src="/img/DSA/hash.svg" alt="哈希表处理冲突演示" style="max-width: 100%; height: auto;" /></p><p>为了减少哈希冲突，哈希映射的函数要尽量将不同的输入键均匀地映射到哈希表的不同索引，以减少冲突（即不同键映射到相同索引的情况）。</p><h3 id="3-4-string"><a href="#3-4-string" class="headerlink" title="3.4 string"></a>3.4 string</h3><p>字符串这个数据结构直观易懂，主要涉及到的考点有KMP算法和sequence alignment算法。这里主要回顾一下KMP算法，sequence alignment会在后面动态规划章节中仔细讲解。</p><h4 id="3-4-1-KMP算法"><a href="#3-4-1-KMP算法" class="headerlink" title="3.4.1 KMP算法"></a>3.4.1 KMP算法</h4><p>KMP算法可以说是学一次忘一次……建议考前一定要临时报佛脚记一下。这个算法的美妙之处就是在于优化了暴力匹配，用前缀表来跳过重复的匹配过程。前缀表就是模式串中每个位置的最长相等前缀和后缀的长度。在发生不匹配的情况下，将子串移动前一个字符串的前缀表的具体值。（感觉京大最喜欢考KMP算法了）<br><img src="/img/DSA/KMP.svg" alt="KMP算法演示" style="max-width: 100%; height: auto;" /></p><h2 id="4-Binary-Tree"><a href="#4-Binary-Tree" class="headerlink" title="4.Binary Tree"></a>4.Binary Tree</h2><p>关于二叉树的考点有许多，像是考二叉树的遍历，二叉搜索树（Binary Search Tree），最小生成树（MST），以及AVL树。首先需要了解二叉树的一些基本性质，例如每个节点的下标，以及二叉树的多种遍历方式。</p><h3 id="4-1-Concepts-of-Binary-Tree"><a href="#4-1-Concepts-of-Binary-Tree" class="headerlink" title="4.1 Concepts of Binary Tree"></a>4.1 Concepts of Binary Tree</h3><img src="/img/DSA/binary_tree.svg" alt="常见的二叉树" style="max-width: 100%; height: auto;" /><p><strong>完全二叉树（complete binary tree）</strong>：是一种二叉树，其中每一层都是满的，除了可能是最后一层，且最后一层的节点从左到右排列。在完全二叉树中，所有的节点都尽可能地靠左排列，这种结构使得它在存储和操作上更为高效。与全二叉树不同，完全二叉树允许最后一层不满，但仍需保持左侧填充。</p><p>对于一个完全二叉树，如果节点的索引为$i$,节点数为$n$那么：</p><ol><li>左孩子节点索引: $2i$</li><li>右孩子节点索引: $2i + 1$</li><li>父亲节点索引: $[i&#x2F;2]$  </li><li>二叉树高度: $ceil(log_{2}{(n+1)})$ 或 $floor(log_{2}{n}) + 1$</li></ol><p><strong>全二叉树（full binary tree）</strong>：是指每个节点要么没有子节点，要么恰好有两个子节点的二叉树。在这种树中，除了叶子节点外，所有节点都有两个子节点。这样的结构确保了树的每一层都被完全填满，只有最后一层可能不满。</p><p><strong>二叉搜索树（Binary Search Tree, BST）</strong>: 是一种二叉树，其中每个节点都包含一个键值，左子树的所有节点键值小于该节点，右子树的所有节点键值大于该节点。这种结构使得查找、插入和删除操作的平均时间复杂度为 O(log n)。其主要性质包括：每个节点最多有两个子节点，左子树和右子树都是二叉搜索树，且没有重复的键值。</p><p>二叉搜索树的搜索迭代实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(root)&#123;<br>            <span class="hljs-keyword">if</span>(val &gt; root-&gt;val) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val &lt; root-&gt;val) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Tree-Traversal"><a href="#4-2-Tree-Traversal" class="headerlink" title="4.2 Tree Traversal"></a>4.2 Tree Traversal</h3><p><strong>层序遍历（Level Order Traversal）：</strong> 开一个队列处理一层的节点并放入下一层的节点。这个遍历也属于<strong>广度优先遍历（BFS）</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>            <span class="hljs-type">int</span> n = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(n--)&#123;<br>                <span class="hljs-keyword">auto</span> node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                nums.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>二叉树的<strong>深度优先遍历（DFS）</strong>可以分为三种：前序遍历，中序遍历和后序遍历。</p><p><strong>前序遍历（Preorder Traversal）：</strong>  <em>根-&gt;左-&gt;右</em>，递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">preorderTraversal</span>(root-&gt;left);<br>        <span class="hljs-built_in">preorderTraversal</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当然也可以开一个栈来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(root || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(root)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                <span class="hljs-keyword">if</span>(root-&gt;right)&#123;<br>                    st.<span class="hljs-built_in">push</span>(root-&gt;right);<br>                &#125;<br>                root = root-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                root = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>后序遍历（Postorder Traversal）：</strong>  <em>左-&gt;右-&gt;根</em>，递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">postorderTraversal</span>(root-&gt;left);<br>        <span class="hljs-built_in">postorderTraversal</span>(root-&gt;right);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>后序遍历同样可以开一个栈来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ans;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* cur = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;left)&#123;<br>                st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                cur-&gt;left = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(cur-&gt;right)&#123;<br>                    st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    cur-&gt;right = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>中序遍历（Inorder Traversal）：</strong>  <em>左-&gt;根-&gt;右</em>，递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;left);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>当然也可以开一个栈来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(root || !st.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(root)&#123;<br>                st.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt; right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>二叉树的中序遍历还有一个重要的考点是<em>逆波兰表达式</em>,这个曾经在京大的过去问中出现过。<strong>逆波兰表达式（Reverse Polish Notation, RPN）</strong> 是一种后缀表示法，用于表示算术表达式。在这种表示法中，运算符跟在操作数之后，而不是在它们之间。这种形式的好处是消除了括号的需要，因为操作的顺序总是由操作符的位置决定。具体的实现方法可以开一个栈轻松解决。<br><img src="/img/DSA/rpn.svg" alt="逆波兰表达式" style="max-width: 70%; height: auto;" /></p><h3 id="4-3-AVL-Tree"><a href="#4-3-AVL-Tree" class="headerlink" title="4.3 AVL Tree"></a>4.3 AVL Tree</h3><p><strong>AVL树</strong>是一种自平衡的二叉搜索树，确保每个节点的左右子树高度差（平衡因子）最多为1。这样可以保证树的高度在 $O(log{n})$ 范围内，确保高效的插入、删除和查找操作。AVL树通过旋转操作来维持平衡，从而优化性能，特别是在频繁修改的场景中。东工有一年考到了这个点，但我认为了解到AVL树的工作原理就ok了,主要聚焦在节点的添加和删除以及树的旋转。<br><img src="/img/DSA/avl_tree_insert.svg" alt="AVL树增加节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_delete.svg" alt="AVL树删除节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_rotate.svg" alt="AVL树左旋和右旋" style="max-width: 100%; height: auto;" /></p><h2 id="4-Graph-Theory"><a href="#4-Graph-Theory" class="headerlink" title="4.Graph Theory"></a>4.Graph Theory</h2><p>本章主要讲解图的基本算法，最小生成树，单源最短路径算法，单源最短路径算法和多源最短路径算法，以及最大流问题。修考题的图算法都是套的模版，因此了解算法的核心思想非常关键。</p><h3 id="4-1图的基本算法"><a href="#4-1图的基本算法" class="headerlink" title="4.1图的基本算法"></a>4.1图的基本算法</h3><p>对于图的表示，我们需要建立一个<strong>邻接矩阵(adjacency matrix)</strong>,简单图的邻接矩阵是(0,1)矩阵并且对角线元素都为0。无向图的邻接矩阵是对称矩阵。<br><img src="/img/DSA/adjacency_matrix.svg" alt="邻接矩阵" style="max-width: 100%; height: auto;" /></p><h4 id="4-1-1-BFS"><a href="#4-1-1-BFS" class="headerlink" title="4.1.1 BFS"></a>4.1.1 BFS</h4><p>在二叉树章节中讲解了树的深度遍历算法，在图中，我们可以同样的利用邻接链表（也就是建一个数组）来获取当前遍历的节点的邻接节点，开一个数组记录已访问的节点，最后利用队列实现层序遍历。<br><img src="/img/DSA/bfs.svg" alt="广度优先算法" style="max-width: 100%; height: auto;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> V; <span class="hljs-comment">// Number of vertices</span><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj; <span class="hljs-comment">// Adjacency list</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">V</span>(v), <span class="hljs-built_in">adj</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// Function to add an edge to the graph</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>        adj[v].<span class="hljs-built_in">push_back</span>(w);<br>    &#125;<br><br>    <span class="hljs-comment">// BFS traversal starting from given source vertex</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">// Mark all vertices as not visited</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(V, <span class="hljs-literal">false</span>)</span></span>;<br><br>        <span class="hljs-comment">// Create a queue for BFS</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; queue;<br><br>        <span class="hljs-comment">// Mark the source node as visited and enqueue it</span><br>        visited[s] = <span class="hljs-literal">true</span>;<br>        queue.<span class="hljs-built_in">push</span>(s);<br><br>        <span class="hljs-keyword">while</span> (!queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// Dequeue a vertex from queue and print it</span><br>            s = queue.<span class="hljs-built_in">front</span>();<br>            cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            queue.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-comment">// Get all adjacent vertices of the dequeued vertex s</span><br>            <span class="hljs-comment">// If an adjacent has not been visited, then mark it visited</span><br>            <span class="hljs-comment">// and enqueue it</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> adjacent : adj[s]) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[adjacent]) &#123;<br>                    visited[adjacent] = <span class="hljs-literal">true</span>;<br>                    queue.<span class="hljs-built_in">push</span>(adjacent);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-DFS"><a href="#4-1-2-DFS" class="headerlink" title="4.1.2 DFS"></a>4.1.2 DFS</h4><p>DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索图形或树数据结构的算法。它尽可能深地访问节点，然后回溯，寻找未访问过的节点。</p><p><strong>基本原理：</strong></p><ol><li>初始化：从起始节点出发，将其标记为访问过。<br>递归或使用栈</li><li><em>递归</em>：对每个未访问的邻接节点，递归调用DFS。（递归的实现方式就是利用栈来记录每一次函数调用的状态）<br><em>栈</em>：将节点压入栈中，访问节点时将其出栈，继续访问其未访问的邻接节点，并将这些邻接节点压入栈。</li><li><em>回溯</em>：如果当前节点的所有邻接节点都访问过，则回溯到上一个节点，继续这个过程，直到所有节点都访问完。<img src="/img/DSA/dfs.svg" alt="深度优先算法" style="max-width: 100%; height: auto;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> V; <span class="hljs-comment">// Number of vertices</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj; <span class="hljs-comment">// Adjacency list</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> v, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visited)</span> </span>&#123;<br>        <span class="hljs-comment">// Mark the current node as visited and print it</span><br>        visited[v] = <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>        <span class="hljs-comment">// Recur for all the vertices adjacent to this vertex</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> adjacent : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[adjacent]) &#123;<br>                <span class="hljs-built_in">DFS</span>(adjacent, visited);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">V</span>(v), <span class="hljs-built_in">adj</span>(v) &#123;&#125;<br><br>    <span class="hljs-comment">// Function to add an edge to the graph</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>        adj[v].<span class="hljs-built_in">push_back</span>(w);<br>    &#125;<br><br>    <span class="hljs-comment">// DFS traversal starting from given source vertex</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>        <span class="hljs-comment">// Mark all the vertices as not visited</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(V, <span class="hljs-literal">false</span>)</span></span>;<br><br>        <span class="hljs-comment">// Call the recursive helper function to print DFS traversal</span><br>        <span class="hljs-built_in">DFS</span>(s, visited);<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>BFS和DFS对比非常鲜明。BFS的性格是保守，害怕风险，尽量做到“广撒网，细收鱼”；而DFS则是奔放，秉持着一颗“不撞南墙不回头”，“不到黄河不死心”的感觉。</p>          </div></li></ol><h4 id="4-1-3-Union-Find"><a href="#4-1-3-Union-Find" class="headerlink" title="4.1.3 Union Find"></a>4.1.3 Union Find</h4><p><strong>并查集（Union-Find）</strong> 算法，又称为不相交集数据结构，是一种用于处理元素分组及查询元素所属组的高效数据结构。它广泛应用于图论（如判断图的连通性、<em>Kruskal算法</em>求最小生成树）并查集主要支持<strong>两种操作</strong>：</p><ol><li>查找（Find）：确定某个元素属于哪个集合（即找到该元素所在集合的代表元素或根节点）。</li><li>合并（Union）：将两个不同的集合合并为一个集合。</li></ol><p>为了提高并查集的效率，通常结合以下两种优化策略：</p><ol><li>路径压缩（Path Compression）：在 Find 操作中，将访问过的所有节点直接连接到根节点，从而降低树的高度。</li><li>按秩合并（Union by Rank）或按大小合并（Union by Size）：在 Union 操作中，总是将较小的树挂到较大的树下，保持树的平衡。</li></ol><p>结合这两种优化后，并查集的时间复杂度几乎接近于常数时间，具体为 反阿克曼函数 的时间复杂度，几乎可以认为是 $O(1)$。<br><img src="/img/DSA/union_find.svg" alt="并查集算法" style="max-width: 100%; height: auto;" /><br>以下是一个使用路径压缩和按秩合并优化的并查集实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;  <span class="hljs-comment">// 存储每个节点的父节点</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; rank;    <span class="hljs-comment">// 存储每个节点的秩（树的高度）</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数：初始化每个节点的父节点为自身，秩为1</span><br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> size) &#123;<br>        parent.<span class="hljs-built_in">resize</span>(size);<br>        rank.<span class="hljs-built_in">resize</span>(size, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找操作：查找元素x所在集合的根节点，并进行路径压缩</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[x] != x)&#123;<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]);  <span class="hljs-comment">// 路径压缩</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 合并操作：将元素x和元素y所在的集合合并</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSets</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootX = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> rootY = <span class="hljs-built_in">find</span>(y);<br><br>        <span class="hljs-keyword">if</span>(rootX == rootY)&#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 已经在同一个集合中</span><br>        &#125;<br><br>        <span class="hljs-comment">// 按秩合并：将秩较小的树挂到秩较大的树下</span><br>        <span class="hljs-keyword">if</span>(rank[rootX] &lt; rank[rootY])&#123;<br>            parent[rootX] = rootY;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[rootX] &gt; rank[rootY])&#123;<br>            parent[rootY] = rootX;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            parent[rootY] = rootX;<br>            rank[rootX] += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-1-4-Topological-Sort"><a href="#4-1-4-Topological-Sort" class="headerlink" title="4.1.4 Topological Sort"></a>4.1.4 Topological Sort</h4><p><strong>拓扑排序（Topological Sorting）</strong>是图论中的一种线性排序方法，主要用于对<strong>有向无环图（Directed Acyclic Graph, DAG</strong> 中的顶点进行排序，使得对于图中的每一条有向边 (u → v)，顶点 u 在排序中都出现在顶点 v 的前面。<br><img src="/img/DSA/topo_sort.svg" alt="拓扑排序算法" style="max-width: 100%; height: auto;" /><br><strong>拓扑排序算法步骤：</strong></p><ol><li>计算每个顶点的入度：统计每个顶点被其他顶点指向的次数（即入度, inDegree）。</li><li>将所有入度为 0 的顶点加入队列：这些顶点没有任何前置依赖。</li><li>重复以下步骤直到队列为空：（1）从队列中取出一个顶点 u，将其加入拓扑排序结果中。（2）遍历 u 的所有邻接顶点 v，将 v 的入度减 1；如果 v 的入度变为 0，则将 v 加入队列。</li><li>检查结果：如果所有顶点都被处理过，则返回拓扑排序；否则，图中有环，无法进行拓扑排序。</li></ol><p>在初始化时，需要遍历所有顶点计算入度，耗时$O(V)$；然后遍历所有边来更新入度并处理顶点，耗时$O(E)$。因此总的时间复杂度是$O(V + E)$。最终的排序顺序是: $1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> V;  <span class="hljs-comment">// 顶点数</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;  <span class="hljs-comment">// 邻接表</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; inDegree;  <span class="hljs-comment">// 入度数组</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Graph</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">V</span>(v), <span class="hljs-built_in">inDegree</span>(v + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        adj[u].<span class="hljs-built_in">push_back</span>(v);<br>        inDegree[v]++;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topologicalSort</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>        <span class="hljs-comment">// 将所有入度为0的顶点加入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(u);<br><br>            <span class="hljs-comment">// 对于所有相邻的顶点，将其入度减1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>                <span class="hljs-keyword">if</span> (--inDegree[v] == <span class="hljs-number">0</span>) &#123;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否存在环</span><br>        <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() != V) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;图中存在环，无法进行拓扑排序&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語勉強</title>
    <link href="/2024/09/10/JPN/"/>
    <url>/2024/09/10/JPN/</url>
    
    <content type="html"><![CDATA[<h3 id="1-〜あっての"><a href="#1-〜あっての" class="headerlink" title="1.〜あっての"></a>1.〜あっての</h3><div class="note note-success">            <p>説明：あるものが存在するのは他のもののおかげであることを強調する表現です。名詞 + あっての + 名詞</p>          </div><p>健康あっての人生なんだから、体調管理には十分気をつけなさい。</p><p>家族の支えがあったからこそ成功できた。</p><h3 id="2-以外の何ものでもない。"><a href="#2-以外の何ものでもない。" class="headerlink" title="2.~以外の何ものでもない。"></a>2.~以外の何ものでもない。</h3><div class="note note-success">            <p>「Aが唯一の理由・原因である」という意味になります。</p>          </div><p>この結果は偶然以外の何ものでもない。</p><h3 id="3-〜いかんで-いかんでは"><a href="#3-〜いかんで-いかんでは" class="headerlink" title="3.〜いかんで&#x2F;いかんでは"></a>3.〜いかんで&#x2F;いかんでは</h3><div class="note note-success">            <p>どちらも「〜によって」「〜次第で」という意味を持ち、前の事柄によって後の結果が変わることを示す表現です。ただし、微妙なニュアンスの違いがあります。</p>          </div><p>天候いかんでは、収穫は全てできないこともある。</p><h3 id="4-～いかんに関わらず・いかんによらず・いかんをとわず"><a href="#4-～いかんに関わらず・いかんによらず・いかんをとわず" class="headerlink" title="4.～いかんに関わらず・いかんによらず・いかんをとわず"></a>4.～いかんに関わらず・いかんによらず・いかんをとわず</h3><div class="note note-success">            <p>「〜に関係なく」や「〜にかかわらず」と同じ意味で使われます。つまり、ある条件や状況に影響されずに、という意味です。</p>          </div><p>成績いかんに関わらず、全員が参加できます。</p><h3 id="5-いざ〜となると・いざ〜となれば・いざ〜となったら"><a href="#5-いざ〜となると・いざ〜となれば・いざ〜となったら" class="headerlink" title="5.いざ〜となると・いざ〜となれば・いざ〜となったら"></a>5.いざ〜となると・いざ〜となれば・いざ〜となったら</h3><div class="note note-success">            <p>いずれも「実際にその状況になったら」という意味で使われます。これらの表現は、ある状況が現実になったときにどうなるか、ということを強調するために使われます。</p>          </div><p>いざ出発となれば、準備が整っていないことに気づく。</p><h3 id="6-〜言わずもがな"><a href="#6-〜言わずもがな" class="headerlink" title="6.〜言わずもがな"></a>6.〜言わずもがな</h3><div class="note note-success">            <p>「〜言わずもがな」という表現は、「言うまでもなく」や「言わなくてもわかる」という意味で使われます。つまり、あることが非常に明白であるため、わざわざ言う必要がないということを強調する表現です。</p>          </div><p>彼の才能は言わずもがな、誰もが認めるところだ。</p><h3 id="7-限りだ"><a href="#7-限りだ" class="headerlink" title="7. ~限りだ"></a>7. ~限りだ</h3><div class="note note-success">            <p>「〜限りだ」という表現は、感情や感覚を強調するために使われます。特に、感動や驚き、悲しみなどの強い感情を表現する際に用いられます。</p>          </div><p>嬉しい限りだ。</p><h3 id="8-かたがた"><a href="#8-かたがた" class="headerlink" title="8.~かたがた"></a>8.~かたがた</h3><div class="note note-success">            <p>「〜しながら」「〜と同時に」という意味：<br>ある行動をしながら、同時に別の目的も果たすことを表します。<br>例：</p>          </div><p>散歩かたがた買い物に行く。<br>(散歩をしながら買い物もする)</p><div class="note note-success">            <p>「〜のついでに」「〜を機会に」という意味：<br>ある行動や状況を利用して、ついでに別のことも行うことを表します。</p>          </div><p>東京出張かたがた友人に会ってきた。<br>(東京への出張を機会に友人にも会った)</p><h3 id="9-かたわら"><a href="#9-かたわら" class="headerlink" title="9. ~かたわら"></a>9. ~かたわら</h3><div class="note note-success">            <p>主な活動や仕事をしながら、同時に別の活動も行うことを表します。</p>          </div><p>教師のかたわら、小説を執筆している。</p><h3 id="10-がてら"><a href="#10-がてら" class="headerlink" title="10.~がてら"></a>10.~がてら</h3><div class="note note-success">            <p>「〜のついでに」「〜と同時に」<br>ある行動をする際に、ついでに別の行動も同時に行うことを表します。主な目的とは別の、副次的な行動を示すのに使われます。</p>          </div><p>散歩がてら、近所の様子を見て回りました。</p><h3 id="11-からある・からする・からの"><a href="#11-からある・からする・からの" class="headerlink" title="11.~からある・からする・からの"></a>11.~からある・からする・からの</h3><div class="note note-success">            <p>强调大，多，重，长等。<br>「からある」前面表示数量，长度，大小，高矮等数量名词；[からする]前面多用表示金额的量词；[からの]前面多表示人物的数量词。</p>          </div><p>１００キロからある荷物を三階まで運ぶには、足腰の強い人が三人は必要だ。</p><p>彼女は４０億からする遺産を相続したそうだ。</p><p>今日のスピーチ大会は５００人からの人が集まった。</p><h3 id="12-始末だ"><a href="#12-始末だ" class="headerlink" title="12.~始末だ"></a>12.~始末だ</h3><div class="note note-success">            <p>「ひどい状態だ」「困った事態だ」「始末に負えない」といった否定的な状況を表現します。<br>話者の失望、困惑、あるいは軽蔑の気持ちを含むことが多いです。</p>          </div><p>彼は借金を重ね、今では家も売らなければならない始末だ。</p><h3 id="13-～ずくめ"><a href="#13-～ずくめ" class="headerlink" title="13.～ずくめ"></a>13.～ずくめ</h3><div class="note note-success">            <p>「～ずくめ」は日本語の文法表現で、「全て～ばかりである」という意味を表します。この表現は、ある特定の性質や状態が全体的に存在することを強調するために使われます。</p>          </div><p>この本は難しい言葉ずくめで、読むのが大変だ。</p><p>彼女の服装は黒ずくめだった。</p><h3 id="14-〜ずじまいだ"><a href="#14-〜ずじまいだ" class="headerlink" title="14.〜ずじまいだ"></a>14.〜ずじまいだ</h3><div class="note note-success">            <p>「〜ずじまいだ」は「〜ずじまい」という表現の丁寧な形です。この表現は、ある行動や状態が最後まで続いて終わることを意味します。主に否定的なニュアンスで使われることが多いです。</p>          </div><p>忙しいくて、結局休暇を取る図じまいだった。</p><p>締め切りに追われて、計画を見直すずじまいだった。</p><h3 id="15-ずにはおかない"><a href="#15-ずにはおかない" class="headerlink" title="15.~ずにはおかない"></a>15.~ずにはおかない</h3><div class="note note-success">            <p>「必ず〜する」「〜せずにはいられない」という強い意志や必然性を表します。</p>          </div><p>この素晴らしい景色を見たら、誰も感動せずにはおかない。</p><p>彼女の熱意は、周りの人々に影響を与えずにはおかないだろう。</p><h3 id="16-術がない"><a href="#16-術がない" class="headerlink" title="16.~術がない"></a>16.~術がない</h3><div class="note note-success">            <p>意味:<br>「〜する方法がない」「〜する手段がない」「〜するすべがない」</p>          </div><p>締め切りに間に合わせる術がなく、締めるしかなっかた。</p><p>彼女を説得する術がないので、このまま計画を進めるしかない。</p><h3 id="17-そびれる"><a href="#17-そびれる" class="headerlink" title="17.~そびれる"></a>17.~そびれる</h3><div class="note note-success">            <p>意味:<br>「〜するチャンスを逃す」「〜し損ねる」「うっかり〜し忘れる」</p>          </div><p>興味深い展覧会があったのに、行きそびれてしまった。</p><p>大切な約束を確認しそびれて、すっかり忘れてしまった。</p><h3 id="18-たところで"><a href="#18-たところで" class="headerlink" title="18.~たところで"></a>18.~たところで</h3><div class="note note-success">            <p>意味:「〜たところで」は「〜しても、結局」や「〜したとしても、それでも」という意味を表します。</p>          </div><p>急いだところで、もう間に合わないだろう。</p><p>お金をたくさん持っているところで、幸せになれるとは限らない。</p><h3 id="19-てしかるべきだ"><a href="#19-てしかるべきだ" class="headerlink" title="19.~てしかるべきだ"></a>19.~てしかるべきだ</h3><div class="note note-success">            <p>意味：「〜するのが当然だ」「〜するのが適切だ」という意味を表します。話者の強い意見や判断を示す表現です。</p>          </div><p>法律を守ってしかるべきだ。</p><p>その問題については、専門家に相談してしかるべきだ。</p><h3 id="20-て憚らない"><a href="#20-て憚らない" class="headerlink" title="20.~て憚らない"></a>20.~て憚らない</h3><div class="note note-success">            <p>意味：遠慮せずに～する」「ためらわずに～する」「大胆に～する」</p>          </div><p>意見を述べて憚らない。</p><p>新しいアイデアを提案して憚らない。</p><h3 id="21-てはかなわない"><a href="#21-てはかなわない" class="headerlink" title="21.~てはかなわない"></a>21.~てはかなわない</h3><div class="note note-success">            <p>「〜するのは困る」や「〜するのは耐えられない」という意味を表す表現です。「かなわない」は「対抗できない」「負ける」「耐えられない」といったニュアンスを持ちます。</p>          </div><p>この騒音では寝てはかなわない。</p><p>彼女は泣かれてはかなわない。</p><h3 id="22-ても差し支えない"><a href="#22-ても差し支えない" class="headerlink" title="22.~ても差し支えない"></a>22.~ても差し支えない</h3><div class="note note-success">            <p>「問題ない」や「大丈夫」といった意味を表します。</p>          </div><p>書類は明日提出しても差し支えありません。</p><p>会議中に退席しても差し支えないでしょうか。</p><h3 id="23-てもともとだ"><a href="#23-てもともとだ" class="headerlink" title="23.~てもともとだ"></a>23.~てもともとだ</h3><div class="note note-success">            <p>「~てもともとだ」は、ある状況や条件が変わっても、結果は変わらないことを強調するときに使われます。つまり、何かが起こったとしても、本質的には何も変わらないという意味合いを持ちます。</p>          </div><p>彼が来なくてもともとだ。</p><p>だめでもともとだから、思い切って彼女に告白してみた。</p><h3 id="24-ても始まらない"><a href="#24-ても始まらない" class="headerlink" title="24.~ても始まらない"></a>24.~ても始まらない</h3><div class="note note-success">            <p>「たとえ〜をしても、何も良い結果は生まれない」「〜をしても意味がない」</p>          </div><p>今から後悔しても始まらない。</p><p>言い訳をしても始まらないよ。</p><h3 id="25-～てやまない"><a href="#25-～てやまない" class="headerlink" title="25.～てやまない"></a>25.～てやまない</h3><div class="note note-success">            <p>ある行動や状態が継続的に行われていることを強調する表現です。</p>          </div><p>結婚する二人の今後の幸せを願ってやまない。</p><p>真実を追求してやまない。</p><h3 id="26-か-と思いきや"><a href="#26-か-と思いきや" class="headerlink" title="26.~(か)と思いきや"></a>26.~(か)と思いきや</h3><div class="note note-success">            <p>「予想や期待とは異なり、意外な結果になって」</p>          </div><p>晴れると思いきや、突然雨が降り出した。</p><p>彼女は怒ると思いきや、意外にも笑顔で許してくれた。</p><h3 id="27-〜ともなく"><a href="#27-〜ともなく" class="headerlink" title="27.〜ともなく"></a>27.〜ともなく</h3><div class="note note-success">            <p>「〜ともなく」という表現は、意識せずに行動をしている様子や、特定の対象や理由がないことを表す日本語の文法表現です。</p>          </div><p>聞くともなく隣の会話が耳に入った。</p><p>電車の窓から外を見るともなく、高校時代の同級生の姿が目に入った。</p><h3 id="28-〜ならいざしらず"><a href="#28-〜ならいざしらず" class="headerlink" title="28.〜ならいざしらず"></a>28.〜ならいざしらず</h3><div class="note note-success">            <p>「〜なら問題ないが、そうでないなら問題だ」「〜なら仕方がないが、そうでないなら受け入れられない」といった意味で使います。</p>          </div><p>小学生ならいざしらず、大学生はこの漢字を知らないのは問題だ。</p><p>新入社員ならいざしらず、入社8年にもなる君がこんなミスをするとは信じられない。</p><h3 id="29-にはあたらない"><a href="#29-にはあたらない" class="headerlink" title="29.~にはあたらない"></a>29.~にはあたらない</h3><div class="note note-success">            <p>意味: 「〜する必要はない」「〜するほどのことではない」といった意味で使われ、感情的な反応や評価を避けるときに用います。</p>          </div><p>彼なりにできるだけの努力をしたのだから、いい結果を出せなかったとしても、非難するには当たらない。</p><p>優秀な田中君のことだから、論文を１週間で仕上げたと聞いても驚くにはあたらない。</p><h3 id="30-におかれましては"><a href="#30-におかれましては" class="headerlink" title="30.~におかれましては"></a>30.~におかれましては</h3><div class="note note-success">            <p>意味: 「〜に関しては」「〜については」の丁寧な形で、相手を非常に敬った形で、その人の状況や状態を指す。</p>          </div><p>社長におかれましては、お元気でご活躍のことと存じます。</p><p>最近のご状況におかれましては、いかがでしょうか。お忙しいことと存じますが、くれぐれもご自愛ください。</p><h3 id="31-にかこつけて"><a href="#31-にかこつけて" class="headerlink" title="31.~にかこつけて"></a>31.~にかこつけて</h3><div class="note note-success">            <p>意味: 「〜を口実にして」「〜を理由にして」といった意味で、表向きの理由を使って、実際は別の意図や目的があることを示します。</p>          </div><p>彼は仕事にかこつけて、頻繁に出張し、観光地を回っている。</p><p>天気にかこつけて、今日の会議は延期されたが、実は準備が間に合わなかったらしい。</p><h3 id="32-にかまけて"><a href="#32-にかまけて" class="headerlink" title="32.~にかまけて"></a>32.~にかまけて</h3><div class="note note-success">            <p>「〜に気を取られて他のことができない」「〜に夢中になって他のことを疎かにする」といった意味で、何かに集中しすぎて、他のことをやる余裕がなくなる状況を表します。</p>          </div><p>彼は仕事にかまけて、家族との時間を全然取っていない。</p><p>スマホにかまけて、勉強が疎かになっている。</p><h3 id="33-にかたくない"><a href="#33-にかたくない" class="headerlink" title="33.~にかたくない"></a>33.~にかたくない</h3><div class="note note-success">            <p>意味: 「〜するのは難しくない」「〜を簡単に理解できる」「〜を容易に想像できる」といった意味を表します。</p>          </div><p>長年に努力してきたことが報われた時の彼の喜びは、想像に難くない。</p><p>異国の地で生活する彼女の苦労は、理解にかたくない。</p><h3 id="34-にしくはない"><a href="#34-にしくはない" class="headerlink" title="34.~にしくはない"></a>34.~にしくはない</h3><div class="note note-success">            <p>意味としては、「〜が一番よい」、「〜が最善である」、「〜するに越したことはない」という考えを表現するものです。</p>          </div><p>安全な道を選ぶにしくはない。</p><p>事前に準備しておくにしくはない。</p><h3 id="35-に忍びない"><a href="#35-に忍びない" class="headerlink" title="35.~に忍びない"></a>35.~に忍びない</h3><div class="note note-success">            <p>「〜に忍びない」という表現は、感情的に耐えられず、ある行為をするのがつらい、または心苦しいと感じるときに使います。</p>          </div><p>彼の写真を捨てるに忍びない。</p><p>その小説の最後の場面はあまりに悲しくて、読むに忍びない。</p><h3 id="36-にたえる"><a href="#36-にたえる" class="headerlink" title="36.~にたえる"></a>36.~にたえる</h3><div class="note note-success">            <p>「〜にたえる（〜に堪える）」は、「〜する価値がある」「〜に耐えられる」という意味を持つ日本語の表現です。主に二つの使い方があります。</p>          </div><p>この映画は見るにたえる作品だ。</p><p>この痛みは堪えるに堪えない。</p><h3 id="37-にとどまらず"><a href="#37-にとどまらず" class="headerlink" title="37.~にとどまらず"></a>37.~にとどまらず</h3><div class="note note-success">            <p>「〜にとどまらず」という表現は、何かが特定の範囲や状況に「とどまる（留まる）」ことなく、さらに広がっている、または影響を及ぼしていることを示す表現です。つまり、「〜だけではなく、さらに」という意味を持ちます。</p>          </div><p>彼の影響は国内にとどまらず、海外にも広がっている。</p><p>この技術は企業内にとどまらず、一般家庭にも普及している。</p><h3 id="38-にひきかえ"><a href="#38-にひきかえ" class="headerlink" title="38.~にひきかえ"></a>38.~にひきかえ</h3><div class="note note-success">            <p>意味：「〜に対して」、「〜と比べて」</p>          </div><p>彼の努力しているにひきかえ、結果が出ていない。</p><p>新製品の売上が好調なにひきかえ、旧製品は苦戦している。</p><h3 id="39-にも増して"><a href="#39-にも増して" class="headerlink" title="39.~にも増して"></a>39.~にも増して</h3><div class="note note-success">            <p>「〜にも増して」は、「〜以上に」と同じ意味で、ある状況や程度がより強く、またはより重要であることを表します。</p>          </div><p>今年の夏は、去年にも増して暑い。</p><p>いつにも増して彼は元気そうだ。</p><h3 id="40-の至りだ"><a href="#40-の至りだ" class="headerlink" title="40.~の至りだ"></a>40.~の至りだ</h3><div class="note note-success">            <p>「非常に〜だ」「極めて〜だ」</p>          </div><p>このような賞をいただき、光栄の至りです。</p><p>皆様の温かいご支援に対し、感激の至りです。</p><h3 id="41-にさておいて・はさておき"><a href="#41-にさておいて・はさておき" class="headerlink" title="41.~にさておいて・はさておき"></a>41.~にさておいて・はさておき</h3><div class="note note-success">            <p>「〜はさておいて」は、何かを一旦脇に置いて、別のことに話題や焦点を移す際に使われる表現です。話の流れの中で、前に述べた内容や問題を一時的に保留して、別の重要なことについて言及したい場合に使います。</p>          </div><p>実現できるかとうかはさておき、まずは新商品のアイディアをみんなで出してみよう。</p><p>社員旅行の件ですが、費用のことはさておいて、まず日程について検討してみましょう。</p><h3 id="42-はそっちのけで・をそっちのけで"><a href="#42-はそっちのけで・をそっちのけで" class="headerlink" title="42.~はそっちのけで・をそっちのけで"></a>42.~はそっちのけで・をそっちのけで</h3><div class="note note-success">            <p>「そっちのけ」とは「そのことを無視する」「放っておく」という意味で、主に否定的なニュアンスで使われます。</p>          </div><p>宿題はそっちのけで、ゲームばかりしている。</p><p>大学4年生の弟は就職のことはそっちのけで、毎日パソコンゲームに没頭している。</p><h3 id="43-羽目になる・羽目に陥る"><a href="#43-羽目になる・羽目に陥る" class="headerlink" title="43.~羽目になる・羽目に陥る"></a>43.~羽目になる・羽目に陥る</h3><div class="note note-success">            <p>「〜羽目になる」や「〜羽目に陥る」は、意図しない結果や不幸な状況に陥ることを表す表現です。</p>          </div><p>遅刻してしまい、会議に出られない羽目になった。</p><p>お金を借りたことが原因で、返済のプレッシャーに陥る羽目になった。</p><h3 id="44-べからず"><a href="#44-べからず" class="headerlink" title="44.~べからず"></a>44.~べからず</h3><div class="note note-success">            <p>意味としては「〜してはならない」「〜すべきではない」という禁止や戒めを表します。形式は動詞の辞書形に「べからず」を付けて作られます。</p>          </div><p>企業から多額のお金を受け取るなんて、政治家としてゆるすべからざる行為だ。</p><p>彼はうちの会社にとって欠くべからざる人材だ。</p><h3 id="45-まじき"><a href="#45-まじき" class="headerlink" title="45.~まじき"></a>45.~まじき</h3><div class="note note-success">            <p>主に道徳的・社会的に「〜してはならない」「〜ふさわしくない」という意味を表します。具体的には、「あるべきではない」「許されない行為や態度」を強調する際に使われます。</p>          </div><p>彼の言動は社会人としてあるまじきもので、とうてい許すことはできない。</p><p>彼のやったことは、人としてあるまじき残酷な行為だ。</p><h3 id="46-めく・めいて・めいた"><a href="#46-めく・めいて・めいた" class="headerlink" title="46.~めく・めいて・めいた"></a>46.~めく・めいて・めいた</h3><div class="note note-success">            <p>「〜めく」「〜めいて」「〜めいた」は、物事や人の様子、性質を表現する際に使われる言葉です。</p>          </div><p>そんな皮肉めいた言い方をしないでください。</p><p>雪が溶けて、野の花が咲き始め、日差しも春めいてきた。</p><h3 id="47-もさることながら"><a href="#47-もさることながら" class="headerlink" title="47.~もさることながら"></a>47.~もさることながら</h3><div class="note note-success">            <p>「〜もさることながら」は、ある事柄を強調しつつ、その上で別の事柄も重要であることを示す表現です。通常、前半に言及したことが重要であると認めつつ、後半でそれに劣らず重要なことを追加します。</p>          </div><p>彼の実力もさることながら、努力も評価されるべきだ。</p><p>両親は、息子に病院の跡を継いで医者になって欲しいと思っているようだ。だが、親の希望もさることながら、やはり本人の気持ちが第一だろう。</p><h3 id="48-を皮切りに"><a href="#48-を皮切りに" class="headerlink" title="48.~を皮切りに"></a>48.~を皮切りに</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>このプロジェクトは、会議を皮切りに始まりました。</p><p>旅行を皮切りに、さまざまな国を訪れました。</p><h3 id="49-を蔑ろにする"><a href="#49-を蔑ろにする" class="headerlink" title="49.~を蔑ろにする"></a>49.~を蔑ろにする</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>彼はチームの意見を蔑ろにして、自分の考えだけを押し通した。</p><p>友人の気持ちを蔑ろにするような行動は避けるべきだ。</p><h3 id="50-をなおざりにして"><a href="#50-をなおざりにして" class="headerlink" title="50.~をなおざりにして"></a>50.~をなおざりにして</h3><div class="note note-success">            <p>何かをいい加減に扱ったり、手を抜いたりすることを意味する表現です。このフレーズは、重要な事柄を怠ったり、十分に注意を払わないことを示します。</p>          </div><p>どんなことがあっても、仕事をなおざりにしてはいけない。</p><p>彼は仕事をなおざりにして、結果的にトラブルを引き起こした。</p><h3 id="51-を控え"><a href="#51-を控え" class="headerlink" title="51.~を控え"></a>51.~を控え</h3><div class="note note-success">            <p>「~を控えて」は、特定の行動や状況を踏まえて、それに関連する行動や注意を促す際に使われる表現です。</p>          </div><p>試験を控えて、しっかり勉強する必要があります。</p><p>引越しを控えて、整理整頓を始めました。</p><h3 id="52-を振り出しに"><a href="#52-を振り出しに" class="headerlink" title="52.~を振り出しに"></a>52.~を振り出しに</h3><div class="note note-success">            <p>ある出来事や行動をきっかけとして、その後の展開や進展が始まることを示す表現です。</p>          </div><p>彼女は転職を振り出しに、キャリアは一新しました。</p><p>彼は小学校の教師を振り出しに社会に出た。</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学公式用法整理</title>
    <link href="/2024/09/08/Math-formula/"/>
    <url>/2024/09/08/Math-formula/</url>
    
    <content type="html"><![CDATA[<h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><blockquote><p>升级后的插件需要双反斜杠“\\\\”，网页才能正确渲染下来</p></blockquote><p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x\leq 0 \\<br>x, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p><h1 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h1><blockquote><p>array和aligned都不适配当前需求，直接用cases环境</p></blockquote><p>$$<br>\begin{cases}<br>    a_1x + b_1y + c_1z &#x3D; d_1 \\<br>    a_2x + b_2y + c_2z &#x3D; d_2 \\<br>    a_3x + b_3y + c_3z &#x3D; d_3<br>\end{cases}<br>$$</p><h1 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h1><p>$$<br>J(\theta) &#x3D; \frac{1}{2m}\sum_{i &#x3D; 0} ^m(y^i - h_\theta (x^i))^2<br>$$</p><h1 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h1><p>$$<br>\frac{\partial J(\theta)}{\partial\theta_j}&#x3D;-\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>$$</p><h1 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h1><p>$$<br>\begin{aligned}<br>\frac{\partial J(\theta)}{\partial\theta_j}<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j&#x3D;0}^n\theta_jx_j^i-y^i) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>\end{aligned}<br>$$</p><h1 id="case环境的使用"><a href="#case环境的使用" class="headerlink" title="case环境的使用"></a>case环境的使用</h1><p>$$<br>a &#x3D;<br>   \begin{cases}<br>     \int x, \mathrm{d} x\\<br>     b^2<br>   \end{cases}<br>$$</p><h1 id="带方框的等式"><a href="#带方框的等式" class="headerlink" title="带方框的等式"></a>带方框的等式</h1><p>$$<br>\begin{aligned}<br> \boxed{x^2+y^2 &#x3D; z^2}<br>\end{aligned}<br>$$</p><h1 id="最大（最小）操作符"><a href="#最大（最小）操作符" class="headerlink" title="最大（最小）操作符"></a>最大（最小）操作符</h1><p>$$<br>\begin{gathered}<br>\operatorname{arg,max}_a f(a)<br> &#x3D; \operatorname*{arg,max}_b f(b) \\<br> \operatorname{arg,min}_c f(c)<br> &#x3D; \operatorname*{arg,min}_d f(d)<br>\end{gathered}<br>$$</p><h1 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h1><p>$$<br>\begin{aligned}<br>  \lim_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \lim\nolimits_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$</p><h1 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h1><p>$$<br>\begin{aligned}<br>   \int_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \int\limits_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$</p><h1 id="多行表达公式"><a href="#多行表达公式" class="headerlink" title="多行表达公式"></a>多行表达公式</h1><p>$$<br>\begin{aligned}<br>J(\mathbf{w})&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m(f(\mathbf{x_i})-y_i)^2\\<br>&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m [f(\mathbf{x_i})]^2-2f(\mathbf{x_i)}y_i+y_i^2<br>\end{aligned}<br>$$</p><h1 id="小括号矩阵"><a href="#小括号矩阵" class="headerlink" title="小括号矩阵"></a>小括号矩阵</h1><p>$$\left(<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right)<br>\tag{2}<br>$$</p><h1 id="中括号矩阵"><a href="#中括号矩阵" class="headerlink" title="中括号矩阵"></a>中括号矩阵</h1><p>$$\left[<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right]<br>\tag{3}<br>$$</p><h1 id="带省略号的矩阵"><a href="#带省略号的矩阵" class="headerlink" title="带省略号的矩阵"></a>带省略号的矩阵</h1><p>$$<br>\left[<br>\begin{matrix}<br>a &amp; b &amp; \cdots &amp; a\\<br>b &amp; b &amp; \cdots &amp; b\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>c &amp; c &amp; \cdots &amp; c<br>\end{matrix}<br>\right]<br>\tag{5}<br>$$</p><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p>$\sin^2\alpha+\cos^2\alpha&#x3D;1$</p><p>$\cfrac{\sin\alpha}{\cos\alpha}&#x3D;\tan\alpha$</p><p>$\sin(2k\pi+\alpha)&#x3D;\sin\alpha(k\in Z)$</p><p>$\cos(2k\pi+\alpha)&#x3D;\cos\alpha(k\in Z)$</p><p>$\tan(2k\pi+\alpha)&#x3D;\tan\alpha(k\in Z)$</p><p>$\cot(2k\pi+\alpha)&#x3D;\cot\alpha(k\in Z)$</p><p>$\sin(\pi+\alpha)&#x3D;-\sin\alpha$</p><p>$\cos(\pi+\alpha)&#x3D;-\cos\alpha$</p><p>$\tan(\pi+\alpha)&#x3D;\tan\alpha$</p><p>$\cot(\pi+\alpha)&#x3D;\cot\alpha$</p><p>$\sin(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\sin\alpha(n为偶数)\\<br>(-1)^{\cfrac{n-1}{2}}\cos\alpha(n为奇数)\end{cases}$</p><p>$\cos(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\cos\alpha(n为偶数)\\(-1)^{\cfrac{n+1}{2}}\sin\alpha(n为奇数)\end{cases}$</p><p>$$<br>\left[<br>    \begin{array}{c|cc}<br>    1 &amp; 2 &amp; 3 \\ \hline<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>    \end{array}<br>\right]<br>\tag{7}<br>$$</p><p>$$x&#x3D;a_0 + \frac{1^2}{a_ 1+\frac{2^2}{a_2+\frac{3^2}{a_3+ \frac{4^2}{a_4+…}}}}$$</p><p>$a \equiv b \pmod n$</p><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>$$<br>e^{i\pi} + 1 &#x3D; 0<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/07/hello-world/"/>
    <url>/2024/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
