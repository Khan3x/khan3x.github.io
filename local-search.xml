<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Operating System</title>
    <link href="/2024/12/11/Operation-System/"/>
    <url>/2024/12/11/Operation-System/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><p>This is for test takers to quickly review Operation System. Credit to 《Operating System, 9th Edition》。操作系统的知识看起来非常得杂乱无章，需要重点关注任务调度算法，内存管理分配算法，以及地址变换机制。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-Introduction-to-Operating-System"><a href="#1-Introduction-to-Operating-System" class="headerlink" title="1. Introduction to Operating System"></a>1. Introduction to Operating System</h2><p>计算机系统可以划分为<strong>4个</strong>主要组件：</p><ol><li><p>硬件(hardware)：指的是物理设备，包括计算机的处理器、内存、硬盘、输入输出设备等。硬件如中央处理单元(CPU)、内存(memory)、输入输出设备(I&#x2F;O device)为系统提供基本的计算资源。</p></li><li><p>操作系统(Operating System)：软件层次上管理硬件资源并提供基本服务的平台，例如 Windows、Linux 等。</p></li><li><p>应用程序(application)：运行在操作系统之上的软件，提供具体的功能和服务，如浏览器、文字处理软件等。</p></li><li><p>用户(user)：使用计算机系统进行操作和执行任务的人员。</p></li></ol><hr><p><strong>单处理器系统（Single-Processor System）</strong> 是指只有一个中央处理单元（CPU）的计算机系统。其特点如下：  </p><ol><li><strong>核心数量</strong>：只有一个处理器核心，用于执行所有的指令和任务。  </li><li><strong>任务调度</strong>：通过时间分片等方法实现多任务操作，但实际上每个时刻只能执行一个任务。  </li><li><strong>适用场景</strong>：适合资源需求较低的应用场景，如传统的个人计算机和嵌入式系统。  </li><li><strong>优点</strong>：结构简单，成本较低，软件开发难度小。  </li><li><strong>缺点</strong>：处理能力有限，无法充分利用多核架构的优势。</li></ol><p><strong>多处理系统（multiprocessing system）(也称为并行系统（parallel system）)</strong> 是指拥有多个处理器（或多个核心）的计算机系统，允许多个任务同时运行。其特点如下：  </p><ol><li><strong>核心数量</strong>：包含两个或更多处理器（或多核），每个核心可以独立执行任务。  </li><li><strong>任务并行</strong>：支持真正的并行计算，显著提高计算速度和效率。  </li><li><strong>架构类型</strong>：分为<strong>对称多处理（Symmetric MultiProcessing, SMP）</strong>和<strong>非对称多处理（Asymmetric MultiProcessing, AMP）</strong>：  <ul><li>SMP：所有处理器平等共享内存和任务。  </li><li>AMP：不同处理器有专门的任务分工。</li></ul></li><li><strong>适用场景</strong>：高性能计算、服务器、多任务处理（如图像处理、机器学习等）。</li></ol><p><strong>多处理器系统的主要优点有：</strong></p><ol><li><p><strong>增加吞吐量</strong>  </p><ul><li>多处理器系统通过并行处理任务显著提高了整体计算吞吐量。  </li><li>多个处理器可以同时执行不同的任务，减少任务队列的等待时间，提高系统的运行效率。  </li><li>特别适用于计算密集型任务，如科学计算、数据处理和复杂的仿真。</li><li>采用N个处理器的加速比不是N，而是小于N（考虑资源共享竞争）</li></ul></li><li><p><strong>规模经济</strong>  </p><ul><li>多处理器系统通过共享内存、I&#x2F;O设备等资源，降低了每个处理器独立配备资源的成本。  </li><li>随着处理器数量增加，系统性能可以线性甚至超线性提升，使整体成本效益更高。  </li><li>常见于需要扩展性强的大型系统，如云计算和服务器集群。</li></ul></li><li><p><strong>增加可靠性</strong>  </p><ul><li>多处理器系统具备更高的容错能力，当一个处理器发生故障时，其他处理器可以接管任务，保证系统的连续运行。  </li><li>提供了冗余机制，使关键任务系统（如航空、医疗设备）在出现硬件问题时仍能保持稳定。比如10个处理器中的1个出了故障，剩下的9个会分担器故障处理器的那部分工作。</li><li>通过任务分配策略，还可有效防止单点故障的影响。</li></ul></li></ol><hr><p><strong>操作系统</strong>（Operating System，OS）是计算机系统中最基础且最重要的<strong>软件</strong>，它负责管理硬件资源并为用户和应用程序提供接口。其主要功能和定义如下：</p><ol><li><p><strong>资源管理者</strong>  : 操作系统负责管理和分配计算机的硬件资源，包括CPU、内存、存储设备和外部设备，以确保各类任务高效运行。</p></li><li><p><strong>用户与硬件之间的桥梁</strong>  : 操作系统提供用户与硬件交互的接口，使用户可以通过简单的命令或图形界面与计算机进行操作，而无需直接了解硬件的底层细节。</p></li><li><p><strong>程序执行的控制中心</strong>  : 操作系统负责调度和协调应用程序的运行，提供多任务处理和资源分配功能，保证系统的稳定性和性能。</p></li><li><p><strong>服务提供者</strong>  : 它为应用程序提供基本的服务，如文件管理、内存管理、进程调度和网络通信，简化了软件开发。</p></li></ol><p>操作系统是计算机系统的核心，它连接硬件和用户，为软件运行提供支持，同时确保系统的高效性和可靠性。</p><hr><p><strong>中断机制</strong>是操作系统中一个关键的功能，用于处理异步事件和高效管理硬件资源。它使得计算机可以响应各种外部或内部事件，如硬件故障、输入输出操作的完成、定时器到期等。下面详细介绍中断机制的各个方面：</p><p>1.<strong>中断的基本概念：</strong> 中断（Interrupt）是指计算机在执行程序的过程中，由于某些突发事件（如硬件设备请求、异常情况等），使得CPU暂时中止当前正在执行的程序，转而去处理这些事件的过程。当中断事件处理完毕后，CPU再回到中断前的程序继续执行。</p><p>2.<strong>中断的分类：</strong></p><ol><li><strong>硬件中断（Hardware Interrupt）</strong>：由外部硬件设备触发，如键盘按键、鼠标点击、网络数据包到达等。</li><li><strong>软件中断（Software Interrupt）</strong>：由软件触发的中断，如系统调用、程序异常等。</li><li><strong>定时器中断（Timer Interrupt）</strong>：由系统定时器触发，用于时间片轮转调度等操作。</li></ol><p>3.<strong>中断处理过程：</strong> 中断处理过程一般包括以下几个步骤：</p><ol><li><strong>中断请求</strong>：外部设备或软件发出中断请求信号。</li><li><strong>中断响应</strong>：CPU检查中断信号，并保存当前执行的上下文（如程序计数器、寄存器等）。</li><li><strong>中断向量</strong>：根据中断类型，CPU查找中断向量表以获取相应的中断服务程序（Interrupt Service Routine，ISR）的入口地址。</li><li><strong>执行中断服务程序</strong>：CPU跳转到ISR，执行相应的中断处理逻辑。</li><li><strong>恢复上下文</strong>：中断处理完成后，CPU恢复先前保存的上下文，继续执行被中断的程序。</li></ol><p>4.<strong>中断优先级：</strong><br>在多种中断同时发生时，需要确定哪个中断优先处理。中断优先级机制用于决定中断处理的顺序。一般来说，硬件中断优先级较高，而软件中断优先级较低。中断控制器（Interrupt Controller）用于管理中断优先级。</p><p>5.<strong>中断屏蔽：</strong> 中断屏蔽是指在某些关键操作期间，暂时禁止某些中断的发生，以防止中断打断正在进行的重要操作。通常使用中断屏蔽寄存器来实现。屏蔽中断可以避免在执行关键代码段时被中断打断，但也需要注意不能长时间屏蔽，以免丢失重要的中断信号。</p><p>6.<strong>中断的优点:</strong></p><ol><li><strong>响应及时</strong>：中断机制可以在事件发生时立即响应，提高系统的实时性。</li><li><strong>资源高效利用</strong>：通过中断机制，可以在硬件设备准备好时才进行处理，而不需要轮询，节省CPU资源。</li><li><strong>多任务处理</strong>：中断机制支持多任务并发处理，增强系统的灵活性和效率。</li></ol><p>7.<strong>中断的缺点:</strong></p><ol><li><strong>中断延迟</strong>：如果中断处理程序过多或过长，可能会导致系统响应延迟。</li><li><strong>复杂性增加</strong>：中断机制需要维护中断向量表和中断控制器，增加了系统的复杂性。</li><li><strong>上下文切换开销</strong>：每次中断处理都涉及上下文切换，带来一定的性能开销。</li></ol><p>以下是一个简单的中断处理流程示例：假设这是一个简单的汇编代码，演示中断处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ORG 100HMOV AX, 0          ; 初始化AX寄存器INTERRUPT_HANDLER:PUSH AX            ; 保存AX寄存器MOV AX, 1234H      ; 中断处理逻辑POP AX             ; 恢复AX寄存器IRET               ; 返回中断前的程序MAIN:MOV AX, 1INT 0              ; 触发中断MOV AX, 2HLT                ; 停止程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个示例中，当执行到 INT 0 指令时，会触发中断并调用 INTERRUPT_HANDLER 来处理中断。在中断处理程序中，保存了AX寄存器的值，并进行了简单的处理后恢复AX寄存器，然后返回到中断前的程序继续执行。通过中断机制，计算机系统可以高效处理各种异步事件，保证系统的稳定性和响应性。</p><hr><p><strong>轮询（Polling）</strong> 是一种通过主动检查设备或资源状态来判断是否需要处理某个事件的机制。操作系统或程序会周期性地访问设备或资源，以确定是否需要执行相关操作。</p><p><strong>轮询的特点：</strong></p><ol><li><p><strong>主动查询</strong>  : 系统不断循环检查设备或资源的状态，而不是等待设备主动通知。</p></li><li><p><strong>简单易实现</strong>  : 轮询机制实现起来比较简单，通常只需要循环读取设备的状态寄存器即可。</p></li><li><p><strong>低效</strong>  : 如果设备状态没有发生变化，CPU可能会浪费大量时间在无意义的查询上，无法高效利用资源。</p></li></ol><p><strong>轮询的工作流程：</strong></p><ol><li>系统通过读取设备状态寄存器获取设备当前状态。  </li><li>如果发现设备准备好（例如I&#x2F;O操作完成），则进行相应的处理。  </li><li>如果设备未准备好，则继续轮询，直到设备状态发生变化。</li></ol><p><strong>轮询的缺点：</strong></p><ul><li><strong>资源浪费</strong>：占用CPU时间，即使设备未准备好也会不断查询。  </li><li><strong>实时性差</strong>：对于需要快速响应的事件，轮询可能无法及时处理。  </li><li><strong>不适合频繁事件</strong>：当事件发生较多时，轮询会影响系统整体性能。</li></ul><p><strong>轮询的优点：</strong></p><ul><li><strong>简单性</strong>：实现简单，不需要复杂的硬件支持。  </li><li><strong>适用性</strong>：适合事件发生频率较低或硬件复杂度较低的场景。</li></ul><p><strong>轮询对比中断机制：</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>轮询</strong></th><th><strong>中断</strong></th></tr></thead><tbody><tr><td>响应方式</td><td>主动查询设备状态</td><td>被动响应设备的中断信号</td></tr><tr><td>资源利用效率</td><td>较低，可能浪费CPU资源</td><td>高效，只在事件发生时占用资源</td></tr><tr><td>实现复杂度</td><td>简单，不需要硬件支持</td><td>复杂，需要硬件和软件配合</td></tr><tr><td>实时性</td><td>较差</td><td>较强</td></tr></tbody></table><p>轮询虽然简单，但在现代操作系统中已逐渐被更高效的<strong>中断机制</strong>取代。</p><hr><p>在操作系统中，<strong>“异常(exception)”</strong> 指的是一种特殊的事件或情况，它们会导致当前正在执行的程序或系统行为发生中断。这些异常可能来自于硬件或软件，通常需要操作系统进行处理，以确保系统的稳定性和安全性。</p><p><strong>异常的分类：</strong></p><ol><li><strong>硬件异常</strong>：由于硬件故障或特殊硬件条件引起，例如内存访问违规、除零错误等。</li><li><strong>软件异常</strong>：由于软件执行过程中出现的非法操作或异常情况引起，例如非法指令、系统调用错误等。</li></ol><p><strong>异常处理过程：</strong></p><ol><li><strong>检测异常</strong>：当异常发生时，硬件或操作系统检测到异常情况。</li><li><strong>保存状态</strong>：当前处理器状态（例如寄存器值、程序计数器）被保存，以便后续恢复。</li><li><strong>调用异常处理程序</strong>：操作系统根据异常类型，调用相应的异常处理程序（Exception Handler）。</li><li><strong>处理异常</strong>：异常处理程序执行特定的操作，以处理或缓解异常情况。</li><li><strong>恢复状态</strong>：异常处理完成后，恢复处理器状态并继续执行被中断的程序。</li></ol><p><strong>常见的异常类型：</strong></p><ul><li><strong>访问违例</strong>：试图访问未授权的内存区域。</li><li><strong>非法指令</strong>：执行了无效或未定义的指令。</li><li><strong>除零错误</strong>：在计算过程中出现除数为零的情况。</li><li><strong>系统调用</strong>：用户程序请求操作系统提供服务时产生的异常。</li></ul><p><strong>异常处理的优点：</strong></p><ul><li><strong>提高系统稳定性</strong>：通过有效的异常处理机制，操作系统可以检测并处理各种错误，避免系统崩溃。</li><li><strong>增强安全性</strong>：异常处理可以防止非法操作，保护系统和用户数据的安全。</li></ul><p>异常处理是操作系统中的一个关键机制，用于管理和处理各种意外事件和错误情况。通过异常处理，操作系统能够保持系统的稳定性和安全性，确保用户和应用程序的正常运行。</p><hr><p>在操作系统中，<strong>中断（Interrupt）和异常（Exception）</strong> 是两种重要的事件，它们都会导致CPU暂停当前的任务，转而去处理这些事件。再总结一下就是：</p><ul><li>中断（Interrupt）：中断是由<u>硬件设备（如键盘，鼠标，网络接口卡等）发出的信号，</u>通知操作系统有一些重要的事件发生，需要立即处理。例如，当你按下键盘上的一个键时，键盘会向CPU发送一个中断信号，CPU会暂停当前的任务，转而去处理这个按键事件。处理完这个事件后，CPU会返回到被中断的任务，继续执行。</li><li>异常（Exception）：异常是由<u>CPU在执行指令过程中发现的问题，</u>如除以零，访问无效的内存地址等。当发生异常时，CPU会暂停当前的任务，转而去执行一个特殊的异常处理程序。处理完这个异常后，CPU可能会返回到被中断的任务，也可能会终止这个任务，这取决于异常的类型和严重性。</li></ul><p>总体来说，中断和异常都是操作系统用来响应和处理重要事件的机制。它们都会导致CPU暂停当前的任务，但来源和处理方式有所不同。<strong>中断通常由外部硬件或定时器触发，表示系统需要对外部事件进行响应，而异常则由程序内部的特殊或错误行为引发，表示需要操作系统介入进行修复或处理</strong>。发生中断或异常时，操作系统都会介入并展开管理工作；<strong>用户态和内核态的切换是通过中断或异常实现的，而中断是实现这种切换的唯一途径，通过修改程序状态字（PSW）来完成状态转换</strong>。</p><hr><p><strong>内存管理</strong> 是操作系统的一项重要功能，负责管理计算机的主存储器，并为应用程序分配和释放内存。内存管理的主要目标是提高内存的使用效率，保证系统的稳定性和安全性。以下是内存管理的一些关键概念和机制：</p><p><strong>内存管理的主要任务:</strong></p><ol><li><strong>内存分配</strong>：为进程分配所需的内存资源，包括动态分配和静态分配。</li><li><strong>内存保护</strong>：确保进程只能访问自己合法的内存区域，防止进程之间相互干扰。</li><li><strong>内存回收</strong>：回收不再使用的内存，以便分配给其他进程。</li></ol><p><strong>内存管理机制:</strong></p><p><strong>1.分段和分页:</strong></p><ul><li><strong>分页</strong>：内存被划分成大小相同的页，每个进程的地址空间也被划分成相同大小的页。通过页表（Page Table）映射进程页和物理内存页，实现内存的管理。</li><li><strong>分段</strong>：内存被划分成不同大小的段，每个段包含一段逻辑地址空间。通过段表（Segment Table）管理和映射各段地址。</li></ul><p><strong>2.虚拟内存:</strong></p><p>虚拟内存技术允许操作系统将实际物理内存与进程的逻辑内存分离，使得进程可以使用比实际物理内存更大的地址空间。虚拟内存通过页表和交换空间（Swap Space）管理，将不常用的页临时存储在磁盘上，需要时再调入内存。</p><p><strong>3.内存保护:</strong></p><ul><li><strong>基址寄存器和界限寄存器</strong>：通过设置每个进程的基址和界限，确保进程只能访问自己的内存区域，防止越界访问。</li><li><strong>页面保护</strong>：通过页表中的保护位控制每个页的访问权限（读、写、执行），保证进程的内存访问安全。</li></ul><p><strong>4. 内存回收:</strong></p><ul><li><strong>垃圾回收</strong>：通过自动检测和回收不再使用的内存，释放资源供其他进程使用。</li><li><strong>内存压缩</strong>：通过内存整理和压缩，减少内存碎片，提高内存利用率。</li></ul><p><strong>内存管理的重要性:</strong></p><ol><li><strong>提高系统性能</strong>：通过有效的内存分配和回收机制，保证进程的高效运行。</li><li><strong>增强系统稳定性</strong>：通过内存保护机制，防止进程之间的相互干扰，保证系统的稳定运行。</li><li><strong>优化资源利用</strong>：通过虚拟内存和分页技术，最大化内存资源的利用率，使得系统能够同时运行更多的进程。</li></ol><p>内存管理是操作系统的一项核心功能，涉及内存的分配、保护和回收等多个方面。通过有效的内存管理，操作系统能够提高系统性能、增强稳定性，并优化资源利用，为应用程序提供稳定可靠的运行环境。</p><hr><p>操作系统的<strong>进程管理</strong>是指对系统中所有进程的创建、调度、执行、和终止进行管理和协调的过程。它是操作系统的核心功能之一，负责保证多个任务能够高效、公平地共享CPU和其他资源。</p><p><strong>进程管理的主要功能：</strong></p><ol><li><p><strong>进程创建与终止</strong>  </p><ul><li>创建新进程：为程序分配必要的资源（如内存、文件句柄）并初始化进程控制块（PCB）。  </li><li>终止进程：释放进程所占用的资源并清理PCB。</li></ul></li><li><p><strong>进程调度</strong>  </p><ul><li>负责决定哪一个进程可以使用CPU。  </li><li>常用的调度算法包括：  <ul><li>先来先服务（FCFS）  </li><li>最短作业优先（SJF）  </li><li>时间片轮转（RR）  </li><li>多级队列调度等。</li></ul></li></ul></li><li><p><strong>进程同步</strong>  </p><ul><li>保证多个进程在访问共享资源时不会产生冲突。  </li><li>使用机制：信号量（Semaphore）、互斥锁（Mutex）、条件变量等。</li></ul></li><li><p><strong>进程通信</strong>  </p><ul><li>提供进程之间交换数据的手段。  </li><li>常用方式：管道（Pipe）、消息队列（Message Queue）、共享内存（Shared Memory）、信号（Signal）等。</li></ul></li><li><p><strong>进程状态管理</strong>  </p><ul><li>维护进程的状态：  <ul><li>新建（New）  </li><li>就绪（Ready）  </li><li>运行（Running）  </li><li>阻塞（Blocked）  </li><li>终止（Terminated）</li></ul></li><li>根据状态变化完成任务切换。</li></ul></li><li><p><strong>多线程支持</strong>  </p><ul><li>管理线程的创建、调度和同步，支持多线程模型（如用户线程和内核线程）。</li></ul></li></ol><p><strong>进程与线程的区别</strong></p><ul><li><strong>进程(Process)</strong> 是资源分配的最小单位，每个进程有独立的地址空间。进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。  </li><li><strong>线程(Thread)</strong> 是CPU调度的最小单位，线程共享进程的地址空间。线程是进程中的一条执行路径，是进程的一个实体，可作为系统独立调度和分派的基本单位。</li></ul><p>进程：就像一家物业管理公司，它独立运营，有自己的一套管理系统（相当于进程的独立地址空间）。这个公司可以接多个任务，但所有任务最终都需要公司的资源来完成。</p><p>单线程：假设你是这家公司的唯一员工。初期，业务量很小，每个任务都需要你亲自去完成。比如，给老张家修完暖气管道，然后再去老李家换电灯泡。这个过程类似于单线程执行——每次只能处理一个任务，必须按顺序进行。</p><ul><li>示例：修暖气管道 -&gt; 换电灯泡</li></ul><p>多线程：随着业务的发展，你雇佣了多个工人。这时，你的公司可以同时为多户人家提供服务。每个工人就是一个线程，他们可以独立处理自己的任务，但仍然共享公司的资源（如工具、交通工具等）。</p><ul><li>示例：工人A修暖气管道，工人B换电灯泡，工人C修水管</li></ul><p>主线程：你作为公司的老板和主线程，负责分配任务、协调工作，确保所有工人（线程）能顺利开展工作。如果某个工人遇到问题（冲突或需要协同），你可以及时介入解决，保持公司的正常运行。</p><p>通过这个类比，进程就像是一个独立的公司，每个线程就像是公司的员工，他们共享公司的资源，并共同完成任务。多线程能提高效率，但需要有效的管理和协调，确保资源的合理使用和任务的顺利完成。</p><p>进程管理是操作系统的核心功能之一，它通过对进程的调度和控制，实现了多任务并发，保证系统资源的高效利用和任务的公平执行。</p><hr><p><strong>API（Application Programming Interface, 应用程序编程接口）</strong> 是一种允许不同软件系统之间进行通信的接口。API 定义了一组函数、方法、协议或工具，使开发者可以利用这些接口来访问另一种软件的功能或数据，而无需了解其内部实现细节。</p><p><strong>API重要特点：</strong></p><ul><li><strong>抽象层（Abstraction Layer）</strong>：API 提供了对底层复杂操作的简化抽象，开发者不需要了解底层实现细节。</li><li><strong>功能封装（Function Encapsulation）</strong>：API 将常用功能封装为可复用的接口，方便开发者调用。</li><li><strong>互操作性（Interoperability）</strong>：不同的软件系统可以通过 API 进行互操作，提高系统的兼容性和可扩展性。</li></ul><p><strong>系统调用（System Call）</strong> 是操作系统内核提供的接口，允许应用程序请求操作系统提供服务。系统调用是程序与操作系统之间的桥梁，使应用程序可以执行底层硬件操作，如文件操作、进程管理和网络通信等。系统调用可以被看作是<strong>操作系统API的一部分</strong>。当你在编程时使用API，你可能会间接地使用系统调用。例如，当你使用C++的文件流对象（如std::fstream）来读写文件时，这些对象内部可能会使用到操作系统的系统调用来进行实际的文件操作。</p><p><strong>系统调用重要特点：</strong></p><ul><li><strong>内核模式（Kernel Mode）</strong>：系统调用将程序从用户模式切换到内核模式，以便执行特权操作。</li><li><strong>服务访问（Service Access）</strong>：通过系统调用，应用程序可以访问操作系统内核提供的服务。</li><li><strong>安全和稳定（Security and Stability）</strong>：系统调用由操作系统内核管理，确保了系统的安全性和稳定性。</li></ul><p><strong>总结：</strong></p><ul><li><strong>API（应用程序编程接口）</strong> 是软件之间进行通信的接口，通过提供预定义的函数和方法，使开发者能够利用现有功能来构建应用程序。</li><li><strong>系统调用（System Call）</strong> 是操作系统提供的接口，使应用程序可以请求操作系统执行底层硬件操作和特权任务。</li></ul><p>API 是一种更高层次的抽象，而系统调用是更底层的接口，两者都在不同层次上为软件开发提供了便利和功能。总的来说，API和系统调用都是使程序员能够更容易地编写代码和交互系统的工具。API提供了更高级别的抽象，而系统调用则提供了对操作系统服务的直接访问。</p><hr><p>操作系统的<strong>四个重要特征</strong>包括：</p><p><strong>1.并发（Concurrency）</strong> 并发是指两个或多个事件在同一时间间隔内发生。在操作系统中，并发可以通过多线程或多进程实现，线程或进程可以在一个处理器上交替执行，或者在多个处理器上同时执行。</p><ul><li><strong>并发（Concurrency）</strong> 是指多个任务在同一时间段内交替进行，给人的感觉是同时发生，但实际上每个任务并不是同时进行的。</li><li><strong>并行（Parallelism）</strong> 与并发不同，并行是指两个或多个事件在同一时刻同时发生。例如：多线程下载文件，多个进程同时处理不同任务。</li></ul><p><strong>2.共享（Sharing）</strong> 共享是指系统中的资源可以被多个并发进程共同使用。共享的方式有两种：同时访问（同时共享）和在一段时间内交替访问（互斥共享）。</p><ul><li><strong>同时共享（Concurrent Sharing）</strong>：多个进程同时访问同一资源。</li><li><strong>互斥共享（Mutual Exclusion Sharing）</strong>：多个进程轮流访问同一资源，以避免冲突。例如：多个进程共享打印机资源，互斥访问临界区。</li></ul><p><strong>3.虚拟化（Virtualization）</strong> 虚拟化是指把一个物理资源（如处理器、内存或磁盘）抽象为多个逻辑资源，或把多个物理资源抽象为一个逻辑资源。虚拟化使得用户感觉有更多的资源可用，或使得资源使用更加高效。</p><ul><li><strong>空分复用（Space Division Multiplexing）</strong>：如虚拟存储器，使4GB内存的计算机能够运行需要超过4GB内存的程序。</li><li><strong>时分复用（Time Division Multiplexing）</strong>：时分复用通过将时间划分为多个时间片，每个时间片分配给不同的任务执行。通过CPU时间片轮转技术实现多任务并行，使得每个任务在短时间内轮流占用CPU资源，给人一种同时执行多个任务的感觉。如虚拟处理器和多任务操作系统，通过CPU时间片轮转技术实现多任务并行。</li></ul><p><strong>4.异步性（Asynchronism）</strong> 异步性是指由于进程间的并发性，使得进程交替执行，进程的执行不是一贯的，也不是在固定的时间间隔内发生。这意味着进程可能走走停停，取决于系统资源的可用性和调度策略。</p><ul><li><strong>示例</strong>：异步I&#x2F;O操作，操作系统在等待I&#x2F;O操作完成时可以执行其他任务。</li></ul><p>这些特征共同作用，使操作系统能够有效地管理计算机资源，提供稳定和高效的运行环境。</p><div class="note note-success">            <p>以上就是操作系统主要关注的内容，后续章节就是扩展讲解上述内容中重要的技术细节和实现思想</p>          </div><h2 id="2-Process-Management"><a href="#2-Process-Management" class="headerlink" title="2. Process Management"></a>2. Process Management</h2><p>本章主要讲解操作系统里面的进程管理部分。理解进程和线程，掌握进程调度相关的各种策略算法，并且熟悉信号量的互斥机制是非常重要的。</p><h3 id="2-1-操作系统的用户交互"><a href="#2-1-操作系统的用户交互" class="headerlink" title="2.1 操作系统的用户交互"></a>2.1 操作系统的用户交互</h3><p>操作系统的用户交互主要分为两种类型：</p><h4 id="2-1-命令解释程序（Command-Interpreter）"><a href="#2-1-命令解释程序（Command-Interpreter）" class="headerlink" title="2.1. 命令解释程序（Command Interpreter）"></a>2.1. 命令解释程序（Command Interpreter）</h4><ul><li>又称为 <strong>命令行界面（CLI，Command Line Interface）</strong>。</li><li>用户通过输入文本命令与操作系统进行交互。</li><li>常见的命令解释程序包括 Unix&#x2F;Linux 系统的 Bash、Windows 的 CMD 和 PowerShell。</li><li><strong>优点</strong>：灵活性高，适合自动化脚本和高级用户。</li><li><strong>缺点</strong>：需要记住大量命令和语法，不直观。</li></ul><p>以下是一个简单的 shell 指令示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 创建一个新的目录mkdir my_new_directory# 进入新创建的目录cd my_new_directory# 创建一个新的空文件touch new_file.txt# 将一段文本写入文件中echo &quot;Hello, World!&quot; &gt; new_file.txt# 显示文件内容cat new_file.txt# 复制文件并重命名cp new_file.txt copy_of_new_file.txt# 显示当前目录中的文件和子目录列表ls -l# 删除复制的文件rm copy_of_new_file.txt# 返回上一级目录cd ..# 删除新创建的目录及其内容rm -r my_new_directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="2-2-图形用户界面（GUI，Graphical-User-Interface）"><a href="#2-2-图形用户界面（GUI，Graphical-User-Interface）" class="headerlink" title="2.2 图形用户界面（GUI，Graphical User Interface）"></a>2.2 图形用户界面（GUI，Graphical User Interface）</h4><ul><li>用户通过图形化元素（如窗口、图标、按钮）与操作系统进行交互。</li><li>常见的图形用户界面包括 Windows 的资源管理器（Windows Explorer）、macOS 的 Finder 以及 GNOME 和 KDE 等 Linux 桌面环境。</li><li><strong>优点</strong>：直观易用，适合初学者和普通用户。</li><li><strong>缺点</strong>：灵活性相对较低，复杂操作可能效率不高。</li></ul><p>这两种交互方式各有优缺点，通常操作系统会同时提供这两种方式，以满足不同用户的需求和使用场景。通过结合命令行界面和图形用户界面，用户可以在不同情况下选择最合适的交互方式，提高工作效率和使用体验。</p><hr>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东北大学2024年冬计算机组成_问题5</title>
    <link href="/2024/12/10/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A62024%E5%B9%B4%E5%86%AC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E6%83%85%E6%8A%A5%E7%94%9F%E5%91%BD/"/>
    <url>/2024/12/10/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A62024%E5%B9%B4%E5%86%AC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E6%83%85%E6%8A%A5%E7%94%9F%E5%91%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="东北大学2024年冬计算机-问题5-by-偷偷"><a href="#东北大学2024年冬计算机-问题5-by-偷偷" class="headerlink" title="东北大学2024年冬计算机_问题5 by 偷偷"></a>东北大学2024年冬计算机_问题5 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p>Consider the following recursive function $f$ that takes an integer and returns an integer.</p><p>$$<br>f(n)&#x3D;<br>\begin{cases}<br>0,\quad n\leq 0 \\<br>f(n-1) \times 2 + n, \quad n&gt;0<br>\end{cases}<br>$$</p><p>Answer the following questions.</p><hr><p><strong>(1)</strong> Find the value of $f(3)$. Show also the intermediate steps in the calculation.</p><p>$$f(0) &#x3D; 0$$<br>$$f(1) &#x3D; f(0) \times 2 + 1 &#x3D; 1$$<br>$$f(2) &#x3D; f(1) \times 2 + 2 &#x3D; 4$$<br>$$f(3) &#x3D; f(2) \times 2 + 3 &#x3D; 11$$</p><hr><p><strong>(2)</strong> Consider a machine with three integer registers $r_{0}$, $r_{1}$, and $r_{2}$, a stack of sufficient size, and the instruction set in Fig.5(a). A program is a sequence of instructions and there is no limit on the size of integers. The program in Fig.5(b) displays the value of $f(30)$ on the screen and terminates. Give an instruction (or part of an instruction) that is appropriate for each of <u>(A), (B), (C),</u> and <u>(D).</u> Also explains in several lines of text how this program goes.</p><center><img src="/img/exam_other/tohoku24.jpg" alt="Memory Access" style="max-width: 100%; height: auto;" /></center><p>Let’s briefly read the assembly language</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">1. set 30, $r12. set 5, $r0      # 这里的‘5’用来记录函数退出的位置，即第5行代码3. push r04. jmp 65. halt r1         # r1用来返回最终的计算结果6. ifpos r1, ______(A) # 循环7. set 0, r18. ret9. push r1              # 不断往栈放入r1，后续必定有弹出r1的动作10. dec r111. set ____(B), r012. push r013. jmp 6              # 循环14. add r1, r1, r2     # 计算乘2的过程，即f(n-1) x 215. ____(C)16. add r1, r2, r1     # 计算加n的过程17. ____(D)            # 需要找准时机退出循环，即要和‘5’呼应上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p><strong>Hint:</strong> 可以尝试令$r1 &#x3D; 3, 然后手动模拟栈计算f(3)的过程</p></blockquote><p>Ans:</p><ul><li>(A): jmp 9</li><li>(B): 14</li><li>(C): pop r1</li><li>(D): ret</li></ul><p>This program initially places the calculation of the recursive endpoint $f(30)$ at the bottom of the stack. It then recursively processes from the bottom upwards until the starting value of the recursion is placed at the top of the stack. Following this, it begins to recursively process from the top downward until it reaches the calculation of the recursive endpoint $f(30)$.</p>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>东北大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>东北大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2023年夏计算机组成</title>
    <link href="/2024/12/08/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A620223%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/08/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A620223%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2023年计算机组成答案-by-偷偷"><a href="#九州大学2023年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2023年计算机组成答案 by 偷偷"></a>九州大学2023年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider a microprocessor having a pipelined datapath. Program execution time ET can be represented by using the three parameters, instruction count required to complete the whole program execution IC, the number of executed instructions per clock cycle IPC, and clock frequency F, as shown in the following equation.<br>$$ET &#x3D; \frac{IC}{IPC \times F}$$</p><p>Answer the following questions.</p><hr><p><strong>(1)</strong> Consider an in-order microprocessor whose instruction issue width is one. Explain the effects of pipelined datapath implementation on IC, IPC, and F, compared to a single-cycle datapath implementation where each instruction is executed in a single clock cycle, respectively. If there are no effects on each parameter, answer “no effects.”</p><ul><li><p><strong>IC：</strong> <strong>No effects.</strong> The instruction count is determined by the program being executed and is independent of whether the processor uses a pipelined or a single-cycle datapath. The same number of instructions will be executed in both cases.</p></li><li><p><strong>IPC:</strong> IPC typically <strong>increases</strong> in a pipelined processor because multiple instructions can be in different stages of execution at the same time. This allows the processor to issue a new instruction each cycle, leading to higher throughput.</p></li><li><p><strong>F</strong>: The clock frequency F can potentially be <strong>higher</strong> in a pipelined processor. This is because each stage of the pipeline is smaller (handling only part of the instruction) compared to the single-cycle implementation where the entire instruction is processed in one cycle. This smaller stage size allows for faster clock cycles, thus enabling a higher frequency.</p></li></ul><hr><p><strong>(2)</strong> We extend the pipelined datapath by increasing the instruction issue width from one to two that forms an in-order superscalar microprocessor, i.e., at most two independent instructions can be executed in parallel. Explain the effects of this extension on IC, IPC, and F, respectively. If there are no effects on each parameter, answer “no effects.”</p><ul><li><p><strong>IC:</strong> <strong>No effects.</strong> The instruction count is still determined by the program being executed.</p></li><li><p><strong>IPC:</strong>  In general, increasing the issue width should <strong>increase IPC</strong>, assuming there are enough independent instructions to take advantage of the increased width. Consider other factors, such as dependencies (data hazards, control hazards) can reduce the potential benefit.</p></li><li><p><strong>F:</strong> <strong>No effects.</strong> Although there may be a slight decrease in frequency due to the added complexity of issuing two instructions per cycle.</p></li></ul><hr><p><strong>(3)</strong> Assume that the instruction issue width is four. Answer the upper limit of IPC that can be achieved by the pipelined datapath.</p><p>Ans: <strong>4</strong></p><hr><p><strong>[Q3]</strong> Consider computer memory systems. Assume a direct-mapped cache memory implemented in a microprocessor chip. The microprocessor uses word addressing, the word size is 4 bytes, the cache size is 16 bytes, the block size is 4 bytes, and the address width is 4 bits. Suppose the cache was initially empty, and the memory access sequence for the following word addresses (represented in the binary numeral system) has occurred. 1101 ⇒ 1010 ⇒ 1111 ⇒ 1101 </p><p>Then we have the following five memory accesses (memory access  ① -⑤ ) consecutively.</p><center><img src="/img/exam/kyusyu23.jpeg" alt="Memory Access" style="max-width: 100%; height: auto;" /></center><p>Answer the following questions.</p><hr><p>(1) Find all of the memory accesses among ① -⑤ that cause a cache hit. If there is no corresponding memory access, answer “not applicable.”</p><blockquote><p><strong>Hint:</strong> Word Addressing. 按字编址</p></blockquote><ul><li>Block offset：block size is <strong>4 bytes(1 word)</strong> and it requires 1 bit.</li><li>Index bit: the number of cache blocks is $\frac{16bytes}{4bytes} &#x3D; 4 &#x3D; 2^2$,the index bit requires 2 bits.</li><li>Tag bits: it requires 4 - 2 - 1 &#x3D; 1 bits</li></ul><p>Before：</p><table><thead><tr><th>Cache Block</th><th>Accessing Order</th></tr></thead><tbody><tr><td>00</td><td></td></tr><tr><td>01</td><td>1010</td></tr><tr><td>10</td><td>1101</td></tr><tr><td>11</td><td>1111</td></tr></tbody></table><p>After：</p><ul><li>1010: hit</li><li>1001: miss</li><li>1000: hit</li><li>0011: miss</li><li>1111: hit</li></ul><hr><p><strong>(2)</strong> Find all of the memory accesses among  ① -⑤  that cause a compulsory miss. If there is no corresponding memory access, answer “not applicable.”</p><p>Compulsory miss: ②</p><hr><p><strong>(3)</strong> Explain how to modify this cache memory to reduce the conflict miss. Also, if there are any demerits to the modification, explain them.</p><p>Modigy the cache to fully associative cache. The index now maps to a set of multiple cache lines, and the block can be placed in any available line within the set, reducing the likelihood of conflicts. However, it requires additional hardware for selecting the correct cache line.</p>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2022年夏计算机组成</title>
    <link href="/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2022年计算机组成答案-by-偷偷"><a href="#九州大学2022年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2022年计算机组成答案 by 偷偷"></a>九州大学2022年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider an in-order microprocessor that has 5-stage pipelined datapath. The implemented pipeline stage are IF, ID, EX, MEM, and WB. The operations in each stage for the “add” are defined in the following table. Assume that the operations in each pipeline stage can be completed in one clock cycle. The written data in the WB stage of an instruction can be read in the ID stage of a subsequent instruction in the same clock cycle. All RAW(Read-After-Write) hazards are resolved by applying a pipeline stall mechanism. Answer the following questions.</p><center><img src="/img/exam/kyusyu22.jpg" alt="Operations of the pipelined datapath" style="max-width: 100%; height: auto;" /></center><hr><p><strong>(1)</strong> Consider the following assembly program. The words on the right of the ‘#’ symbol in each line are comments. Identify all flow dependencies by describing which instruction depends on which instructions through which register.</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add $1, $3, $5 # &lt;1&gt;add $9, $2, $3 # &lt;2&gt;add $6, $3, $3 # &lt;3&gt;add $3, $4, $3 # &lt;4&gt;add $4, $7, $1 # &lt;5&gt;add $5, $7, $4 # &lt;6&gt;add $9, $3, $6 # &lt;7&gt;add $2, $7, $6 # &lt;8&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p><strong>Hint:</strong> 流依赖（Flow Dependency），也称为Read-After-Write (RAW) 依赖，是指一条指令需要读取一个由前一条指令写入的寄存器值。</p></blockquote><p>从上到下依次分析写入的寄存器，可以得到存在的Flow Dependencies 有：</p><ul><li>&lt;5&gt; depends on &lt;1&gt; through $1</li><li>&lt;7&gt; depends on &lt;3&gt; through $6</li><li>&lt;8&gt; depends on &lt;3&gt; through $6</li><li>&lt;7&gt; depends on &lt;4&gt; through $3</li><li>&lt;6&gt; depends on &lt;5&gt; through $4</li></ul><hr><p><strong>(2)</strong> Assume the instruction issue width is one. Answer the number of clock cycles required for the execution of the assembly program.</p><blockquote><p><strong>Hint:</strong> 一条指令在写回（WB）阶段写入的数据，可以在同一个时钟周期内被随后的指令在指令解码（ID）阶段读取。</p></blockquote><p>We can draw the pipeline stages below.</p><img src="/img/exam/kyusyu22.svg" alt="pipeline" style="max-width: 100%; height: auto;" /><p>According to the pipeline stages, it requires <strong>14</strong> clock cycles for the execution of the assembly program.</p><hr><p><strong>(3)</strong> We extend the datapath by increasing the instruction issue width from one to two that forms an in-order superscalar microprocessor, i.e., at most, two independent instructions can be executed in parallel. Answer the number of clock cycles required for the execution of the assembly program on the extended datapath.</p><p>We can draw the pipeline stages below.</p><img src="/img/exam/kyusyu22-2.svg" alt="pipeline" style="max-width: 100%; height: auto;" /><p>According to the pipeline stages, it requires <strong>12</strong> clock cycles for the execution of the assembly program.</p><hr><p><strong>(4)</strong> The data path extension presented in (3) causes a 5% decrease in its clock frequency. Answer the performance improvement rate achieved by implementing the extension.</p><p>We know that,</p><p>$$\text{CPU Time} &#x3D; IC \times CPI \times \frac{1}{f}$$</p><p>When extending the datapath, IC reimains the same, CPI improves $\frac{14}{12}$ and the frequency decreases 5%. The improvement $K$ is:</p><p>$$ K &#x3D; \frac{\text{CPU Time}}{\text{CPU Time’}}&#x3D; \frac{14 \times 0.95}{12} \approx \text{111%} $$</p><hr><p><strong>[Q3]</strong> Explain what “compulsory misses”, “conflict misses”, and what “capacity misses” are in cache memory systems, respectively.</p><blockquote><p><strong>Hint:</strong> 直接映射缺失的3C模型</p></blockquote><ul><li><p><strong>Compulsory Misses:</strong> Misses that occur when data is accessed for the first time.</p></li><li><p><strong>Conflict Misses:</strong> Misses that occur  when different data blocks are mapped to the same cache line position causing frequent replacements, resulting in misses even if the cache capacity is sufficient.</p></li><li><p><strong>Capacity Misses:</strong> Due to limited cache capacityeven if all blocks in the cache are fully utilized, it still cannot accommodate all the needed data blocks, resulting in misses.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2021年夏计算机组成</title>
    <link href="/2024/12/06/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/06/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2021年计算机组成答案-by-偷偷"><a href="#九州大学2021年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2021年计算机组成答案 by 偷偷"></a>九州大学2021年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider a microprocessor that has a 5-stage pipelined datapath. The implemented pipeline stages are IF (Instruction Fetch), ID (Instruction Decode), EX (EXecution),MEM (MEMory access), and WB (Write Back). Answer the following questions.</p><hr><p><strong>(1)</strong> The latency of pipeline stages, IF, ID, EX, MEM, and WB, is 240 ps, 400 ps, 200ps, 250 ps, and 180 ps, respectively. Answer the maximum clock frequency of this datapath (unit is GHz).</p><blockquote><p><strong>Hint:</strong> The clock period is determined by the slowest (longest latency) pipeline stage.</p></blockquote><p>The slowest stage is ID with a latency of 400 ps. The clock period must be at least as long as this latency to ensure that the slowest stage completes in one cycle.</p><p>$$<br>\text{Clock Frequency} &#x3D; \frac{1}{\text{Clock Period}} &#x3D; \frac{1}{400 \ \text{ps}} &#x3D; \frac{1}{400 \times 10^{-12}} &#x3D; 2.5\ \text{GHz}<br>$$</p><hr><p><strong>(2)</strong> Consider increasing the number of pipeline stages from 5 to 6 by partitioning a single pipeline stage, IF, ID, EX, MEM, or WB, to two stages. Assume the latency of the partitioned pipeline stages is half of that of the original stage. Choose one pipeline stage that should be partitioned for maximising the clock frequency of the datapath, and answer the maximum clock frequency we can achieve by this design optimization (unit is GHz).</p><p>To get the maximum clock frequency, we need to minimize the clock period, thus the best stage to partition for maximizing the clock frequency is the ID stage.</p><ul><li>By splitting the ID stage, its latency is halved to 200 ps.</li><li>The MEM stage becomes the longest (250 ps), so the clock period is now determined by MEM.</li></ul><p>$$<br>\text{Clock Frequency} &#x3D; \frac{1}{\text{Clock Period}} &#x3D; \frac{1}{250 \ \text{ps}} &#x3D; \frac{1}{250 \times 10^{-12}} &#x3D; 4 \ \text{GHz}<br>$$</p><hr><p><strong>(3)</strong> For the execution of a program, the pipeline stage partitioning presented in (2)caused 10 % increase in CPI (Clock cycles Per Instruction). Assume there are no negative effects caused by the pipeline stage partitioning except for the CPI increase.Answer the performance improvement rate achieved by applying the pipeline stage partitioning.</p><ul><li>Before:</li></ul><p>$$\text{CPU Time} &#x3D; \frac {IC \cdot CPI}{f} &#x3D; \frac{IC \cdot CPI} {2.5 \ \text{GHz}}$$</p><ul><li>After partitioning:</li></ul><p>$$ \text{CPU Time’} &#x3D; \frac {IC \cdot CPI \cdot \text{110%} }{f’} &#x3D; \frac{IC \cdot CPI \cdot  \text{110%}}{4 \ \text{GHz}} $$</p><ul><li>The improvement rate K is:</li></ul><p>$$ K &#x3D; \frac{\text{CPU Time}}{\text{CPU Time’}} \approx \text{145%} $$</p><hr><p><strong>(4)</strong> Explain the advantages and disadvantages of increasing the number of pipeline stages.</p><ol><li><p><strong>Advantages：</strong></p><ul><li><strong>Higher Clock Frequency：</strong> each stage performs a smaller part of the instruction cycle. This can reduce the latency of each stage, allowing the processor to run at a higher clock frequency.</li><li><strong>Improved Instruction Throughput：</strong> With more pipeline stages, instructions can be processed more concurrently. This increases the potential instruction throughput because multiple instructions can be in different stages of execution at the same time.</li></ul></li><li><p><strong>Disadvantages:</strong></p><ul><li><strong>Increased Latency per Instruction:</strong> With more stages being executed in the pipeline, even though each individual stage is shorter, an instruction still takes more cycles to pass through all the stages which leads to the increasing of CPI</li><li><strong>More Complex Control Logic:</strong> As the number of pipeline stages increases, the control logic required to manage the pipeline also becomes more complex, which may results in pipeline hazards</li></ul></li></ol><hr><p><strong>[Q3]</strong> Consider a direct-mapped cache memory that accepts a 32-bit memory address consisting of a cache tag field, a cache index field, and a cache block offset field. Suppose a byte addressing scheme, the word size is 4 bytes, the cache size is 16 Kilo-bytes, and the cache block size is 32 bytes. Answer the bit-width of the cache tag field.</p><p>$32 \ bytes &#x3D; 2^5 \ bytes$, the block offset is $5 \ bits$</p><p>$\text{number of cache blocks} &#x3D; \frac{16KByte}{32Byte} &#x3D; 2^9$, the cache index requires $9 \ bits$</p><p>$$ Cache \ tag \ width &#x3D; 32 − Index bits − Offset bits &#x3D; 32 - 9 - 5 &#x3D; 18\ bits $$</p><hr>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Digital Circuit</title>
    <link href="/2024/11/04/Digital-Circuit/"/>
    <url>/2024/11/04/Digital-Circuit/</url>
    
    <content type="html"><![CDATA[<h1 id="Digital-Circuit"><a href="#Digital-Circuit" class="headerlink" title="Digital Circuit"></a>Digital Circuit</h1><p>Credit to《Digital Design and Computer Architecture, Second Edition》🤯 Let’s quickly review this subject. The diagram is powered by <a href="https://github.com/jgraph/drawio-desktop">@drawio</a></p><blockquote><p> 催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Logic-Gates"><a href="#1-Logic-Gates" class="headerlink" title="1. Logic Gates"></a>1. Logic Gates</h2><p>第一章主要认识最基础的逻辑门元件，然后熟悉其对应的真值表(Truth Table),主要是为第二章的组合电路(combinational circuit)做铺垫。</p><p><strong>NOT 门（非门）:</strong> 输出是输入的逻辑反， $Y &#x3D; \neg A$</p><p><strong>BUF 门（缓冲器）:</strong> 输出与输入相同，用于信号强化。$Y &#x3D; A$</p><p><strong>AND 门（与门）:</strong> 所有输入均为1时，输出才为1。$Y &#x3D; A \cap B$</p><p><strong>OR 门（或门）:</strong> 任意输入为1时，输出为1。$Y &#x3D; A \cup B$</p><img src="/img/DC/add.svg" alt="逻辑门1" style="max-width: 100%; height: auto;" /><p><strong>NAND 门（与非门）:</strong> 与门输出取反。 $ Y &#x3D; \neg (A \cap B) $</p><p><strong>NOR 门（或非门）:</strong> 或门输出取反。 $ Y &#x3D; \neg (A \cup B) $</p><p><strong>XOR 门（异或门）:</strong> 相异为1，相同为0。 $ Y &#x3D; A \oplus B $</p><p><strong>XNOR 门（同或门）:</strong> 相同为0，相异为1。 $ Y &#x3D; \neg (A \oplus B) $</p><img src="/img/DC/nand.svg" alt="逻辑门2" style="max-width: 100%; height: auto;" /><p><strong>三态缓冲器（tristate buffer）</strong> 是一种数字电路元件，其输出可以处于三种状态之一：高电平（1）、低电平（0）或高阻态（Z）。高阻态表示输出像断开一样，不驱动任何电流，可以用于总线控制等应用。</p><p><strong>高水平有效（Active High）</strong></p><p>在高水平有效的三态缓冲器中，当控制信号为高电平（1）时，缓冲器输出有效，即输出输入信号的值。当控制信号为低电平（0）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 &#x3D; 1：输出 &#x3D; 输入信号</li><li>控制信号 &#x3D; 0：输出 &#x3D; 高阻态（Z）</li></ul><p><strong>低水平有效（Active Low）</strong></p><p>在低水平有效的三态缓冲器中，当控制信号为低电平（0）时，缓冲器输出有效，即输出输入信号的值。当控制信号为高电平（1）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 &#x3D; 0：输出 &#x3D; 输入信号</li><li>控制信号 &#x3D; 1：输出 &#x3D; 高阻态（Z）</li></ul><p align="center">  <img src="/img/DC/buffer.svg" alt="逻辑门3" style="max-width: 110%; height: auto;" /></p><h2 id="2-Combinational-Logic-Circuit"><a href="#2-Combinational-Logic-Circuit" class="headerlink" title="2. Combinational Logic Circuit"></a>2. Combinational Logic Circuit</h2><p>组合逻辑电路（Combinational Logic Circuit）是一种数字电路，其中输出仅依赖于当前输入，而不依赖于之前的输入状态。这意味着组合电路没有存储元件，因此它没有记忆功能。其主要特性包括：</p><ul><li><p>无记忆功能：输出<strong>仅由当前输入决定</strong>，与之前的输入无关。</p></li><li><p>固定的逻辑功能：根据输入信号的组合，输出信号以确定的方式变化。</p></li><li><p>构建简单：组合电路通常由基本逻辑门（如AND、OR、NOT、NAND、NOR、XOR、XNOR）构建，可以用来实现任意逻辑功能。</p></li></ul><p>在有逻辑门的基础知识下，还需要有布尔表达式以及卡诺图的基础下才能完成组合电路的设计。</p><h3 id="2-1-Boolean-Equation"><a href="#2-1-Boolean-Equation" class="headerlink" title="2.1 Boolean Equation"></a>2.1 Boolean Equation</h3><p><strong>与或式（Sum of Products, SOP）</strong> 是一种布尔表达式形式，表示多个与项（积项）之间的或操作。每个积项由一个或多个变量通过与操作连接而成。与或式通常用于表达布尔函数的标准形式之一。例如：</p> <center>$ Y = A \cdot B + \overline{A}  \cdot C + B \cdot \overline{C} $</center><p><strong>或与式（Product of Sums, POS）</strong> 是布尔表达式的另一种形式，表示多个或项（和项）之间的与操作。每个和项由一个或多个变量通过或操作连接而成。或与式也常用于表达布尔函数的标准形式之一。例如：</p><center> $ Y = (A + B) \cdot (\overline {A} + C) \cdot (B + \overline{C}) $</center><p><strong>最小项 (Minterms)</strong> 是布尔函数的标准形式之一，其中每个最小项对应一个输出为1的输入组合。最小项由所有变量的与运算构成，每个变量可能是原变量或其补变量。通俗解释就是输出为1对应积项为1的累加。</p><p>示例：考虑一个布尔函数 ( F(A, B, C) )：</p><ul><li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最小项为 $ ( A \cdot \overline{B} \cdot C )$ </li><li>当 ( A &#x3D; 0 ), ( B &#x3D; 1 ), ( C &#x3D; 0 ) 时，最小项为 $ ( \overline{A} \cdot B \cdot \overline{C} )$</li></ul><p>假设布尔函数在以下输入组合下输出为1：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>相应的最小项表示为：</p><center>$ F(A, B, C) = \overline{A} \cdot \overline{B} \cdot C + \overline{A} \cdot B \cdot \overline{C} + A \cdot \overline{B} \cdot C $</center><p><strong>最大项 (Maxterms)</strong> 是布尔函数的另一种标准形式，其中每个最大项对应一个输出为0的输入组合。最大项由所有变量的或运算构成，每个变量可能是原变量或其补变量。通俗解释就是输入为0所对应的和项为0的累乘</p><p>示例：同样考虑布尔函数 ( F(A, B, C) )：</p><p>这两个组合对应的最大项为：</p><ul><li>当 ( A &#x3D; 0 ), ( B &#x3D; 0 ), ( C &#x3D; 0 ) 时，最大项为$ (A + B + C) $</li><li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最大项为$ (\overline{A} + B + \overline{C} ) $</li></ul><p>假设布尔函数 ( F(A, B, C) ) 在以下输入组合下输出为0：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>因此，相应的最大项表达式为：</p><center> \[F(A, B, C) = (A + B + C) \cdot (\overline{A} + \overline{B} + C)\] </center><p><strong>总结</strong></p><ul><li><strong>最小项</strong>：布尔函数输出为1时，对应输入组合的与运算。</li><li><strong>最大项</strong>：布尔函数输出为0时，对应输入组合的或运算。</li></ul><blockquote><p>这些概念在布尔代数和数字电路设计中非常有用，也是这门课的高频考点</p></blockquote><h3 id="2-2-Boolean-Operation-Rules"><a href="#2-2-Boolean-Operation-Rules" class="headerlink" title="2.2 Boolean Operation Rules"></a>2.2 Boolean Operation Rules</h3><p>布尔运算的基本定律，和卡诺图一样，是逻辑电路化简的主要手段</p><h4 id="2-2-1-交换律（Commutative-Law）"><a href="#2-2-1-交换律（Commutative-Law）" class="headerlink" title="2.2.1 交换律（Commutative Law）"></a>2.2.1 交换律（Commutative Law）</h4><p>交换律表示在布尔运算中，操作数的位置可以互换。</p><ul><li><strong>与运算</strong>：$ A \cdot B &#x3D; B \cdot A $</li><li><strong>或运算</strong>：$ A + B &#x3D; B + A $</li></ul><h4 id="2-2-2-结合律（Associative-Law）"><a href="#2-2-2-结合律（Associative-Law）" class="headerlink" title="2.2.2 结合律（Associative Law）"></a>2.2.2 结合律（Associative Law）</h4><p>结合律表示在布尔运算中，操作数的组合方式不影响运算结果。</p><ul><li><strong>与运算</strong>：$ (A \cdot B) \cdot C &#x3D; A \cdot (B \cdot C) $</li><li><strong>或运算</strong>：$ (A + B) + C &#x3D; A + (B + C) $</li></ul><h4 id="2-2-3-分配律（Distributive-Law）"><a href="#2-2-3-分配律（Distributive-Law）" class="headerlink" title="2.2.3 分配律（Distributive Law）"></a>2.2.3 分配律（Distributive Law）</h4><p>分配律表示一种运算可以分配到另一种运算上。</p><ul><li><strong>与对或</strong>：$ A \cdot (B + C) &#x3D; (A \cdot B) + (A \cdot C) $</li><li><strong>或对与</strong>：$ A + (B \cdot C) &#x3D; (A + B) \cdot (A + C) $</li></ul><h4 id="2-2-4-吸收律（Absorption-Law）"><a href="#2-2-4-吸收律（Absorption-Law）" class="headerlink" title="2.2.4 吸收律（Absorption Law）"></a>2.2.4 吸收律（Absorption Law）</h4><p>吸收律表示通过某些布尔运算可以简化表达式。</p><ul><li>$ A + (A \cdot B) &#x3D; A $</li><li>$ A \cdot (A + B) &#x3D; A $</li></ul><h4 id="2-2-5-合并律（Combining-Law）"><a href="#2-2-5-合并律（Combining-Law）" class="headerlink" title="2.2.5 合并律（Combining Law）"></a>2.2.5 合并律（Combining Law）</h4><p>合并律表示布尔变量和其补变量的某些组合具有特定的结果。</p><ul><li>$ A + \overline{A} &#x3D; 1 $</li><li>$ A \cdot \overline{A} &#x3D; 0 $</li></ul><h4 id="2-2-6-一致律（Identity-Law）"><a href="#2-2-6-一致律（Identity-Law）" class="headerlink" title="2.2.6 一致律（Identity Law）"></a>2.2.6 一致律（Identity Law）</h4><p>一致律表示布尔变量与1和0的运算结果。</p><ul><li><strong>与1</strong>：$ A \cdot 1 &#x3D; A $</li><li><strong>与0</strong>：$ A \cdot 0 &#x3D; 0 $</li><li><strong>或1</strong>：$ A + 1 &#x3D; 1 $</li><li><strong>或0</strong>：$ A + 0 &#x3D; A $</li></ul><h4 id="2-2-7-德摩根律（De-Morgan’s-Laws）"><a href="#2-2-7-德摩根律（De-Morgan’s-Laws）" class="headerlink" title="2.2.7 德摩根律（De Morgan’s Laws）"></a>2.2.7 德摩根律（De Morgan’s Laws）</h4><p>德摩根律表示对布尔表达式取反的规则。</p><ul><li>$ \overline{A \cdot B} &#x3D; \overline{A} + \overline{B} $</li><li>$ \overline{A + B} &#x3D; \overline{A} \cdot \overline{B} $</li></ul><h4 id="2-2-8-部分二级公式推导"><a href="#2-2-8-部分二级公式推导" class="headerlink" title="2.2.8 部分二级公式推导"></a>2.2.8 部分二级公式推导</h4><ul><li>$ A + \overline{A}B &#x3D; A + B$</li></ul><p>证明: $A(1 + B) + {A}B &#x3D; A + AB + \overline{A}B &#x3D; A + B $ </p><ul><li>$ (A + B) \cdot (A + C) &#x3D; A + (B \cdot C) $</li></ul><p>证明: $ AA + AC + AB + BC &#x3D; A + AB + AC + BC &#x3D; A(1 + B + C) + BC &#x3D; A + BC $</p><ul><li>$A \cdot (A + B) &#x3D; A$</li></ul><p>证明: $AA + AB &#x3D; A + AB &#x3D; A(1 + B) &#x3D; A$</p><ul><li>$BC + B\overline{C} &#x3D; B$</li></ul><p>证明: $B \cdot (C + \overline{C}) &#x3D; B \cdot 1 &#x3D; B$</p><ul><li>$(A + B) \cdot (A + \overline{B}) &#x3D; A$</li></ul><p>证明: $AA + A\overline{B} + AB + B\overline{B} &#x3D; A + A(B + \overline{B}) &#x3D; A + A &#x3D; A$</p><ul><li>$AB + \overline{A}C + BC &#x3D; AB + \overline{A}C$</li></ul><p>证明关键：使用吸收律 $A + AB &#x3D; A$, 推广为$AB + ABC &#x3D; AB$</p><p>$$<br>\begin{aligned}<br>&amp;AB + \overline{A}C + BC \\<br>&amp;&#x3D; AB + \overline{A}C + (A + \overline{A})BC \\<br>&amp;&#x3D; AB + \overline{A}C + ABC + \overline{A}CB \\<br>&amp;&#x3D; AB + ABC + \overline{A}C + \overline{A}CB \text{(使用推广公式)} \\<br>&amp;&#x3D; AB + \overline{A}C<br>\end{aligned}<br>$$</p><p>根据吸收律可继续推广下去：<br>$$AB + \overline{A}C + BC\cdot(\text{其他任何项}) &#x3D; AB + \overline{A}C  $$ </p><p>在表达式中，无论包含 $B$ 和 $C$ 的项如何复杂（例如 $BCDEFGH$），它都不会改变整个表达式的最终结果。</p><div class="note note-primary">            <p>渲染上述公式太折磨了！修考一般不考如此复杂的化简，一般掌握K-Map化简足够应付</p>          </div><h3 id="2-3-K-Map"><a href="#2-3-K-Map" class="headerlink" title="2.3 K-Map"></a>2.3 K-Map</h3><p>在绘制卡诺图的时候需要用到格雷码的表格。首先引入一个格雷码的概念。</p><h4 id="2-3-1-Gray-Code"><a href="#2-3-1-Gray-Code" class="headerlink" title="2.3.1 Gray Code"></a>2.3.1 Gray Code</h4><p>格雷码（Gray Code）是一种<strong>特殊的二进制编码方式</strong>，其特点是<strong>相邻的两个数码之间仅有一位二进制数不同</strong>。格雷码的发明即是用来将误差之可能性缩减至最小，编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码，可以使装置做数字步进时只更动最少的位元数以提高稳定性。</p><p><strong>格雷码的特性</strong></p><ul><li><strong>相邻差一位</strong>：每个相邻编码仅一位不同，减少了转换时的误差风险。</li><li><strong>非权重编码</strong>：格雷码不按照传统二进制编码的权值（如 $1, 2, 4, 8, \dots$）累加。</li></ul><p><strong>2 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>01</td></tr><tr><td>1</td><td>11</td><td>10</td></tr></tbody></table><p><strong>3 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>001</td><td>011</td><td>010</td></tr><tr><td>1</td><td>110</td><td>111</td><td>101</td><td>100</td></tr></tbody></table><p><strong>4 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>00</td><td>0000</td><td>0001</td><td>0011</td><td>0010</td></tr><tr><td>01</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td></tr><tr><td>11</td><td>1110</td><td>1111</td><td>1101</td><td>1100</td></tr><tr><td>10</td><td>1010</td><td>1011</td><td>1001</td><td>1000</td></tr></tbody></table><blockquote><p>上述表格，无论是以x轴对称，或者y轴对称，或者中心对称，均只有1位的差异</p></blockquote><h4 id="2-3-2-卡诺图化简步骤"><a href="#2-3-2-卡诺图化简步骤" class="headerlink" title="2.3.2 卡诺图化简步骤"></a>2.3.2 卡诺图化简步骤</h4><ol><li><p>构建 K 图：根据布尔函数的输入变量数量，构建相应大小的 K 图：</p><ul><li>2 位变量：4 格（2×2）</li><li>3 位变量：8 格（2×4）</li><li>4 位变量：16 格（4×4）</li></ul></li></ol><p>横轴和纵轴的变量顺序需按照<strong>格雷码</strong>排列，以确保相邻格子之间只有一个变量不同。</p><ol start="2"><li><p>填写真值表和无关项：</p><ul><li>根据逻辑函数或真值表，在 K 图中标记输出为 1 的位置。</li><li>将无关项标(Don’t Care Conditions)记为 X。无关项是那些对最终结果没有影响的输入组合，可以被自由选择为 1 或 0，以帮助扩大合并区域。</li></ul></li><li><p>寻找最大合并区域：</p><ul><li>在 K 图中，寻找可以合并的 1 和 X 区域。合并的目标是形成2 的幂次方大小的区域（例如 1、2、4、8 等格），并使每个 1 尽量包含在最大的区域中。</li><li>合并时遵循以下规则：<ul><li>只允许合并相邻的 1 和 X（上下、左右、包围环绕相邻）。</li><li>尽量优先选择包含更多无关项 X 的区域，以增加合并区域的大小。</li><li>合并区域可以是矩形、正方形，甚至是环绕 K 图的封闭区域。</li></ul></li></ul></li><li><p>合并相邻项：</p><ul><li>每个合并区域中的变量中，如果某个变量在区域内既有 0 又有 1，则忽略该变量（因为它在该区域中无关紧要）。</li><li>将每个合并区域的共同变量提取为一个积项。对于每个变量：<ul><li>如果变量在区域内始终为 1，则使用原变量（如 $A$）。</li><li>如果变量在区域内始终为 0，则使用其反码（如 $\overline{A}$）。</li></ul></li></ul></li><li><p>写出最简化表达式：</p><ul><li>将所有合并区域的积项求和，得到逻辑函数的最简化形式。</li><li>所有包含在化简表达式中的项应尽量少，以确保表达式是最简形式。</li></ul></li></ol><blockquote><p>多练多化简就行了，没什么难度</p></blockquote><h3 id="2-4-常见数字模块"><a href="#2-4-常见数字模块" class="headerlink" title="2.4 常见数字模块"></a>2.4 常见数字模块</h3><p>这一小节跟计算机组成中的算术运算关联度很高，数字电路就是来讲解计算机所呈现出来的算术运算在底层是如何用逻辑元器件实现的。</p><h4 id="2-4-1-Half-Adder"><a href="#2-4-1-Half-Adder" class="headerlink" title="2.4.1 Half Adder"></a>2.4.1 Half Adder</h4><p><strong>半加器 (Half Adder)</strong> 是一个基本的数字电路，用于计算两个单比特二进制数的和。它的功能是执行二进制加法，并且产生两个输出：</p><ul><li>Sum：表示两个输入二进制数加法的结果（不考虑进位）。这里用$S$来表示和。</li><li>Carry：表示加法结果中<strong>产生的进位</strong>。这里用$Cout$来表示产生的进位了。</li></ul><p>根据如下K-Map我们可以得出和与进位的表达式，分别为：$S &#x3D; A \oplus B$ , $Cout &#x3D; A\cdot B$，再把组合电路进行封装📦(encapsulation)可以得到半加器这个电路元件<br><img src="/img/DC/half_adder.svg" alt="半加器" style="max-width: 100%; height: auto;" />  </p><h4 id="2-4-2-Full-Adder"><a href="#2-4-2-Full-Adder" class="headerlink" title="2.4.2 Full Adder"></a>2.4.2 Full Adder</h4><p><strong>全加器 (Full Adder)</strong> 是数字电路中的一种基本元件，用于对二进制数进行加法运算。与半加器（Half Adder）相比，全加器可以对两个二进制数和一个进位位进行加法运算，并输出结果和新的进位位。</p><p>全加器的输入包括三个位：</p><ul><li><p>A（第一个加数位）</p></li><li><p>B（第二个加数位）</p></li><li><p>Cin（输入进位位）</p></li></ul><p>全加器的输出包括两个位：</p><ul><li><p>S（和位）：表示加法结果的当前位。</p></li><li><p>Cout（输出进位位）：表示加法结果的进位位。</p></li></ul><img src="/img/DC/full_adder.svg" alt="全加器" style="max-width: 100%; height: auto;" />  <p>首先分析真值表写出最小项表达式，对于$S$有：</p><p>$$<br>\begin{aligned}<br>S &amp;&#x3D; \overline{A} \cdot B \cdot \overline{C_{in}} + A \cdot\overline{B} \cdot \overline{C_{in}} + \overline{A} \cdot \overline{B} \cdot C_{in} + A \cdot B \cdot C_{in} \\<br>&amp;&#x3D; \overline{C_{in}}(A \oplus B) + C_{in} \overline{(A \oplus B)} \\<br>&amp;&#x3D; A \oplus B \oplus C_{in}<br>\end{aligned}<br>$$</p><p>对于$C_{out}$有：</p><p>$$<br>\begin{aligned}<br>C_{out} &amp;&#x3D; AB \overline{C_{in}} + \overline{A}BC_{in} + A \overline{B}C_{in} + ABC_{in} \\<br>&amp;&#x3D; AB + C_{in}(A \oplus B)<br>\end{aligned}<br>$$</p><p><strong>思考🤔</strong> ：为什么黑书给的是 $C_{out} &#x3D; AB + AC_{in} + BC_{in}$ ，这时候可以借助K-Map化简：如下图所示</p><div style="text-align: center;">  <img src="/img/DC/fa1.svg" alt="k-map" style="max-width: 100%; height: auto;" /></div><p>根据K-Map化简，我们的全加器的画法会得出上图的电路，而如果根据真值表进行表达式化简，我们会得到下图的全加器。</p><img src="/img/DC/fa2.svg" alt="Full Adder" style="max-width: 100%; height: auto;" />  <p>我们可以用2个半加器和一个或门封装成一个全加器,具体的计算过程就不赘述了，这是修考重点！</p><img src="/img/DC/fa3.svg" alt="全加器封装" style="max-width: 100%; height: auto;" />  <h4 id="2-4-3-Ripple-Carry-Adder"><a href="#2-4-3-Ripple-Carry-Adder" class="headerlink" title="2.4.3 Ripple-Carry Adder"></a>2.4.3 Ripple-Carry Adder</h4><p><strong>Ripple-Carry Adder</strong> （行波进位加法器）是一种用于二进制数加法的简单组合逻辑电路，由多个一位全加器（Full Adder）级联而成，每个全加器负责处理输入位和进位。</p><ol><li><p><strong>组成结构</strong>  </p><ul><li>Ripple-Carry Adder 包括 $n$ 个全加器，用于计算 $n$ 位二进制数的加法。  </li><li>每个全加器接收两个输入位 $A[i]$ 和 $B[i]$，以及前一位的进位 $C[i]$。  </li><li>输出为和 $S[i]$ 和进位 $C[i+1]$。</li></ul></li><li><p><strong>进位传播</strong>  </p><ul><li>第一个全加器处理最低有效位 $A[0]$ 和 $B[0]$ 以及初始进位（通常为 0），产生和 $S[0]$ 和进位 $C[1]$。  </li><li>进位 $C[1]$ 传递到下一个全加器，依次类推，直到最高有效位。</li></ul></li><li><p><strong>优缺点</strong></p><ul><li><p><strong>优点</strong>  </p><ul><li>设计简单，硬件实现容易。</li></ul></li><li><p><strong>缺点</strong>  </p><ul><li><strong>进位传播延迟</strong>：每个全加器必须等待前一级的进位信号，导致延迟随位数线性增长，影响运算速度。</li></ul></li></ul><p>Ripple-Carry Adder 适用于简单、低速应用；但无法满足更高速的加法需求。</p></li></ol><img src="/img/DC/ripple.svg" alt="4bit行波进位加法器" style="max-width: 100%; height: auto;" />  <h4 id="2-4-4-Carry-Lookahead-Adder-CLA"><a href="#2-4-4-Carry-Lookahead-Adder-CLA" class="headerlink" title="2.4.4 Carry-Lookahead Adder (CLA)"></a>2.4.4 Carry-Lookahead Adder (CLA)</h4><p><strong>Carry-Lookahead Adder (CLA)</strong> ，即先行进位加法器，是一种改进的加法器，用于快速执行二进制加法，解决 Ripple-Carry Adder 中进位传播延迟的问题。</p><p>Carry-Lookahead Adder 通过并行计算进位信号，而不依赖逐级传播，从而显著提高速度。其核心思想是利用生成信号和传播信号：</p><ol><li><p><strong>生成信号 (Generate)</strong>  ：表示某一位的加法会直接产生一个进位：<br>$G_i &#x3D; A_i \cdot B_i$</p></li><li><p><strong>传播信号 (Propagate)</strong>  ：表示某一位的加法会将来自上一位的进位传递下去：<br>$P_i &#x3D; A_i + B_i$</p></li><li><p><strong>进位计算公式</strong>  ：根据生成和传播信号，计算每一位的进位：<br>$C_{i+1} &#x3D; G_i + P_i \cdot C_i$   其中，$C_0$ 是初始进位。</p></li></ol><p><strong>推导证明：</strong><br>根据前面全加器的结论，我们有：</p><ol><li><p><strong>初始公式</strong><br>$$C_{i + 1} &#x3D; A_{i} \cdot B_{i} + (A_{i} + B_{i}) \cdot C_{i}$$</p></li><li><p><strong>引入生成信号和传播信号</strong>(都是已知信号)<br>$$G_{i} &#x3D; A_{i} \cdot B_{i}$$<br>$$P_{i} &#x3D; A_{i} + B_{i}$$</p></li><li><p><strong>公式代换</strong><br>$$C_{i + 1} &#x3D; G_{i} + P_{i} \cdot C_{i} \quad \text{(用 $P_{i}$ 代换 $(A_{i} + B_{i})$)}$$</p></li></ol><p>那么我就可以用已知的输入 $A_{0}$  ~  $A_{n-1}$ 和 $B_{0}$  ~  $B_{n-1}$ 以及 $C_{0}$ 来确定进位是什么了。比如：</p><p>$$C_{1} &#x3D; G_{0} + P_{0} \cdot C_{0}$$</p><p>$$C_{2} &#x3D; G_{1} + P_{1} \cdot C_{1} &#x3D; G_{1} + P_{1} G_{0} + P_{1}P_{0}C_{0}$$<br>不断迭代我们可以得出 $C_{3}$ 和 $C_{4}$ ，甚至到 $C_{n-1}$ ，但是！考虑到电路的复杂程度和电路成本的情况下，我们可以稍微妥协一下，采用分块的策略，比如实现一个32bit的加法器，我们可以将四个全加器分成一个块使用上面推导出来的门电路封装成一个块打包好。然后我们就可以迅速确定当前块的进位，减少等待进位的时间。<em>在不考虑其他门延迟的情况下</em></p><ul><li>不分块的情况下：需要等32次进位的传递</li><li>4个为一块的情况下：只需要等$32&#x2F;4 &#x3D; 8$次进位传递</li></ul><img src="/img/DC/lookahead.jpeg" alt="黑书: 32bit超前进位加法器" style="max-width: 100%; height: auto;" />  <p><strong>优点</strong></p><ul><li><strong>减少延迟</strong>：进位计算是并行完成的，速度显著快于 Ripple-Carry Adder。</li><li><strong>高效的硬件实现</strong>：适合多位二进制数加法的高速场景。</li></ul><p><strong>缺点</strong></p><ul><li><strong>硬件复杂度增加</strong>：需要额外的逻辑电路来计算生成和传播信号，随着位数增加，复杂性迅速提高。</li><li><strong>功耗较高</strong>：更多逻辑门导致功耗增加。</li></ul><p>Carry-Lookahead Adder 是一种高效的加法器设计，常用于高速处理器中。相比 Ripple-Carry Adder，它通过并行化进位计算显著提高了运算速度，但也牺牲了一定的硬件简单性。</p><h4 id="2-4-5-Half-Subtractor"><a href="#2-4-5-Half-Subtractor" class="headerlink" title="2.4.5 Half Subtractor"></a>2.4.5 Half Subtractor</h4><p>半减法器（Half Subtractor）可以对两个单个位的二进制数进行减法运算。它有两个输入：被减数$A$和减数$B$，输出包括差值（Difference, $D$）和借位（Borrow, $B_{0}$）。</p><ul><li><p>差值 $D &#x3D; A \oplus B$</p></li><li><p>借位$B_{0} &#x3D; \overline{A}B$</p></li></ul><div style="text-align: center;"><img src="/img/DC/half.svg" alt="半减法器" style="max-width: 100%; height: auto;" />  </div><h4 id="2-4-6-Full-Subtractor"><a href="#2-4-6-Full-Subtractor" class="headerlink" title="2.4.6 Full Subtractor"></a>2.4.6 Full Subtractor</h4><p>全减法器（Full Subtractor）可以对两个单个位的二进制数以及一个借位输入进行减法运算。它有三个输入：被减数$X$，减数$Y$，来自低位借位输入（Borrow_in, $B_{in}$），输出包括差值（Difference, $D$）和向高位的借位输出（Borrow_out, $B_{out}$）。</p><p>差值$D &#x3D; X ⊕ Y ⊕ B_{in}$</p><p>借位输出$<br>B_{out}&#x3D; \overline{X}B_{in} + \overline{X}Y + YB_{in}<br>$</p><blockquote><p>上述公式可以通过真值表和K-map得出，这里就省略了</p></blockquote><div style="text-align: center;"><img src="/img/DC/sub2.svg" alt="半减法器" style="max-width: 100%; height: auto;" />  </div><p>Q：<em>如何用N-bit全加器实现全减器？</em></p><p>计算机中的加减运算都是通过补码进行的，根据补码运算有$A - B$ 实现的时候可以转化为$A + (-B)$, 我们又有 $\overline{B} + 1 &#x3D; -B$，所以$Y &#x3D; A - B &#x3D; A + \overline{B} + 1$</p><div style="text-align: center;"><img src="/img/DC/sub3.svg" alt="N-bit减法器" style="max-width: 100%; height: auto;" />  </div><h4 id="2-4-7-Multiplexer"><a href="#2-4-7-Multiplexer" class="headerlink" title="2.4.7 Multiplexer"></a>2.4.7 Multiplexer</h4><p>复用器(Multiplexer)是一种数字电路元件，它的主要功能是将多个输入信号中的一个传递到输出端。复用器可以被视为一个多路选择开关，通过控制选择信号选择特定的输入线路。</p><p><strong>工作原理：</strong></p><ul><li><strong>输入信号</strong>：有 $2^n$ 个输入信号线，每条线路可传递一个信号。</li><li><strong>选择信号</strong>：通过 $n$ 条选择线决定选取哪一个输入信号。</li><li><strong>输出信号</strong>：仅有一个输出，输出选定的输入信号。</li></ul><p>复用器的输出可表示为：<br>$$<br>Y &#x3D; I_i \quad (i \text{由选择信号确定})<br>$$<br>其中 $I_i$ 是第 $i$ 个输入。下图是一个用门电路设计2:1 MUX并封装的过程</p><img src="/img/DC/mux.svg" alt="2:1 MUX" style="max-width: 100%; height: auto;" />  <p><strong>基本结构：</strong></p><ul><li><strong>数据输入端（Data Inputs）</strong>：多路信号的输入端口。</li><li><strong>选择端（Select Lines）</strong>：控制信号，决定选用哪个输入。</li><li><strong>输出端（Output Line）</strong>：传递选定信号的端口。</li></ul><p>例如：<br>对于一个 <strong>4路复用器（4-to-1 MUX）</strong>：</p><ul><li>有 4 个输入线：$I_0, I_1, I_2, I_3$。</li><li>有 2 个选择线：$S_1, S_0$。</li><li>有 1 个输出线：$Y$。</li></ul><p>输出由选择信号 $S_1$ 和 $S_0$ 确定：</p><p>$$<br>Y &#x3D;<br>\begin{cases}<br>I_0, &amp; \text{if } S_1S_0 &#x3D; 00 \\<br>I_1, &amp; \text{if } S_1S_0 &#x3D; 01 \\<br>I_2, &amp; \text{if } S_1S_0 &#x3D; 10 \\<br>I_3, &amp; \text{if } S_1S_0 &#x3D; 11<br>\end{cases}<br>$$</p><p>通过增加选择信号线数，复用器可以扩展为更大的多路选择器（如 8-to-1、16-to-1）。</p><img src="/img/DC/mux2.svg" alt="MUX" style="max-width: 100%; height: auto;" />  <h4 id="2-4-8-Decoder"><a href="#2-4-8-Decoder" class="headerlink" title="2.4.8 Decoder"></a>2.4.8 Decoder</h4><p>译码器是一种<strong>组合逻辑电路</strong>，其主要功能是将输入的<strong>二进制代码</strong>转换为<strong>独热码（one-hot code）</strong>，即在输出中只有一条线路为高电平，其余为低电平。</p><div class="note note-success">            <p>独热码工作原理:如果有 $n$ 个类别，则需要一个长度为 $n$ 的二进制向量。对应某个类别的位置为1，其余位置为0。例如，对于3个类别：A, B, C：</p><ul><li>类别 A 编码为：$[1, 0, 0]$</li><li>类别 B 编码为：$[0, 1, 0]$</li><li>类别 C 编码为：$[0, 0, 1]$</li></ul>          </div><p><strong>译码器工作原理</strong></p><ul><li><strong>输入信号</strong>：有 $n$ 条输入信号线，用于表示二进制编码。</li><li><strong>输出信号</strong>：有 $2^n$ 条输出信号线，每个输出对应一种输入组合。</li><li><strong>控制信号（可选）</strong>：部分译码器可能需要使能信号（Enable），用于控制译码器的工作状态。</li></ul><p>译码器根据输入信号的值，激活唯一对应的输出线。例如：</p><ul><li>输入：$00, 01, 10, 11$</li><li>输出：$Y_0, Y_1, Y_2, Y_3$ 依次被激活。</li></ul><p><strong>译码器基本结构</strong></p><p>对于一个 $n$ 位输入的译码器：</p><ul><li>有 $2^n$ 个输出信号线。</li><li>每个输出信号线对应一个输入组合。</li></ul><p>例如，一个 <strong>2-to-4 译码器</strong>（2位输入，4个输出）：</p><ul><li>输入：$A_1, A_0$。</li><li>输出：$Y_0, Y_1, Y_2, Y_3$。</li><li>输出逻辑：<br>$$<br>Y_0 &#x3D; \overline{A_1} \cdot \overline{A_0}, \quad<br>Y_1 &#x3D; \overline{A_1} \cdot A_0, \quad<br>Y_2 &#x3D; A_1 \cdot \overline{A_0}, \quad<br>Y_3 &#x3D; A_1 \cdot A_0<br>$$</li></ul><p>译码器是数字电路中重要的基础模块，用于信号的<strong>解码与路由</strong>。</p><img src="/img/DC/decoder.svg" alt="译码器" style="max-width: 100%; height: auto;" />  <h3 id="2-5-传播延迟和最小延迟"><a href="#2-5-传播延迟和最小延迟" class="headerlink" title="2.5 传播延迟和最小延迟"></a>2.5 传播延迟和最小延迟</h3><p><strong>传播延迟（Propagation Delay, $t_{pd}$）</strong></p><ul><li>定义：信号从输入端变化到输出端<strong>完全稳定</strong>所需的时间。对于组合电路来说就是关键路径上面每一个元件的传播延迟之和</li><li>影响因素：<ul><li>器件特性：如晶体管的开关速度、驱动能力。</li><li>负载电容：较大的负载电容会增加传播延迟。</li><li>电路拓扑：更复杂的路径结构会增加延迟。</li></ul></li><li>意义：传播延迟决定了电路的速度性能，即最大运行频率。</li></ul><p><strong>最小延迟（Contamination Delay, $t_{cd}$）</strong></p><ul><li>定义：信号在电路中传输所需的<strong>最短时间</strong>，反映信号可能在某些路径上过快到达输出端的时间。对于组合电路来说是最短路径上面每个元件的最小延迟之和。</li><li>影响因素：<ul><li>布线长度和材料特性。</li><li>逻辑门数量与优化设计。</li></ul></li><li>意义：<ul><li>保持时间（Hold Time）违规：最小延迟可能导致竞争冒险或保持时间问题。</li><li>必须确保最小延迟不会破坏电路的时序完整性。</li></ul></li></ul><img src="/img/DC/pd.svg" alt="传播延迟和最小延迟" style="max-width: 100%; height: auto;" />  <div class="note note-success">            <p>Note: 每个门的传播延迟和最小延迟要看参数表,而且传播延迟和最小延迟这个问题非常艰深…</p>          </div><h3 id="2-6-Glitch"><a href="#2-6-Glitch" class="headerlink" title="2.6 Glitch"></a>2.6 Glitch</h3><p><strong>毛刺（Glitch）</strong> 是数字电路中由于信号传播延迟或竞争冒险导致的短暂错误信号脉冲，通常表现为在信号稳定之前出现的意外高电平或低电平跳变。</p><p><strong>产生原因：</strong></p><ul><li>竞争冒险（Hazards）：当多条信号路径的传播延迟不一致时，可能导致某一时刻输出信号短暂错误。</li><li>门延迟： 逻辑门的延迟导致信号在不同路径上到达输出端的时间不同。</li><li>不完全同步：异步信号未正确对齐，导致输出出现瞬时错误信号。</li></ul><img src="/img/DC/glitch.svg" alt="毛刺时序图" style="max-width: 100%; height: auto;" />  <p>为了消除毛刺，可以通过添加冗余项优化逻辑表达式，确保信号在所有可能的变化路径中保持稳定。</p><p><strong>步骤：</strong></p><ul><li>构造卡诺图：根据真值表将逻辑表达式填入卡诺图。</li><li>标记相邻格子：将输出为“1”的相邻单元块分组，覆盖现有的逻辑区域。<br>检查是否有相邻的“1”之间存在空隙（可能导致冒险）。</li><li>添加冗余项：对于无法完全覆盖的相邻“1”之间的空隙，添加额外的逻辑项来补充。<br>确保每一个相邻的“1”都连通，避免由于输入信号变化导致逻辑的不连续。</li><li>生成优化后的逻辑表达式：将包含冗余项的逻辑表达式写出并实现。</li></ul><p>通过使用卡诺图消除毛刺的关键是：</p><ol><li>识别相邻逻辑之间的不连续性。</li><li>添加冗余项确保逻辑表达式的稳定性。</li><li>优化后可减少信号跳变，避免毛刺的产生。</li></ol><img src="/img/DC/glitch2.svg" alt="毛刺消除" style="max-width: 100%; height: auto;" />  <h2 id="3-Sequential-Logic-Circuit"><a href="#3-Sequential-Logic-Circuit" class="headerlink" title="3. Sequential Logic Circuit"></a>3. Sequential Logic Circuit</h2><p><strong>时序逻辑电路（Sequential Logic Circuit）</strong> 是一类输出<u>不仅取决于当前输入，还与电路的历史状态相关的电路。</u>它通过存储元件（如触发器、锁存器等）记录状态，具有<em>记忆功能</em>。</p><p><strong>时序逻辑电路特点:</strong></p><ul><li>记忆功能：与组合逻辑电路不同，时序逻辑电路可以存储数据。</li><li>状态变化：状态的变化通常由时钟信号控制，随着时钟信号的边沿（上升沿或下降沿）进行更新。</li><li>输出依赖性：输出依赖于当前输入和之前的状态。</li></ul><h3 id="3-1-Latch"><a href="#3-1-Latch" class="headerlink" title="3.1 Latch"></a>3.1 Latch</h3><p><strong>锁存器（Latch）</strong>是一种<strong>基本的存储元件</strong>，用于存储一个<strong>单个位的二进制信息</strong>。它的输出状态会随输入信号的变化而更新，具体取决于使能信号（通常称为<strong>控制信号</strong>或<strong>使能信号</strong>）。</p><p>工作方式为<strong>电平触发</strong>：  锁存器根据控制信号的电平（高电平或低电平）决定是否更新输出。  </p><ul><li>当使能信号为有效电平时，输出跟随输入变化。</li><li>当使能信号为无效电平时，锁存器保持当前状态（记忆功能）。</li></ul><p><strong>1. 锁存器类型：</strong></p><ul><li><p><strong>SR锁存器（Set-Reset Latch）</strong>：</p><ul><li>基于两个交叉耦合的与非门（NAND）或或非门（NOR）构成。</li><li>通过 $S$（置位）和 $R$（复位）信号控制状态。</li><li>存在不允许 $S &#x3D; R &#x3D; 1$ 的<strong>无效状态</strong>（对于NOR实现）。</li></ul></li><li><p><strong>D锁存器（Data Latch）</strong>：</p><ul><li>又称为<strong>数据锁存器</strong>。</li><li>有效控制信号时，输出 $Q$ 跟随输入 $D$；无效时，输出保持不变。</li></ul></li><li><p><strong>JK锁存器</strong>：</p><ul><li>改进了SR锁存器的无效状态问题，能够实现翻转（Toggle）功能。</li></ul></li></ul><p><strong>2. 锁存器特点：</strong></p><ul><li><strong>电平敏感</strong>：锁存器会在控制信号有效的整个时间内更新状态，而不是像触发器那样在时钟边沿更新。</li><li><strong>记忆功能</strong>：能够存储当前状态，直到输入或控制信号改变。</li></ul><p><strong>3. 锁存器应用</strong></p><ul><li><strong>数据暂存</strong>：存储单个位的信息。</li><li><strong>寄存器的构成</strong>：多个锁存器组合可以组成寄存器，用于数据存储和处理。</li><li><strong>时序电路</strong>：如简单的状态存储元件。</li></ul><p>锁存器是电平触发的基本存储元件，可以根据输入和使能信号存储信息或保持状态。其在数字电路中的作用类似“开关”，用以暂存和传递数据。</p><h4 id="3-1-1-SR锁存器（Set-Reset-Latch）"><a href="#3-1-1-SR锁存器（Set-Reset-Latch）" class="headerlink" title="3.1.1 SR锁存器（Set-Reset Latch）"></a>3.1.1 SR锁存器（Set-Reset Latch）</h4><p>SR锁存器是一种<strong>基本的锁存器类型</strong>，用于通过置位信号（Set）和复位信号（Reset）控制输出状态。它是由两个交叉耦合的逻辑门（通常是 NAND 或 NOR 门）构成的。</p><p><strong>SR Latch工作方式：</strong></p><ul><li><strong>输入信号</strong>：  <ul><li>$S$（Set）：置位信号，用于将输出 $Q$ 设置为高电平（1）。</li><li>$R$（Reset）：复位信号，用于将输出 $Q$ 设置为低电平（0）。</li></ul></li><li><strong>输出信号</strong>：<ul><li>$Q$：当前状态输出。</li><li>$\overline{Q}$：$Q$ 的反相输出，满足 $Q \cdot \overline{Q} &#x3D; 0$。</li></ul></li></ul><p>SR 锁存器的状态随 $S$ 和 $R$ 的变化而更新，具体规则如下：</p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$\overline{Q}$</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>保持</td><td>保持</td><td>保持当前状态</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>复位（Reset）</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>置位（Set）</td></tr><tr><td>1</td><td>1</td><td>无效</td><td>无效</td><td>无效状态（禁止）</td></tr></tbody></table><p><strong>SR Latch特点：</strong></p><ul><li><strong>电平敏感</strong>：<br>SR锁存器根据 $S$ 和 $R$ 的电平信号控制输出状态。</li><li><strong>无效状态</strong>：<br>当 $S &#x3D; 1$ 且 $R &#x3D; 1$ 时，$Q$ 和 $\overline{Q}$ 都为 0，这种状态被定义为无效状态，通常在设计中需要避免。</li></ul><p><strong>SR Latch实现：</strong> SR锁存器可以通过以下两种逻辑门实现：</p><ul><li><strong>NOR门实现：</strong>：<ul><li>当 $S &#x3D; 1$ 时，置位 $Q &#x3D; 1$；当 $R &#x3D; 1$ 时，复位 $Q &#x3D; 0$。</li></ul></li><li><strong>NAND门实现：</strong>：<ul><li>信号逻辑与 NOR 门相反，通常 $S$ 和 $R$ 信号需要取反。</li></ul></li></ul><p><strong>SR Latch应用：</strong></p><ul><li><strong>状态存储</strong>：  记录电路中的状态信号。</li><li><strong>控制电路</strong>：  用于实现简单的时序控制功能。</li><li><strong>锁存电路</strong>：  用作更复杂存储元件（如触发器）的基础单元。</li></ul><p>SR锁存器是最基本的锁存器，通过置位和复位信号控制输出状态，但需要避免无效状态。它在简单存储和状态保持电路中有广泛应用。</p><img src="/img/DC/sr.svg" alt="NOR门SR锁存器" style="max-width: 100%; height: auto;" />  <p>还有一种是由NAND门构成的SR锁存器，注意真值表和由NOR门构成的SR锁存器的区别</p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$\overline{Q}$</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td><strong>无效状态</strong>（禁止）</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>复位（Reset）</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>置位（Set）</td></tr><tr><td>1</td><td>1</td><td>保持</td><td>保持</td><td>保持当前状态</td></tr></tbody></table><img src="/img/DC/sr2.svg" alt="NAND门SR锁存器" style="max-width: 100%; height: auto;" />  <h4 id="3-1-2-D锁存器（Data-Latch）"><a href="#3-1-2-D锁存器（Data-Latch）" class="headerlink" title="3.1.2 D锁存器（Data Latch）"></a>3.1.2 D锁存器（Data Latch）</h4><p>D锁存器是一种基本的时序逻辑电路，用于存储1位二进制数据。它根据时钟信号的状态决定是否允许数据输入被存储。</p><ol><li><p><strong>输入和输出：</strong></p><ul><li><strong>D（Data）输入</strong>：需要存储的数据。</li><li><strong>使能信号（Enable&#x2F;Clock，通常用<code>E</code>或<code>EN</code>表示）</strong>：控制数据存储的信号。</li><li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li></ul></li><li><p><strong>工作原理：</strong></p><ul><li>当 <strong>使能信号为高</strong>（<code>E = 1</code>）：锁存器“打开”，D输入的值直接通过电路输出到 Q。</li><li>当 <strong>使能信号为低</strong>（<code>E = 0</code>）：锁存器“锁住”，Q 保持之前存储的值，不受 D 输入变化的影响。</li></ul></li><li><p><strong>特性：</strong></p><ul><li>数据在 <strong>使能信号有效期间</strong> 会被更新。</li><li>D锁存器消除了竞争（Race）条件，因为它只有一个数据输入（D），避免了像 SR 锁存器中的非法状态（S&#x3D;R&#x3D;1）。</li></ul></li><li><p><strong>应用：</strong></p></li></ol><ul><li><strong>数据存储单元</strong>：用作基本的位存储器。</li><li><strong>数据保持电路</strong>：维持信号的稳定性。</li><li><strong>边沿触发寄存器</strong>（如 D 触发器）的基本构造单元。</li></ul><table><thead><tr><th>Enable (E)</th><th>Data (D)</th><th>Output (Q)</th></tr></thead><tbody><tr><td>0</td><td>X (任意)</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>D锁存器逻辑门组成：</p><ul><li>两个<strong>与非门（NAND）或与门（AND）</strong>用来生成控制信号。</li><li>两个交叉耦合的 NAND 门（或 NOR 门）构成一个基本的锁存器（SR 锁存器）。</li></ul><img src="/img/DC/dlatch.svg" alt="D锁存器" style="max-width: 100%; height: auto;" />  <h4 id="3-1-3-JK锁存器（JK-Latch）"><a href="#3-1-3-JK锁存器（JK-Latch）" class="headerlink" title="3.1.3 JK锁存器（JK Latch）"></a>3.1.3 JK锁存器（JK Latch）</h4><p>JK锁存器是一种增强型的时序逻辑电路，是对 SR 锁存器的改进，避免了 SR 锁存器中 <code>S=1</code> 和 <code>R=1</code> 时的非法状态问题。它被广泛用于时序电路中，能够实现多种功能，如保持、置位、复位和翻转。</p><ol><li><p><strong>输入和输出：</strong></p><ul><li><strong>J（Set）</strong>：对应置位功能。</li><li><strong>K（Reset）</strong>：对应复位功能。</li><li><strong>使能信号（Enable 或 Clock）</strong>：控制锁存器工作状态。</li><li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li></ul></li><li><p><strong>功能定义：</strong></p><ul><li><strong>J&#x3D;0, K&#x3D;0</strong>：保持状态（Q 保持不变）。</li><li><strong>J&#x3D;0, K&#x3D;1</strong>：复位（Q&#x3D;0）。</li><li><strong>J&#x3D;1, K&#x3D;0</strong>：置位（Q&#x3D;1）。</li><li><strong>J&#x3D;1, K&#x3D;1</strong>：翻转状态（Q 从 0 变为 1，或从 1 变为 0）。</li></ul></li></ol><table><thead><tr><th>Enable (E)</th><th>J</th><th>K</th><th>Q (Next State)</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>0</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>Q̅（翻转）</td></tr></tbody></table><ol start="3"><li><strong>JK锁存器应用:</strong></li></ol><ul><li><strong>寄存器设计</strong>：作为存储单元使用。</li><li><strong>计数器</strong>：通过翻转功能实现二进制计数器。</li><li><strong>时序电路</strong>：作为基本的控制逻辑单元。</li></ul><img src="/img/DC/jklatch.svg" alt="JK锁存器" style="max-width: 100%; height: auto;" />  <h3 id="3-2-Flip-FLop"><a href="#3-2-Flip-FLop" class="headerlink" title="3.2 Flip-FLop"></a>3.2 Flip-FLop</h3><p>触发器是数字电路中的一种基本<strong>时序逻辑电路</strong>，用于存储一个二进制位的信息。它具有<strong>存储能力</strong>和<strong>同步性</strong>，是寄存器、计数器等时序电路的基础组件。</p><p><strong>触发器的特点：</strong></p><ol><li><strong>存储能力</strong>：可以存储1位二进制数据（0或1）。</li><li><strong>同步性</strong>：大多数触发器通过<strong>时钟信号（Clock）</strong>控制状态的改变。</li><li><strong>状态保持</strong>：在没有输入信号变化时，触发器会保持当前状态。</li></ol><p><strong>常见触发器类型：</strong></p><p><strong>SR触发器：</strong></p><ul><li>基本类型，具有两个输入：<strong>Set（置1）</strong> 和 <strong>Reset（清0）</strong>。</li><li>特点：<ul><li>S&#x3D;1, R&#x3D;0：输出为1。</li><li>S&#x3D;0, R&#x3D;1：输出为0。</li><li>S&#x3D;0, R&#x3D;0：保持状态。</li><li><strong>S&#x3D;1, R&#x3D;1</strong>：不稳定状态（无效）。</li></ul></li></ul><p><strong>D触发器（数据触发器）：</strong></p><ul><li>具有一个数据输入端（D）和一个时钟输入端（CLK）。</li><li>特点：<ul><li>在时钟信号的有效边沿（上升沿或下降沿）到来时，将输入D的值传递到输出Q。</li></ul></li><li>应用：<ul><li>常用于数据同步和寄存器设计。</li></ul></li></ul><p><strong>JK触发器：</strong></p><ul><li>是RS触发器的改进型，消除了<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态。</li><li>输入为J和K：<ul><li>J&#x3D;1, K&#x3D;0：置1。</li><li>J&#x3D;0, K&#x3D;1：清0。</li><li>J&#x3D;K&#x3D;1：状态翻转。</li></ul></li><li>应用：<ul><li>广泛用于计数器和状态机设计。</li></ul></li></ul><p><strong>T触发器（触发翻转器）：</strong></p><ul><li>只有一个输入（T）。</li><li>特点：<ul><li>T&#x3D;1：状态翻转。</li><li>T&#x3D;0：状态保持。</li></ul></li><li>应用：<ul><li>常用于计数器电路。</li></ul></li></ul><p>触发器是数字电路中<strong>存储单元的核心</strong>，用来实现数据存储和同步控制。不同类型的触发器适用于不同的功能需求：</p><ul><li>SR触发器用于简单存储；</li><li>D触发器用于数据锁存；</li><li>JK触发器适合复杂逻辑控制；</li><li>T触发器常用于计数和分频。</li></ul><h4 id="3-2-1-SR-Flip-Flop"><a href="#3-2-1-SR-Flip-Flop" class="headerlink" title="3.2.1 SR Flip-Flop"></a>3.2.1 SR Flip-Flop</h4><p><strong>SR触发器</strong>是一种基本的双稳态存储单元，用于存储1位二进制信息。SR触发器由 <strong>Set（S）</strong> 和 <strong>Reset（R）</strong> 两个输入控制输出状态，常用于简单的存储和逻辑控制。</p><p><strong>工作原理</strong></p><ul><li><strong>S（Set）</strong>：设置触发器的输出为1（Q&#x3D;1）。</li><li><strong>R（Reset）</strong>：重置触发器的输出为0（Q&#x3D;0）。</li><li>$Q$ 和 $\overline{Q}$：为触发器的输出和其反向输出。</li></ul><p><strong>逻辑功能表</strong></p><table><thead><tr><th>S</th><th>R</th><th>Q（输出）</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>保持</td><td>保持上次状态</td></tr><tr><td>0</td><td>1</td><td>0</td><td>清零</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置1</td></tr><tr><td>1</td><td>1</td><td>无效</td><td>不允许状态</td></tr></tbody></table><p> <strong>状态说明</strong></p><ol><li><strong>S&#x3D;0, R&#x3D;0</strong>：触发器保持当前状态，不发生变化。</li><li><strong>S&#x3D;1, R&#x3D;0</strong>：输出Q被置为1（Set）。</li><li><strong>S&#x3D;0, R&#x3D;1</strong>：输出Q被重置为0（Reset）。</li><li><strong>S&#x3D;1, R&#x3D;1</strong>：为无效状态，因Q和Q’会同时为1，违背Q和Q’互补的逻辑。</li></ol><p> <strong>应用场景</strong></p><ul><li><strong>存储单元</strong>：用于存储1位数据。</li><li><strong>逻辑控制</strong>：作为简单的状态保持和切换电路。</li><li><strong>锁存器</strong>：用于构成其他类型的触发器（如D触发器和JK触发器）。</li></ul><p>SR触发器是最基本的触发器类型，但存在<strong>S&#x3D;1, R&#x3D;1</strong>的不允许状态，限制了它在复杂电路中的使用。改进型触发器（如JK触发器）解决了这一问题。</p><p>SR触发器状态转移公式：<br>$$<br>\begin{cases}<br>Q_{n+1}  &#x3D; S + \overline{R}Q_{n} \\<br>S \cdot R &#x3D; 0  (约束条件)<br>\end{cases}<br>$$</p><img src="/img/DC/srff.svg" alt="SR触发器" style="max-width: 100%; height: auto;" />  <h4 id="3-2-2-D-Flip-Flop"><a href="#3-2-2-D-Flip-Flop" class="headerlink" title="3.2.2 D Flip-Flop"></a>3.2.2 D Flip-Flop</h4><p><strong>D触发器</strong>（Data Flip-Flop, DFF）是数字电路中一种基本的时序逻辑电路，用于存储1位二进制数据。它通过 <strong>数据输入端（D）</strong> 和 <strong>时钟信号（CLK）</strong> 实现同步数据存储。D触发器也经常称为主从触发器（master-slave flip-flop），边沿触发器（edge-triggered flip-flop）或者正边沿触发器（positive edge-triggered flip-flop）。</p><p> <strong>工作原理:</strong></p><ul><li><strong>D输入</strong>：决定触发器的输出值。</li><li><strong>CLK输入</strong>：控制触发器的状态更新，确保输出只有在特定时钟条件下（如上升沿或下降沿）才更新。</li><li>当时钟信号有效时，<strong>D的值会传递到输出Q</strong>，同时Q’为Q的反相。</li></ul><p> <strong>逻辑功能表:</strong></p><table><thead><tr><th>CLK（时钟）</th><th>D（数据）</th><th>Q（输出）</th><th>状态</th></tr></thead><tbody><tr><td>上升沿</td><td>0</td><td>0</td><td>输出清零</td></tr><tr><td>上升沿</td><td>1</td><td>1</td><td>输出置1</td></tr><tr><td>其他</td><td>-</td><td>保持</td><td>状态不变</td></tr></tbody></table><p> <strong>DFF特点:</strong></p><ol><li><strong>同步性</strong>：依赖时钟信号控制，输出只在时钟有效时更新。</li><li><strong>无争议状态</strong>：相比SR触发器，D触发器没有无效状态。</li><li><strong>锁存功能</strong>：在时钟无效时，输出保持上一次的状态。</li></ol><p> <strong>DFF应用场景:</strong></p><ol><li><strong>寄存器</strong>：用于存储和传输数据。</li><li><strong>移位寄存器</strong>：通过多级D触发器实现数据位移。</li><li><strong>计数器</strong>：作为计数器电路的基础单元。</li><li><strong>同步电路</strong>：用于数据同步或信号稳定。</li></ol><p>D触发器是一种<strong>简单高效的存储单元</strong>，它通过时钟信号的控制实现数据的同步存储，广泛应用于各种数字电路中。一个D触发器可以由反相时钟控制的2个背靠背的D锁存器构成。</p><img src="/img/DC/dff.svg" alt="D触发器" style="max-width: 100%; height: auto;" />  <p><em>对于上升沿触发的DFF的时序图：</em></p><div style="text-align: center;"><img src="/img/DC/dff2.svg" alt="DFF" style="max-width: 100%; height: auto;" />  </div><div class="note note-success">            <p>至于为什么是上升沿触发，可以画一下主锁存器的值和从锁存器的值的时序图，此处省略</p>          </div><p><em>当然还有下降沿触发的DFF的时序图：</em></p><img src="/img/DC/dff3.svg" alt="下降沿DFF" style="max-width: 100%; height: auto;" />  <p>D触发器状态转移公式：<br>$$Q_{n+1} &#x3D; D$$</p><h4 id="3-2-3-JK-Flip-Flop"><a href="#3-2-3-JK-Flip-Flop" class="headerlink" title="3.2.3 JK Flip-Flop"></a>3.2.3 JK Flip-Flop</h4><p><strong>JK触发器</strong>是一种改进型的双稳态触发器，是对<strong>SR触发器</strong>的增强，解决了SR触发器中<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态问题。它通过输入信号J和K以及时钟信号CLK实现状态控制，具有更强的功能和更广的应用。</p><p> <strong>JKFF工作原理：</strong></p><ul><li><strong>J（Set）</strong>：与SR触发器的S功能类似，用于设置输出Q&#x3D;1。</li><li><strong>K（Reset）</strong>：与SR触发器的R功能类似，用于清零输出Q&#x3D;0。</li><li><strong>CLK（时钟信号）</strong>：用于同步控制，触发器的状态仅在时钟信号的有效边沿发生变化。</li></ul><p><strong>JKFF逻辑功能表：</strong></p><table><thead><tr><th>J</th><th>K</th><th>$Q_{n}$（输出）</th><th>$Q_{n+1}$（下一状态）</th><th>状态描述</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Q</td><td>保持</td><td>状态保持</td></tr><tr><td>0</td><td>1</td><td>0</td><td>清零</td><td>Reset</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置1</td><td>Set</td></tr><tr><td>1</td><td>1</td><td>Q’（反相）</td><td>翻转</td><td>Toggle（翻转）</td></tr></tbody></table><p> <strong>JKFF特点：</strong></p><ol><li><strong>无无效状态</strong>：J&#x3D;1, K&#x3D;1 时，触发器的输出状态翻转，解决了SR触发器的争议状态问题。</li><li><strong>同步性</strong>：在时钟信号控制下工作，确保状态变化的同步。</li><li><strong>功能多样</strong>：可以通过J和K的输入实现保持、置1、清零、翻转等功能。</li></ol><p> <strong>JKFF结构组成：</strong></p><ul><li>由SR触发器扩展而来，增加了逻辑门以控制输入S和R，确保J&#x3D;1, K&#x3D;1 时实现输出翻转。</li><li>常采用 <strong>边沿触发（Edge-triggered）</strong> 的设计，使其适用于复杂的时序电路。</li></ul><p> <strong>JKFF应用场景：</strong></p><ol><li><strong>计数器</strong>：JK触发器在计数器电路中广泛应用，用于实现递增或递减计数。</li><li><strong>状态机</strong>：设计复杂的同步时序电路。</li><li><strong>分频器</strong>：利用J&#x3D;1, K&#x3D;1的翻转特性实现时钟信号分频。</li></ol><p>JK触发器的实现可以通过主从结构，由两个SR触发器级联完成。</p><img src="/img/DC/jkff.svg" alt="JKFF" style="max-width: 100%; height: auto;" />  <p>下面是<em>下降沿触发</em>的JKFF的时序图:</p><img src="/img/DC/jkff2.svg" alt="JKFF时序图" style="max-width: 100%; height: auto;" />  <p>我们可以得出JKFF的状态转移公式：</p><p>$$Q_{n+1} &#x3D; J\overline{Q_{n}} + \overline{k}Q_{n}$$</p><div class="note note-success">            <p>JKFF时序图口诀：00不变，11翻转，10置1，01置0</p>          </div><h4 id="3-2-4-T-Flip-Flop"><a href="#3-2-4-T-Flip-Flop" class="headerlink" title="3.2.4 T Flip-Flop"></a>3.2.4 T Flip-Flop</h4><p><strong>T触发器</strong>（Toggle Flip-Flop）是一种基本的时序逻辑电路，用于实现<strong>状态翻转</strong>或<strong>分频功能</strong>。</p><p><strong>TFF工作原理：</strong></p><ul><li><strong>T输入（Toggle）</strong>：用于控制触发器的翻转功能。<ul><li>T&#x3D;0：保持当前状态</li><li>T&#x3D;1：状态翻转</li></ul></li><li><strong>CLK（时钟信号）</strong>：控制T触发器的状态更新，输出仅在时钟信号的有效边沿发生变化。</li></ul><p><strong>TFF逻辑功能表：</strong></p><table><thead><tr><th>CLK（时钟）</th><th>T（输入）</th><th>$Q_{n}$（输出）</th><th>$Q_{n+1}$（下一状态）</th><th>状态描述</th></tr></thead><tbody><tr><td>上升沿</td><td>0</td><td>Q</td><td>保持</td><td>状态保持</td></tr><tr><td>上升沿</td><td>1</td><td>Q’</td><td>翻转</td><td>Toggle（翻转）</td></tr><tr><td>其他</td><td>-</td><td>保持</td><td>保持</td><td>状态不变</td></tr></tbody></table><p><strong>TFF特点：</strong></p><ol><li><strong>状态翻转</strong>：当T&#x3D;1时，输出状态在每个时钟边沿发生翻转。</li><li><strong>分频功能</strong>：每次翻转需要一个时钟信号，因此输出频率为输入时钟频率的一半。</li><li><strong>简化结构</strong>：通过将JK触发器的J和K输入连接为同一信号T，简化了设计。</li></ol><p><strong>TFF实现方式：</strong></p><ol><li><strong>由JK触发器实现</strong>：将J&#x3D;K&#x3D;T，形成T触发器的逻辑。</li><li><strong>直接实现</strong>：通过逻辑门电路设计，实现T输入控制翻转功能。</li></ol><p><strong>TFF应用场景：</strong></p><ol><li><strong>计数器</strong>：用于实现二进制计数器的单个计数位。</li><li><strong>分频器</strong>：将时钟信号的频率降低一半，用于时钟分频。</li><li><strong>状态机</strong>：在简单状态转换电路中用作基本单元。</li></ol><p>TFF的一种实现如下图：<br><img src="/img/DC/tff.svg" alt="TFF" style="max-width: 100%; height: auto;" />  </p><p>TFF的时序图如下：<br><img src="/img/DC/tff2.svg" alt="TFF Time Diagram" style="max-width: 100%; height: auto;" />  </p><p>我们可以得出TFF的状态转移方程式为：</p><p>$$Q_{n+1} &#x3D; T \oplus Q_{n}$$</p><h3 id="3-3-Synchronous-Sequential-Logic"><a href="#3-3-Synchronous-Sequential-Logic" class="headerlink" title="3.3 Synchronous Sequential Logic"></a>3.3 Synchronous Sequential Logic</h3><p>Synchronous Sequential Logic（同步时序逻辑）是一类数字逻辑电路，其输出不仅取决于当前的输入，还取决于电路的状态（通常存储在触发器中）。这种电路的状态变化由一个<u>全局时钟信号</u>同步控制。</p><p>同步时序电路可以设计为两种类型：</p><ul><li>Mealy电路：输出依赖于当前状态和输入（对应有限自动机中的 Mealy 机）。</li><li>Moore电路：输出<strong>仅依赖于</strong>当前状态（对应有限自动机中的 Moore 机）。</li></ul><div class="note note-success">            <p>记忆：摩尔庄园–&gt;摩尔当前–&gt;摩尔电路只依赖于当前状态</p>          </div><img src="/img/DC/fsm.svg" alt="FSM" style="max-width: 100%; height: auto;" />  <p>根据上图可以再深入理解一下两种有限状态机（Finite State Machine, FSM），举个例子，判断输出1是如何依赖的：</p><ul><li>Mealy型FSM输出1需要同时依赖<strong>当前状态</strong>和<strong>输入</strong><ul><li>当前状态B并且输入1，可以输出1</li><li>当前状态B并且输入0，可以输出1</li></ul></li><li>Moore型FSM输出1只依赖当前状态：<ul><li>当前状态是B是，输出1</li><li>当前状态是C，输出1</li></ul></li></ul><p>关于同步时序电路的设计一般有如下步骤：</p><ol><li>原始状态图</li><li>状态图化简（当两个状态具有同样的输入时，也具有相同的输出和相同的次态时，可以合并）</li><li>状态分配（画状态表的时候与卡诺图一一对应比较合理高效！例如00、01、11、10这样子）</li><li>选触发器（D、JK；3个状态选2个FF，5个状态选3个FF； $2^{n-1} &lt; M \leq 2^{n}$）</li><li>确定激励方程组以及输出方程组</li><li>画图✍️检查能否自启动</li></ol><p>常见的同步时序电路设计一般包含：计数器，序列检测器，串行数据检测器等。</p><div class="note note-primary">            <p>同步时序电路设计的思路都很固定，参考过去问巩固练习即可</p>          </div><p>计数器过去问典型题目：马不停蹄🐎</p><p>序列检测器典型题目：马不停蹄🐎</p><p>串行数据检测器典型题目：马不停蹄🐎</p><h3 id="3-4-Asynchronous-Sequential-Logic"><a href="#3-4-Asynchronous-Sequential-Logic" class="headerlink" title="3.4 Asynchronous Sequential Logic"></a>3.4 Asynchronous Sequential Logic</h3><p><strong>Asynchronous Sequential Logic（异步时序逻辑）</strong> 是一种不依赖全局时钟信号的逻辑电路设计。其状态的变化由输入信号的变化直接触发，而不是由时钟脉冲控制。与同步时序逻辑相比，异步逻辑更灵活，但设计和调试更复杂。</p><p><strong>异步时序逻辑特点：</strong></p><ol><li>无全局时钟信号：异步电路的状态变化完全由输入信号或内部信号的变化触发，而不需要时钟信号协调。</li><li>依赖传播延迟：异步逻辑的行为受门延迟和信号传播时间的影响，可能会导致竞争和冒险现象。</li><li>更快的响应速度：输入变化会立即影响输出，因此响应速度通常比同步电路快。</li><li>更复杂的设计：需要解决元态（Metastability）、竞争（Race Condition）和冒险（Hazard）问题，设计和验证复杂度较高。</li></ol><div class="note note-primary">            <p>修考基本很少考异步时序电路设计，参考过去问巩固练习。</p>          </div><p>异步时序电路设计题目：马不停蹄🐎</p><h2 id="4-偷偷说"><a href="#4-偷偷说" class="headerlink" title="4. 偷偷说"></a>4. 偷偷说</h2><p>数字电路的重点就是组合电路和时序电路的设计，在理解每个元件特性的基础上，设计类的题目都非常固定。数字电路的黑书说实话写的很差劲：一是逻辑不连贯，二是忽略了很多推导细节。相反，《論理回路入門》by：坂井 修一，这本书我觉得写的非常不错，短小精悍，非常适合修考备考。</p><p>Thanks <a href="https://github.com/jgraph/drawio-desktop">@drawio</a> for generating the powerful diagrams.</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Digital Circuit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Architecture</title>
    <link href="/2024/10/21/Computer-Architecture/"/>
    <url>/2024/10/21/Computer-Architecture/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h1><p>This is for test takers to quickly review Computer Architecture. The whole notes contain 5 parts and I try to make it clear and simple. Credit to《Computer Organization and Design : The Hardware&#x2F;Software Interface, 5th Edition》目前我也在<a href="https://www.xly-edu.com/">@新领域理工塾</a>，讲授这门课😇</p><blockquote><p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>在本章中，主要引入一下计算机组成的概念然后讲解衡量计算机的性能指标，并着重讲解涉及到的计量单位和公式。</p><h3 id="1-1-常用单位"><a href="#1-1-常用单位" class="headerlink" title="1.1 常用单位"></a>1.1 常用单位</h3><p>容量单位常用<strong>字节(Byte)</strong> ,衡量单位是<em>2进制(Binary)</em> ,容量之间的数量级关系是：$2^{10}$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如： $1TB&#x3D;2^{10} GB&#x3D; 1024GB$; $1GB&#x3D;2^{10}MB&#x3D;1024MB$</p></blockquote><p>衡量传输速度常用<strong>位每秒(bps,bit per secod)</strong> ,衡量单位是<em>10进制(Decimal)</em> ,传输速度之间的数量级关系是：$10^3$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如：$1kbit&#x2F;s&#x3D;1000bit&#x2F;s$, $1mbit&#x2F;s&#x3D;1000kbit&#x2F;s$</p></blockquote><p>另外需要注意的单位换算是：</p><ul><li>$bit&#x2F;s$记作$bps$</li><li>$1 Byte &#x3D; 8 bit$</li><li>$1 Bps &#x3D; 1 Byte&#x2F;second &#x3D; 8 bit&#x2F;second &#x3D; 8 bps$</li></ul><h3 id="1-2-计算机结构中的8个伟大思想"><a href="#1-2-计算机结构中的8个伟大思想" class="headerlink" title="1.2 计算机结构中的8个伟大思想"></a>1.2 计算机结构中的8个伟大思想</h3><ul><li>Moore’s Law: 芯片上的集成度每18～24个月翻一番</li><li>Abstraction：使用抽象来表示不同设计层次，化繁为简</li><li>Common Case Fast: 加速大概率事件远比优化小概率事件更能提高性能，即抓住主要矛盾</li><li>Parallel Performance: 并行操作来提高性能，说白了就是<del>打工人能做多少做多少</del></li><li>Pipeline: 这是一个并行场景的具体实现，后面章节会详细讲解🔎</li><li>Prediction：通过猜测的方式提前启动某些操作，提高性能，投资人讲究一个增收降本的策略。</li><li>Hierachy of memory: 用存储器层次来解决容量，速度，成本之间的相互矛盾需求。小而精则贵，大而糙则贱</li><li>Dependable：任何一个物理器件都有可能失效，使用冗余部件的方式来提高系统的可靠性，即备胎🛞</li></ul><p>在加速大概率事件中有一个定量分析的<strong>Amdahl定律</strong>：</p><center>$改进后的执行时间 = 改进影响的执行时间 / 加速比 + 改进不影响的执行时间$</center><center>$t_{\text{改进}} = t_{\text{相关}} / S + t_{\text{无关}}$</center><h3 id="1-3-计算机语言"><a href="#1-3-计算机语言" class="headerlink" title="1.3 计算机语言"></a>1.3 计算机语言</h3><p>计算机语言主要分为三类：<strong>高级语言</strong>、<strong>汇编语言</strong>和<strong>机器语言</strong>。程序执行的过程是先将高级语言编译为汇编语言，然后通过汇编，将汇编语言转化为相应的机器语言。</p><h4 id="1-3-1-高级语言-High-level-programming-language"><a href="#1-3-1-高级语言-High-level-programming-language" class="headerlink" title="1.3.1 高级语言(High-level programming language)"></a>1.3.1 高级语言(High-level programming language)</h4><p>最接近人类自然语言的编程语言。常见的高级语言包括C++, Java, Python, 和JavaScript。</p><h4 id="1-3-2-汇编语言-Assembly-language"><a href="#1-3-2-汇编语言-Assembly-language" class="headerlink" title="1.3.2 汇编语言(Assembly language)"></a>1.3.2 汇编语言(Assembly language)</h4><p>汇编语言是一种低级编程语言，它直接对应于机器语言，但使用人类更易理解的符号和短语来表示。每条汇编指令通常都对应一条机器语言指令，因此汇编语言被认为是机器语言的符号表示。汇编语言需要使用汇编器（Assembler）将代码转换为机器语言。这种语言通常用于编写需要精确控制硬件的程序，如操作系统内核和驱动程序。汇编语言的分类一般有两种主要类型：<strong>RISC指令集（Reduced Instruction Set Computing）</strong> 和 <strong>CISC指令集（Complex Instruction Set Computing）</strong>。</p><ul><li><strong>RISC指令集：</strong> 即简化指令集计算（Reduced Instruction Set Computing）：这种类型的指令集特点是<em>指令集较为简单，每条指令执行时间固定而短，通常在一个时钟周期内完成</em>。这使得RISC处理器能够更快速地执行大量简单的指令。代表性的RISC架构包括<u>ARM、MIPS和SPARC。</u></li><li><strong>CISC指令集：</strong>即复杂指令集计算（Complex Instruction Set Computing），这种类型的指令集特点是指令集复杂，每条指令可能<em>需要多个时钟周期</em>才能完成执行。CISC处理器通过一个复杂的指令集试图降低编程的复杂性，使得某些复杂操作能通过一条指令完成。典型的CISC架构包括<u>x86和VAX。</u></li></ul><div class="note note-success">            <p>在修考中，出现的汇编语言是RISC指令集，因此在后序章节只讲解RISC指令</p>          </div><h4 id="1-3-3-机器语言-Machine-language"><a href="#1-3-3-机器语言-Machine-language" class="headerlink" title="1.3.3 机器语言(Machine language)"></a>1.3.3 机器语言(Machine language)</h4><p>机器语言是计算机能够直接执行的最底层编程语言。它由二进制代码组成，每条指令由一串0和1表示（eg. 00000111111010001），直接控制计算机的硬件操作。由于其复杂性和难以阅读，人类很少直接编写机器语言程序。</p><blockquote><p>总结：高级语言编译为汇编语言，然后汇编语言通过汇编转化为由01串组成的机器语言</p></blockquote><h3 id="1-4-冯·诺伊曼结构-Von-Neumann-architecture"><a href="#1-4-冯·诺伊曼结构-Von-Neumann-architecture" class="headerlink" title="1.4 冯·诺伊曼结构(Von Neumann architecture)"></a>1.4 冯·诺伊曼结构(Von Neumann architecture)</h3><img src="/img/CA/von.svg" alt="冯诺伊曼结构" style="max-width: 100%; height: auto;" /><p><strong>输入设备(Input Devices)</strong> 是用于向计算机输入数据和指令的硬件。例如，键盘（Keyboard）、鼠标（Mouse）、扫描仪（Scanner）、话筒（Microphone）等。它们将用户的操作转化为计算机能够理解的信号。</p><p><strong>输出设备(Output Devices)</strong> 是用于从计算机输出数据和结果的硬件。例如，显示器（Monitor）、打印机（Printer）、扬声器（Speakers）等。它们将计算机处理后的数据转化为用户可以理解的信息。</p><p><strong>控制器(Control Unit, CU)</strong> 是负责从存储器读取指令，并解释和执行指令的计算机部件。它管理和协调计算机的各个部分，以确保指令被按顺序执行。</p><p><strong>运算器(Arithmetic Logic Unit, ALU)</strong> 是执行算术运算和逻辑运算的核心部件。它能处理整数和浮点数的加、减、乘、除等运算，也能进行与、或、非等逻辑运算。</p><p><strong>存储器(Memory)</strong> 是存储数据和指令的地方。分为主存储器（Main Memory）和辅助存储器（Secondary Storage）。主存储器（如RAM，随机存取存储器，Random Access Memory）用于存储当前正在使用的数据和指令；辅助存储器（如硬盘，Hard Disk Drive）用于长期存储数据。</p><p><strong>中央处理器(Central Processing Unit, CPU)</strong> 是计算机的“大脑”，负责解释和执行指令。它由控制器（Control Unit, CU）和运算器（Arithmetic Logic Unit, ALU）组成，管理并处理所有的计算任务。</p><h3 id="1-5-计算机性能指标"><a href="#1-5-计算机性能指标" class="headerlink" title="1.5 计算机性能指标"></a>1.5 计算机性能指标</h3><p><strong>响应时间（Response Time）：</strong> 响应时间，又称执行时间，是指系统从接收到请求到开始产生输出结果所经过的时间。</p><p><strong>吞吐率（Throughput）：</strong> 吞吐率是指在单位时间内系统能够处理的请求数量。它衡量的是系统的处理能力。高吞吐率意味着在同样的时间内，系统能够处理更多的请求或完成更多的工作。</p><p><strong>CPU性能公式(Performance)：</strong></p><center>$CPU性能 = 1 / 执行时间$</center><p>A的性能比B的性能高$X$倍计算：  $X&#x3D;t_{B执行时间}&#x2F;t_{A执行时间}$</p><p><strong>时钟周期长度(Clock Cycle Length):</strong><br>是指计算机时钟信号中相邻两个相同状态（如两个上升沿）之间的时间间隔。CPU做的任何动作所消耗的时间都是一个时钟周期的整数倍。通常以纳秒（ns）为单位,记作 $T$</p><p><strong>时钟周期频率(Clock Cycle Frequency):</strong><br>则是时钟信号每秒钟振荡的次数，通常以赫兹（Hz）为单位。它是时钟周期长度的倒数。例如，如果时钟周期长度是2纳秒，那么时钟频率就是0.5 GHz,记作 $f$</p><p>两者之间的关系是：</p><ul><li><p>时钟周期长度 &#x3D; 1 &#x2F; 时钟周期频率, 即 $T &#x3D; 1 &#x2F; f$</p></li><li><p>时钟周期频率 &#x3D; 1 &#x2F; 时钟周期长度, 即 $f &#x3D; 1 &#x2F; T$</p></li></ul><p><strong>CPI(Cycles Per Instruction):</strong><br>是计算机性能指标，用于衡量每条指令所需的平均时钟周期数。它反映了CPU执行指令的效率。CPI的计算公式是：</p><center>$ \text{CPI} = \frac{\text{总时钟周期数}}{\text{指令数}} $</center><p><strong>时钟周期数计算公式(Clock Cycle):</strong></p><center>$Clock Cycle=指令数\times平均每条指令所需周期数 = IC \times CPI$</center><blockquote><p>注：指令数(Instruction Count, IC)是指CPU在执行一个程序时，需要执行的指令总数。</p></blockquote><p><strong>CPU执行时间：</strong></p><center>$ \text{CPU Time} = \text{指令数} \times \text{CPI} \times \text{时钟周期长度} = IC \times CPI \times T = IC \times CPI / f$</center><p>还有一个衡量指标<strong>是MIPS(million instructions per second)</strong>:</p><center>$ MIPS = IC / (\text{CPU Time} \times 10^{6}) = f / (CPI \times 10^{6})$</center><p><strong>功耗计算公式：</strong> 记住就行</p><center> $P = \frac{1}{2} \times U^2 \times f$</center><blockquote><p>注： $P$ 是功耗，$C$ 是负载电容， $U$ 是电压， $f$ 是开关频率</p></blockquote><h2 id="2-Instructions-The-Language-of-Computers"><a href="#2-Instructions-The-Language-of-Computers" class="headerlink" title="2. Instructions: The Language of Computers"></a>2. Instructions: The Language of Computers</h2><p>这一章非常重要，因为修考题目中经常出现理解汇编语言的题目。本章主要讲解RISC-V指令集架构还有五种寻址方式</p><h3 id="2-1-Instrcucton"><a href="#2-1-Instrcucton" class="headerlink" title="2.1 Instrcucton"></a>2.1 Instrcucton</h3><p>计算机在底层执行程序时，通过读取由0和1组成的机器指令来执行命令。在RISC-V指令集中，所有的机器指令都是32位长，也就是32位的二进制串。这些32位的机器指令对应的汇编语言指令通常由操作码和两个地址码组成（形式：操作码 + 地址码 + 地址码）。规定：</p><ul><li>程序中的变量存放在保存寄存器（store reg）中：$s0~$s7共8个</li><li>临时变量，中间变量存放在临时寄存器（temp reg）中：$t0~$t7共8个</li><li>零寄存器，永远存放32位的0，记作$zero</li></ul><h3 id="2-2-RISC-V-Instruction-Set"><a href="#2-2-RISC-V-Instruction-Set" class="headerlink" title="2.2 RISC-V Instruction Set"></a>2.2 RISC-V Instruction Set</h3><h4 id="2-2-1-基本指令"><a href="#2-2-1-基本指令" class="headerlink" title="2.2.1 基本指令"></a>2.2.1 基本指令</h4><p><strong>加法，减法指令(add, sub):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; c &#x3D; a + b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; badd $s2, $s0, $s1  &#x2F;&#x2F; c &#x3D; a - b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; bsub $s2, $s0, $s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>加立即数指令(addi):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; i &#x3D; i + 1, i存放在$s0寄存器中addi $s0, $s0, 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>逻辑运算指令:</strong> and(与)，or(或)，nor（或非）</p><p><strong>逻辑左移(shift left logic, sll)和右移(shift right logic, srl):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sll $to, $s2, 2 &#x2F;&#x2F; 将$s2寄存器的值左移2位，即变为4倍，存放在$t0中srl $to, $s2, 1 &#x2F;&#x2F; 将$s2寄存器的值右移1位，即变为1&#x2F;2倍，存放在$t0中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>取字指令(load word, lw)和存字指令(save word, sw):</strong><br>因为寄存器是按字(Word)存储，而内存是按字节(Byte)编址,在RISC-V指令集中，约定：1 Word &#x3D; 32 bit &#x3D; 4 Byte。</p><blockquote><p>举个例子：已知a[0]的地址存放在寄存器s0中，现在需要取a[2]的值存放在寄存器t0中；a[2]和a[0]之间的字节偏移有 2 * 4 &#x3D; 8 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw $t0, 8($s0)  &#x2F;&#x2F; 取出$s0偏移8字节的位置的值，存放在$t0寄存器中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><blockquote><p>同理，如果我们要把t0寄存器的值存到a[4]中去，可以知道a[4]与a[0]的字节偏移有 4 * 4 &#x3D; 16 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw $t0, 16($s0) &#x2F;&#x2F; 注意操作的方向和lw相反<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="2-2-2-装载32位立即数到寄存器"><a href="#2-2-2-装载32位立即数到寄存器" class="headerlink" title="2.2.2 装载32位立即数到寄存器"></a>2.2.2 装载32位立即数到寄存器</h4><p>因为装载的32位立即数不能完全放进32位的机器指令中，因此寄存器可以通过两条指令来完成：LUI (Load Upper Immediate) 和 ORI (OR Immediate)。比如将立即数 0xF7EE57AD 装载到寄存器中这个两个指令需要完成的动作是：</p><blockquote><p>0xF7EE57AD 对应的 32 位二进制数是：1111 0111 1110 1110 0101 0111 1010 1101</p></blockquote><ul><li><p>LUI 指令：取0xF7EE57AD的高16位数（1111 0111 1110 1110) 放入寄存器的高16位</p></li><li><p>ORI 指令：将寄存器和剩下的低16位数做立即与的动作(0101 0111 1010 1101)</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $s1, 63470 &#x2F;&#x2F; 1111 0111 1110 1110 对应的十进制数是 63470ori $s1, 22957 &#x2F;&#x2F; 0101 0111 1010 1101 对应的十进制数是 22957&#x2F;* 整个动作如下：step1: 取到高16位数，$s1的值为 1111 0111 1110 1110 0000 0000 0000 0000step2: $s1的值与低16位数立即与 0000 0000 0000 0000 0101 0111 1010 1101最终$s1的值为 1111 0111 1110 1110 0101 0111 1010 1101*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然还有其他写法：比如lui和addi。例如，要将立即数 0x12345678 装载到寄存器 t0 中</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $t0, 0x12345 &#x2F;&#x2F; 将高20位0x12345装载到t0addi $t0, $t0, 0x678 &#x2F;&#x2F; 将剩余的12位0x678添加到t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li></ul><h4 id="2-2-3-判断和决策指令"><a href="#2-2-3-判断和决策指令" class="headerlink" title="2.2.3 判断和决策指令"></a>2.2.3 判断和决策指令</h4><p><strong>BEQ（Branch if Equal） 指令：</strong></p><ul><li><strong>功能</strong>：比较两个寄存器的值，如果它们相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>beq rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">beq $t0, $t1, label &#x2F;&#x2F; 如果t0和t1相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>BNE（Branch if Not Equal） 指令：</strong></li></ul></li><li><strong>功能</strong>：比较两个寄存器的值，如果它们不相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>bne rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">bne $t0, $t1, label &#x2F;&#x2F; 如果t0和t1不相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>小于则置位(set less than, slt)：</strong></li></ul></li></ul><p><strong>功能</strong>：将两个寄存器中的值进行比较，如果第一个寄存器的值小于第二个寄存器的值，则将目标寄存器设为1，否则设为0。</p><ul><li><strong>格式</strong>：<code>slt rd, rs1, rs2</code><ul><li><code>rd</code>：目标寄存器</li><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">slt $t0, $t1, $t2 &#x2F;&#x2F; 如果t1 &lt; t2，则将t0设为1；否则设为0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>J指令(JUMP)</strong></p><ul><li><strong>功能</strong>：无条件跳转到指定的目标地址。这个指令改变了程序的执行流程，立即将控制转移到指定的地址。</li><li><strong>格式</strong>：<code>j offset</code><ul><li><code>offset</code>：相对当前地址的跳转偏移量</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j label &#x2F;&#x2F; 无条件跳转到label标记的位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-3-Assembly-language-and-High-level-programming-language"><a href="#2-3-Assembly-language-and-High-level-programming-language" class="headerlink" title="2.3 Assembly language and High-level programming language"></a>2.3 Assembly language and High-level programming language</h3><p>举个例子，有C++代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value3 <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t0 <span class="token operator">=</span> value1<span class="token punctuation">;</span>    <span class="token keyword">int</span> t1 <span class="token operator">=</span> value2<span class="token punctuation">;</span>    <span class="token keyword">int</span> t2 <span class="token operator">=</span> t0 <span class="token operator">+</span> t1<span class="token punctuation">;</span> <span class="token comment">// t2 = t0 + t1</span>    <span class="token keyword">int</span> t3 <span class="token operator">=</span> t1 <span class="token operator">-</span> t0<span class="token punctuation">;</span> <span class="token comment">// t3 = t1 - t0</span>    <span class="token keyword">int</span> t4 <span class="token operator">=</span> t0 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment">// t4 = t0 + 4</span>    <span class="token keyword">int</span> t5 <span class="token operator">=</span> t0 <span class="token operator">&amp;</span> t1<span class="token punctuation">;</span> <span class="token comment">// t5 = t0 AND t1</span>    <span class="token keyword">int</span> t6 <span class="token operator">=</span> t0 <span class="token operator">|</span> t1<span class="token punctuation">;</span> <span class="token comment">// t6 = t0 OR t1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t0 <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> ELSE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> main<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>ELSE<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于 nop)</span>    <span class="token keyword">goto</span> EXIT<span class="token punctuation">;</span>main<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于循环到 main)</span>EXIT<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于结束)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>其对应的汇编语言是</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.datavalue1: .word 5value2: .word 10value3: .word 15.textmain:    lw $t0, value1      # 将value1的值加载到$t0    lw $t1, value2      # 将value2的值加载到$t1    add $t2, $t0, $t1     # $t2 &#x3D; $t0 + $t1    sub $t3, $t1, $t0     # $t3 &#x3D; $t1 - $t0    addi $t4, $t0, 4     # $t4 &#x3D; $t0 + 4    and $t5, $t0, $t1     # $t5 &#x3D; $t0 AND $t1    or $t6, $t0, $t1      # $t6 &#x3D; $t0 OR $t1    beq $t0, $t1, ELSE   # 如果$t0 &#x3D;&#x3D; $t1，则跳转到ELSE    bne $t0, $t1, main   # 如果$t0 !&#x3D; $t1，则跳转到mainELSE:    j EXIT             # 无条件跳转到EXITEXIT:    nop                # 无操作（用于占位）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-4-Three-Instruction-Formats"><a href="#2-4-Three-Instruction-Formats" class="headerlink" title="2.4 Three Instruction Formats"></a>2.4 Three Instruction Formats</h3><p>在汇编语言中，主要有三种指令格式：R型指令、I型指令和J型指令。每种格式有特定的结构，用于不同类型的操作。</p><h4 id="2-4-1-R-type-Register-Instructions"><a href="#2-4-1-R-type-Register-Instructions" class="headerlink" title="2.4.1 R-type (Register) Instructions"></a>2.4.1 R-type (Register) Instructions</h4><ul><li><strong>目的</strong>：用于需要三个寄存器的算术和逻辑操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：第一个源寄存器。</li><li><code>rs2</code>：第二个源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>funct3</code> 和 <code>funct7</code>：附加功能代码，用于指定具体操作。</li></ul></li><li><strong>例子</strong>：<code>add rd, rs1, rs2</code> <ul><li>将 <code>rs1</code> 和 <code>rs2</code> 中的内容相加，并将结果存储在 <code>rd</code> 中。</li></ul></li></ul><h4 id="2-4-2-I-type-Immediate-Instructions"><a href="#2-4-2-I-type-Immediate-Instructions" class="headerlink" title="2.4.2 I-type (Immediate) Instructions"></a>2.4.2 I-type (Immediate) Instructions</h4><ul><li><strong>目的</strong>：用于带有立即数（嵌入指令中的常数）的操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>imm</code>：立即数（常数）。</li><li><code>funct3</code>：附加功能代码。</li></ul></li><li><strong>例子</strong>：<code>addi rd, rs1, imm</code><ul><li>将 <code>rs1</code> 和 <code>imm</code> 的内容相加，并将结果存储在 <code>rd</code></li></ul></li></ul><h4 id="2-4-3-J-type-Jump-Instructions"><a href="#2-4-3-J-type-Jump-Instructions" class="headerlink" title="2.4.3 J-type (Jump) Instructions"></a>2.4.3 J-type (Jump) Instructions</h4><ul><li><strong>目的</strong>：用于修改程序控制流的跳转操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>offset</code>：跳转偏移量。</li></ul></li><li><strong>例子</strong>：<code>j offset</code><ul><li>跳转到通过将 <code>offset</code> 添加到当前程序计数器（PC）计算出的地址。</li></ul></li></ul><h3 id="2-5-Five-Addressing-Modes"><a href="#2-5-Five-Addressing-Modes" class="headerlink" title="2.5 Five Addressing Modes"></a>2.5 Five Addressing Modes</h3><h4 id="2-5-1-立即寻址（Immediate-Addressing）"><a href="#2-5-1-立即寻址（Immediate-Addressing）" class="headerlink" title="2.5.1 立即寻址（Immediate Addressing）"></a>2.5.1 立即寻址（Immediate Addressing）</h4><ul><li><strong>定义</strong>：操作数直接在指令中给出。</li><li><strong>例子</strong>：<code>MOV AL, 5</code><ul><li>这里，数值 <code>5</code> 直接被移动到寄存器 <code>AL</code> 中。</li></ul></li></ul><h4 id="2-5-2-直接寻址（Direct-Addressing）"><a href="#2-5-2-直接寻址（Direct-Addressing）" class="headerlink" title="2.5.2 直接寻址（Direct Addressing）"></a>2.5.2 直接寻址（Direct Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址在指令中明确给出。</li><li><strong>例子</strong>：<code>MOV AX, [1234H]</code><ul><li>该指令将内存地址 <code>1234H</code> 的值移动到寄存器 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-3-间接寻址（Indirect-Addressing）"><a href="#2-5-3-间接寻址（Indirect-Addressing）" class="headerlink" title="2.5.3 间接寻址（Indirect Addressing）"></a>2.5.3 间接寻址（Indirect Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址存储在寄存器或内存位置中。</li><li><strong>例子</strong>：<code>MOV AX, [BX]</code><ul><li>内存位置 <code>[BX]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-4-索引寻址（Indexed-Addressing）"><a href="#2-5-4-索引寻址（Indexed-Addressing）" class="headerlink" title="2.5.4 索引寻址（Indexed Addressing）"></a>2.5.4 索引寻址（Indexed Addressing）</h4><ul><li><strong>定义</strong>：操作数的最终地址由寄存器内容与常数相加生成。</li><li><strong>例子</strong>：<code>MOV AX, [SI+20H]</code><ul><li>内存位置 <code>[SI + 20H]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-5-寄存器寻址（Register-Addressing）"><a href="#2-5-5-寄存器寻址（Register-Addressing）" class="headerlink" title="2.5.5 寄存器寻址（Register Addressing）"></a>2.5.5 寄存器寻址（Register Addressing）</h4><ul><li><strong>定义</strong>：操作数位于寄存器中，寄存器在指令中直接指定。</li><li><strong>例子</strong>：<code>MOV AX, BX</code><ul><li><code>BX</code> 中的值被移动到 <code>AX</code></li></ul></li></ul><div class="note note-primary">            <p>程序计数器PC在取指令时会自增4（每条指令是4字节），因此，下一条指令的地址是PC + 4。若当前指令需要进行跳转或分支，字地址偏移量则用于计算目标地址。具体来说，如果你有一个偏移量offset，在跳转指令中，你通常会将其左移2位（因为地址是字节为单位的），然后加到PC + 4上来获得目标地址。</p>          </div><h2 id="3-Arithmetic-Operations-in-Computers"><a href="#3-Arithmetic-Operations-in-Computers" class="headerlink" title="3. Arithmetic Operations in Computers"></a>3. Arithmetic Operations in Computers</h2><p>本章主要讲解的知识点有，计算机是如何表示整数和进行整数运算的，以及浮点数的表示规范。本章在修考的考察非常精细，一定要理清每种数的表示。下面的例子都用8bit来表示并且给出对应的表示范围。</p><h3 id="3-1-Integer-Representation"><a href="#3-1-Integer-Representation" class="headerlink" title="3.1 Integer Representation"></a>3.1 Integer Representation</h3><p>本小节介绍无符号整数、原码、反码和补码的表示方法。</p><h4 id="3-1-1-无符号整数（Unsigned-Integer）"><a href="#3-1-1-无符号整数（Unsigned-Integer）" class="headerlink" title="3.1.1 无符号整数（Unsigned Integer）"></a>3.1.1 无符号整数（Unsigned Integer）</h4><p><strong>表示方法</strong>：<br>无符号整数只表示<strong>非负数</strong>，使用所有位表示数值，不用负号。8位无符号整数的取值范围是从0到255。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$0$</li><li>最大值：$2^8 - 1 &#x3D; 255$</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的无符号表示：<code>00000101</code></li><li>十进制数255的无符号表示：<code>11111111</code></li></ul><h4 id="3-1-2-原码（Sign-Magnitude）"><a href="#3-1-2-原码（Sign-Magnitude）" class="headerlink" title="3.1.2 原码（Sign-Magnitude）"></a>3.1.2 原码（Sign-Magnitude）</h4><p><strong>表示方法</strong>：<br>原码使用最高位作为符号位（0表示正数，1表示负数），其余位表示数值的绝对值。对于8位原码，正数的最高位是0，负数的最高位是1。因此原码有$+0$和$-0$两种表示方法，分别是$00000000$,$10000000$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>1111111</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的原码表示：<code>00000101</code></li><li>十进制数-5的原码表示：<code>10000101</code></li></ul><h4 id="3-1-3-反码（One’s-Complement）"><a href="#3-1-3-反码（One’s-Complement）" class="headerlink" title="3.1.3 反码（One’s Complement）"></a>3.1.3 反码（One’s Complement）</h4><p><strong>表示方法</strong>：<br>反码对正数和负数的表示方法稍有不同。正数的反码与原码相同，负数的反码是将其绝对值的原码的每一位取反（0变1，1变0）。因此反码有也有$+0$和$-0$两种表示方法，分别是$00000000$和$11111111$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>10000000</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的反码表示：<code>00000101</code></li><li>十进制数-5的反码表示：<code>11111010</code>（原码<code>00000101</code>取反）</li></ul><h4 id="3-1-4-补码（Two’s-Complement）"><a href="#3-1-4-补码（Two’s-Complement）" class="headerlink" title="3.1.4 补码（Two’s Complement）"></a>3.1.4 补码（Two’s Complement）</h4><p><strong>表示方法</strong>：<br>补码是最常用的负数表示方法。正数的补码与原码相同，负数的补码是其绝对值的原码取反后加1。补码的意义是<em>消除原码和反码有2种零的表示方法</em>，可以用于直接计算。计算机都是用补码进行整数加减运算。因为补码只有一种$0$的表示方法，因此负数的表示范围会比整数多一个。</p><blockquote><p>补码非常爱考的一个点：$11111111$(-1), $10000000$(-128,因为超出8位范围), $00000000$(0)</p></blockquote><p><strong>表示范围</strong>：</p><ul><li>最小值：$-128$（<code>10000000</code>），🚨重中之重</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的补码表示：<code>00000101</code></li><li>十进制数-5的补码表示：<code>11111011</code>（原码<code>00000101</code>取反后加1）</li></ul><h4 id="3-1-5-表示方法总结"><a href="#3-1-5-表示方法总结" class="headerlink" title="3.1.5 表示方法总结"></a>3.1.5 表示方法总结</h4><table><thead><tr><th>表示法</th><th>最小值</th><th>最大值</th><th>示例 - 正数</th><th>示例 - 负数</th><th>0的表示个数</th></tr></thead><tbody><tr><td>无符号整数</td><td>0</td><td>255</td><td><code>00000101</code> (5)</td><td>N&#x2F;A</td><td>1</td></tr><tr><td>原码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>10000101</code> (-5)</td><td>2</td></tr><tr><td>反码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111010</code> (-5)</td><td>2</td></tr><tr><td>补码</td><td>-128</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111011</code> (-5)</td><td>1</td></tr></tbody></table><h3 id="3-2-符号位扩展与大小端编址"><a href="#3-2-符号位扩展与大小端编址" class="headerlink" title="3.2 符号位扩展与大小端编址"></a>3.2 符号位扩展与大小端编址</h3><p>这几个考点经常出现在题目的开胃前菜，是很容易忽略的一个考点，切记切记。</p><h4 id="3-2-1-符号位扩展（sign-extension）"><a href="#3-2-1-符号位扩展（sign-extension）" class="headerlink" title="3.2.1 符号位扩展（sign extension）"></a>3.2.1 符号位扩展（sign extension）</h4><p><strong>符号位扩展（sign extension）</strong> 是指在将带符号的数从较小的位数扩展到较大位数时，保持其数值的正负性。这个过程通常在处理数值的运算或数据类型转换时使用。<br>填充高位：</p><ul><li>如果符号位为0，扩展时在左边填充0。</li><li>如果符号位为1，扩展时在左边填充1。<br>假设我们要将一个8位的补码数扩展到16位：</li></ul><p><strong>8位正数</strong></p><ul><li>原数：<code>00001010</code>（十进制10）</li><li>扩展后：<code>00000000 00001010</code>（仍然是十进制10）</li></ul><p><strong>8位负数</strong></p><ul><li>原数：<code>11111010</code>（十进制-6）</li><li>扩展后：<code>11111111 11111010</code>（仍然是十进制-6）</li></ul><h4 id="3-2-2-大端编址（Big-endian）和小端编址（Little-endian）"><a href="#3-2-2-大端编址（Big-endian）和小端编址（Little-endian）" class="headerlink" title="3.2.2 大端编址（Big-endian）和小端编址（Little-endian）"></a>3.2.2 大端编址（Big-endian）和小端编址（Little-endian）</h4><p>大端编址（Big-endian）和小端编址（Little-endian）是两种不同的数据存储方式，决定了多字节数据在内存中的排列顺序。</p><p><strong>大端编址（Big-endian）</strong></p><ul><li><strong>定义</strong>：在大端模式下，数据的高位字节存储在低地址，低位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>12</code></li><li>地址 <code>0x01</code>：<code>34</code></li><li>地址 <code>0x02</code>：<code>56</code></li><li>地址 <code>0x03</code>：<code>78</code></li></ul></li></ul><p><strong>小端编址（Little-endian）</strong></p><ul><li><strong>定义</strong>：在小端模式下，数据的低位字节存储在低地址，高位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>78</code></li><li>地址 <code>0x01</code>：<code>56</code></li><li>地址 <code>0x02</code>：<code>34</code></li><li>地址 <code>0x03</code>：<code>12</code></li></ul></li></ul><p><strong>应用</strong></p><ul><li><strong>大端</strong>：常用于网络协议（如TCP&#x2F;IP），因为网络字节顺序采用大端。</li><li><strong>小端</strong>：通常用于个人电脑（如x86架构的处理器）。</li></ul><img src="/img/CA/endianness.svg" alt="大端和小端序" style="max-width: 100%; height: auto;" /><h3 id="3-3-Arithmetic-Operations-Logic"><a href="#3-3-Arithmetic-Operations-Logic" class="headerlink" title="3.3 Arithmetic Operations Logic"></a>3.3 Arithmetic Operations Logic</h3><p>参照<a href="https://toutou.zeabur.app/2024/11/04/Digital-Circuit/">数字电路笔记</a>第二章的算术运算实现</p><h3 id="3-4-IEEE754-Float-Point-Number"><a href="#3-4-IEEE754-Float-Point-Number" class="headerlink" title="3.4 IEEE754 Float Point Number"></a>3.4 IEEE754 Float Point Number</h3><p><strong>IEEE 754 单精度浮点数</strong></p><p>IEEE 754 单精度浮点数总共32位：1位符号位（S），8位指数位（E），23位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为127，即实际的指数值是存储的指数值减去127。<ul><li>例如，如果指数部分存储的是10000001（二进制的129），实际的指数就是129-127&#x3D;2。</li></ul></li><li><strong>尾数位（F）</strong>：23位，表示小数部分。注意尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 127)} \times 1.F$ </center><p><strong>IEEE 754 双精度浮点数</strong></p><p>IEEE 754 双精度浮点数总共64位：1位符号位（S），11位指数位（E），52位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为1023，即实际的指数值是存储的指数值减去1023。<ul><li>例如，如果指数部分存储的是10000000010（二进制的1026），实际的指数就是1026-1023&#x3D;3。</li></ul></li><li><strong>尾数位（F）</strong>：52位，表示小数部分。尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 1023)} \times 1.F$ </center><img src="/img/CA/float.svg" alt="浮点数表示格式" style="max-width: 100%; height: auto;" /><blockquote><p>思考：为什么需要偏阶值(Bias)的存在？</p></blockquote><p>偏阶（Bias）的存在主要是为了简化浮点数的比较和计算过程。以下是几个具体原因：</p><ol><li><p><strong>简化比较操作</strong>：<br>通过使用偏阶，所有可能的指数值都被映射到一个非负范围内，使得比较浮点数时可以简单地比较其指数部分的数值。例如，对于单精度浮点数，偏阶127确保了指数范围从 -127 到 128 被映射到 0 到 255。</p></li><li><p><strong>标准化表示</strong>：<br>使用偏阶可以确保指数部分总是一个非负数，从而使浮点数表示更为统一和标准化。这对于硬件电路设计和算法实现有很大的便利性。</p></li><li><p><strong>处理负指数</strong>：<br>偏阶允许使用非负整数来表示负指数，这对表示非常小的浮点数（接近于0）尤其有用。通过偏阶值，可以直接在指数部分进行加法和减法，而不需要额外处理负数。</p></li></ol><p>举个例子，对于单精度浮点数，偏阶是127。这意味着：</p><ul><li>实际指数为0时，存储的指数值是127。</li><li>实际指数为-1时，存储的指数值是126。</li><li>实际指数为+1时，存储的指数值是128。</li></ul><p>这种设计大大简化了计算和比较过程，让浮点运算变得高效和准确。</p><h2 id="4-Processor"><a href="#4-Processor" class="headerlink" title="4.  Processor"></a>4.  Processor</h2><p>MIPS是一种采取RISC的架构。MIPS 处理器的指令执行过程被分为<strong>五个主要阶段。</strong> 通过流水线的设计，MIPS 能够在每个时钟周期执行多个指令阶段，从而提升性能。以下是每个阶段的详细说明：</p><h3 id="4-1-指令周期分解"><a href="#4-1-指令周期分解" class="headerlink" title="4.1 指令周期分解"></a>4.1 指令周期分解</h3><ol><li><p><strong>取指令（IF，Instruction Fetch）</strong></p><ul><li>从指令存储器中读取当前指令，将其载入到指令寄存器（IR，Instruction Register）中。</li><li>将程序计数器（PC）更新为下一条指令的地址，一般为当前 PC 值加 4（因为每条指令长度固定为 4 字节）。</li><li>在这个阶段，通常也会将 PC 的值保存，以备后续的跳转或分支指令使用。</li></ul></li><li><p><strong>指令译码（ID，Instruction Decode）</strong></p><ul><li>解析指令的操作码（opcode），以确定指令类型和具体的操作。</li><li>从寄存器文件中读取操作数（源寄存器数据）。在 R 型指令中读取两个寄存器，而 I 型和 J 型指令则根据需求读取一个或不读取。</li><li>进行分支地址的计算（PC + 偏移量），以备可能的跳转或分支指令使用。</li><li>根据指令类型生成控制信号，控制信号会影响后续各个阶段的具体操作。</li></ul></li><li><p><strong>执行（EX，Execute）</strong></p><ul><li><strong>算术或逻辑操作</strong>：如果是算术或逻辑指令，ALU（算术逻辑单元）执行相应操作，例如加法、减法、与或非等。</li><li><strong>内存地址计算</strong>：若是加载或存储指令，ALU 计算内存访问的目标地址（基地址 + 偏移量）。</li><li><strong>分支判断</strong>：若是分支指令，在 ALU 进行判断后决定是否采用分支地址。</li><li>这一阶段的结果（例如运算结果或目标地址）将传递给下一阶段。</li></ul></li><li><p><strong>访存（MEM，Memory Access）</strong></p><ul><li><strong>加载指令</strong>：如果是加载指令（如 <code>lw</code>），从内存中读取数据，并将其存入一个临时寄存器。</li><li><strong>存储指令</strong>：如果是存储指令（如 <code>sw</code>），将寄存器中的数据写入指定的内存地址。</li><li>其他指令在这一阶段不做任何操作，直接进入下一个阶段。</li></ul></li><li><p><strong>写回（WB，Write Back）</strong></p><ul><li>将执行结果写回到寄存器文件中（如 <code>R</code> 型和 <code>I</code> 型指令）。</li><li>对于加载指令，将从内存读取的数据写入目标寄存器。</li><li>此阶段完成后，处理器准备进入下一条指令的执行。</li></ul></li></ol><h3 id="4-2-Pipeline-Basics"><a href="#4-2-Pipeline-Basics" class="headerlink" title="4.2 Pipeline Basics"></a>4.2 Pipeline Basics</h3><p>在指令周期的五个阶段，可以把数据通路分为5个阶段，形成流水线(pipeline)。<br><img src="/img/CA/pipeline.png" alt="流水线" style="max-width: 100%; height: auto;" /><br>根据上图，可以很直观的给出流水线相关计算公式：</p><center>$时钟周期数 = 指令数 + 流水级级数 - 1 = IC + n - 1$</center><center>$理想加速比 = 流水线级数 = n$</center><blockquote><p>注意⚠️：时钟周期取5个阶段中最慢的阶段作为时钟周期（木桶效应）</p></blockquote><h3 id="4-3-Pipeline-Hazards"><a href="#4-3-Pipeline-Hazards" class="headerlink" title="4.3 Pipeline Hazards"></a>4.3 Pipeline Hazards</h3><p><strong>流水线冒险（Pipeline Hazards）</strong> 是在指令流水线中可能导致流水线停顿或性能下降的问题。主要有三种类型的流水线冒险：数据冒险、控制冒险和结构冒险。下面是对每种冒险的详细讲解：</p><h4 id="4-3-1-数据冒险-Data-Hazard"><a href="#4-3-1-数据冒险-Data-Hazard" class="headerlink" title="4.3.1 数据冒险 (Data Hazard)"></a>4.3.1 数据冒险 (Data Hazard)</h4><p>数据冒险是由于指令之间的数据依赖性导致的。例如，一条指令需要使用前一条指令的计算结果，如果在计算结果尚未写回寄存器时就使用该结果，流水线会因为缺少数据而停顿。常见的数据冒险有以下几种类型：</p><ul><li><p><strong>RAW（Read After Write，读后写）</strong>：最常见的数据冒险类型。假设有指令 A 和指令 B，A 先于 B 执行。如果 B 读取 A 的结果而 A 还未写回寄存器，则会产生数据冒险。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A: R1 &#x3D; R2 + R3B: R4 &#x3D; R1 + R5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>指令 B 在 A 的结果写回之前读取了 R1，造成数据冒险。</p></li><li><p><strong>WAR（Write After Read，写后读）</strong>：较少见，发生在指令先读取了寄存器的值，而后续指令修改了该寄存器的值。这种冒险通常在特定的流水线架构中才会发生。</p></li><li><p><strong>WAW（Write After Write，写后写）</strong>：如果流水线支持多发射或指令乱序执行，就可能发生这种冒险。即先有一条指令写一个寄存器，后续指令也写相同寄存器，但乱序执行导致后面的指令先写完。</p></li></ul><p>解决方法：</p><ul><li>数据转发 (Data Forwarding)或旁路（bypass）：将未写回寄存器的数据直接转发给下一条指令的执行单元，从而避免等待写回寄存器的过程。</li><li>插入气泡 (Bubble)：让流水线停顿一个或多个周期，直到所需数据准备就绪。</li></ul><h4 id="4-3-2-控制冒险-Control-Hazard"><a href="#4-3-2-控制冒险-Control-Hazard" class="headerlink" title="4.3.2 控制冒险 (Control Hazard)"></a>4.3.2 控制冒险 (Control Hazard)</h4><p>控制冒险是因为分支指令或跳转指令的出现，使得流水线不能确定下一条要执行的指令，从而导致流水线停顿。分支指令可能改变程序执行的路径，而在确定跳转目标前，流水线并不知道应该继续取哪条指令。</p><p>例如，以下代码段中，当执行<code>if</code>判断时，可能会发生控制冒险：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span>    <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token function">do_something_else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在判断 <code>a &gt; b</code> 之前，流水线不知道下一步应该执行 <code>do_something</code> 还是 <code>do_something_else</code>。</p><p>解决方法：</p><ul><li>分支预测 (Branch Prediction)：利用硬件预测分支指令的执行路径。现代处理器使用动态分支预测，根据历史执行情况预测下一步操作。</li><li>延迟槽 (Delay Slot)：将分支指令后的指令提前执行，即使分支结果不确定也先执行下一条指令，从而减少停顿，但这种方法需要编译器支持。</li><li>分支目标缓冲区 (Branch Target Buffer, BTB)：缓存分支指令的目标地址，减少分支跳转的停顿时间。</li></ul><h4 id="4-3-3-结构冒险-Structural-Hazard"><a href="#4-3-3-结构冒险-Structural-Hazard" class="headerlink" title="4.3.3 结构冒险 (Structural Hazard)"></a>4.3.3 结构冒险 (Structural Hazard)</h4><p>结构冒险是由于硬件资源的竞争导致的。在指令执行过程中，如果两个或多个指令同时需要访问同一硬件资源（例如，内存、寄存器或 ALU 单元），但硬件资源不能同时支持多个访问请求，则会产生结构冒险。</p><p>例如，如果处理器的内存访问和取指令共享相同的内存端口，且一个指令在内存中读取数据的同时，另一个指令需要从内存中取指令，就会产生结构冒险。</p><p>解决方法：</p><ul><li>增加硬件资源：在流水线设计时，增加必要的硬件资源。例如，为指令存储和数据存储提供独立的内存端口，避免资源竞争。</li><li>流水线停顿：当资源不可用时，让流水线停顿一个周期，以等待资源的释放。</li></ul><div class="note note-primary">            <p>流水线在修考里面是非常非常重要的存在‼️我更希望用经典的例题讲解然后来帮助理解。</p>          </div><p>经典流水线问题：<a href="https://toutou.zeabur.app/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">九州大学2022年夏季计算机组成过去问</a></p><h2 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h2><p>本章主要讲解存储器的层次和局部性原理。这一章和操作系统的重合度非常高，建议配合操作系统复习。本章的Cache映射和TLB映射在修考题中出现的频率非常高。</p><h3 id="5-1-Memory-Hierachy"><a href="#5-1-Memory-Hierachy" class="headerlink" title="5.1 Memory Hierachy"></a>5.1 Memory Hierachy</h3><p>如标题所见，这是计算机8大设计思想之一，采用层次结构将存储器主要分为4个层次，从顶层到底层依次是：寄存器，高速缓存，主存，外存。<br><img src="/img/CA/memory.svg" alt="存储器层次" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-Register"><a href="#5-1-1-Register" class="headerlink" title="5.1.1 Register"></a>5.1.1 Register</h4><p>寄存器是 CPU 中的高速存储单元，用于暂时存储指令和数据，帮助 CPU 进行快速计算。它们是 CPU 中访问速度最快的存储器，因为它们直接位于 CPU 内核中，靠近运算单元（如算术逻辑单元，ALU）。</p><p><strong>寄存器的特点</strong></p><ul><li><strong>速度快</strong>：寄存器的访问速度比 Cache 和主存（RAM）都要快，能满足 CPU 的即时需求。</li><li><strong>容量小</strong>：寄存器数量有限，通常每个寄存器只有几个字节或几十个字节的容量。</li><li><strong>功能明确</strong>：寄存器根据用途被分为不同类型，每种寄存器在特定的指令或运算中起特定的作用。</li></ul><p><strong>常见的寄存器类型</strong></p><ol><li><strong>通用寄存器</strong>：用于临时存储数据，支持基本的加、减、乘、除等运算。</li><li><strong>程序计数器 (PC)</strong> ：保存下一条要执行指令的地址，用于控制程序执行的顺序。</li><li><strong>状态寄存器&#x2F;标志寄存器</strong>：存储运算结果的状态信息，如是否为零、是否有溢出等，用于条件判断。</li><li><strong>堆栈指针 (SP)</strong> ：指向栈顶位置，用于函数调用和返回的管理。</li><li><strong>地址寄存器</strong>：存储内存地址，用于快速访问特定的内存位置。</li></ol><p><strong>寄存器的作用</strong><br>寄存器用于 CPU 执行指令时的临时数据存储，避免频繁访问较慢的内存单元。它们直接与 CPU 核心连接，确保计算快速、高效。</p><h4 id="5-1-2-Cache"><a href="#5-1-2-Cache" class="headerlink" title="5.1.2 Cache"></a>5.1.2 Cache</h4><p><strong>Cache</strong>（缓存）是位于 CPU 和主存（RAM）之间的高速存储器，用于缓解 CPU 与主存之间的速度差异。Cache 通过暂时存储常用的数据和指令，减少 CPU 访问主存的次数，从而提高整体运算速度。Cache 通常是由 <strong>SRAM（静态随机存取存储器）</strong> 组成的；SRAM是易失性存储器，尽管 SRAM 的数据不需要周期性刷新，但一旦电源关闭，存储在其中的数据就会丢失。这是因为 SRAM 的存储原理基于晶体管的电状态，当电源断开时，这些状态会消失。<strong>DRAM</strong>则有些许不同，需要定期刷新以维持数据，刷新操作会耗费一定时间和电力，但也是易失性存储器(volatile memory)。</p><p><strong>Cache 的特点</strong></p><ul><li><strong>访问速度快</strong>：Cache 的访问速度比主存快，仅次于寄存器，能快速提供数据。</li><li><strong>层级结构</strong>：Cache 通常分为多级，包括 L1、L2 和 L3 缓存，分别位于不同的 CPU 层次上，L1 速度最快但容量最小，L3 容量最大但速度相对较慢。</li><li><strong>自动管理</strong>：Cache 由硬件自动管理，CPU 根据访问数据的频率和规律自动将数据加载到 Cache 中，无需程序员手动干预。</li></ul><p><strong>Cache 的作用</strong><br>Cache 主要用于存储 CPU 经常访问的数据或指令，以减少访问主存的延迟，提升 CPU 的执行效率。现代处理器通常会采用多级缓存结构，以平衡容量与速度之间的需求。</p><h4 id="5-1-3-Main-Memory"><a href="#5-1-3-Main-Memory" class="headerlink" title="5.1.3 Main Memory"></a>5.1.3 Main Memory</h4><p><strong>内存</strong>（Memory）一般称为主存(Main Memory)，是计算机中用于临时存储数据和程序的部件，CPU 可以快速访问其中的数据。内存的主要作用是为 CPU 提供运行时的工作区，用于存放操作系统、应用程序和当前处理的数据。</p><p><strong>内存的特点</strong></p><ul><li><strong>速度适中</strong>：内存的访问速度介于 Cache 和硬盘之间。尽管比硬盘快很多，但比不上 CPU 内部的寄存器和缓存。</li><li><strong>容量较大</strong>：内存容量一般较大，能够存储多个程序和大量数据，以满足系统的多任务需求。</li><li><strong>易失性</strong>：内存（RAM）通常由 DRAM（动态随机存取存储器）组成。DRAM 由于容量大、成本相对较低，也是一种易失性存储器，断电后数据会丢失。</li></ul><p><strong>内存的作用</strong></p><p>内存用于临时存放正在执行的程序和正在处理的数据，起到了 CPU 与硬盘之间的缓冲作用，使得系统运行更加高效。计算机在开机后，将程序从硬盘加载到内存中，CPU 再从内存中读取指令执行。</p><h4 id="5-1-4-Secondary-Memory"><a href="#5-1-4-Secondary-Memory" class="headerlink" title="5.1.4 Secondary Memory"></a>5.1.4 Secondary Memory</h4><p><strong>Secondary Memory</strong>（二级存储器）是计算机的外部存储，用于长期存储数据和程序，断电后数据不会丢失。常见的二级存储器包括硬盘驱动器 (HDD)、固态硬盘 (SSD)、光盘、以及 USB 闪存等。</p><p><strong>辅助存储器的特点</strong></p><ul><li><strong>非易失性(nonvolatile)</strong> ：辅助存储器断电后仍能保留数据，适合长期存储文件、程序和系统数据。</li><li><strong>大容量</strong>：相比于主存，辅助存储器容量更大，能够存储大量的数据和文件。</li><li><strong>较慢的访问速度</strong>：辅助存储器的读写速度比内存慢，因此用于存储不需要频繁访问的数据。</li></ul><p><strong>辅助存储器的作用</strong></p><p>辅助存储器用于存储计算机的操作系统、应用程序、用户文件和其他数据，提供数据的长期保存。计算机在启动时会将操作系统和相关程序从辅助存储器加载到内存中，以便 CPU 处理。</p><h3 id="5-2-Principle-of-Locality"><a href="#5-2-Principle-of-Locality" class="headerlink" title="5.2 Principle of Locality"></a>5.2 Principle of Locality</h3><p>局部性原理(principle of locality)是计算机组成中的一个关键概念，用来描述程序在执行过程中，访问内存地址或存储单元的一种倾向。局部性原理主要分为以下两类：</p><p><strong>时间局部性（Temporal Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么在不久的将来它很可能会再次被访问。</li><li><strong>例子</strong>：在循环中多次访问某个变量。比如循环计数器，每次迭代都会访问该变量。</li></ul><p><strong>空间局部性（Spatial Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么它附近的数据也很可能会在不久的将来被访问。</li><li><strong>例子</strong>：遍历数组时，逐个访问数组中的元素。比如访问数组<code>arr[0]</code>后，很可能访问<code>arr[1]</code>。</li></ul><blockquote><p>局部性原理在设计计算机缓存（Cache）时尤为重要。因为缓存利用局部性原理，通过临时存储经常访问的数据或地址来减少访问主内存的次数，提高整体系统性能。</p></blockquote><h3 id="5-3-Cache’s-Performance"><a href="#5-3-Cache’s-Performance" class="headerlink" title="5.3 Cache’s Performance"></a>5.3 Cache’s Performance</h3><p>Cache的主要考点围绕在命中率和缺失率的计算；在Cache映射中也有非常多的改进策略。</p><h4 id="5-3-1-Cache-Hit-Miss"><a href="#5-3-1-Cache-Hit-Miss" class="headerlink" title="5.3.1 Cache Hit &amp; Miss"></a>5.3.1 Cache Hit &amp; Miss</h4><p><strong>Cache命中（Cache Hit）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据在缓存中找到时，就称为Cache命中。命中率（Hit Rate）是命中次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它已经在缓存中，直接读取数据，避免了访问慢速的主内存，从而提高了整体性能。</li></ul><p><strong>Cache缺失（Cache Miss）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据不在缓存中，必须从主内存中读取时，就称为Cache缺失。缺失率（Miss Rate）是缺失次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它不在缓存中，处理器需要从主内存中读取该数据块，并将其放入缓存中。这个过程比直接从缓存读取要慢得多。</li></ul><p>命中率(Hit Rate)和缺失率(Miss Rate)的计算方法非常直观，分别是命中&#x2F;缺失的次数占访存次数的比例。</p><h4 id="5-3-2-命中时间、缺失代价和访存阻塞周期"><a href="#5-3-2-命中时间、缺失代价和访存阻塞周期" class="headerlink" title="5.3.2 命中时间、缺失代价和访存阻塞周期"></a>5.3.2 命中时间、缺失代价和访存阻塞周期</h4><p><strong>命中时间（Hit Time）</strong></p><ul><li><strong>定义</strong>：命中时间是指CPU在缓存中找到数据所需的时间，包括地址翻译、缓存访问和数据返回给处理器的时间。通常只有1个时钟周期长度。</li><li><strong>计算</strong>：命中时间通常由缓存访问的硬件特性决定，具体时间取决于缓存的层级和设计。</li></ul><p><strong>缺失代价（Miss Penalty）</strong></p><ul><li><strong>定义</strong>：缺失代价是指当数据不在缓存中，需要从较低层级的缓存或主存中加载数据所需的时间。</li><li><strong>计算</strong>：缺失代价 &#x3D; 低层级缓存或主存的访问时间 + 将数据传送到缓存中的时间。</li></ul><p><strong>访存阻塞周期（Memory Stall Cycles）</strong></p><ul><li><strong>定义</strong>：访存阻塞周期是指由于缓存缺失导致处理器需要等待数据加载而停顿的周期数。</li><li><strong>计算</strong>：访存阻塞周期 &#x3D; 缺失率 × 缺失代价</li></ul><p>假设：</p><ul><li>命中时间为1个周期。</li><li>缺失代价为50个周期。</li><li>缺失率为5%。</li></ul><p>那么：访存阻塞周期 &#x3D; 5% × 50个周期 &#x3D; 2.5个周期。</p><p>普适性的衡量会给上一个缺失率(Miss Rate), 那么</p><center>$访存阻塞周期 = 访存次数 \times 缺失率 \times 缺失代价$</center><h3 id="5-4-Cache的三种映射方式"><a href="#5-4-Cache的三种映射方式" class="headerlink" title="5.4 Cache的三种映射方式"></a>5.4 Cache的三种映射方式</h3><p><strong>1. 直接映射（Direct Mapped Cache）</strong></p><ul><li><strong>定义</strong>：每个内存块都映射到缓存的一个特定位置。缓存中的每个位置可以存储多个内存块，但在任意时间只能存储一个。</li><li><strong>优点</strong>：实现简单且成本低。</li><li><strong>缺点</strong>：冲突较多，即不同内存块可能会映射到同一个缓存位置，导致频繁替换。</li></ul><p><strong>2. 全关联映射（Fully Associative Cache）</strong></p><ul><li><strong>定义</strong>：内存块可以映射到缓存的任何位置。缓存中的每个位置都可以存储任何内存块。</li><li><strong>优点</strong>：减少了冲突，因为任何内存块都可以放到任何缓存位置。</li><li><strong>缺点</strong>：实现复杂且成本高，需要比较所有缓存位置以找到匹配的块。</li></ul><p><strong>3. 组关联映射（Set Associative Cache）</strong></p><ul><li><strong>定义</strong>：缓存分成多个组，每个组包含若干个位置。内存块首先映射到某个组，然后可以存储在该组的任意位置。</li><li><strong>优点</strong>：在复杂度和性能之间取得平衡，减少了直接映射中的冲突，同时实现比全关联映射更简单。</li><li><strong>缺点</strong>：组的选择可能会导致一些复杂度，但总的来说，比全关联映射低。<img src="/img/CA/cache_map.svg" alt="Cache三种映射方式" style="max-width: 100%; height: auto;" /></li></ul><h4 id="5-4-1-直接映射"><a href="#5-4-1-直接映射" class="headerlink" title="5.4.1 直接映射"></a>5.4.1 直接映射</h4><p>映射规则：Cache块号 &#x3D; 内存块号 % Cache块数</p><blockquote><p>比如，Cache共有8块，内存的十号块映射在Cache的块号是：10 % 8 &#x3D; 2</p></blockquote><p>直接映射缓存（Direct Mapped Cache）内存地址通常被分成三个字段：块内字节偏移、索引位和标记位。</p><p><strong>1. 块内字节偏移（Block Offset）</strong></p><ul><li><strong>定义</strong>：块内字节偏移用于定位一个块中的具体字节。</li><li><strong>计算</strong>：偏移位的数量取决于块的大小。例如，如果块大小为4个字节，则需要2位来表示块内字节偏移。<ul><li>例子：对于一个块大小为4个字节的缓存，偏移位可能是<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>。</li></ul></li></ul><p><strong>2. 索引位（Index Bits）</strong></p><ul><li><strong>定义</strong>：索引位用于定位缓存中的具体行（块）。</li><li><strong>计算</strong>：索引位的数量取决于缓存的行数。例如，如果缓存有8行，需要3位索引位来标识具体的行。<ul><li>例子：对于一个有8行的缓存，索引位可能是<code>000</code>到<code>111</code>。</li></ul></li></ul><p><strong>3. 标记位（Tag Bits）</strong></p><ul><li><strong>定义</strong>：标记位用于区分不同内存块，它们映射到同一个缓存行。</li><li><strong>计算</strong>：标记位的数量 &#x3D; 内存地址总位数 - 索引位数量 - 块内字节偏移位数量。<ul><li>例子：假设内存地址总位数为16位，块大小为4字节（2位块内偏移），缓存有8行（3位索引），那么标记位数量为11（16-3-2&#x3D;11）。</li></ul></li></ul><blockquote><p><strong>示例</strong> ：假设有一个16位的内存地址，缓存有8行，每行块大小为4字节。</p></blockquote><p>内存地址：<code>1010110010101110</code></p><ul><li><strong>块内字节偏移</strong>：2位（最右边的2位），<code>10</code> 表示块内的某个字节。</li><li><strong>索引位</strong>：3位（次右边的3位），<code>110</code> 表示缓存的具体行。</li><li><strong>标记位</strong>：11位（剩余左边的位），<code>10101100101</code> 用于区分不同的内存块。</li></ul><p><strong>内存地址分解</strong>：</p><ul><li>标记位（Tag）：<code>10101100101</code></li><li>索引位（Index）：<code>110</code></li><li>块内字节偏移（Block Offset）：<code>10</code></li></ul><center>$Cache容量 = （标记位 + 数据位）\times 行数 $</center>补充：如果题目强调了有效位的存在，那么Cache的每一行需要多1bit的有效位，则<center>$Cache容量 = （1 + 标记位 + 数据位）\times 行数 $</center><p>有效位是缓存系统中的一个重要概念，用于指示缓存块中的数据是否有效。具体来说，有效位帮助确定当前缓存块是否包含可以被处理器使用的有效数据。</p><ol><li><strong>指示数据有效性</strong>：有效位为1表示缓存块中的数据有效且可用；为0表示缓存块中的数据无效，可能未被使用或需要更新。</li><li><strong>管理缓存块</strong>：当一个新的内存块被加载到缓存时，会设置有效位为1。当缓存块的数据被替换或失效时，有效位被设置为0。</li></ol><p><strong>实现原理</strong></p><ul><li><strong>检查有效位</strong>：每次缓存访问时，首先检查有效位。如果有效位为0，即使缓存地址匹配，数据也不被使用，因为它无效。</li><li><strong>缓存替换</strong>：在缓存替换时，新的数据块写入缓存，并将对应的有效位设置为1。被替换的数据块的有效位通常被设置为0，表示数据无效。</li></ul><p><strong>示例</strong><br>假设一个缓存系统有4个块，每个块都有一个有效位：</p><ul><li>块0：有效位&#x3D;1（数据有效）</li><li>块1：有效位&#x3D;0（数据无效）</li><li>块2：有效位&#x3D;1（数据有效）</li><li>块3：有效位&#x3D;0（数据无效）</li></ul><p>当处理器访问一个地址时，它首先检查缓存块的有效位。如果有效位为1，它会进一步检查地址是否匹配；如果有效位为0，则直接从主存获取数据。</p><h4 id="5-4-2-直接映射缺失的3C模型"><a href="#5-4-2-直接映射缺失的3C模型" class="headerlink" title="5.4.2 直接映射缺失的3C模型"></a>5.4.2 直接映射缺失的3C模型</h4><p><strong>1. 冷缺失（Cold Miss）</strong></p><ul><li><strong>定义</strong>：也称为强制缺失或首次缺失。这种情况发生在缓存首次加载数据块时，因为缓存中还没有存储该数据块。</li><li><strong>示例</strong>：程序第一次访问一个数据块时，缓存中还没有该数据块，导致冷缺失。</li></ul><p><strong>2. 容量缺失（Capacity Miss）</strong></p><ul><li><strong>定义</strong>：由于缓存容量有限，即使缓存中所有块都被充分利用，仍然无法容纳所有需要的数据块，从而导致缺失。</li><li><strong>示例</strong>：程序需要访问的数据块数量超过了缓存容量，导致一些较早访问的数据块被驱逐，再次访问时需要重新加载。</li></ul><p><strong>3. 冲突缺失（Conflict Miss）</strong></p><ul><li><strong>定义</strong>：也称为干扰缺失。这种情况发生在直接映射缓存中，不同的数据块映射到同一个缓存块位置，导致频繁替换，即使缓存容量足够也会出现缺失。</li><li><strong>示例</strong>：两个或多个数据块映射到同一个缓存位置，导致数据块被替换，从而产生冲突缺失。</li></ul><img src="/img/CA/map_miss.svg" alt="3C模型" style="max-width: 100%; height: auto;" />  <p>直接映射在应对上面的Cache缺失的时候有三种处理方式：</p><p><strong>1.写直达（Write Through）：</strong></p><ul><li>CPU同时向Cache和主存写入数据</li><li>实现简单，但写入速度慢</li><li>保持了Cache和主存的一致性</li></ul><p><strong>写缓冲（Write Buffer）：</strong></p><ul><li>CPU先写入Cache</li><li>数据暂存在写缓冲区</li><li>后台异步写入主存</li><li>提高了写入效率</li></ul><p><strong>写回（Write Back）：</strong></p><ul><li>CPU只写入Cache</li><li>使用脏位(Dirty Bit)标记修改</li><li>仅在数据被替换时才写回主存</li><li>最高效但实现复杂</li></ul><img src="/img/CA/map_strategy.svg" alt="Cache缺失策略" style="max-width: 100%; height: auto;" /><h4 id="5-4-3-多级缓存机制"><a href="#5-4-3-多级缓存机制" class="headerlink" title="5.4.3 多级缓存机制"></a>5.4.3 多级缓存机制</h4><p>多级缓存（Multilevel Cache）是一种在计算机系统中提高处理器访问数据速度的技术，通常将缓存分为多个层次，如 L1、L2 和 L3 缓存。这些缓存层次的设置能够平衡存取速度、容量和成本，确保 CPU 能更快地获取需要的数据。</p><p><strong>多级缓存的主要特点</strong></p><ol><li><p><strong>L1缓存</strong>（一级缓存）：通常集成在 CPU 内核中，速度最快，容量较小（一般为几十KB）。L1缓存分为指令缓存（I-Cache）和数据缓存（D-Cache），分别用于存储指令和数据，帮助 CPU 快速访问常用数据。</p></li><li><p><strong>L2缓存</strong>（二级缓存）：相比 L1 缓存稍慢，但容量更大（几百KB到几MB），通常也集成在处理器中。L2 缓存为 L1 提供数据支援，命中率高，进一步减少了 CPU 对主存（RAM）的访问需求。</p></li><li><p><strong>L3缓存</strong>（三级缓存）：用于共享多个 CPU 内核的数据，容量较大（几MB到几十MB），但访问速度比 L2 缓慢。L3缓存作为所有内核的公共缓存，提升了多核处理器的并行性能。</p></li><li><p><strong>工作原理</strong>：CPU 会首先查找 L1 缓存，如果未命中则依次查找 L2 和 L3 缓存，直到最后访问主存。这样的分级缓存结构可以减少主存访问次数，从而提高系统性能。</p></li><li><p><strong>优点</strong>：多级缓存结构能显著降低数据访问延迟，提高处理器的执行效率；而且它能有效利用缓存的层级特性，合理分配存取速度和容量。</p></li></ol><p><strong>多级缓存背景下的平均 CPI 计算</strong></p><p>在多级缓存系统中，平均每条指令的周期数（CPI，Cycles Per Instruction）可以通过考虑每一级缓存的缺失率和缺失代价来计算。这里的缺失率指的是每一级缓存未命中（缺失）的概率，缺失代价则是缓存未命中时所需要的额外处理周期数。平均 CPI 的计算可以按以下步骤进行。</p><p>假设：</p><ul><li>$\text{CPI}_{\text{ideal}}$ 是理想情况下（没有缓存缺失）的 CPI，即不考虑缓存缺失时每条指令的周期数。</li><li>L1、L2、L3 分别是一级、二级和三级缓存。</li><li>$\text{MR}_n$ 表示第 $n$ 级缓存的缺失率（Miss Rate）。</li><li>$\text{MC}_n$ 表示第 $n$ 级缓存的缺失代价（Miss Penalty），即在第 $n$ 级缓存缺失时需要的额外周期数。</li></ul><p>平均 CPI 的计算可以分为以下步骤：</p><ol><li><p><strong>L1 缓存的贡献</strong>：L1 缓存缺失的情况下，需要访问 L2 缓存，因此 L1 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L1}} = \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}}$ </center></li><li><p><strong>L2 缓存的贡献</strong>：L1 缓存缺失时会访问 L2 缓存，如果 L2 缓存也缺失，则需要访问 L3 缓存。L2 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L2}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$ </center></li><li><p><strong>L3 缓存的贡献</strong>：当 L1 和 L2 都缺失时，才会访问 L3 缓存。如果 L3 缓存也缺失，就会访问主存，因此 L3 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L3}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}}$ </center></li><li><p><strong>主存的贡献</strong>：当 L1、L2 和 L3 缓存都缺失时，才会访问主存。因此主存的平均贡献为：</p><center> $\text{CPI}_{\text{memory}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$ </center></li></ol><p>把各级缓存和主存的贡献相加，再加上理想情况下的 CPI，得到总的平均 CPI：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{CPI}_{\text{L1}} + \text{CPI}_{\text{L2}} + \text{CPI}_{\text{L3}} + \text{CPI}_{\text{memory}}$ </center><p>展开后，即：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$$+ \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$</center><blockquote><ul><li>每一级缓存的贡献都是基于它前一级缓存的缺失率和自身的缺失代价递归计算的。</li><li>这个公式综合了各级缓存的缺失率和缺失代价，提供了一个较为准确的平均 CPI 估计。</li></ul></blockquote><h3 id="5-5-Virtual-Memory"><a href="#5-5-Virtual-Memory" class="headerlink" title="5.5 Virtual Memory"></a>5.5 Virtual Memory</h3><p>虚拟存储器通过地址映射机制，将操作系统使用的虚拟地址转换为不同的物理地址。这个过程涉及多层缓存和映射关系，例如：</p><ul><li>Cache 将处理器寄存器访问的地址映射到内存中的物理地址，以加速数据读取。</li><li>主存（内存）充当磁盘的缓存，从磁盘读取数据时，常用的数据会保存在内存中以加快访问速度。</li><li>TLB（快表）是页表的缓存，用于快速查找虚拟地址到物理地址的映射，减少页表查找的开销。</li></ul><p>将虚拟地址转换为物理地址的过程通常涉及几个关键步骤：</p><ol><li><p>地址生成：当程序访问某个内存位置时，它会生成一个虚拟地址。</p></li><li><p>页号和偏移量：虚拟地址被分为两个部分：页号和偏移量。页号用于识别该地址所属的页，而偏移量则指定了在该页内的具体位置。</p></li><li><p>快速表 (Translation Lookaside Buffer, TLB)：在检查页表之前，系统首先检查快速表 (TLB)，这是一个小而快速的缓存，存储最近的虚拟到物理地址的转换。如果在 TLB 中找到转换（TLB 命中），则可以快速检索物理地址。</p></li><li><p>页表查找：如果在 TLB 中未找到转换（TLB 未命中），系统将访问页表。页表包含条目，将每个虚拟页号映射到内存中相应的物理页框号。</p></li><li><p>物理地址形成：一旦访问了页表，就可以获得物理页框号。然后，物理地址通过将该页框号与原虚拟地址中的偏移量结合来形成。</p></li><li><p>访问内存：系统现在使用物理地址访问 RAM 中的数据。</p></li><li><p>页面缺失处理：如果所需的页面不在内存中（页面缺失），操作系统将从磁盘存储中检索该页面，并相应地更新页表。</p></li></ol><img src="/img/CA/address.svg" alt="Address Translation" style="max-width: 100%; height: auto;" /><p>关于虚拟地址和物理地址还有更多的考点内容，比如各种替换策略和写策略，这里的内容我更愿意放到操作系统的对应章节来讲解😈马不停蹄更新中🐎</p><div class="note note-primary">            <p>完结撒花🎉<br>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語語彙まとめ</title>
    <link href="/2024/09/28/JPN-Words/"/>
    <url>/2024/09/28/JPN-Words/</url>
    
    <content type="html"><![CDATA[<h1 id="日语单词自测"><a href="#日语单词自测" class="headerlink" title="日语单词自测"></a>日语单词自测</h1><p><em>配合moji插件查看中文释义👀</em></p><h2 id="1-動詞"><a href="#1-動詞" class="headerlink" title="1. 動詞"></a>1. 動詞</h2><p>欺く「あざむく」、覗く「のぞく」、湧く「わく」、逃れる「のがれる」、挑む「いどむ」、固める「かためる」、奪う「うばう」、紛れ込む「まぎれ込む」、仕掛ける「しかける」、強引「ごういん」、溢れる「あふれる」、謙る「へりくだる」、絡み合う「からみあう」、仰ぐ「あおぐ」、耽る「ふける」、眩む「くらむ」、紡ぐ「つむぐ」、辿り着く「たどりつく」、戒める「いましめる」、親しむ「したしむ」、身構える「みがまえる」、草臥れる「くたびれる」、勤める「つとめる」、睨む「にらむ」、濁る「にごる」、融合「ゆうごう」、襲う「おそう」、押し込む「おしこむ」、焚く「たく」、惑う「まどう」、傾ける「かたむける」、金縛り「かなしばり」、軋む「きしむ」、免れる「まぬかれる」、与かる「あずかる」、炙る「あぶる」、嘆く「なげく」、誂える「あつらえる」、埋める「うずめる」、頷く「うなずく」、貫く「つらぬく」、授ける「さずける」、値する「あたいする」、省みる「かえりみる」、打ち明ける「うちあける」、押し寄せる「おしよせる」、呆れる「あきれる」、綴る「つずる」、攫う「さらう」、専ら「もっぱら」、呟く「つぶやく」、呼び掛ける「よびかける」、見なす「みなす」、戸惑う「とまどう」、透き通る「すきとおる」、怒鳴る「どなる」、齎す「もたらす」、富む「とむ」、拗ねる「すねる」、威張る「いばる」、凌ぐ「しのぐ」、弁償「べんしょう」、安らぐ「やすらぐ」、見合わせる「みあわせる」、気軽「きがる」、見込む「みこむ」、奉る「たてまつる」、緩める「ゆるめる」、磨く「みがく」、充ちる「みちる」、跨る「またがる」、覆う「おおう」、吹き出す「ふきだす」、交じる「まじる」、紡ぐ「つむぐ」、慰める「なぐさめる」、実る「みのる」、叱る「しかる」、馳せる「はせる」、愚か「おろか」、疑う「うたがう」、探る「さぐる」、痺れる「しびれる」、食い違う「くいちがう」、窺う「うかがう」、揃う「そろう」、報いる「むくいる」、撒く「まく」、拘る「こだわる」、気に障る「きにさわる」、押し切る「おしきる」、立ち寄る「たちよる」、蹴る「ける」、除去「じょきょ」、囁く「ささやく」、志す「こころざす」、伏せる「ふせる」、巫山戯る「ふざける」、奢る「おごる」、褪せる「あせる」、記す「しるす」、絶る「たえる」、背く「そむく」、取り払う「とりはらう」、俯く「うつむく」、照れる「てれる」、掲げる「かかげる」、仕上げる「しあげる」、映える「はえる」、乱れる「みだれる」、惜しむ「おしむ」、呼び寄せる「よびよせる」、衰える「おとろえる」、慣らす「ならす」、治る「なおる」、遂げる「とげる」、費やす「ついやす」、励ます「はげます」、滞る「とどこおる」、隔てる「へだてる」、謝る「あやまる」、昇進「しょうしん」、睨む「にらむ」、急かす「せかす」、帯びる「おびる」、冷やす「ひやす」、潤す「うるおす」、狼狽える「うろたえる」、濡らす「ぬらす」、庇う「かばう」、抱え込む「かかえこむ」、秘める「ひめる」、割り当てる「わりあてる」、思い詰める「おもいつめる」、練る「ねる」、持て成す「もてなす」、賄う「まかなう」、跳ねる「はねる」、募る「つのる」、絡める「からめる」、転がる「ころがる」、労わる「いたわる」、復旧「ふっきゅう」、薄まる「うすまる」、遠ざける「とおざける」、お詫び「おわび」、躊躇う「ためらう」、潰れる「つぶれる」、断る「ことわる」、舞う「まう」、絡む「からむ」、切り出す「きりだす」、排卵「はいらん」、収まる「おさまる」、治する「じする」、狭める「せばめる」、覆す「くつがえす」、滅びる「ほろびる」、翻す「ひるがえす」、立て替える「たてかえる」、弾く「はじく」、養う「やしなう」、鈍る「にぶる」、唱える「となえる」、蓄える「たくわえる」、損なう「そこなう」、培う「つちかう」、見失う「みうしなう」、避ける「よける」、讃る「たたえる」、掘る「ほる」、怠る「おこたる」、敬う「うやまう」、臨む「のぞむ」、目論む「もくろむ」、偽る「いつわる」、了承「りょうしょう」、賑わう「にぎわう」、遮る「さえぎる」、取り消す「とりけす」、愛着「あいちゃく」、駆使「くし」、儲かる「もうかる」、縮まる「ちぢまる」、怯える「おびえる」、逸らす「そらす」、癒す「いやす」、差し引く「さしひく」、項垂れる「うなだれる」、拒む「こばむ」、担う「になう」、催す「もよおす」、引き返す「ひきかえす」、解ける「ほどける」、妨げる「さまたげる」、築く「きずく」、弾む「はずむ」、商う「あきなう」、食い止める「くいとめる」、訴える「うったえる」、辿る「たどる」、打ち切る「うちきる」、潤う「うるおう」、究明「きゅうめい」、立ち直る「たちなおる」、倒す「たおす」、削る「けずる」、言い張る「いいはる」、劣る「おとる」、偏る「かたよる」、阻む「はばむ」、遡る「さかのぼる」、冷え込む「ひえこむ」、取り払う「とりはらう」、収拾「しゅうしゅう」、出揃う「でそろう」、洗う「あらう」、仕込む「しこむ」、囃す「はやす」、見惚れる「みとれる」、馴染む「なじむ」、見落とす「みおとす」、仕入れる「しいれる」、扱う「あつかう」、搾る「しぼる」、見通す「みとおす」、費やす「ついやす」、座が白ける「ざがしらける」、讃える「たたえる」、持て余す「もてあます」、補う「おぎなう」、煉る「ねる」、清澄「せいちょう」、訪れる「おとずれる」、眺める「ながめる」、見積もる「みつもる」</p><h2 id="2-名詞"><a href="#2-名詞" class="headerlink" title="2. 名詞"></a>2. 名詞</h2><p>物語「ものがたり」、非難「ひなん」、靄「もや」、競技「きょうぎ」、過労「かろう」、振る舞い「ふるまい」、倹約「けんやく」、氏神「うじがみ」、大木「たいぼく」、復興「ふっこう」、亭主関白「ていしゅかんぱく」、畑「はたけ」、役割「やくわり」、脇「わき」、残酷「ざんこく」、稼業「かぎょう」、木立「きだち」、愛想「あいそ」、苦情「くじょう」、良し悪し「よしあし」、苛め「いじめ」、腰「こし」、当選「とうせん」、目論見「もくろみ」、冒頭「ぼうとう」、羽目「はめ」、下駄「げた」、屋敷「やしき」、一昨年「おととし」、照明「しょうめい」、虚ろ「うつろ」、合否「ごうひ」、私邸「してい」、扱い「あつかい」、神秘「しんぴ」、琴「こと」、里「さと」、猥褻「わいせつ」、暮れ「くれ」、醍醐味「だいごみ」、蓄積「ちくせき」、臥床「がしょう」、山懐「やまふところ」、生涯「しょうがい」、跡地「あとち」、味方「みかた」、取材「しゅざい」、発祥地「はっしょうち」、出入り「でいり」、達者「たっしゃ」、原動力「げんどうりょく」、拘束「こうそく」、融通「ゆうずう」、手際「てぎわ」、立食「りっしょく」、善悪「ぜんあく」、境地「きょうち」、人並み「人なみ」、裸足「はだし」、身内「みうち」、無礼「ぶれい」、懇談「こんだん」、試し「ためし」、公平「こうへい」、魅了「みりょう」、霧「きり」、合間「あいま」、顎「あご」、野生「やせい」、険悪「けんあく」、垢「あか」、庵「いおり」、吟味「ぎんみ」、修復「しゅうふく」、迫真「はくしん」、証「あかし」、話題「わだい」、転がし「ころがし」、干物「ひもの」、過誤「かご」、有頂天「うちょうてん」、懲戒「ちょうかい」、規制「きせい」、文献「ぶんけん」、猿「さる」、霞「かすみ」、叡智「えいち」、神話「しんわ」、賃金「ちんぎん」、密輸入「みつゆにゅう」、賭ける「かける」、育ち「そだち」、割れ目「われめ」、大人「おとな」、ありのまま、細菌「さいきん」、応募「おうぼ」、煮物「にもの」、潮流「ちょうりゅう」、焦る「あせる」、取り上げる「とりあげる」、昨年「さくねん」、贅沢「ぜいたく」、真骨頂「しんこっちょう」、争い「あらそい」、女房「にょうぼう」、足場「あしば」、要請「ようせい」、無難「ぶなん」、水着「みずぎ」、車窓「しゃそう」、合致「がっち」、外見「がいけん」、獣「けもの」、代物「しろもの」、田舎者「いなかもの」、趣「おもむき」、束縛「そくばく」、いらいら、緩和「かんわ」、芽「め」、幾分「いくぶん」、最善「さいぜん」、軽蔑「けいべつ」、日取り「ひどり」、無事「ぶじ」、糧「かて」、厄介「やっかい」、手渡し「てわたし」、一見「いっけん」、マスコミ、気の毒「きのどく」、埋立地「うめたてち」、窮屈「きゅうくつ」、勢い良く「いきおいよく」、触れ合い「ふれあい」、青二才「あおにさい」、怪我「けが」、辺鄙「へんぴ」、発端「ほったん」、跋扈「ばっこ」、ゆとり、最期「さいご」、作風「さくふう」、証拠「しょうこ」、生垣「いけがき」、用心棒「ようじんぼう」、安らぐ「やすらぐ」、折節「おりふし」、言及「げんきゅう」、風見鶏「かざみどり」、居眠り「いぬむり」、崖「がけ」、臆病「おくびょう」、一斉「いっせい」、断言「だんげん」、稲光「いなびかり」、勘定「かんじょう」、気前「きまえ」、気立「きだて」、箇条書き「かじょうがき」、編集「へんしゅう」、皆無「かいむ」、当たり「あたり」、漬物「つけもの」、拍手「はくしゅ」、節約「せつやく」、妄想「もうそう」、割合「わりあい」、壁際「かべぎわ」、出鱈目「でたらめ」、納期「のうき」、重体「じゅうたい」、理不尽「りふじん」、弁解「べんかい」、心構え「こころがまえ」、気配「きはい」、変遷「へんせん」、敏捷「びんしょう」、発足「はっそく」、加味「かみ」、内訳「うちわけ」、無造作「むぞうさ」、伴奏「ばんそう」、本筋「ほんすじ」、拠点「きょてん」、需要「じゅよう」、重複「ちょうふく」、積立金「つみたてきん」、軌道「きどう」、群衆「ぐんしゅう」、巧妙「こうみょう」、大筋「おおすじ」、主催「しゅさい」、督促「とくそく」、印「しるし」、配布「はいふ」、枠「わく」、決意「けつい」、質素「しっそ」、憤り「いきどおり」、統合「とうごう」、意気込み「いきごみ」、粘り「ねばり」、中枢「ちゅうすう」、厳正「げんせい」、優勝「ゆうしょう」、陳列「ちんれつ」、樹木「じゅもく」、照合「しょうごう」、証「あかし」、繁盛「はんじょう」、網羅「もうら」、念頭「ねんとう」、安堵「あんど」、由緒「ゆいしょ」、添付「てんぷ」、巡り「めぐり」、憩い「いこい」、廃れる「すたれる」、緊密「きんみつ」、強制「きょうせい」、役名「やくめい」、利子「りし」、難点「なんてん」、満喫「まんきつ」、合意「ごうい」、格段「かくだん」、把握「はあく」、競り合い「せりあい」、煩雑「はんざつ」、利潤「りじゅん」、趣旨「しゅし」、仰天「ぎょうてん」、裏腹「うらはら」、閲覧「えつらん」、兆し「きざし」、該当「がいとう」、先方「せんぽう」、目先「めさき」、改革「かいかく」、打診「だしん」、破損「はそん」、素ぶり「そぶり」、多岐「たき」、手間「てま」、緩和「かんわ」、貧富「ひんぷ」、合併「がっぺい」、概略「がいりゃく」、予断「よだん」、真っ先「まっさき」、人手「ひとで」、抜粋「ばっすい」、嫌味「いやみ」、朦朧「もうろう」、携わる「たずさわる」、食い違い「くいちがい」、怒り「いかり」、提起「ていき」、重宝「ちょうほう」、入念「にゅうねん」、工面「くめん」、推理「すいり」、淵「ふち」、遂行「すいこう」、鑑定「かんてい」、仕組み「しくみ」、口出し「くちだし」、腕前「うでまえ」、ゆとり、抱負「ほうふ」、人脈「じんみゃく」、手分け「てわけ」、逸材「いつざい」、踏襲「とうしゅう」、仕業「しわざ」、雑踏「ざっとう」、契約「けいやく」、相場「そうば」、異色「いしょく」、言い訳「いいわけ」、凝縮「ぎょうしゅく」、逸れる「それる」、収支「しゅうし」、有数「ゆうすう」、興奮「こうふん」、指図「さしず」、日夜「にちや」、逸脱「いつだつ」、処置「しょち」、概ね「おおむね」、拍子「ひょうし」、探り「さぐり」、可決「かけつ」、合致「がっち」、何れ「いずれ」、考慮「こうりょ」、経歴「けいれき」、傾斜「けいしゃ」、圧迫「あっぱく」、張り合う「はりあう」、利息「りそく」、起伏「きふく」、根拠「こんきょ」、ノルマ、手がかり「てがかり」、ウエイト、皮肉「ひにく」、固執「こしゅう」、お手上げ「おてあげ」、辞任「じにん」、躍進「やくしん」、裏付け「うらずけ」、帰結「きけつ」、名誉「めいよ」、互角「ごかく」、合弁「ごうべん」、釈明「しゃくめい」、溝「みぞ」、宿命「しゅくめい」、区々「まちまち」、暴露「ばくろ」、開拓「かいたく」、日差し「ひざし」、慣習「かんしゅう」、殺菌「さっきん」、落胆「らくたん」、会心「かいしん」、寄与「きよ」、承諾「しょうだく」、拠り所「よりどころ」、忍耐「にんたい」、大義「だいぎ」、贖罪「しょくざい」、倦怠「けんたい」、戒律「かいりつ」、途方「とほう」、土台「どだい」、分離「ぶんり」、卑怯「ひきょう」、下着「したぎ」、由緒「ゆいしょ」、珍重「ちんちょう」、奉公「ほうこう」、挙式「きょしき」、戦争「せんそう」、基「もとい」、乱発「らんぱつ」、零落「れいらく」、上映「じょうえい」、カオス、座敷「ざしき」、領域「りょういき」、碌「ろく」、内向「ないこう」、一命「いちめい」、贔屓「ひいき」、処分「しょぶん」、潤沢「じゅんたく」、流行「りゅうこう」、息吹「いぶき」、獲物「えもの」、妙「みょう」、幕府「ばくふ」、重荷「おもに」、道連れ「みちずれ」、高潔「こうけつ」、厳正「げんせい」、薬酒「やくしゅ」、気晴らし「きばらし」、報知「ほうち」、悪ふざけ「わるふざけ」、恍惚「こうこつ」、妥協「だきょう」、不思議「ふしぎ」、節目「ふしめ」、ニュアンス、</p><h2 id="3-形容詞"><a href="#3-形容詞" class="headerlink" title="3. 形容詞"></a>3. 形容詞</h2><p>鋭い「するどい」、甚だしい「はなはだしい」、朗らか「ほがらか」、等しい「ひとしい」、素っ気無い「そっけない」、雄大「ゆうだい」、騒がしい「さわがしい」、ぶかぶか「ぶかぶか」、逞しい「たくましい」、所謂「いわゆる」、緩やか「ゆるやか」、惨め「みじめ」、煌々「こうこう」、滑らか「なめらか」、無茶苦茶「むちゃくちゃ」、微か「かすか」、きまぐれ「きまぐれ」、目覚ましい「めざましい」、物足りない「ものたりない」、つれない、申し分ない「もうしぶんない」、べたべた、忌まわしい「いまわしい」、煩わしい「わずらわしい」、頼もしい「たのもしい」、気障「きざ」、切ない「せつない」、密接「みっせつ」、冥冥「めいめい」、見苦しい「みぐるしい」、あっかない、飛び飛び「とびとび」、達観「たっかん」、うざい、閑静「かんせい」、台無し「だいなし」、望ましい「のぞましい」、細やか「ささやか」、淑やか「しとやか」、真面「まとも」、煌々「こうこう」、淡々「たんたん」、厳密「げんみつ」、出しゃばり「でしゃばり」、刺々しい「とげとげしい」、厳か「おごそか」、乏しい「とぼしい」、疎ら「まばら」、慌ただしい「あわただしい」、待ち遠しい「まちどおしい」、疎か「疎か」、和やか「なごやか」、漠然「ばくぜん」、もどかしい、腹立たしい「はらだたしい」、怪しい「あやしい」、呆気ない「あっけない」、仄か「ほのか」、華やか「はなやか」、特異「とくい」、喧しい「やかましい」、無闇「むやみ」、鬱陶しい「うっとうしい」、おっちょこちょい、卑しい「いやしい」、速やか「すみやか」、浅ましい「あさましい」、勇ましい「いさましい」、穏やか「おだやか」、風情「ふぜい」、あくどい、虚しい「むなしい」、潔い「いさぎよい」、健やか「すこやか」、歴然「れきぜん」、悩ましい「なやましい」、画一的「かくいつてき」、広大「こうだい」、紛らわしい「まぎらわしい」、図々しい「ずうずうしい」、夥しい「おびただしい」、呆然「ぼうぜん」、しなやか、在り来り「ありきたり」、頑な「かたくな」、手薄「てうす」、目まぐるしい「めまぐるしい」、素直「すなお」、粘り強い「ねばりずよい」、容易い「たやすい」、爽やか「さわやか」、清々しい「すがすがしい」、柔い「やわい」、不備「ふび」、強か「したたか」、心地よい「ここちよい」、凄まじい「すさまじい」、紛れる「まぎれる」、弱い「よわい」、幅広い「はばひろい」、克明「こくめい」、重厚「じゅうこう」、端的「たんてき」、顕著「けんちょ」、分厚い「ぶあつい」、淡い「あわい」、密か「ひそか」、閑静「かんせい」、肝心「かんじん」、あり得ない「ありえない」、愕然「がくぜん」、口惜しい「くちおしい」、手ごろ「てごろ」、朗らか「ほがらか」、あやふや、立派「りっぱ」、だらしない、</p><h2 id="4-副詞"><a href="#4-副詞" class="headerlink" title="4. 副詞"></a>4. 副詞</h2><p>ぶらぶら、こそこそ、じろじろ、たっぷり、はらはら、がさがさ、がっしり、がやがや、さっぱり、しみじみ、のんびり、ゆったり、すやすや、ぎょうぎょう、めらめら、そっと、益々「ますます」、すらすら、尚更「なおさら」、ちらほら、いよいよ、めちゃくちゃ、ひんやり、ドキドキ、伸び伸び「のびのび」、にこにこ、ぞろぞろ、もやもや、ひっそり、そわそわ、ひょっとして、のっそり、とにかく、わくわく、うっかり、ごろごろ、めそめそ、ぞっと、僅か「わずか」、どっしり、ぐったり、嘸「さぞ」、いやいや、ちょいちょい、如何「いかん」、しっかり、ひたすら、予め「あらかじめ」、差し当たって、からから、ヘラヘラ、ぐっすり、ぐるぐる、のんびり、ひらひら、如何にも「いかにも」、ぼんやり、がっかり、ズルズル、偶々「たまたま」、きっちり、しっとり、元来「がんらい」、あっさり、びっくり、うっとり、丸ごと「まるごと」、すっかり、直に「じかに」、頻りに「しきりに」、バッチリ、ぎっしり、あたかも、すかすか、せっかく、きっかり、最早「もはや」、因みに「ちなみに」、こっそり、悠々「ゆうゆう」、ぼろぼろ、ハキハキ、ぺこぺこ、ふっくら、さっさと、にっこり、ギリギリ、すくすく、じめじめ、果たして「はたして」、至って「いたって」、敢えて「あえて」、からっと、いっそ、ぬるぬる、せめて、隈なく「くまなく」、とっくに、ぎっしり、くよくよ、悉く「ことごとく」、いとも、自ずと「おのずと」、ぐらぐら、ぶらぶら、猛然「もうぜん」、ぼうっと、てきぱき、俄かに「にわかに」、正しく「まさしく」、予々「かねがね」、ふんわり、どうやら、うんざり、不意に「ふいに」、改めて「あらためて」、辛うじて「かろうじて」、急遽「きゅうきょ」、丸で「まるで」、めきめき、随時「ずいじ」、即刻「そっこく」、へとへと、ざっと、しんなり、若干「じゃっかん」、一先ず「ひとまず」、すんなり、無性に「むしょうに」、さらさら、ちらっと、強いて「しいて」、何となく「なんとなく」、取り分け「とりわけ」、且つ「かつ」、はっきり、逐一「ちくいち」、言わば「いわば」、少しずつ「すこしずつ」、どんどん、ちやほや、全く「まったく」、些か「いささか」</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年8月东大情理CS算法题解读</title>
    <link href="/2024/09/15/UTO-DSA-2021-8/"/>
    <url>/2024/09/15/UTO-DSA-2021-8/</url>
    
    <content type="html"><![CDATA[<h1 id="Author-偷偷"><a href="#Author-偷偷" class="headerlink" title="Author: 偷偷  "></a><center>Author: 偷偷  </center></h1><h1 id="尊重原创，偷偷wx-LifeGoesOn-Rio"><a href="#尊重原创，偷偷wx-LifeGoesOn-Rio" class="headerlink" title="尊重原创，偷偷wx:LifeGoesOn_Rio  "></a><center>尊重原创，偷偷wx:LifeGoesOn_Rio  </center></h1><div class="note note-success">            <p>这道题的场景是实现一个排序算法，目的是优化时间复杂度。题目的策略是使用分治递归(Divide &amp; Conquer),在深度理解题目的场景下可以解决这道题目。</p>          </div><p>Firstly, read the pseudocode.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// return the least value that is >= kl/m</span><span class="token keyword">int</span> <span class="token function">multfrac</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// *q &lt;= *p</span><span class="token keyword">void</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">></span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>        <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>        <span class="token operator">*</span>q <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// sort in ascending order</span><span class="token keyword">void</span> <span class="token function">mysort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>  <span class="token comment">// number of elements</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">/** fill in the  blanks **/</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>(1) 当k &lt; 4, 即元素个数小于4时做升序排序，分类讨论即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>   <span class="token comment">// 元素个数不多于1时，不做任何处理</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比较交换一次</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token comment">// 依次比较三次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>算法详细过程如下：<br><img src="/img/DSA/swap_compare.jpg" alt="交换流程演示" style="max-width: 100%; height: auto;" /></p><p>(2) </p><p>$$<br>T(n)&#x3D;<br>\begin{cases}<br>1,\quad n\leq 3 \\<br>n^{\log_{4&#x2F;3}{3}}, \quad n&gt;3<br>\end{cases}<br>$$</p><p>这里也是分类讨论：</p><p>当n &lt;&#x3D; 3时，比较次数不随输入规模变化，因此为1；</p><p>当n &gt; 3时，代入分析：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort后3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><img src="/img/DSA/swap_compare2.jpg" alt="递归树演示" style="max-width: 100%; height: auto;" /><p>根据递归树可以写出主定理公式(Master theorem):<br>$$T(n) &#x3D; 3T(3n&#x2F;4) + O(n) $$<br>根据套路：这里b &#x3D; 4&#x2F;3, a &#x3D; 3.<br>$$O(n ^{\log_{b}{a}}) &#x3D; O(n^{log_{4&#x2F;3}{3}}) &gt; O(n) $$<br>所以有<br>$$T(n) &#x3D; O(n^{\log_{4&#x2F;3}{3}})$$</p><p>(3) (4, 2, 3, 3), (4, 3, 2, 3), (4, 3, 3, 2) can always work properly. (4, 2, 3, 2) can’t always work properly.</p><blockquote><p>可以看下图演示：前两次的sort调用的交集部分是排好数组最大的部分，第三次sort调用要覆盖剩余没有排好的部分；对于(4, 2, 3, 2), 前两次调用排好了数组最大的1&#x2F;4部分，所以第三次调用至少要覆盖数组前3&#x2F;4的大小，而第三次调用只覆盖了前1&#x2F;2，所以这个组合不行。</p></blockquote><img src="/img/DSA/swap_compare3.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>(4)<br>$$<br>\begin{cases}<br>    x + y &gt; w \\<br>    x + y + z &gt;&#x3D; 2w<br>\end{cases}<br>$$</p><blockquote><p>在解决第三题后，第四题就非常容易了。</p></blockquote><img src="/img/DSA/swap_compare4.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>视数组的大小为1，第一次调用排好前x&#x2F;w部分的元素，第二次大小排好后y&#x2F;w部分的元素。所以排序需满足：</p><ol><li>前两次调用的范围必须要有交集</li><li>第三次调用必须要覆盖完前两次调用的没有排好的部分。因此有：<br>$$ x&#x2F; w + y &#x2F; w &gt; 1$$<br>$$ z &#x2F; w &gt;&#x3D;  1 - (x + y - w) &#x2F; w $$</li></ol>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>数据结构与算法</category>
      
      <category>东京大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
      <tag>东京大学</tag>
      
      <tag>修考答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure &amp; Algorithms</title>
    <link href="/2024/09/10/DSA/"/>
    <url>/2024/09/10/DSA/</url>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure-Algorithms"><a href="#Data-Structure-Algorithms" class="headerlink" title="Data Structure &amp; Algorithms"></a>Data Structure &amp; Algorithms</h1><p>This is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(<strong>偷偷</strong>).The main language is in Chinese but you can see some concepts in English &amp; Japanese. And the pseudocode is in the style of <strong>C++</strong>. Let’s quickly review this subject!</p><p>这是偷偷刷了很多修考题之后总结出来的修考秘籍，全文都是考点，彻底高能。</p><h2 id="1-Introduction-to-Algorithms"><a href="#1-Introduction-to-Algorithms" class="headerlink" title="1. Introduction to Algorithms"></a>1. Introduction to Algorithms</h2><p>这一章主要计划复习<strong>时间复杂度(Time Complexity)</strong> 和 <strong>空间复杂度(Space Complexity)</strong> 两个概念，然后再仔细回顾 <strong>分治递归(DIvide &amp; Conquer)</strong> 这一重要的概念。最后再给出解决时间复杂度常用的分析方法和万能的<strong>主定理公式（Master Theorem）</strong></p><h3 id="1-1-时间复杂度与空间复杂度"><a href="#1-1-时间复杂度与空间复杂度" class="headerlink" title="1.1 时间复杂度与空间复杂度"></a>1.1 时间复杂度与空间复杂度</h3><div class="note note-success">            <p><strong>Space Complexity</strong>: 空间复杂度描述的是算法运行时所需的额外内存空间。通俗解释就是算法在运行的时候需要开辟多少空间的大小。O(1)指一个点集；O(n)就是开辟一个一维空间；O(n^2)开辟二维空间；O(n^3)开辟三维空间。在第二章讲解排序算法的时候，也会用到本章非常多的前置知识。</p>          </div><p>O(1): 常数空间复杂度，表示算法所需的额外空间是固定的，不随输入规模变化。例如，一个固定大小的变量。</p><p>O(n): 线性空间复杂度，表示算法所需的额外空间与输入规模成正比。例如，一个长度为 n 的数组。</p><p>O(n^2): 平方空间复杂度，表示算法所需的额外空间与输入规模的平方成正比。例如，一个 n x n 的二维数组。</p><p>O(n^3): 立方空间复杂度，表示算法所需的额外空间与输入规模的立方成正比。例如，一个 n x n x n 的三维数组。</p><p>一些常见的数据结构的空间复杂度：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> nums <span class="token comment">// 三维数组：O(n^3)</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> nums <span class="token comment">// 二维数组：O(n^2)</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>      <span class="token comment">// 栈：O(n)</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token comment">// 双端队列：O(n)</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> linkedList<span class="token punctuation">;</span>   <span class="token comment">// 链表：O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p><strong>Time complexity</strong>: 时间复杂度是衡量算法效率的重要指标之一，它描述了算法执行所需时间随输入规模增长的变化情况。这是修考中必考的一个地方：（1）如分析给出的代码的时间复杂度（Hint：关注for，while循环）（2）根据源代码优化时间复杂度设计新的算法（Hint：空间换时间）</p>          </div><p>常见的时间复杂度有以下几种：</p><p>O(1): <strong>常数时间复杂度</strong>，算法的执行时间不随输入规模变化。例如，访问数组中的某个元素。</p><p><code>int a = nums[10]  // 给a赋值数组下标为10的元素</code></p><p>O(n): <strong>线性时间复杂度</strong>，算法的执行时间与输入规模成正比。例如，遍历一个长度为 n 的数组。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; /* 操作 */ &#125;</code></p><p>O(log n): 对数时间复杂度，算法的执行时间随输入规模的对数增长。例如，二分查找(Binary Search)算法。</p><p><code>int binarySearch(int[] arr, int target) &#123; /* 二分查找逻辑 */ &#125;</code></p><p> O(n^2) : <strong>平方时间复杂度</strong>，算法的执行时间与输入规模的平方成正比。例如，冒泡排序(Bubble Sort)算法。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; /* 冒泡排序逻辑 */ &#125; &#125;</code></p><p>O(2^n): <strong>指数时间复杂度</strong>，算法的执行时间随输入规模的指数增长。例如，解决所有子集问题的递归算法。</p><p><code>void subsets(int[] nums) &#123; /* 递归逻辑 */ &#125;</code></p><p>在描述使劲复杂度的时候，有三种表示需要注意一下：</p><p>$O$: 表示渐进上界； $\Omega$: 表示渐进下界； $\Theta$: 渐进紧确界</p><h3 id="1-2-分治递归-Divide-Conquer"><a href="#1-2-分治递归-Divide-Conquer" class="headerlink" title="1.2 分治递归(Divide &amp; Conquer)"></a>1.2 分治递归(Divide &amp; Conquer)</h3><div class="note note-success">            <p>分治递归(Divide &amp; conquer)的思想是将原问题分割成更小的子问题，自顶向下地解决每个子问题，并最终自底向上合并它们的解来解决主问题。</p>          </div><p>常见的分治递归有：二分查找(Binary Search) 和归并排序(Merge Sort).</p><h4 id="1-2-1-二分查找-Binary-Search"><a href="#1-2-1-二分查找-Binary-Search" class="headerlink" title="1.2.1 二分查找(Binary Search)"></a>1.2.1 二分查找(Binary Search)</h4><img src="/img/DSA/binary_search.svg" alt="二分查找演示" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 前提nums是有序数组</span><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// (避免left + right) / 2 的溢出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>   <span class="token comment">// 找到目标，返回索引</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 目标在左半部分</span>        <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 目标在右半部分</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>根据上图我们得出递归表达式：<br>$T(n) &#x3D; T(n &#x2F; 2) + O(1)$， 得出$T(n) &#x3D; O(log_{2}{n})$</p><h4 id="1-2-2-归并排序-Merge-Sort"><a href="#1-2-2-归并排序-Merge-Sort" class="headerlink" title="1.2.2 归并排序(Merge Sort)"></a>1.2.2 归并排序(Merge Sort)</h4><img src="/img/DSA/merge_sort.svg" alt="归并排序演示" style="max-width: 100%; height: auto;" />这个图像有效地展示了归并排序的"分而治之"策略： 1.将大问题（排序整个数组）分解成小问题（排序子数组） 2.解决小问题（对小数组排序） 3.将小问题的解合并成大问题的解（合并有序子数组）<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 合并两个有序的子数组</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子数组的长度</span>    <span class="token keyword">int</span> n2 <span class="token operator">=</span> right <span class="token operator">-</span> mid<span class="token punctuation">;</span>     <span class="token comment">// 右子数组的长度</span>    <span class="token comment">// 创建临时数组存储左右子数组</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftArr</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rightArr</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 复制数据到临时数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> rightArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token comment">// i是左子数组指针，j是右子数组指针，k是合并后数组的指针</span>    <span class="token comment">// 合并左右子数组</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的左子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的右子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 递归实现归并排序</span><span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 递归排序左右两部分</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 合并已排序的部分</span>        <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>递归式：$T(n) &#x3D; 2T(n &#x2F; 2) + O(n)$, 所以$T(n) &#x3D; O(nlog_{2}{n})$</p><h3 id="1-3-主定理-Master-Theorem"><a href="#1-3-主定理-Master-Theorem" class="headerlink" title="1.3 主定理(Master Theorem)"></a>1.3 主定理(Master Theorem)</h3><p>递归方程形式如：<br>$$T(n) &#x3D; aT(n &#x2F; b) + O(n^d)$$</p><div class="note note-success">            <p>其中，$a$表示子问题的数量，b表示每个子问题是原问题规模的$1&#x2F;b$, $O(n^d)$ 表示在每一层分治过程之外，解决问题所需的额外代价，通常是合并或分割的代价。</p>          </div><p><strong>情况 1：</strong><br>如果$log_{b}{a} &gt; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(\log_{b}{a}) $$</p><p><strong>解释：</strong> 在这种情况下，分治产生的子问题数量增长得更快，主导时间复杂度的是递归中的分治部分。</p><p><strong>情况 2：</strong><br>如果$log_{b}{a} &#x3D; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(n^d\log{n}) $$</p><p><strong>解释：</strong> 在这种情况下，分治和额外开销的增长速度相同，因此总的时间复杂度是 $n^d\log{n}$。</p><p><strong>情况 3：</strong><br>如果 $log_{b}{a} &lt; d$，则递归式的解为：<br>$$T(n) &#x3D; O(n^d)$$<br><strong>解释：</strong> 在这种情况下，额外的开销主导时间复杂度，因此复杂度主要由 $n^d$决定。</p><p><strong>斯特林近似公式（Stirling’s Formula）:</strong> $n! \approx \sqrt{2 \pi n} \left( \frac{n}{e} \right)^n$</p><h2 id="2-Sorting-Algorithm"><a href="#2-Sorting-Algorithm" class="headerlink" title="2.Sorting Algorithm"></a>2.Sorting Algorithm</h2><p>再时间复杂度和空间复杂度的概念后，并引入了分治递归和归并排序算法；接下来这一章就主要回顾常见的一些排序算法，然后分析他们的时间复杂度和空间复杂度。</p><h3 id="2-1-插入排序-Insertion-Sort"><a href="#2-1-插入排序-Insertion-Sort" class="headerlink" title="2.1 插入排序(Insertion Sort)"></a>2.1 <strong>插入排序(Insertion Sort)</strong></h3><p>这个算法的过程也很直观：插入排序的核心思想是将一个新元素插入到已经排好序的子序列中的适当位置。<br><img src="/img/DSA/insertation_sort.svg" alt="插入排序演示" style="max-width: 100%; height: auto;" /><br>最好的情况下是：原数组规模小或者大部分数据有序，那么我们一次遍历就可以完成好排序。 最坏的情况下是：原数组是降序排列的，意思是每一次插入新元素的时候，都要遍历一遍已排好序的子数组。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 从第二个元素开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 回溯检查并交换</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最坏情况：$T(n) &#x3D; T(n - 1) + O(n)$,  $T(n) &#x3D; O(n^2)$</p><p>最好情况：$T(n) &#x3D; T(n - 1) + O(1)$,  $T(n) &#x3D; O(n)$</p><h3 id="2-2冒泡排序-Bubble-Sort"><a href="#2-2冒泡排序-Bubble-Sort" class="headerlink" title="2.2冒泡排序(Bubble Sort)"></a>2.2冒泡排序(Bubble Sort)</h3><p>冒泡排序是一个直观的算法，通过重复地遍历数组来工作。在每次遍历中，它比较相邻的元素并在需要时交换它们，这样每次迭代都会将当前未排序部分中的最大元素’冒泡’到数组的末尾正确位置。这个过程从左到右重复进行，直到整个数组排序完成。一句话概括就是：不断的进行两两比较。<br><img src="/img/DSA/bubble_sort.svg" alt="冒泡排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 控制循环的轮数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 内层循环，相邻比较</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 交换元素</span>                std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>冒泡排序平均时间复杂度</strong>：$T(n) &#x3D; O(n^2)$</p><h3 id="2-3选择排序-Selection-Sort"><a href="#2-3选择排序-Selection-Sort" class="headerlink" title="2.3选择排序(Selection Sort)"></a>2.3选择排序(Selection Sort)</h3><p>选择排序的基本思想是分阶段地将数组划分为两部分：已排序部分和未排序部分。每一轮从未排序部分中找到最小（或最大）的元素，放到已排序部分的末尾，直到整个数组排序完成。<br><img src="/img/DSA/selection_sort.svg" alt="选择排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 已排序数组末尾</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 找未排序数组中的最小元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIdx <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>选择排序时间复杂度：</strong> $T(n) &#x3D; O(n^2)$</p><h3 id="2-4快速排序-Quick-Sort"><a href="#2-4快速排序-Quick-Sort" class="headerlink" title="2.4快速排序(Quick Sort)"></a>2.4快速排序(Quick Sort)</h3><p>快速排序的本质是分治法。它通过选择一个基准元素，将原数组划分为小于基准元素和大于基准元素的两个子数组，然后对这两个子数组进行递归排序。<br><img src="/img/DSA/quick_sort.svg" alt="快速排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分区函数</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 选择最后一个元素作为基准</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 小于基准的元素的索引</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果当前元素小于或等于基准</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 增加小于基准的元素索引</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 快速排序函数</span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// pi是分区索引，arr[pi]现在在正确的位置</span>        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 分别对左右子数组进行递归排序</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在最坏情况下，基准元素可能是最大或最小值，这会导致一个子数组为空，另一个子数组的大小为 $n-1$，此时的时间复杂度为 $T(n) &#x3D; T(n-1) + O(n) &#x3D;O(n^2)$。而在平均情况下，基准元素能够较好地划分数组，时间复杂度为 $T(n) &#x3D; 2T(n&#x2F;2) + O(n)&#x3D;O(n\log{n})$ 。</p><h3 id="2-5堆排序-Heap-Sort"><a href="#2-5堆排序-Heap-Sort" class="headerlink" title="2.5堆排序(Heap Sort)"></a>2.5堆排序(Heap Sort)</h3><p>这个考点应该是修考最爱考的一个了！（敲重点）堆排序的基本思想是不断维护一个最大堆。在每次排序过程中，首先将最大堆的根节点（最大值）与堆的最后一个元素交换，然后缩小堆的范围（排除最后一个元素），并对新的根节点进行下沉操作，以恢复最大堆的性质。重复这一过程，直到所有元素都被排序。<br><img src="/img/DSA/heap_sort.svg" alt="堆排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 堆化函数，用于维护最大堆性质</span><span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 初始化最大值为根</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子节点</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 右子节点</span>    <span class="token comment">// 如果左子节点大于根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token comment">// 如果右子节点大于当前最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token comment">// 如果最大值不是根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 递归地堆化受影响的子树</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 堆排序函数</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 构建最大堆（从最后一个非叶子节点开始）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 一个个从堆顶取出元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前根移到末尾</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在减小的堆上调用 max heapify</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>建堆的时间复杂度为$O(n)$,每个节点的调整最多为$O(\log{n})$次。在排序的过程中需要建堆$O(n)$次，并且每次需要$O(logn)$来维护堆(heapify),因此对排序总的时间复杂度为$O(n\log{n})$</p><h2 id="3-Data-Structure"><a href="#3-Data-Structure" class="headerlink" title="3.Data Structure"></a>3.Data Structure</h2><p>这一章主要讲解常见的数据结构,如栈(stack),队列(queue),链表(linked list),哈希表(hash map),以及字符串(string)。二叉树考点众多我会单独做成一章并且和图算法一块复习。</p><h3 id="3-1-Stack-Queue"><a href="#3-1-Stack-Queue" class="headerlink" title="3.1 Stack &amp; Queue"></a>3.1 Stack &amp; Queue</h3><p><strong>栈(stack)</strong> :后进先出(LIFO), <strong>队列</strong> :先进先出(FIFO)。另外，栈和队列是可以相互实现的，了解到这个程度，我认为就掌握到栈和队列的基本性质了。</p><p><em>Q1: 如何用栈实现队列？</em></p><div class="note note-success">            <p>A: 开两个栈，一个负责栈负责放入元素，另一个栈负责弹出元素</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个栈负责放入元素，一个栈负责弹出元素</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>      <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟入队过程</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟弹出队首元素过程</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取队首元素的值</span>    <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取队首元素的值</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 放回</span>        out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>Q2：如何用队列实现栈？</em></p><div class="note note-success">            <p>A：开两个队列，一个模拟入栈，一个模拟出栈。更优化的方式是直接开一个队列即可,不断的出队入队就可以实现栈的性质。</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个队列负责入栈，一个负责出栈</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 把in队列的元素不断出队只剩一个，即时栈顶</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶的元素</span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取弹出后的值</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 再放入队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 弹出栈顶元素</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      n<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 把对位元素调整到队首</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶元素  </span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> ans<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="3-2-Linked-List"><a href="#3-2-Linked-List" class="headerlink" title="3.2 Linked List"></a>3.2 Linked List</h3><p>常见的链表有单链表和双链表。<em>单链表</em>：每个节点只包含一个指向下一个节点的指针，访问节点时只能从头节点开始向后遍历。<em>双链表</em>：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。这使得可以在链表中向前和向后遍历。<br><img src="/img/DSA/linkedlist.svg" alt="链表演示" style="max-width: 100%; height: auto;" /></p><p><strong>链表的优缺点</strong></p><p><em>优点</em>：1)动态大小：链表的大小可以动态调整，不像数组那样需要预先定义大小。2)方便插入和删除：在链表中插入或删除节点的时间复杂度为 O(1)，只需调整指针，而数组则可能需要移动大量元素。</p><p><em>缺点</em>：1)内存占用：每个节点需要额外的存储空间来存储指针，导致比数组更高的内存开销。2)随机访问困难：链表不支持快速随机访问，查找元素的时间复杂度为 O(n)。</p><h3 id="3-3-Hash-Map"><a href="#3-3-Hash-Map" class="headerlink" title="3.3 Hash Map"></a>3.3 Hash Map</h3><p><strong>哈希映射（Hash Map）</strong> 是一种数据结构，用于以键值对（key-value pairs）形式存储数据。它通过一个哈希函数将键映射到数组中的索引，从而实现快速的数据访问。主要特点有：</p><p>1）快速查找：平均情况下，哈希映射可以在 O(1) 时间内进行查找、插入和删除操作。</p><p>2）键值对存储：每个元素都由一个唯一的键和与之关联的值组成，可以通过键快速访问对应的值。</p><p>3）哈希函数：将键转换为数组索引的函数，好的哈希函数可以减少冲突（不同键映射到相同索引）。</p><p>4）处理冲突：常用的方法包括<strong>链式法(chaining)<strong>和</strong>开放寻址法（open addressing）</strong>。<br><img src="/img/DSA/hash.svg" alt="哈希表处理冲突演示" style="max-width: 100%; height: auto;" /></p><p>为了减少哈希冲突，哈希映射的函数要尽量将不同的输入键均匀地映射到哈希表的不同索引，以减少冲突（即不同键映射到相同索引的情况）。</p><h3 id="3-4-string"><a href="#3-4-string" class="headerlink" title="3.4 string"></a>3.4 string</h3><p>字符串这个数据结构直观易懂，主要涉及到的考点有KMP算法和sequence alignment算法。这里主要回顾一下KMP算法，关于string类型的其他考点：最长子序列问题和序列比对(Sequence Alignment)，会在后面动态规划章节中仔细讲解。</p><h4 id="3-4-1-KMP算法"><a href="#3-4-1-KMP算法" class="headerlink" title="3.4.1 KMP算法"></a>3.4.1 KMP算法</h4><p>KMP算法可以说是学一次忘一次……建议考前一定要临时报佛脚记一下。这个算法的美妙之处就是在于优化了暴力匹配，用前缀表来跳过重复的匹配过程。前缀表就是模式串中每个位置的最长相等前缀和后缀的长度。在发生不匹配的情况下，将子串移动前一个字符串的前缀表的具体值。（感觉京大最喜欢考KMP算法了）<br><img src="/img/DSA/KMP.svg" alt="KMP算法演示" style="max-width: 100%; height: auto;" /></p><h2 id="4-Binary-Tree"><a href="#4-Binary-Tree" class="headerlink" title="4.Binary Tree"></a>4.Binary Tree</h2><p>关于二叉树的考点有许多，像是考二叉树的遍历，二叉搜索树（Binary Search Tree），最小生成树（MST），以及AVL树。首先需要了解二叉树的一些基本性质，例如每个节点的下标，以及二叉树的多种遍历方式。</p><h3 id="4-1-Concepts-of-Binary-Tree"><a href="#4-1-Concepts-of-Binary-Tree" class="headerlink" title="4.1 Concepts of Binary Tree"></a>4.1 Concepts of Binary Tree</h3><img src="/img/DSA/binary_tree.svg" alt="常见的二叉树" style="max-width: 100%; height: auto;" /><p><strong>完全二叉树（complete binary tree）</strong>：是一种二叉树，其中每一层都是满的，除了可能是最后一层，且最后一层的节点从左到右排列。在完全二叉树中，所有的节点都尽可能地靠左排列，这种结构使得它在存储和操作上更为高效。与全二叉树不同，完全二叉树允许最后一层不满，但仍需保持左侧填充。</p><p>对于一个完全二叉树，如果节点的索引为$i$,节点数为$n$那么：</p><ol><li>左孩子节点索引: $2i$</li><li>右孩子节点索引: $2i + 1$</li><li>父亲节点索引: $[i&#x2F;2]$  </li><li>二叉树高度: $ceil(log_{2}{(n+1)})$ 或 $floor(log_{2}{n}) + 1$</li></ol><p><strong>全二叉树（full binary tree）</strong>：是指每个节点要么没有子节点，要么恰好有两个子节点的二叉树。在这种树中，除了叶子节点外，所有节点都有两个子节点。这样的结构确保了树的每一层都被完全填满，只有最后一层可能不满。</p><p><strong>二叉搜索树（Binary Search Tree, BST）</strong>: 是一种二叉树，其中每个节点都包含一个键值，左子树的所有节点键值小于该节点，右子树的所有节点键值大于该节点。这种结构使得查找、插入和删除操作的平均时间复杂度为 O(log n)。其主要性质包括：每个节点最多有两个子节点，左子树和右子树都是二叉搜索树，且没有重复的键值。</p><p>二叉搜索树的搜索迭代实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">></span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="4-2-Tree-Traversal"><a href="#4-2-Tree-Traversal" class="headerlink" title="4.2 Tree Traversal"></a>4.2 Tree Traversal</h3><p><strong>层序遍历（Level Order Traversal）：</strong> 开一个队列处理一层的节点并放入下一层的节点。这个遍历也属于<strong>广度优先遍历（BFS）</strong>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">auto</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>二叉树的<strong>深度优先遍历（DFS）</strong> 可以分为三种：前序遍历，中序遍历和后序遍历。</p><p><strong>前序遍历（Preorder Traversal）：</strong>  <em>根-&gt;左-&gt;右</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然也可以开一个栈来实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>后序遍历（Postorder Traversal）：</strong>  <em>左-&gt;右-&gt;根</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>后序遍历同样可以开一个栈来实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>中序遍历（Inorder Traversal）：</strong>  <em>左-&gt;根-&gt;右</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然也可以开一个栈来实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token operator">-></span> right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>二叉树的中序遍历还有一个重要的考点是<em>逆波兰表达式</em>,这个曾经在京大的过去问中出现过。<strong>逆波兰表达式（Reverse Polish Notation, RPN）</strong> 是一种后缀表示法，用于表示算术表达式。在这种表示法中，运算符跟在操作数之后，而不是在它们之间。这种形式的好处是消除了括号的需要，因为操作的顺序总是由操作符的位置决定。具体的实现方法可以开一个栈轻松解决。<br><img src="/img/DSA/rpn.svg" alt="逆波兰表达式" style="max-width: 70%; height: auto;" /></p><h3 id="4-3-AVL-Tree"><a href="#4-3-AVL-Tree" class="headerlink" title="4.3 AVL Tree"></a>4.3 AVL Tree</h3><p><strong>AVL树</strong>是一种自平衡的二叉搜索树，确保每个节点的左右子树高度差（平衡因子）最多为1。这样可以保证树的高度在 $O(log{n})$ 范围内，确保高效的插入、删除和查找操作。AVL树通过旋转操作来维持平衡，从而优化性能，特别是在频繁修改的场景中。东工有一年考到了这个点，但我认为了解到AVL树的工作原理就ok了,主要聚焦在节点的添加和删除以及树的旋转。<br><img src="/img/DSA/avl_tree_insert.svg" alt="AVL树增加节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_delete.svg" alt="AVL树删除节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_rotate.svg" alt="AVL树左旋和右旋" style="max-width: 100%; height: auto;" /></p><h2 id="5-Graph-Theory"><a href="#5-Graph-Theory" class="headerlink" title="5.Graph Theory"></a>5.Graph Theory</h2><p>本章主要讲解图的基本算法，最小生成树，单源最短路径算法，单源最短路径算法和多源最短路径算法，以及最大流问题。修考题的图算法都是套的模版，因此了解算法的核心思想非常关键。</p><h3 id="5-1图的基本算法"><a href="#5-1图的基本算法" class="headerlink" title="5.1图的基本算法"></a>5.1图的基本算法</h3><p>对于图的表示，我们需要建立一个<strong>邻接矩阵(adjacency matrix)</strong>,简单图的邻接矩阵是(0,1)矩阵并且对角线元素都为0。无向图的邻接矩阵是对称矩阵。<br><img src="/img/DSA/adjacency_matrix.svg" alt="邻接矩阵" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-BFS"><a href="#5-1-1-BFS" class="headerlink" title="5.1.1 BFS"></a>5.1.1 BFS</h4><p>在二叉树章节中讲解了树的深度遍历算法，在图中，我们可以同样的利用邻接链表（也就是建一个数组）来获取当前遍历的节点的邻接节点，开一个数组记录已访问的节点，最后利用队列实现层序遍历。<br><img src="/img/DSA/bfs.svg" alt="广度优先算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// BFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Create a queue for BFS</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> queue<span class="token punctuation">;</span>        <span class="token comment">// Mark the source node as visited and enqueue it</span>        visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Dequeue a vertex from queue and print it</span>            s <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Get all adjacent vertices of the dequeued vertex s</span>            <span class="token comment">// If an adjacent has not been visited, then mark it visited</span>            <span class="token comment">// and enqueue it</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-1-2-DFS"><a href="#5-1-2-DFS" class="headerlink" title="5.1.2 DFS"></a>5.1.2 DFS</h4><p>DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索图形或树数据结构的算法。它尽可能深地访问节点，然后回溯，寻找未访问过的节点。</p><p><strong>基本原理：</strong></p><ol><li>初始化：从起始节点出发，将其标记为访问过。之后开始递归或使用栈</li><li><em>递归</em>：对每个未访问的邻接节点，递归调用DFS。（递归的实现方式就是利用栈来记录每一次函数调用的状态）<br><em>栈</em>：将节点压入栈中，访问节点时将其出栈，继续访问其未访问的邻接节点，并将这些邻接节点压入栈。</li><li><em>回溯</em>：如果当前节点的所有邻接节点都访问过，则回溯到上一个节点，继续这个过程，直到所有节点都访问完。<img src="/img/DSA/dfs.svg" alt="深度优先算法" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">&amp;</span>visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark the current node as visited and print it</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token comment">// Recur for all the vertices adjacent to this vertex</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// DFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all the vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Call the recursive helper function to print DFS traversal</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p>BFS和DFS对比非常鲜明。BFS的性格是保守，害怕风险，尽量做到“广撒网，细收鱼”；而DFS则是奔放，秉持着一颗“不撞南墙不回头”，“不到黄河不死心”的感觉。</p>          </div></li></ol><h4 id="5-1-3-Topological-Sort"><a href="#5-1-3-Topological-Sort" class="headerlink" title="5.1.3 Topological Sort"></a>5.1.3 Topological Sort</h4><p><strong>拓扑排序（Topological Sorting）</strong>是图论中的一种线性排序方法，主要用于对<strong>有向无环图（Directed Acyclic Graph, DAG</strong> 中的顶点进行排序，使得对于图中的每一条有向边 (u → v)，顶点 u 在排序中都出现在顶点 v 的前面。<br><img src="/img/DSA/topo_sort.svg" alt="拓扑排序算法" style="max-width: 100%; height: auto;" /><br><strong>拓扑排序算法步骤：</strong></p><ol><li>计算每个顶点的入度：统计每个顶点被其他顶点指向的次数（即入度, inDegree）。</li><li>将所有入度为 0 的顶点加入队列：这些顶点没有任何前置依赖。</li><li>重复以下步骤直到队列为空：（1）从队列中取出一个顶点 u，将其加入拓扑排序结果中。（2）遍历 u 的所有邻接顶点 v，将 v 的入度减 1；如果 v 的入度变为 0，则将 v 加入队列。</li><li>检查结果：如果所有顶点都被处理过，则返回拓扑排序；否则，图中有环，无法进行拓扑排序。</li></ol><p>在初始化时，需要遍历所有顶点计算入度，耗时$O(V)$；然后遍历所有边来更新入度并处理顶点，耗时$O(E)$。因此总的时间复杂度是$O(V + E)$。最终的排序顺序是: $1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7$。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span>  <span class="token comment">// 顶点数</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span>  <span class="token comment">// 邻接表</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inDegree<span class="token punctuation">;</span>  <span class="token comment">// 入度数组</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inDegree</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        <span class="token comment">// 将所有入度为0的顶点加入队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 对于所有相邻的顶点，将其入度减1</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 检查是否存在环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"图中存在环，无法进行拓扑排序"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-1-4-Union-Find"><a href="#5-1-4-Union-Find" class="headerlink" title="5.1.4 Union Find"></a>5.1.4 Union Find</h4><p><strong>并查集（Union-Find）</strong> 算法，又称为不相交集数据结构，是一种用于处理元素分组及查询元素所属组的高效数据结构。它广泛应用于图论（如判断图的连通性、<em>Kruskal算法</em>求最小生成树）并查集主要支持<strong>两种操作</strong>：</p><ol><li>查找（Find）：确定某个元素属于哪个集合（即找到该元素所在集合的代表元素或根节点）。</li><li>合并（Union）：将两个不同的集合合并为一个集合。</li></ol><p>为了提高并查集的效率，通常结合以下两种优化策略：</p><ol><li>路径压缩（Path Compression）：在 Find 操作中，将访问过的所有节点直接连接到根节点，从而降低树的高度。</li><li>按秩合并（Union by Rank）或按大小合并（Union by Size）：在 Union 操作中，总是将较小的树挂到较大的树下，保持树的平衡。</li></ol><p>结合这两种优化后，并查集的时间复杂度几乎接近于常数时间，具体为 反阿克曼函数 的时间复杂度，几乎可以认为是 $O(1)$。<br><img src="/img/DSA/union_find.svg" alt="并查集算法" style="max-width: 100%; height: auto;" /><br>以下是一个使用路径压缩和按秩合并优化的并查集实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 存储每个节点的父节点</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rank<span class="token punctuation">;</span>    <span class="token comment">// 存储每个节点的秩（树的高度）</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数：初始化每个节点的父节点为自身，秩为1</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        rank<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作：查找元素x所在集合的根节点，并进行路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 路径压缩</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作：将元素x和元素y所在的集合合并</span>    <span class="token keyword">void</span> <span class="token function">unionSets</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 已经在同一个集合中</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 按秩合并：将秩较小的树挂到秩较大的树下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-2-Minimum-Spanning-Tree"><a href="#5-2-Minimum-Spanning-Tree" class="headerlink" title="5.2 Minimum Spanning Tree"></a>5.2 Minimum Spanning Tree</h3><p><strong>最小生成树（Minimum Spanning Tree, MST）</strong> 是指在一个带权无向图中，连接所有顶点的一个子图，使得：</p><ol><li>这个子图是一个树（即没有环，并且连通所有顶点）。</li><li>这个树的总边权和最小。</li></ol><p><strong>特点</strong>：</p><ol><li>最小生成树包含图中所有的顶点，但只包含连接这些顶点的最少数量的边（即 $V - 1$条边，$V$为顶点数）。</li><li>它保证生成的树的边权总和最小。</li></ol><p>常见的MST生成算法有2种：<em>Kruskal算法</em>和<em>Prim算法</em>。简单来说，Kruskal是基于边的选择，而Prim算法是从某个顶点开始构建最小生成树的，逐步扩展树的边界。</p><h4 id="5-2-1-Kruskal"><a href="#5-2-1-Kruskal" class="headerlink" title="5.2.1 Kruskal"></a>5.2.1 Kruskal</h4><p>具体步骤为：</p><ol><li>首先对所有边按权重从小到大排序。</li><li>然后依次利用<strong>并查集（Union Find）</strong>检查每条边的两个顶点是否属于不同的集合，如果是，则将它们合并，并将该边加入最小生成树。</li><li>重复这个过程，直到最小生成树中包含了$V−1$条边。</li></ol><p><strong>时间复杂度：</strong> 边排序耗时$O(ElogE)$，并查集操作近似为$O(1)$，因此总时间复杂度为$O(ElogE)$。<br><img src="/img/DSA/kruskal.svg" alt="Kruskal算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含起点、终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 比较函数，按照权重升序排序</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> weight <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 并查集（Union-Find）结构体</span><span class="token keyword">struct</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">,</span> rank<span class="token punctuation">;</span>    <span class="token comment">// 初始化并查集，所有节点的父节点初始化为自己，秩(rank)初始化为0</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作，使用路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作，按秩合并</span>    <span class="token keyword">void</span> <span class="token function">unite</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootU <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootV <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootU <span class="token operator">!=</span> rootV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">=</span> rootV<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>                rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Kruskal算法实现</span><span class="token keyword">int</span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 按权重升序排序所有边(至关重要的一环)</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edges<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UnionFind <span class="token function">uf</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> edgesUsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已经加入生成树的边数</span>    <span class="token comment">// 遍历所有边</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 查找两个顶点是否属于不同的集合（不同的连通分量）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">)</span> <span class="token operator">!=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">,</span> edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将它们合并到同一个集合</span>            mstWeight <span class="token operator">+=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span> <span class="token comment">// 将这条边的权重加入总权重</span>            edgesUsed<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 如果已经加入V-1条边，生成树构建完毕</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>edgesUsed <span class="token operator">==</span> numVertices <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-2-2-Prim算法"><a href="#5-2-2-Prim算法" class="headerlink" title="5.2.2 Prim算法"></a>5.2.2 Prim算法</h4><p>Prim算法的基本思想是从一个顶点开始，逐步将与当前生成树相连的最小边加入到树中，直到包含图中所有顶点为止。不同于Kruskal算法选择的是边，Prim算法在每一步选择的是<em>与已连接的顶点相连的最小权重边</em>。</p><p>算法步骤：</p><ol><li>初始化：选择一个起始顶点，标记为生成树的一部分。<br>使用一个数组&#x2F;优先队列来记录所有尚未加入生成树的顶点到当前生成树的最小边的权重。</li><li>选择最小边：<br>在每一步中，从所有与生成树相连的边中选择权重最小的边（维护一个优先队列），确保这个边不会形成环。</li><li>更新距离：将选择的边的顶点加入生成树<u>并更新尚未加入树的顶点到新生成树的最小边的权重。</u></li><li>重复上述步骤，直到所有顶点都被加入生成树。</li></ol><p>对每条边的操作（插入、删除、更新最小边权重）是$O(logV)$的，因此总的时间复杂度为$O(ElogV)$，其中$E$是边的数量，$V$是顶点的数量。<br><img src="/img/DSA/prim.svg" alt="Prim算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Prim算法的实现</span><span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 标记每个顶点是否在生成树中</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">inMST</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录最小权重的边的权重，初始化为无穷大(敲重点)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">minEdgeWeight</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 优先队列（最小堆），存储&#123;边的权重，顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    <span class="token comment">// 从第0号顶点开始</span>    minEdgeWeight<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 取出权重最小的边</span>        <span class="token keyword">int</span> weight <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果顶点u已经在MST中，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 将顶点u加入MST</span>        inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        mstWeight <span class="token operator">+=</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 更新与顶点u相连的其他顶点的最小边权重</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inMST<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">&lt;</span> minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>w<span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-3-单源最短路径算法"><a href="#5-3-单源最短路径算法" class="headerlink" title="5.3 单源最短路径算法"></a>5.3 单源最短路径算法</h3><p>单源最短路径算法（Single-Source Shortest Path, SSSP）用于从图中的一个指定起点（源点）出发，找到该点到图中所有其他顶点的最短路径。常用的单源路径算法为<strong>Dijkstra算法</strong>和<strong>Bellman-Ford算法</strong>。Dijkstra算法只能用于无负权边的图。如果图中存在负权边，Dijkstra算法的结果可能不正确。Bellman-Ford算法可以处理带负权边的图，且能够检测负权环（如果存在负权环，则说明不存在最短路径）。</p><h4 id="5-3-1-Dijkstra’s-algorithm"><a href="#5-3-1-Dijkstra’s-algorithm" class="headerlink" title="5.3.1 Dijkstra’s algorithm"></a>5.3.1 Dijkstra’s algorithm</h4><p><strong>Dijkstra算法</strong>的基本思想是：每次贪心地从当前未处理的顶点中选择一个距离源点最近的顶点，标记其最短路径为确定，然后通过该顶点更新其邻接点的最短路径。过反复选择距离最小的顶点，并更新邻接点的路径长度，最终能确定所有顶点的最短路</p><p><strong>时间复杂度</strong>：在使用优先队列（最小堆）的情况下，Dijkstra算法的时间复杂度为$O(ElogV)$，其中E是图中边的数量，V是顶点的数量。取出当前最小距离顶点的操作需要$O(logV)$时间。每条边被检查一次，更新时需要$O(logV)$的时间来调整优先队列。在稠密图中，算法的效率略低，因为每次更新都需要重新维护优先队列，但在稀疏图中性能良好。<br><img src="/img/DSA/dijkstra.svg" alt="Dijkstra算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 存储从源点到每个顶点的最短距离</span>    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 源点到自身的距离为0</span>        <span class="token comment">// 优先队列：最小堆，存储的是&#123;距离, 顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> source<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>  <span class="token comment">// 取出距离源点最近的顶点</span>        <span class="token keyword">int</span> d <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>   <span class="token comment">// 当前顶点的最短距离</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果当前距离已经不是最优解，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 更新顶点 u 的邻接点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> weight <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token comment">// 如果通过 u 到 v 的路径更短，更新路径</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 v 插入优先队列</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-3-2-Bellman-Ford-Algorithm"><a href="#5-3-2-Bellman-Ford-Algorithm" class="headerlink" title="5.3.2 Bellman-Ford Algorithm"></a>5.3.2 Bellman-Ford Algorithm</h4><p><strong>Bellman-Ford算法</strong>是一种经典的算法，用于解决单源最短路径问题（Single Source Shortest Path, SSSP），即从图中的某个源点到其他所有顶点的最短路径。它与Dijkstra算法的不同之处在于，Bellman-Ford可以处理权值为负数的边，并且能够检测出图中是否存在负权环（negative-weight cycle）。</p><p>Bellman-Ford算法的核心思想是通过<strong>松弛（relaxation）</strong> 操作逐步更新每个顶点的最短路径估计值。松弛操作的含义是，如果从某条边可以得到比当前已知更短的路径，则更新路径长度。算法通过多次迭代更新路径，确保找到全局的最短路径。</p><p><strong>算法步骤：</strong></p><ol><li>初始化：将源点到源点的距离设为0（即$dist[source] &#x3D; 0$），其他所有顶点到源点的距离初始设为正无穷大（$dist[v] &#x3D; ∞$）。设定前驱节点为None或相应的初始值。</li><li>松弛所有边：对于图中的所有边$(u,v)$，检查是否可以通过$u$达到$v$的更短路径，即$dist[v] &gt; dist[u] + weight(u, v)$。如果是，则更新$dist[v] &#x3D; dist[u] + weight(u, v)$。重复这个过程最多$n−1$次，其中$n$是顶点的数量。因为最短路径最多包含$n−1$条边。</li><li>检测负权环（可选步骤）：在完成$n−1$次松弛操作后，再对所有边执行一次松弛操作。如果此时还能继续更新某个顶点的最短路径值，则说明图中存在负权环，因为在无负权环的情况下，经过$n−1$次松弛操作后，所有最短路径应该已经收敛。</li></ol><p>边的松弛操作需要对每条边执行，图中一共有𝑚条边。算法需要对所有边重复𝑛−1次（因为最短路径最多包含𝑛−1条边），因此时间复杂度为𝑂(𝑛⋅𝑚)</p><img src="/img/DSA/bellman_ford.svg" alt="松弛操作" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> Bellmanford算法伪代码function BellmanFord<span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> Step <span class="token number">1</span><span class="token punctuation">:</span> Initialize distances    <span class="token keyword">for</span> each vertex v <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> ∞  <span class="token operator">//</span> Set <span class="token builtin">all</span> distances to infinity        predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> null  <span class="token operator">//</span> No predecessors initially    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token operator">//</span> The distance <span class="token keyword">from</span> the source to itself <span class="token keyword">is</span> zero    <span class="token operator">//</span> Step <span class="token number">2</span><span class="token punctuation">:</span> Relax <span class="token builtin">all</span> edges n<span class="token operator">-</span><span class="token number">1</span> times    <span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">1</span> to <span class="token operator">|</span>V<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>            <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>                predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u    <span class="token operator">//</span> Step <span class="token number">3</span><span class="token punctuation">:</span> Check <span class="token keyword">for</span> negative<span class="token operator">-</span>weight cycles    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>            error <span class="token string">"Graph contains a negative-weight cycle"</span>        <span class="token keyword">return</span> dist<span class="token punctuation">,</span> predecessor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-4-多源最短路径算法"><a href="#5-4-多源最短路径算法" class="headerlink" title="5.4 多源最短路径算法"></a>5.4 多源最短路径算法</h3><h4 id="5-4-1-Floyd-Wallshall’s-Algorithm"><a href="#5-4-1-Floyd-Wallshall’s-Algorithm" class="headerlink" title="5.4.1 Floyd-Wallshall’s Algorithm"></a>5.4.1 Floyd-Wallshall’s Algorithm</h4><p><strong>Floyd-Warshall算法</strong> 是一种经典的动态规划算法，用于解决所有点对最短路径问题。它可以在加权图中找出每一对顶点之间的最短路径，<em>即使图中包含负权重边</em>，只要没有负权重环路（即从某个顶点出发经过一些边又回到该顶点且路径总权重为负）。<u>京大知能</u>的一年过去问就考了这道题的手动迭代推理，在复习这个题的时候建议和京大的过去问配合看。</p><p><strong>算法步骤：</strong></p><ol><li><p>初始化：将距离矩阵$dist[][]$初始化为图的邻接矩阵。如果$i &#x3D;&#x3D; j$，则$dist[i][j] &#x3D; 0$，表示从节点$i$到节点$j$的路径距离为$0$。如果$i ≠ j$且两点之间有边，则$dist[i][j] &#x3D; weight(i, j)$，否则$dist[i][j]设为∞$（表示两点不直接相连）。</p></li><li><p>动态规划：通过三重循环逐步更新每对顶点之间的最短距离。外层循环选取一个中间顶点$k$，中间两层循环更新每一对顶点$i$和$j$之间的最短路径，判断是否通过$k$可以得到更短的路径。如果$dist[i][k] + dist[k][j] &lt; dist[i][j]$，则更新$dist[i][j]$。公式为：</p><div style="text-align: center;">$$dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])$$</div></li></ol><p><strong>时间复杂度：</strong><br>Floyd-Warshall算法的时间复杂度为$O(V³)$，其中$V$是图中顶点的数量。三重嵌套循环的每一层都依赖于顶点的数量，因此该算法适合顶点较少的图。对于边多（稠密图）且顶点数量不多的情况，它是一个有效的算法。<br><img src="/img/DSA/floyd.svg" alt="Floyd算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">floydWarshall</span><span class="token punctuation">(</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储最短路径</span>    <span class="token comment">// 初始化距离矩阵，将其设为输入图的邻接矩阵</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 三重循环：i是起点，j是终点，k是中间节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果从i通过k到j的路径更短，则更新dist[i][j]</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span>                     dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-5-Maximum-FLow-Problem"><a href="#5-5-Maximum-FLow-Problem" class="headerlink" title="5.5 Maximum FLow Problem"></a>5.5 Maximum FLow Problem</h3><p><strong>最大流问题</strong>是网络流理论中的一个经典问题，旨在寻找在一个流网络（或称为容量网络）中，从源点到汇点的最大可能流量。这个问题可以应用于很多实际场景，比如交通网络、物流系统、通信网络等。</p><p><strong>最大流问题</strong>的定义：</p><ol><li><p>流网络：由顶点集和边集组成的有向图，其中每条边都有一个非负的容量，表示能通过该边的最大流量。这个网络中有一个特定的顶点被称为源点（source），另一个顶点称为汇点（sink）。</p></li><li><p>流量：从源点到汇点传输的流称为流量。流量需要遵守以下两个条件：</p></li><li><p>容量限制：每条边上的流量不能超过该边的容量。</p></li><li><p>流量守恒：除了源点和汇点，其他顶点的流入流量与流出流量相等。</p></li></ol><p>本章只讲解Ford-Fulkerson算法，有余力可以再了解一下Edmonds-Karp算法和Push-Relabel算法。</p><h4 id="5-5-1-Ford-Fulkerson-Algorithm"><a href="#5-5-1-Ford-Fulkerson-Algorithm" class="headerlink" title="5.5.1 Ford-Fulkerson Algorithm"></a>5.5.1 Ford-Fulkerson Algorithm</h4><p>福特-福尔克森算法的核心思想是利用增广路径（Augmenting Path）来增加网络中的流量。增广路径是指在残余网络（Residual Network）中，从源点到汇点的一条路径，且路径上的每条边都有剩余容量（Residual Capacity）大于零。算法通过反复寻找这样的路径，并沿路径增加流量，直到没有增广路径为止。<br><img src="/img/DSA/ford.svg" alt="Ford-Fulkerson算法演示" style="max-width: 100%; height: auto;" /><br><strong>初始状态：</strong></p><p>如图所示，所有边的初始流量都为 0。我们的目标是找到从源点 S 到汇点 T 的最大流。</p><p><strong>第一次迭代：</strong></p><ul><li><strong>a.</strong> 找一条增广路径，例如：S -&gt; A -&gt; C -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 5（A 到 C 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 0&#x2F;10 \rightarrow 5&#x2F;10 \\<br>A \to C: &amp;\ 0&#x2F;5 \rightarrow 5&#x2F;5 \\<br>C \to T: &amp;\ 0&#x2F;9 \rightarrow 5&#x2F;9<br>\end{aligned}<br>$$</li></ul><p><strong>第二次迭代：</strong></p><ul><li><strong>a.</strong> 找另一条增广路径，例如：S -&gt; B -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 6（D 到 T 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to B: &amp;\ 0&#x2F;8 \rightarrow 6&#x2F;8 \\<br>B \to D: &amp;\ 0&#x2F;7 \rightarrow 6&#x2F;7 \\<br>D \to T: &amp;\ 0&#x2F;6 \rightarrow 6&#x2F;6<br>\end{aligned}<br>$$</li></ul><p><strong>第三次迭代：</strong></p><ul><li><strong>a.</strong> 找下一条增广路径，例如：S -&gt; A -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 3（A 到 D 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 5&#x2F;10 \rightarrow 8&#x2F;10 \\<br>A \to D: &amp;\ 0&#x2F;3 \rightarrow 3&#x2F;3 \\<br>D \to T: &amp;\ 6&#x2F;6 \text{（已满，无法增加）}<br>\end{aligned}<br>$$</li></ul><p><strong>算法终止：</strong><br>此时，我们无法找到从 S 到 T 的更多增广路径。所有通向 T 的边都已经满了：</p><ul><li>$C \to T: 5&#x2F;9$</li><li>$D \to T: 6&#x2F;6$</li></ul><p><strong>计算最大流：</strong><br>最大流等于从源点出发的所有流量之和：<br>$$<br>8\ (\text{S} \to \text{A}) + 6\ (\text{S} \to \text{B}) &#x3D; 14<br>$$<br>也等于进入汇点的所有流量之和：<br>$$<br>5\ (\text{C} \to \text{T}) + 6\ (\text{D} \to \text{T}) &#x3D; 11<br>$$</p><p><strong>最终结果：</strong></p><ul><li>最大流值为 14</li><li>S -&gt; A -&gt; C -&gt; T 路径上流量为 5</li><li>S -&gt; B -&gt; D -&gt; T 路径上流量为 6</li><li>S -&gt; A -&gt; D -&gt; T 路径上流量为 3</li></ul><p>Ford-Fulkerson 算法的核心思想是不断寻找增广路径并增加流量，直到无法找到更多的增广路径为止。每次找到增广路径后，我们都会更新网络中的流量，直到达到最大流。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">function FordFulkerson<span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 初始化残余图    ResidualGraph Gf <span class="token operator">=</span> CreateResidualGraph<span class="token punctuation">(</span>G<span class="token punctuation">)</span>        <span class="token operator">//</span> 初始化最大流为<span class="token number">0</span>    maxFlow <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> true<span class="token punctuation">:</span>        <span class="token operator">//</span> 在残余图中寻找增广路径        Path augmentingPath <span class="token operator">=</span> FindAugmentingPath<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>                <span class="token operator">//</span> 如果没有找到增广路径，算法终止        <span class="token keyword">if</span> augmentingPath <span class="token keyword">is</span> empty<span class="token punctuation">:</span>            <span class="token keyword">break</span>                <span class="token operator">//</span> 找到增广路径上的最小残余容量        minResidualCapacity <span class="token operator">=</span> FindMinResidualCapacity<span class="token punctuation">(</span>augmentingPath<span class="token punctuation">)</span>                <span class="token operator">//</span> 更新残余图        UpdateResidualGraph<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> augmentingPath<span class="token punctuation">,</span> minResidualCapacity<span class="token punctuation">)</span>                <span class="token operator">//</span> 增加最大流        maxFlow <span class="token operator">=</span> maxFlow <span class="token operator">+</span> minResidualCapacity        <span class="token keyword">return</span> maxFlowfunction FindAugmentingPath<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 使用DFS或BFS寻找从source到sink的路径    <span class="token operator">//</span> 返回找到的路径，如果没有路径则返回空function FindMinResidualCapacity<span class="token punctuation">(</span>Path augmentingPath<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 遍历路径，找到最小的残余容量    <span class="token operator">//</span> 返回最小残余容量function UpdateResidualGraph<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Path augmentingPath<span class="token punctuation">,</span> <span class="token builtin">int</span> minResidualCapacity<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> augmentingPath<span class="token punctuation">:</span>        <span class="token operator">//</span> 减少正向边的残余容量        Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-</span> minResidualCapacity        <span class="token operator">//</span> 增加反向边的残余容量        Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> minResidualCapacityfunction CreateResidualGraph<span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 创建一个与原图结构相同的残余图    <span class="token operator">//</span> 初始化残余容量等于原图的容量    <span class="token operator">//</span> 为每条边添加一条初始容量为<span class="token number">0</span>的反向边    <span class="token operator">//</span> 返回创建的残余图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="6-Greedy-Algorithm"><a href="#6-Greedy-Algorithm" class="headerlink" title="6. Greedy Algorithm"></a>6. Greedy Algorithm</h2><p><strong>贪心算法</strong>是一种算法设计范式，其核心思想是：在解决问题时，总是做出在当前状态下看起来最优的选择，即局部最优解，希望通过一系列这样的选择能够最终得到全局最优解。这个算法理解起来非常直观，但是合理性证明的话需要严格的数学证明。本章着重讲解最经典的<strong>最大子序和问题（Maximum Subarray）</strong> 和<strong>合并区间问题（Merge Intervals）</strong></p><h3 id="6-1-Maximum-Subarray"><a href="#6-1-Maximum-Subarray" class="headerlink" title="6.1 Maximum Subarray"></a>6.1 Maximum Subarray</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/maximum-subarray/description/">Leetcode 53题</a>练习。</p><blockquote><p>问题描述是：Given an integer array nums, find the subarray with the largest sum, and return its sum.</p></blockquote><p><strong>Example 1:</strong></p><ul><li><p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p></li><li><p>Output: 6</p></li><li><p>Explanation: The subarray [4,-1,2,1] has the largest sum 6.</p></li></ul><p>解决这个问题的贪心算法也叫Kadane算法：算法从左到右遍历一次数组，在每一步，它都计算当前位置结束的子数组的最大和（Current Sum）同时，它保持追踪全局的最大和（Max Sum）。最终，Max Sum的最后一个值就是整个问题的解。<br><img src="/img/DSA/kadane.svg" alt="kadane算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            curSum <span class="token operator">+=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> curSum <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 贪心地取子数组最大值</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> maxSum <span class="token operator">=</span> curSum<span class="token punctuation">;</span> <span class="token comment">// 不断更新结果</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="6-2-Merge-Intervals"><a href="#6-2-Merge-Intervals" class="headerlink" title="6.2 Merge Intervals"></a>6.2 Merge Intervals</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/merge-intervals/description/">Leetcode 56题</a>练习。</p><blockquote><p>题目描述：Given an array of intervals where $\text{intervals}[i] &#x3D; [\text{start}_i, \text{end}_i]$, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p></blockquote><p><strong>Example 1:</strong></p><p>Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</p><p>Output: [[1,6],[8,10],[15,18]]</p><p>Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</p><p>解决这道题的思路是：先排序让所有相邻的区间尽可能重合在一起(以开端最小优先，其次结尾最小次之)，然后一次遍历贪心地选择局部最优解。<br><img src="/img/DSA/merge.svg" alt="合并区间算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 重载cmp函数，让区间的排列以开端最小优先，其次结尾最小优先</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 贪心地选择是否合并区间</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 若不重合，则加入结果数组</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 若重合，则合并区间并贪心的选择区间结尾</span>            <span class="token keyword">else</span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="7-Dynamic-Programming"><a href="#7-Dynamic-Programming" class="headerlink" title="7. Dynamic Programming"></a>7. Dynamic Programming</h2><p><strong>动态规划（Dynamic Programming, DP）</strong> 是一种用于解决最优化问题的算法设计技巧。它通过将问题分解为更小的子问题，并记录其解来<u>避免重复计算</u>，从而提高算法的效率。本章主要讲解5个经典DP问题：<em>斐波那契数列</em>，<em>背包问题</em>，<em>股票问题</em>，<em>最长公共子序列</em>，以及<em>序列比对问题</em>。</p><h3 id="7-1-Fibonacci-Sequence"><a href="#7-1-Fibonacci-Sequence" class="headerlink" title="7.1 Fibonacci Sequence"></a>7.1 Fibonacci Sequence</h3><p>形如：$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ….$的数列称之为斐波那契数，我们可以很轻易地得到递归式：$dp[n] &#x3D; dp[n-1] + dp[n-2]$,然后我们再对递归式子进行初始化：$dp[0] &#x3D; 1, dp[1] &#x3D; 1$, 我们就可以利用递归式求得所有的斐波那契数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-2-Knapsack-Problem"><a href="#7-2-Knapsack-Problem" class="headerlink" title="7.2 Knapsack Problem"></a>7.2 Knapsack Problem</h3><p>关于背包问题有三种：0-1背包，完全背包，多重背包。应对修考我认为掌握0-1背包问题就足够了。关于0-1背包的问题描述是：</p><ol><li>一组物品，每个物品都有一个重量和一个价值。</li><li>一个背包，具有固定的容量。</li></ol><p>给定$n$个物品，每个物品$i$具有重量$w[i]$和价值$v[i]$，还有一个背包的最大容量$W$。目标是选择物品的组合，使得在不超过背包容量的情况下，背包中的物品总价值最大。</p><p><strong>1.定义状态：</strong> $dp[i][j]$表示在考虑前$i$个物品，且背包容量为$j$时的最大价值。</p><p><strong>2.状态转移方程：</strong> 对于每个物品$i$，有两个选择：</p><ul><li>不放入背包：此时最大价值为$dp[i-1][j]$。</li><li>放入背包：此时最大价值为$dp[i-1][j - w[i]] + v[i]$，前提是当前物品的重量不超过背包容量 $j &gt;&#x3D; w[i]$。</li></ul><p>因此，状态转移方程为：<br>$$<br>dp[i][j] &#x3D; \begin{cases}<br>dp[i-1][j] &amp; \text{if } j &lt; w[i] \\<br>\max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]) &amp; \text{if } j \geq w[i]<br>\end{cases}<br>$$</p><p><strong>3.边界条件：</strong></p><ul><li>当没有物品可选时，最大价值为$0$，即 $(dp[0][j] &#x3D; 0)$。</li><li>当背包容量为$0$时，最大价值也为$0$，即 $(dp[i][0] &#x3D; 0)$。</li></ul><p><strong>4.计算顺序：</strong></p><p>先遍历物品再遍历背包更容易理解，从 $(i &#x3D; 1)$到 $(n)$，对于每个物品，再从 $(j &#x3D; 0)$到$(W)$计算。当然也可以先遍历背包再遍历物品，这里不过多赘述。</p><p><strong>5.返回结果：</strong> 最终的最大价值为 $(dp[n][W])$。</p><p>假设有以下物品和背包容量：</p><ul><li>物品 1：重量 &#x3D; 2，价值 &#x3D; 3</li><li>物品 2：重量 &#x3D; 3，价值 &#x3D; 4</li><li>物品 3：重量 &#x3D; 4，价值 &#x3D; 5</li><li>物品 4：重量 &#x3D; 5，价值 &#x3D; 6</li></ul><p>背包容量为 5。<br><img src="/img/DSA/01knapsnack.svg" alt="01背包遍历演示" style="max-width: 100%; height: auto;" /></p><p>遍历的核心代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> W<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 装不下的情况</span>            <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装下的情况</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-3-Stock-Problem"><a href="#7-3-Stock-Problem" class="headerlink" title="7.3 Stock Problem"></a>7.3 Stock Problem</h3><p>股票问题有很多种，这里介绍一种，参考<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">Leetcode 122题</a>。题目描述是：</p><blockquote><p>You are given an integer array $prices$ where $prices[i]$ is the price of a given stock on the ith day. On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold <u>at most one share </u> of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: prices &#x3D; [7,1,5,3,6,4]</li><li>Output: 7</li><li>Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.<br>Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.<br>Total profit is 4 + 3 &#x3D; 7.<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// have the stock on the day 0;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token comment">// no stock on the day 0;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// no stock on the day n - 1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul><p><strong>初始状态：</strong></p><p><code>dp[0][0] = -prices[0]</code>：表示在第$0$天买入股票后的利润，利润为负的股票价格。<br><code>dp[0][1] = 0</code>：表示在第$0$天没有持有股票，利润为$0$。</p><p><strong>状态转移：</strong></p><blockquote><p><strong>对于第$i$天，持有股票的状态 <code>dp[i][0]</code>，有两种可能：</strong></p></blockquote><ul><li>前一天已经持有股票，保持不动：<code>dp[i-1][0]</code>。  </li><li>前一天没有持有股票，但今天买入：<code>dp[i-1][1] - prices[i]</code>（买入股票，减去当天股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])</code>。</p><blockquote><p><strong>对于第$i$天，不持有股票的状态 <code>dp[i][1]</code>，也有两种可能：</strong></p></blockquote><ul><li>前一天已经不持有股票，保持不动：<code>dp[i-1][1]</code>。  </li><li>前一天持有股票，但今天卖出：<code>dp[i-1][0] + prices[i]</code>（卖出股票，得到当前股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</code>。</p><p><strong>最终结果：</strong> 返回 <code>dp[n-1][1]</code>，表示最后一天不持有股票的最大利润。</p><h3 id="7-4-Longest-Common-Subsequence"><a href="#7-4-Longest-Common-Subsequence" class="headerlink" title="7.4 Longest Common Subsequence"></a>7.4 Longest Common Subsequence</h3><p><strong>最长公共子序列（LCS）</strong> 也是修考的一个常考点，具体参考：<a href="https://leetcode.com/problems/longest-common-subsequence/description/">Leetcode 1143</a></p><blockquote><p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”. A common subsequence of two strings is a subsequence that is common to both strings.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: text1 &#x3D; “abcde”, text2 &#x3D; “ace” </li><li>Output: 3  </li><li>Explanation: The longest common subsequence is “ace” and its length is 3.</li></ul><p><strong>定义状态：</strong></p><p>$$<br>dp[i][j] \text{ 表示在考虑前 } i \text{ 个字符的 } \text{text1} \text{ 和前 } j \text{ 个字符的 } \text{text2} \text{ 时的最长公共子序列的长度。}<br>$$</p><p><strong>状态转移方程：</strong></p><p>对于每个字符对<code>text1[i-1] </code> 和<code>text2[j-1]</code>，有两种情况：</p><ul><li>如果 <code>&#39;text1[i-1] == text2[j-1]&#39;</code>，说明这两个字符相同，最长公共子序列可以延长 1，此时 <code>&#39;dp[i][j] = dp[i-1][j-1] + 1&#39;</code>。</li><li>如果 <code>&#39;text1[i-1] != text2[j-1]&#39;</code>，则取决于之前的子问题结果，最长公共子序列为：<ul><li>不包括当前字符：<code>&#39;dp[i][j] = max(dp[i][j-1], dp[i-1][j])&#39;</code>。</li></ul></li></ul><p><strong>边界条件：</strong></p><ul><li>当 <code>&#39;i = 0&#39;</code> 或 <code>&#39;j = 0&#39;</code> 时，即有一个字符串为空，最长公共子序列长度为 0，所以初始化时 <code>&#39;dp[0][j] = 0&#39;</code> 和 <code>&#39;dp[i][0] = 0&#39;</code>。</li></ul><p><strong>计算顺序：</strong></p><p>从 <code>&#39;i = 1&#39;</code> 到 <code>&#39;n&#39;</code>，对于每个字符，再从 <code>&#39;j = 1&#39;</code> 到 <code>&#39;m&#39;</code> 计算 <code>&#39;dp[i][j]&#39;</code>，逐步构建整个表。</p><p><strong>返回结果：</strong></p><p>最终结果为 <code>&#39;dp[n][m]&#39;</code>，即考虑所有字符的最长公共子序列的长度。<br><img src="/img/DSA/lcs.svg" alt="LCS遍历演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-5-Sequence-Alignment"><a href="#7-5-Sequence-Alignment" class="headerlink" title="7.5 Sequence Alignment"></a>7.5 Sequence Alignment</h3><p><strong>序列比对（Sequence Alignment）</strong> 是生物信息学中的一个核心问题，用于比较两个或多个生物序列（如DNA、RNA或蛋白质）的相似性。其目的是通过对比序列中的元素（碱基或氨基酸）找出它们之间的最优匹配方式，进而揭示它们的进化关系、功能相似性或结构上的保守性。</p><h4 id="7-5-1-Needleman–Wunsch-algorithm"><a href="#7-5-1-Needleman–Wunsch-algorithm" class="headerlink" title="7.5.1 Needleman–Wunsch algorithm"></a>7.5.1 Needleman–Wunsch algorithm</h4><p>Needleman-Wunsch算法是用于进行全局序列比对的经典算法，特别适用于对比两个生物序列（如DNA、RNA或蛋白质）时，将它们的整个序列进行对齐。它采用动态规划的思想来寻找两个序列的最优对齐方式。<br><img src="/img/DSA/needle.svg" alt="序列比对算法演示" style="max-width: 100%; height: auto;" /></p><p><strong>Needleman-Wunsch算法步骤：</strong></p><p><strong>定义状态：</strong></p><p>设有两个序列 <code>A</code> 和 <code>B</code>，长度分别为 <code>n</code> 和 <code>m</code>。<br>创建一个大小为 <code>(n+1) x (m+1)</code> 的二维矩阵 <code>dp</code>，其中 <code>dp[i][j]</code> 表示序列 <code>A</code> 的前 <code>i</code> 个字符与序列 <code>B</code> 的前 <code>j</code> 个字符的最优对齐得分。</p><p><strong>罚分机制：</strong></p><ul><li><strong>匹配</strong>：当 <code>A[i-1] == B[j-1]</code> 时，表示两个字符相同，得分为 <code>match score</code>。</li><li><strong>不匹配</strong>：当 <code>A[i-1] != B[j-1]</code> 时，表示两个字符不同，得分为 <code>mismatch penalty</code>。</li><li><strong>Gap</strong>：当在序列 <code>A</code> 或 <code>B</code> 中插入一个字符时，得分为 <code>gap penalty</code>。</li></ul><p><strong>初始化：</strong></p><ul><li>第一行和第一列表示序列与空序列的比对。比对空序列时，每个字符都需要插入或删除，因此使用缺口罚分（gap penalty）。</li><li>初始化 <code>dp[0][0] = 0</code>，代表两个空序列的得分为 0。</li><li>初始化第一行：<code>dp[0][j] = j * gap penalty</code>，表示序列 <code>B</code> 的前 <code>j</code> 个字符与空序列的比对得分。</li><li>初始化第一列：<code>dp[i][0] = i * gap penalty</code>，表示序列 <code>A</code> 的前 <code>i</code> 个字符与空序列的比对得分。</li></ul><p><strong>状态转移方程：</strong>对于矩阵中的每个 <code>dp[i][j]</code>，有三种可能的情况：</p><ol><li><strong>匹配</strong>：如果 <code>A[i-1] == B[j-1]</code>，即两个字符相同，则可以匹配，得分为 <code>dp[i-1][j-1] + match score</code>。</li><li><strong>不匹配</strong>：如果 <code>A[i-1] != B[j-1]</code>，则可以进行替换，得分为 <code>dp[i-1][j-1] + mismatch penalty</code>。</li><li><strong>插入&#x2F;删除（Gap）</strong>：在序列 <code>A</code> 或 <code>B</code> 中插入一个字符，得分为 <code>dp[i][j-1] + gap penalty</code> 或 <code>dp[i-1][j] + gap penalty</code>。</li></ol><p>取这三种操作中的最大值更新 <code>dp[i][j]</code>，即：</p><p>$$<br>dp[i][j] &#x3D; \max\left(dp[i-1][j-1] + \text{(match&#x2F;mismatch score)}, dp[i-1][j] + \text{gap penalty}, dp[i][j-1] + \text{gap penalty}\right)<br>$$</p><p><strong>回溯：</strong>填完矩阵后，从右下角 <code>dp[n][m]</code> 开始回溯，找出最优路径，从而得到序列 <code>A</code> 和 <code>B</code> 的最优全局对齐方案。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化：处理空序列的情况</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一列，表示A的前i个字符和空序列的比对</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一行，表示B的前j个字符和空序列的比对</span><span class="token comment">// 填充 dp 表</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 匹配或不匹配的情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符相等，则进行匹配，加上 match_score</span>            <span class="token keyword">int</span> match <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> match_score<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符不相等，则进行替换，加上 mismatch_penalty</span>            <span class="token keyword">int</span> mismatch <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> mismatch_penalty<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 2. 插入的情况</span>        <span class="token keyword">int</span> insert <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 在序列 A 中插入 gap</span>        <span class="token comment">// 3. 删除的情况</span>        <span class="token keyword">int</span> del <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>     <span class="token comment">// 在序列 B 中插入 gap</span>                <span class="token comment">// 取三种操作的最大值来更新 dp[i][j]</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> match_score <span class="token operator">:</span> mismatch_penalty<span class="token punctuation">)</span><span class="token punctuation">,</span> insert<span class="token punctuation">,</span> del<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 最终结果是 dp[n][m]，表示A和B的最优全局比对得分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="8-P-NP-problem"><a href="#8-P-NP-problem" class="headerlink" title="8. P&#x2F;NP problem"></a>8. P&#x2F;NP problem</h2><p><strong>P&#x2F;NP问题</strong> 是计算机科学中的一个核心难题，涉及确定哪些问题可以在合理的时间内（多项式时间）被解决，和哪些问题的解可以在合理的时间内被验证。它是理论计算机科学和数学中最著名、最重要的未解决问题之一。</p><p><strong>P类问题</strong></p><p>P类问题（Polynomial time）指的是那些可以在多项式时间内被解决的问题。也就是说，给定一个问题实例，使用某种算法可以在输入规模为 $n$ 时，用 $n^k$（其中 $k$ 是一个常数）次运算步骤就可以得到结果。</p><ul><li><p>例如，常见的排序算法（如快速排序）和图论中的最短路径算法（如Dijkstra算法）都是 <strong>P类问题</strong>。它们的时间复杂度是多项式级别的。</p></li><li><p><strong>直观理解</strong>：如果一个问题属于P类，那么它是“容易”解决的，因为我们可以用有效的算法在合理的时间内求解。</p></li></ul><p><strong>NP类问题</strong></p><p>NP类问题（Nondeterministic Polynomial time）是指那些解可以在多项式时间内被验证的问题，尽管可能没有已知的多项式时间算法来找到这个解。</p><ul><li><p>也就是说，如果我们猜测出一个解，可以在多项式时间内检查这个解是否正确。但是，要找到这个解可能会很难，甚至没有已知的多项式时间算法来求解。</p></li><li><p><strong>经典的NP问题</strong> 包括旅行商问题（TSP）、背包问题和布尔可满足性问题（SAT）。这些问题的特点是验证解很容易，但找到最优解可能非常耗时。</p></li></ul><p><strong>P与NP的关系</strong></p><ul><li><p><strong>P是否属于NP？</strong></p><ul><li><p>P类问题显然也是NP类问题。如果我们能够在多项式时间内求解一个问题，那我们一定也能在多项式时间内验证这个解。</p></li><li><p>因此可以得出结论：<strong>P是NP的一个子集</strong>，即 $P \subseteq NP$。</p></li></ul></li><li><p><strong>P与NP的区别</strong></p><ul><li>关键在于我们还不确定 <strong>P类问题</strong> 和 <strong>NP类问题</strong> 是否是同一个集合。这就是 <strong>P vs NP</strong> 问题的核心所在：<ul><li>如果 $P &#x3D; NP$，那么所有能在多项式时间内验证的解也可以在多项式时间内求解。</li><li>如果 $P \neq NP$，那么有一些问题能在多项式时间内验证解，但没有已知的多项式时间算法来求解它们。</li></ul></li></ul></li></ul><p><strong>NP完全问题（NP-Complete）</strong></p><p>NP完全问题（NP-Complete, NPC）是NP类问题中的一个特殊子集，它们有两个重要的特性：</p><ol><li>它们本身是NP类问题。</li><li>任何一个NP类问题都可以通过多项式时间的归约（转换）转换为这个NP完全问题。</li></ol><ul><li><p><strong>重要性</strong>：如果你能找到一个NP完全问题的多项式时间解法，那么所有的NP问题都可以在多项式时间内解决。因此，NP完全问题是NP类问题中的“最难问题”。</p></li><li><p><strong>典型的NP完全问题</strong>：</p><ul><li>旅行商问题（TSP）：寻找一条经过每个城市恰好一次且路径最短的旅行路线。</li><li>3-SAT问题：判断一个布尔公式是否有解。</li><li>顶点覆盖问题：在一个图中找到最小的顶点集合，使得每条边至少有一个顶点被覆盖。</li></ul></li></ul><p><strong>P vs NP问题</strong></p><p>P vs NP问题是指：<strong>P是否等于NP？</strong></p><ul><li><p>如果 <strong>P &#x3D; NP</strong>，意味着所有NP问题都有多项式时间的求解算法。这将意味着大量的难问题（如密码学中的问题）可以被快速解决。</p></li><li><p>如果 <strong>P ≠ NP</strong>，那么一些问题的解可以快速验证，但无法快速求解。</p></li></ul><p>目前，这个问题尚未解决，它是 <strong>“千禧年大奖问题”</strong> 之一，美国克雷数学研究所为解决这个问题悬赏 <strong>100万美元</strong>。</p><p><strong>总结</strong></p><ul><li><strong>P类问题</strong>：可以在多项式时间内求解。</li><li><strong>NP类问题</strong>：可以在多项式时间内验证解，但不一定能在多项式时间内求解。</li><li><strong>P vs NP问题</strong>：我们不知道所有可以快速验证的解是否也可以快速求解，即是否 $P &#x3D; NP$。</li></ul><h2 id="9-偷偷说"><a href="#9-偷偷说" class="headerlink" title="9.偷偷说"></a>9.偷偷说</h2><p>本文应该囊括了修考绝大部分的考点了，当然还有双指针和滑动窗口，哈希之类的算法技巧我觉得就不用大费周章地写下来了。做修考题我认为最重要的是阅读伪代码的能力！希望这篇文章可以帮助到修考受验生们。完结撒花🎉</p><div class="note note-success">            <p>偷偷目前兼任私塾班主任，如果需要1对1辅导，请联系：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語勉強</title>
    <link href="/2024/09/10/JPN/"/>
    <url>/2024/09/10/JPN/</url>
    
    <content type="html"><![CDATA[<h3 id="1-〜あっての"><a href="#1-〜あっての" class="headerlink" title="1.〜あっての"></a>1.〜あっての</h3><div class="note note-success">            <p>説明：あるものが存在するのは他のもののおかげであることを強調する表現です。名詞 + あっての + 名詞</p>          </div><p>健康あっての人生なんだから、体調管理には十分気をつけなさい。</p><p>家族の支えがあったからこそ成功できた。</p><h3 id="2-以外の何ものでもない。"><a href="#2-以外の何ものでもない。" class="headerlink" title="2.~以外の何ものでもない。"></a>2.~以外の何ものでもない。</h3><div class="note note-success">            <p>「Aが唯一の理由・原因である」という意味になります。</p>          </div><p>この結果は偶然以外の何ものでもない。</p><h3 id="3-〜いかんで-いかんでは"><a href="#3-〜いかんで-いかんでは" class="headerlink" title="3.〜いかんで&#x2F;いかんでは"></a>3.〜いかんで&#x2F;いかんでは</h3><div class="note note-success">            <p>どちらも「〜によって」「〜次第で」という意味を持ち、前の事柄によって後の結果が変わることを示す表現です。ただし、微妙なニュアンスの違いがあります。</p>          </div><p>天候いかんでは、収穫は全てできないこともある。</p><h3 id="4-～いかんに関わらず・いかんによらず・いかんをとわず"><a href="#4-～いかんに関わらず・いかんによらず・いかんをとわず" class="headerlink" title="4.～いかんに関わらず・いかんによらず・いかんをとわず"></a>4.～いかんに関わらず・いかんによらず・いかんをとわず</h3><div class="note note-success">            <p>「〜に関係なく」や「〜にかかわらず」と同じ意味で使われます。つまり、ある条件や状況に影響されずに、という意味です。</p>          </div><p>成績いかんに関わらず、全員が参加できます。</p><h3 id="5-いざ〜となると・いざ〜となれば・いざ〜となったら"><a href="#5-いざ〜となると・いざ〜となれば・いざ〜となったら" class="headerlink" title="5.いざ〜となると・いざ〜となれば・いざ〜となったら"></a>5.いざ〜となると・いざ〜となれば・いざ〜となったら</h3><div class="note note-success">            <p>いずれも「実際にその状況になったら」という意味で使われます。これらの表現は、ある状況が現実になったときにどうなるか、ということを強調するために使われます。</p>          </div><p>いざ出発となれば、準備が整っていないことに気づく。</p><h3 id="6-〜言わずもがな"><a href="#6-〜言わずもがな" class="headerlink" title="6.〜言わずもがな"></a>6.〜言わずもがな</h3><div class="note note-success">            <p>「〜言わずもがな」という表現は、「言うまでもなく」や「言わなくてもわかる」という意味で使われます。つまり、あることが非常に明白であるため、わざわざ言う必要がないということを強調する表現です。</p>          </div><p>彼の才能は言わずもがな、誰もが認めるところだ。</p><h3 id="7-限りだ"><a href="#7-限りだ" class="headerlink" title="7. ~限りだ"></a>7. ~限りだ</h3><div class="note note-success">            <p>「〜限りだ」という表現は、感情や感覚を強調するために使われます。特に、感動や驚き、悲しみなどの強い感情を表現する際に用いられます。</p>          </div><p>嬉しい限りだ。</p><h3 id="8-かたがた"><a href="#8-かたがた" class="headerlink" title="8.~かたがた"></a>8.~かたがた</h3><div class="note note-success">            <p>「〜しながら」「〜と同時に」という意味：<br>ある行動をしながら、同時に別の目的も果たすことを表します。<br>例：</p>          </div><p>散歩かたがた買い物に行く。<br>(散歩をしながら買い物もする)</p><div class="note note-success">            <p>「〜のついでに」「〜を機会に」という意味：<br>ある行動や状況を利用して、ついでに別のことも行うことを表します。</p>          </div><p>東京出張かたがた友人に会ってきた。<br>(東京への出張を機会に友人にも会った)</p><h3 id="9-かたわら"><a href="#9-かたわら" class="headerlink" title="9. ~かたわら"></a>9. ~かたわら</h3><div class="note note-success">            <p>主な活動や仕事をしながら、同時に別の活動も行うことを表します。</p>          </div><p>教師のかたわら、小説を執筆している。</p><h3 id="10-がてら"><a href="#10-がてら" class="headerlink" title="10.~がてら"></a>10.~がてら</h3><div class="note note-success">            <p>「〜のついでに」「〜と同時に」<br>ある行動をする際に、ついでに別の行動も同時に行うことを表します。主な目的とは別の、副次的な行動を示すのに使われます。</p>          </div><p>散歩がてら、近所の様子を見て回りました。</p><h3 id="11-からある・からする・からの"><a href="#11-からある・からする・からの" class="headerlink" title="11.~からある・からする・からの"></a>11.~からある・からする・からの</h3><div class="note note-success">            <p>强调大，多，重，长等。<br>「からある」前面表示数量，长度，大小，高矮等数量名词；[からする]前面多用表示金额的量词；[からの]前面多表示人物的数量词。</p>          </div><p>１００キロからある荷物を三階まで運ぶには、足腰の強い人が三人は必要だ。</p><p>彼女は４０億からする遺産を相続したそうだ。</p><p>今日のスピーチ大会は５００人からの人が集まった。</p><h3 id="12-始末だ"><a href="#12-始末だ" class="headerlink" title="12.~始末だ"></a>12.~始末だ</h3><div class="note note-success">            <p>「ひどい状態だ」「困った事態だ」「始末に負えない」といった否定的な状況を表現します。<br>話者の失望、困惑、あるいは軽蔑の気持ちを含むことが多いです。</p>          </div><p>彼は借金を重ね、今では家も売らなければならない始末だ。</p><h3 id="13-～ずくめ"><a href="#13-～ずくめ" class="headerlink" title="13.～ずくめ"></a>13.～ずくめ</h3><div class="note note-success">            <p>「～ずくめ」は日本語の文法表現で、「全て～ばかりである」という意味を表します。この表現は、ある特定の性質や状態が全体的に存在することを強調するために使われます。</p>          </div><p>この本は難しい言葉ずくめで、読むのが大変だ。</p><p>彼女の服装は黒ずくめだった。</p><h3 id="14-〜ずじまいだ"><a href="#14-〜ずじまいだ" class="headerlink" title="14.〜ずじまいだ"></a>14.〜ずじまいだ</h3><div class="note note-success">            <p>「〜ずじまいだ」は「〜ずじまい」という表現の丁寧な形です。この表現は、ある行動や状態が最後まで続いて終わることを意味します。主に否定的なニュアンスで使われることが多いです。</p>          </div><p>忙しいくて、結局休暇を取る図じまいだった。</p><p>締め切りに追われて、計画を見直すずじまいだった。</p><h3 id="15-ずにはおかない"><a href="#15-ずにはおかない" class="headerlink" title="15.~ずにはおかない"></a>15.~ずにはおかない</h3><div class="note note-success">            <p>「必ず〜する」「〜せずにはいられない」という強い意志や必然性を表します。</p>          </div><p>この素晴らしい景色を見たら、誰も感動せずにはおかない。</p><p>彼女の熱意は、周りの人々に影響を与えずにはおかないだろう。</p><h3 id="16-術がない"><a href="#16-術がない" class="headerlink" title="16.~術がない"></a>16.~術がない</h3><div class="note note-success">            <p>意味:<br>「〜する方法がない」「〜する手段がない」「〜するすべがない」</p>          </div><p>締め切りに間に合わせる術がなく、締めるしかなっかた。</p><p>彼女を説得する術がないので、このまま計画を進めるしかない。</p><h3 id="17-そびれる"><a href="#17-そびれる" class="headerlink" title="17.~そびれる"></a>17.~そびれる</h3><div class="note note-success">            <p>意味:<br>「〜するチャンスを逃す」「〜し損ねる」「うっかり〜し忘れる」</p>          </div><p>興味深い展覧会があったのに、行きそびれてしまった。</p><p>大切な約束を確認しそびれて、すっかり忘れてしまった。</p><h3 id="18-たところで"><a href="#18-たところで" class="headerlink" title="18.~たところで"></a>18.~たところで</h3><div class="note note-success">            <p>意味:「〜たところで」は「〜しても、結局」や「〜したとしても、それでも」という意味を表します。</p>          </div><p>急いだところで、もう間に合わないだろう。</p><p>お金をたくさん持っているところで、幸せになれるとは限らない。</p><h3 id="19-てしかるべきだ"><a href="#19-てしかるべきだ" class="headerlink" title="19.~てしかるべきだ"></a>19.~てしかるべきだ</h3><div class="note note-success">            <p>意味：「〜するのが当然だ」「〜するのが適切だ」という意味を表します。話者の強い意見や判断を示す表現です。</p>          </div><p>法律を守ってしかるべきだ。</p><p>その問題については、専門家に相談してしかるべきだ。</p><h3 id="20-て憚らない"><a href="#20-て憚らない" class="headerlink" title="20.~て憚らない"></a>20.~て憚らない</h3><div class="note note-success">            <p>意味：遠慮せずに～する」「ためらわずに～する」「大胆に～する」</p>          </div><p>意見を述べて憚らない。</p><p>新しいアイデアを提案して憚らない。</p><h3 id="21-てはかなわない"><a href="#21-てはかなわない" class="headerlink" title="21.~てはかなわない"></a>21.~てはかなわない</h3><div class="note note-success">            <p>「〜するのは困る」や「〜するのは耐えられない」という意味を表す表現です。「かなわない」は「対抗できない」「負ける」「耐えられない」といったニュアンスを持ちます。</p>          </div><p>この騒音では寝てはかなわない。</p><p>彼女は泣かれてはかなわない。</p><h3 id="22-ても差し支えない"><a href="#22-ても差し支えない" class="headerlink" title="22.~ても差し支えない"></a>22.~ても差し支えない</h3><div class="note note-success">            <p>「問題ない」や「大丈夫」といった意味を表します。</p>          </div><p>書類は明日提出しても差し支えありません。</p><p>会議中に退席しても差し支えないでしょうか。</p><h3 id="23-てもともとだ"><a href="#23-てもともとだ" class="headerlink" title="23.~てもともとだ"></a>23.~てもともとだ</h3><div class="note note-success">            <p>「~てもともとだ」は、ある状況や条件が変わっても、結果は変わらないことを強調するときに使われます。つまり、何かが起こったとしても、本質的には何も変わらないという意味合いを持ちます。</p>          </div><p>彼が来なくてもともとだ。</p><p>だめでもともとだから、思い切って彼女に告白してみた。</p><h3 id="24-ても始まらない"><a href="#24-ても始まらない" class="headerlink" title="24.~ても始まらない"></a>24.~ても始まらない</h3><div class="note note-success">            <p>「たとえ〜をしても、何も良い結果は生まれない」「〜をしても意味がない」</p>          </div><p>今から後悔しても始まらない。</p><p>言い訳をしても始まらないよ。</p><h3 id="25-～てやまない"><a href="#25-～てやまない" class="headerlink" title="25.～てやまない"></a>25.～てやまない</h3><div class="note note-success">            <p>ある行動や状態が継続的に行われていることを強調する表現です。</p>          </div><p>結婚する二人の今後の幸せを願ってやまない。</p><p>真実を追求してやまない。</p><h3 id="26-か-と思いきや"><a href="#26-か-と思いきや" class="headerlink" title="26.~(か)と思いきや"></a>26.~(か)と思いきや</h3><div class="note note-success">            <p>「予想や期待とは異なり、意外な結果になって」</p>          </div><p>晴れると思いきや、突然雨が降り出した。</p><p>彼女は怒ると思いきや、意外にも笑顔で許してくれた。</p><h3 id="27-〜ともなく"><a href="#27-〜ともなく" class="headerlink" title="27.〜ともなく"></a>27.〜ともなく</h3><div class="note note-success">            <p>「〜ともなく」という表現は、意識せずに行動をしている様子や、特定の対象や理由がないことを表す日本語の文法表現です。</p>          </div><p>聞くともなく隣の会話が耳に入った。</p><p>電車の窓から外を見るともなく、高校時代の同級生の姿が目に入った。</p><h3 id="28-〜ならいざしらず"><a href="#28-〜ならいざしらず" class="headerlink" title="28.〜ならいざしらず"></a>28.〜ならいざしらず</h3><div class="note note-success">            <p>「〜なら問題ないが、そうでないなら問題だ」「〜なら仕方がないが、そうでないなら受け入れられない」といった意味で使います。</p>          </div><p>小学生ならいざしらず、大学生はこの漢字を知らないのは問題だ。</p><p>新入社員ならいざしらず、入社8年にもなる君がこんなミスをするとは信じられない。</p><h3 id="29-にはあたらない"><a href="#29-にはあたらない" class="headerlink" title="29.~にはあたらない"></a>29.~にはあたらない</h3><div class="note note-success">            <p>意味: 「〜する必要はない」「〜するほどのことではない」といった意味で使われ、感情的な反応や評価を避けるときに用います。</p>          </div><p>彼なりにできるだけの努力をしたのだから、いい結果を出せなかったとしても、非難するには当たらない。</p><p>優秀な田中君のことだから、論文を１週間で仕上げたと聞いても驚くにはあたらない。</p><h3 id="30-におかれましては"><a href="#30-におかれましては" class="headerlink" title="30.~におかれましては"></a>30.~におかれましては</h3><div class="note note-success">            <p>意味: 「〜に関しては」「〜については」の丁寧な形で、相手を非常に敬った形で、その人の状況や状態を指す。</p>          </div><p>社長におかれましては、お元気でご活躍のことと存じます。</p><p>最近のご状況におかれましては、いかがでしょうか。お忙しいことと存じますが、くれぐれもご自愛ください。</p><h3 id="31-にかこつけて"><a href="#31-にかこつけて" class="headerlink" title="31.~にかこつけて"></a>31.~にかこつけて</h3><div class="note note-success">            <p>意味: 「〜を口実にして」「〜を理由にして」といった意味で、表向きの理由を使って、実際は別の意図や目的があることを示します。</p>          </div><p>彼は仕事にかこつけて、頻繁に出張し、観光地を回っている。</p><p>天気にかこつけて、今日の会議は延期されたが、実は準備が間に合わなかったらしい。</p><h3 id="32-にかまけて"><a href="#32-にかまけて" class="headerlink" title="32.~にかまけて"></a>32.~にかまけて</h3><div class="note note-success">            <p>「〜に気を取られて他のことができない」「〜に夢中になって他のことを疎かにする」といった意味で、何かに集中しすぎて、他のことをやる余裕がなくなる状況を表します。</p>          </div><p>彼は仕事にかまけて、家族との時間を全然取っていない。</p><p>スマホにかまけて、勉強が疎かになっている。</p><h3 id="33-にかたくない"><a href="#33-にかたくない" class="headerlink" title="33.~にかたくない"></a>33.~にかたくない</h3><div class="note note-success">            <p>意味: 「〜するのは難しくない」「〜を簡単に理解できる」「〜を容易に想像できる」といった意味を表します。</p>          </div><p>長年に努力してきたことが報われた時の彼の喜びは、想像に難くない。</p><p>異国の地で生活する彼女の苦労は、理解にかたくない。</p><h3 id="34-にしくはない"><a href="#34-にしくはない" class="headerlink" title="34.~にしくはない"></a>34.~にしくはない</h3><div class="note note-success">            <p>意味としては、「〜が一番よい」、「〜が最善である」、「〜するに越したことはない」という考えを表現するものです。</p>          </div><p>安全な道を選ぶにしくはない。</p><p>事前に準備しておくにしくはない。</p><h3 id="35-に忍びない"><a href="#35-に忍びない" class="headerlink" title="35.~に忍びない"></a>35.~に忍びない</h3><div class="note note-success">            <p>「〜に忍びない」という表現は、感情的に耐えられず、ある行為をするのがつらい、または心苦しいと感じるときに使います。</p>          </div><p>彼の写真を捨てるに忍びない。</p><p>その小説の最後の場面はあまりに悲しくて、読むに忍びない。</p><h3 id="36-にたえる"><a href="#36-にたえる" class="headerlink" title="36.~にたえる"></a>36.~にたえる</h3><div class="note note-success">            <p>「〜にたえる（〜に堪える）」は、「〜する価値がある」「〜に耐えられる」という意味を持つ日本語の表現です。主に二つの使い方があります。</p>          </div><p>この映画は見るにたえる作品だ。</p><p>この痛みは堪えるに堪えない。</p><h3 id="37-にとどまらず"><a href="#37-にとどまらず" class="headerlink" title="37.~にとどまらず"></a>37.~にとどまらず</h3><div class="note note-success">            <p>「〜にとどまらず」という表現は、何かが特定の範囲や状況に「とどまる（留まる）」ことなく、さらに広がっている、または影響を及ぼしていることを示す表現です。つまり、「〜だけではなく、さらに」という意味を持ちます。</p>          </div><p>彼の影響は国内にとどまらず、海外にも広がっている。</p><p>この技術は企業内にとどまらず、一般家庭にも普及している。</p><h3 id="38-にひきかえ"><a href="#38-にひきかえ" class="headerlink" title="38.~にひきかえ"></a>38.~にひきかえ</h3><div class="note note-success">            <p>意味：「〜に対して」、「〜と比べて」</p>          </div><p>彼の努力しているにひきかえ、結果が出ていない。</p><p>新製品の売上が好調なにひきかえ、旧製品は苦戦している。</p><h3 id="39-にも増して"><a href="#39-にも増して" class="headerlink" title="39.~にも増して"></a>39.~にも増して</h3><div class="note note-success">            <p>「〜にも増して」は、「〜以上に」と同じ意味で、ある状況や程度がより強く、またはより重要であることを表します。</p>          </div><p>今年の夏は、去年にも増して暑い。</p><p>いつにも増して彼は元気そうだ。</p><h3 id="40-の至りだ"><a href="#40-の至りだ" class="headerlink" title="40.~の至りだ"></a>40.~の至りだ</h3><div class="note note-success">            <p>「非常に〜だ」「極めて〜だ」</p>          </div><p>このような賞をいただき、光栄の至りです。</p><p>皆様の温かいご支援に対し、感激の至りです。</p><h3 id="41-にさておいて・はさておき"><a href="#41-にさておいて・はさておき" class="headerlink" title="41.~にさておいて・はさておき"></a>41.~にさておいて・はさておき</h3><div class="note note-success">            <p>「〜はさておいて」は、何かを一旦脇に置いて、別のことに話題や焦点を移す際に使われる表現です。話の流れの中で、前に述べた内容や問題を一時的に保留して、別の重要なことについて言及したい場合に使います。</p>          </div><p>実現できるかとうかはさておき、まずは新商品のアイディアをみんなで出してみよう。</p><p>社員旅行の件ですが、費用のことはさておいて、まず日程について検討してみましょう。</p><h3 id="42-はそっちのけで・をそっちのけで"><a href="#42-はそっちのけで・をそっちのけで" class="headerlink" title="42.~はそっちのけで・をそっちのけで"></a>42.~はそっちのけで・をそっちのけで</h3><div class="note note-success">            <p>「そっちのけ」とは「そのことを無視する」「放っておく」という意味で、主に否定的なニュアンスで使われます。</p>          </div><p>宿題はそっちのけで、ゲームばかりしている。</p><p>大学4年生の弟は就職のことはそっちのけで、毎日パソコンゲームに没頭している。</p><h3 id="43-羽目になる・羽目に陥る"><a href="#43-羽目になる・羽目に陥る" class="headerlink" title="43.~羽目になる・羽目に陥る"></a>43.~羽目になる・羽目に陥る</h3><div class="note note-success">            <p>「〜羽目になる」や「〜羽目に陥る」は、意図しない結果や不幸な状況に陥ることを表す表現です。</p>          </div><p>遅刻してしまい、会議に出られない羽目になった。</p><p>お金を借りたことが原因で、返済のプレッシャーに陥る羽目になった。</p><h3 id="44-べからず"><a href="#44-べからず" class="headerlink" title="44.~べからず"></a>44.~べからず</h3><div class="note note-success">            <p>意味としては「〜してはならない」「〜すべきではない」という禁止や戒めを表します。形式は動詞の辞書形に「べからず」を付けて作られます。</p>          </div><p>企業から多額のお金を受け取るなんて、政治家としてゆるすべからざる行為だ。</p><p>彼はうちの会社にとって欠くべからざる人材だ。</p><h3 id="45-まじき"><a href="#45-まじき" class="headerlink" title="45.~まじき"></a>45.~まじき</h3><div class="note note-success">            <p>主に道徳的・社会的に「〜してはならない」「〜ふさわしくない」という意味を表します。具体的には、「あるべきではない」「許されない行為や態度」を強調する際に使われます。</p>          </div><p>彼の言動は社会人としてあるまじきもので、とうてい許すことはできない。</p><p>彼のやったことは、人としてあるまじき残酷な行為だ。</p><h3 id="46-めく・めいて・めいた"><a href="#46-めく・めいて・めいた" class="headerlink" title="46.~めく・めいて・めいた"></a>46.~めく・めいて・めいた</h3><div class="note note-success">            <p>「〜めく」「〜めいて」「〜めいた」は、物事や人の様子、性質を表現する際に使われる言葉です。</p>          </div><p>そんな皮肉めいた言い方をしないでください。</p><p>雪が溶けて、野の花が咲き始め、日差しも春めいてきた。</p><h3 id="47-もさることながら"><a href="#47-もさることながら" class="headerlink" title="47.~もさることながら"></a>47.~もさることながら</h3><div class="note note-success">            <p>「〜もさることながら」は、ある事柄を強調しつつ、その上で別の事柄も重要であることを示す表現です。通常、前半に言及したことが重要であると認めつつ、後半でそれに劣らず重要なことを追加します。</p>          </div><p>彼の実力もさることながら、努力も評価されるべきだ。</p><p>両親は、息子に病院の跡を継いで医者になって欲しいと思っているようだ。だが、親の希望もさることながら、やはり本人の気持ちが第一だろう。</p><h3 id="48-を皮切りに"><a href="#48-を皮切りに" class="headerlink" title="48.~を皮切りに"></a>48.~を皮切りに</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>このプロジェクトは、会議を皮切りに始まりました。</p><p>旅行を皮切りに、さまざまな国を訪れました。</p><h3 id="49-を蔑ろにする"><a href="#49-を蔑ろにする" class="headerlink" title="49.~を蔑ろにする"></a>49.~を蔑ろにする</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>彼はチームの意見を蔑ろにして、自分の考えだけを押し通した。</p><p>友人の気持ちを蔑ろにするような行動は避けるべきだ。</p><h3 id="50-をなおざりにして"><a href="#50-をなおざりにして" class="headerlink" title="50.~をなおざりにして"></a>50.~をなおざりにして</h3><div class="note note-success">            <p>何かをいい加減に扱ったり、手を抜いたりすることを意味する表現です。このフレーズは、重要な事柄を怠ったり、十分に注意を払わないことを示します。</p>          </div><p>どんなことがあっても、仕事をなおざりにしてはいけない。</p><p>彼は仕事をなおざりにして、結果的にトラブルを引き起こした。</p><h3 id="51-を控え"><a href="#51-を控え" class="headerlink" title="51.~を控え"></a>51.~を控え</h3><div class="note note-success">            <p>「~を控えて」は、特定の行動や状況を踏まえて、それに関連する行動や注意を促す際に使われる表現です。</p>          </div><p>試験を控えて、しっかり勉強する必要があります。</p><p>引越しを控えて、整理整頓を始めました。</p><h3 id="52-を振り出しに"><a href="#52-を振り出しに" class="headerlink" title="52.~を振り出しに"></a>52.~を振り出しに</h3><div class="note note-success">            <p>ある出来事や行動をきっかけとして、その後の展開や進展が始まることを示す表現です。</p>          </div><p>彼女は転職を振り出しに、キャリアは一新しました。</p><p>彼は小学校の教師を振り出しに社会に出た。</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学公式用法整理</title>
    <link href="/2024/09/08/Math-formula/"/>
    <url>/2024/09/08/Math-formula/</url>
    
    <content type="html"><![CDATA[<h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><blockquote><p>升级后的插件需要双反斜杠“\\\\”，网页才能正确渲染下来</p></blockquote><p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x\leq 0 \\<br>x, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p><h1 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h1><blockquote><p>array和aligned都不适配当前需求，直接用cases环境</p></blockquote><p>$$<br>\begin{cases}<br>    a_1x + b_1y + c_1z &#x3D; d_1 \\<br>    a_2x + b_2y + c_2z &#x3D; d_2 \\<br>    a_3x + b_3y + c_3z &#x3D; d_3<br>\end{cases}<br>$$</p><h1 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h1><p>$$<br>J(\theta) &#x3D; \frac{1}{2m}\sum_{i &#x3D; 0} ^m(y^i - h_\theta (x^i))^2<br>$$</p><h1 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h1><p>$$<br>\frac{\partial J(\theta)}{\partial\theta_j}&#x3D;-\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>$$</p><h1 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h1><p>$$<br>\begin{aligned}<br>\frac{\partial J(\theta)}{\partial\theta_j}<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j&#x3D;0}^n\theta_jx_j^i-y^i) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>\end{aligned}<br>$$</p><h1 id="case环境的使用"><a href="#case环境的使用" class="headerlink" title="case环境的使用"></a>case环境的使用</h1><p>$$<br>a &#x3D;<br>   \begin{cases}<br>     \int x, \mathrm{d} x\\<br>     b^2<br>   \end{cases}<br>$$</p><h1 id="带方框的等式"><a href="#带方框的等式" class="headerlink" title="带方框的等式"></a>带方框的等式</h1><p>$$<br>\begin{aligned}<br> \boxed{x^2+y^2 &#x3D; z^2}<br>\end{aligned}<br>$$</p><h1 id="最大（最小）操作符"><a href="#最大（最小）操作符" class="headerlink" title="最大（最小）操作符"></a>最大（最小）操作符</h1><p>$$<br>\begin{gathered}<br>\operatorname{arg,max}_a f(a)<br> &#x3D; \operatorname*{arg,max}_b f(b) \\<br> \operatorname{arg,min}_c f(c)<br> &#x3D; \operatorname*{arg,min}_d f(d)<br>\end{gathered}<br>$$</p><h1 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h1><p>$$<br>\begin{aligned}<br>  \lim_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \lim\nolimits_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$</p><h1 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h1><p>$$<br>\begin{aligned}<br>   \int_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \int\limits_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$</p><h1 id="多行表达公式"><a href="#多行表达公式" class="headerlink" title="多行表达公式"></a>多行表达公式</h1><p>$$<br>\begin{aligned}<br>J(\mathbf{w})&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m(f(\mathbf{x_i})-y_i)^2\\<br>&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m [f(\mathbf{x_i})]^2-2f(\mathbf{x_i)}y_i+y_i^2<br>\end{aligned}<br>$$</p><h1 id="小括号矩阵"><a href="#小括号矩阵" class="headerlink" title="小括号矩阵"></a>小括号矩阵</h1><p>$$\left(<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right)<br>\tag{2}<br>$$</p><h1 id="中括号矩阵"><a href="#中括号矩阵" class="headerlink" title="中括号矩阵"></a>中括号矩阵</h1><p>$$\left[<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right]<br>\tag{3}<br>$$</p><h1 id="带省略号的矩阵"><a href="#带省略号的矩阵" class="headerlink" title="带省略号的矩阵"></a>带省略号的矩阵</h1><p>$$<br>\left[<br>\begin{matrix}<br>a &amp; b &amp; \cdots &amp; a\\<br>b &amp; b &amp; \cdots &amp; b\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>c &amp; c &amp; \cdots &amp; c<br>\end{matrix}<br>\right]<br>\tag{5}<br>$$</p><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p>$\sin^2\alpha+\cos^2\alpha&#x3D;1$</p><p>$\cfrac{\sin\alpha}{\cos\alpha}&#x3D;\tan\alpha$</p><p>$\sin(2k\pi+\alpha)&#x3D;\sin\alpha(k\in Z)$</p><p>$\cos(2k\pi+\alpha)&#x3D;\cos\alpha(k\in Z)$</p><p>$\tan(2k\pi+\alpha)&#x3D;\tan\alpha(k\in Z)$</p><p>$\cot(2k\pi+\alpha)&#x3D;\cot\alpha(k\in Z)$</p><p>$\sin(\pi+\alpha)&#x3D;-\sin\alpha$</p><p>$\cos(\pi+\alpha)&#x3D;-\cos\alpha$</p><p>$\tan(\pi+\alpha)&#x3D;\tan\alpha$</p><p>$\cot(\pi+\alpha)&#x3D;\cot\alpha$</p><p>$\sin(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\sin\alpha(n为偶数)\\<br>(-1)^{\cfrac{n-1}{2}}\cos\alpha(n为奇数)\end{cases}$</p><p>$\cos(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\cos\alpha(n为偶数)\\(-1)^{\cfrac{n+1}{2}}\sin\alpha(n为奇数)\end{cases}$</p><p>$$<br>\left[<br>    \begin{array}{c|cc}<br>    1 &amp; 2 &amp; 3 \\ \hline<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>    \end{array}<br>\right]<br>\tag{7}<br>$$</p><p>$$x&#x3D;a_0 + \frac{1^2}{a_ 1+\frac{2^2}{a_2+\frac{3^2}{a_3+ \frac{4^2}{a_4+…}}}}$$</p><p>$a \equiv b \pmod n$</p><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>$$<br>e^{i\pi} + 1 &#x3D; 0<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/07/hello-world/"/>
    <url>/2024/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
