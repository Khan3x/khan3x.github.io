<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Probability Theory</title>
    <link href="/2025/07/25/Probability-theory/"/>
    <url>/2025/07/25/Probability-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="Probability-Theory"><a href="#Probability-Theory" class="headerlink" title="Probability Theory"></a>Probability Theory</h1><p>本篇笔记主要回顾一下概率论的相关内容。全文没有严格的上下文关系:)</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-概率论中集合运算的关系"><a href="#1-概率论中集合运算的关系" class="headerlink" title="1. 概率论中集合运算的关系"></a>1. 概率论中集合运算的关系</h2><h3 id="1-1-基本集合运算定义"><a href="#1-1-基本集合运算定义" class="headerlink" title="1.1. 基本集合运算定义"></a>1.1. 基本集合运算定义</h3><ul><li><p><strong>并集</strong>（Union）：<br>$A \cup B &#x3D; {x \mid x \in A \text{ or } x \in B}$</p></li><li><p><strong>交集</strong>（Intersection）：<br>$A \cap B &#x3D; {x \mid x \in A \text{ and } x \in B}$</p></li><li><p><strong>补集</strong>（Complement）：<br>$A^c &#x3D; {x \mid x \notin A}$</p></li><li><p><strong>差集</strong>（Difference）：<br>$A \setminus B &#x3D; {x \mid x \in A \text{ and } x \notin B}$</p></li><li><p><strong>对称差</strong>（Symmetric Difference）：<br>$A \triangle B &#x3D; (A \setminus B) \cup (B \setminus A)$</p></li></ul><hr><h3 id="1-2-基本关系与恒等律"><a href="#1-2-基本关系与恒等律" class="headerlink" title="1.2. 基本关系与恒等律"></a>1.2. 基本关系与恒等律</h3><ul><li><p>幂等律：</p><p>$$<br>A \cup A &#x3D; A,\quad A \cap A &#x3D; A<br>$$</p></li><li><p>交换律：</p><p>$$<br>A \cup B &#x3D; B \cup A,\quad A \cap B &#x3D; B \cap A<br>$$</p></li><li><p>结合律：</p><p>$$<br>(A \cup B) \cup C &#x3D; A \cup (B \cup C) \<br>(A \cap B) \cap C &#x3D; A \cap (B \cap C)<br>$$</p></li><li><p>分配律：</p><p>$$<br>A \cup (B \cap C) &#x3D; (A \cup B) \cap (A \cup C) \<br>A \cap (B \cup C) &#x3D; (A \cap B) \cup (A \cap C)<br>$$</p></li><li><p>吸收律：</p><p>$$<br>A \cup (A \cap B) &#x3D; A,\quad A \cap (A \cup B) &#x3D; A<br>$$</p></li><li><p>双重补集：</p><p>$$<br>(A^c)^c &#x3D; A<br>$$</p></li></ul><hr><h3 id="1-3-德摩根律（De-Morgan’s-Laws）"><a href="#1-3-德摩根律（De-Morgan’s-Laws）" class="headerlink" title="1.3. 德摩根律（De Morgan’s Laws）"></a>1.3. 德摩根律（De Morgan’s Laws）</h3><ul><li><p>对于两个集合：</p><p>$$<br>(A \cup B)^c &#x3D; A^c \cap B^c \<br>(A \cap B)^c &#x3D; A^c \cup B^c<br>$$</p></li><li><p>对于有限多个集合：</p><p>$$<br>\left( \bigcup_{i&#x3D;1}^{n} A_i \right)^c &#x3D; \bigcap_{i&#x3D;1}^{n} A_i^c \<br>\left( \bigcap_{i&#x3D;1}^{n} A_i \right)^c &#x3D; \bigcup_{i&#x3D;1}^{n} A_i^c<br>$$</p></li></ul><hr><h3 id="1-4-空集与全集关系（以样本空间-Omega-为全集）"><a href="#1-4-空集与全集关系（以样本空间-Omega-为全集）" class="headerlink" title="1.4. 空集与全集关系（以样本空间 $\Omega$ 为全集）"></a>1.4. 空集与全集关系（以样本空间 $\Omega$ 为全集）</h3><ul><li><p>空集性质：</p><p>$$<br>A \cup \varnothing &#x3D; A,\quad A \cap \varnothing &#x3D; \varnothing<br>$$</p></li><li><p>全集性质：</p><p>$$<br>A \cup \Omega &#x3D; \Omega,\quad A \cap \Omega &#x3D; A<br>$$</p></li><li><p>补集相关：</p><p>$$<br>A \cup A^c &#x3D; \Omega,\quad A \cap A^c &#x3D; \varnothing<br>$$</p></li></ul><hr><h3 id="1-5-包含与等价关系"><a href="#1-5-包含与等价关系" class="headerlink" title="1.5. 包含与等价关系"></a>1.5. 包含与等价关系</h3><ul><li><p>包含关系：<br>$A \subseteq B \Leftrightarrow A \cup B &#x3D; B \text{ 且 } A \cap B &#x3D; A$</p></li><li><p>等价关系：<br>$A &#x3D; B \Leftrightarrow A \subseteq B \text{ 且 } B \subseteq A$</p></li></ul><hr><h3 id="1-6-其他常用运算公式"><a href="#1-6-其他常用运算公式" class="headerlink" title="1.6. 其他常用运算公式"></a>1.6. 其他常用运算公式</h3><ul><li><p>差集转化为交集与补集：</p><p>$$<br>A \setminus B &#x3D; A \cap B^c<br>$$</p></li><li><p>对称差公式：</p><p>$$<br>A \triangle B &#x3D; (A \cup B) \setminus (A \cap B)<br>$$</p></li><li><p>差集运算公式：</p></li></ul><p>$$<br>A \setminus B &#x3D; A \cap B^c &#x3D; A \setminus (A \cap B) &#x3D; A(1 - B)<br>$$</p><h2 id="2-概率的基本性质与公式"><a href="#2-概率的基本性质与公式" class="headerlink" title="2. 概率的基本性质与公式"></a>2. 概率的基本性质与公式</h2><p>概率是描述某一事件发生可能性的数学工具。在概率论中，概率满足以下<strong>基本公理</strong>和由此推导出的一系列常用公式。</p><hr><h3 id="2-1-概率的三大公理（Kolmogorov-公理）"><a href="#2-1-概率的三大公理（Kolmogorov-公理）" class="headerlink" title="2.1 概率的三大公理（Kolmogorov 公理）"></a>2.1 概率的三大公理（Kolmogorov 公理）</h3><p>设 $\Omega$ 为样本空间，$\mathcal{F}$ 为事件集合，$P(\cdot)$ 为概率函数，则概率满足以下 <strong>三条基本公理</strong>：</p><ol><li><p><strong>非负性（Non-negativity）：</strong></p><p>$$<br>\forall A \in \mathcal{F}, \quad P(A) \geq 0<br>$$</p></li><li><p><strong>规范性（Normalization）：</strong></p><p>$$<br>P(\Omega) &#x3D; 1<br>$$</p></li><li><p><strong>可列可加性（Countable Additivity）：</strong></p><p>若 $A_1, A_2, A_3, \dots$ 两两互不相交（即 $A_i \cap A_j &#x3D; \varnothing$，$i \ne j$），则：</p><p>$$<br>P\left(\bigcup_{i&#x3D;1}^{\infty} A_i \right) &#x3D; \sum_{i&#x3D;1}^{\infty} P(A_i)<br>$$</p></li></ol><hr><h3 id="2-2-基本推论与常用公式"><a href="#2-2-基本推论与常用公式" class="headerlink" title="2.2 基本推论与常用公式"></a>2.2 基本推论与常用公式</h3><h4 id="1-空集的概率为-0："><a href="#1-空集的概率为-0：" class="headerlink" title="1. 空集的概率为 0："></a>1. <strong>空集的概率为 0：</strong></h4><p>$$<br>P(\varnothing) &#x3D; 0<br>$$</p><h4 id="2-子集关系："><a href="#2-子集关系：" class="headerlink" title="2. 子集关系："></a>2. <strong>子集关系：</strong></h4><p>若 $A \subseteq B$，则：</p><p>$$<br>P(A) \leq P(B)<br>$$</p><h4 id="3-补集公式："><a href="#3-补集公式：" class="headerlink" title="3. 补集公式："></a>3. <strong>补集公式：</strong></h4><p>$$<br>P(A^c) &#x3D; 1 - P(A)<br>$$</p><h4 id="4-有限可加性（两个事件的并）："><a href="#4-有限可加性（两个事件的并）：" class="headerlink" title="4. 有限可加性（两个事件的并）："></a>4. <strong>有限可加性（两个事件的并）：</strong></h4><p>对于任意事件 $A$ 和 $B$，</p><p>$$<br>P(A \cup B) &#x3D; P(A) + P(B) - P(A \cap B)<br>$$</p><blockquote><p>如果 $A$ 和 $B$ 互斥（即 $A \cap B &#x3D; \varnothing$），则：</p><p>$$<br>P(A \cup B) &#x3D; P(A) + P(B)<br>$$</p></blockquote><h4 id="5-差集的概率："><a href="#5-差集的概率：" class="headerlink" title="5. 差集的概率："></a>5. <strong>差集的概率：</strong></h4><p>$$<br>P(A \setminus B) &#x3D; P(A) - P(A \cap B)<br>$$</p><h4 id="6-三事件并的公式："><a href="#6-三事件并的公式：" class="headerlink" title="6. 三事件并的公式："></a>6. <strong>三事件并的公式：</strong></h4><p>对于任意事件 $A, B, C$：</p><p>$$<br>\begin{aligned}<br>P(A \cup B \cup C) &amp;&#x3D; P(A) + P(B) + P(C) \\<br>&amp;\quad - P(A \cap B) - P(A \cap C) - P(B \cap C) \\<br>&amp;\quad + P(A \cap B \cap C)<br>\end{aligned}<br>$$</p><h4 id="7-有限全集划分公式（全概率定理基础形式）："><a href="#7-有限全集划分公式（全概率定理基础形式）：" class="headerlink" title="7. 有限全集划分公式（全概率定理基础形式）："></a>7. <strong>有限全集划分公式（全概率定理基础形式）：</strong></h4><p>若 $A_1, A_2, \dots, A_n$ 构成不相交且覆盖全集的划分（即 $\bigcup A_i &#x3D; \Omega$ 且 $A_i \cap A_j &#x3D; \varnothing$，$i \ne j$），则对于任意事件 $B$：</p><p>$$<br>P(B) &#x3D; \sum_{i&#x3D;1}^{n} P(B \cap A_i)<br>$$</p><hr><h3 id="2-3-概率的范围限制"><a href="#2-3-概率的范围限制" class="headerlink" title="2.3 概率的范围限制"></a>2.3 概率的范围限制</h3><p>概率总是介于 0 与 1 之间：</p><p>$$<br>0 \leq P(A) \leq 1<br>$$</p><h2 id="3-条件概率与贝叶斯公式（Conditional-Probability-and-Bayes’-Theorem）"><a href="#3-条件概率与贝叶斯公式（Conditional-Probability-and-Bayes’-Theorem）" class="headerlink" title="3. 条件概率与贝叶斯公式（Conditional Probability and Bayes’ Theorem）"></a>3. 条件概率与贝叶斯公式（Conditional Probability and Bayes’ Theorem）</h2><h3 id="3-1-条件概率的定义"><a href="#3-1-条件概率的定义" class="headerlink" title="3.1 条件概率的定义"></a>3.1 条件概率的定义</h3><p>设事件 $A$ 和 $B$ 满足 $P(B) &gt; 0$，则 <strong>在事件 $B$ 发生的条件下，事件 $A$ 发生的概率</strong>，称为<strong>条件概率</strong>，记作 $P(A \mid B)$：</p><p>$$<br>P(A \mid B) &#x3D; \frac{P(A \cap B)}{P(B)}<br>$$</p><p>同理，也有：</p><p>$$<br>P(B \mid A) &#x3D; \frac{P(A \cap B)}{P(A)}<br>$$</p><blockquote><p>条件概率体现的是 <strong>“在某个背景下概率的重新评估”</strong>。</p></blockquote><hr><h3 id="3-2-条件概率的性质"><a href="#3-2-条件概率的性质" class="headerlink" title="3.2 条件概率的性质"></a>3.2 条件概率的性质</h3><ol><li><p>非负性：</p><p>$$<br>P(A \mid B) \geq 0<br>$$</p></li><li><p>规范性（$B$ 发生的背景下）：</p><p>$$<br>P(B \mid B) &#x3D; 1<br>$$</p></li><li><p>可加性：<br>若 $A_1, A_2$ 不相交，则：</p><p>$$<br>P(A_1 \cup A_2 \mid B) &#x3D; P(A_1 \mid B) + P(A_2 \mid B)<br>$$</p></li></ol><hr><h3 id="3-3-乘法公式（乘法定理）"><a href="#3-3-乘法公式（乘法定理）" class="headerlink" title="3.3 乘法公式（乘法定理）"></a>3.3 乘法公式（乘法定理）</h3><p>由条件概率定义可得：</p><p>$$<br>P(A \cap B) &#x3D; P(B) \cdot P(A \mid B) &#x3D; P(A) \cdot P(B \mid A)<br>$$</p><p>如果有多个事件 $A_1, A_2, \dots, A_n$，则：</p><p>$$<br>P(A_1 \cap A_2 \cap \dots \cap A_n) &#x3D; P(A_1) \cdot P(A_2 \mid A_1) \cdot P(A_3 \mid A_1 \cap A_2) \cdots<br>$$</p><hr><h3 id="3-4-全概率公式（Law-of-Total-Probability）"><a href="#3-4-全概率公式（Law-of-Total-Probability）" class="headerlink" title="3.4 全概率公式（Law of Total Probability）"></a>3.4 全概率公式（Law of Total Probability）</h3><p>设 ${B_1, B_2, \dots, B_n}$ 是一个<strong>完备事件组</strong>（划分样本空间的互不相交事件）且 $P(B_i) &gt; 0$，则对于任意事件 $A$ 有：</p><p>$$<br>P(A) &#x3D; \sum_{i&#x3D;1}^n P(B_i) \cdot P(A \mid B_i)<br>$$</p><blockquote><p>这表示从多个路径计算 $A$ 的“总概率”。</p></blockquote><hr><h3 id="3-5-贝叶斯公式（Bayes’-Theorem）"><a href="#3-5-贝叶斯公式（Bayes’-Theorem）" class="headerlink" title="3.5 贝叶斯公式（Bayes’ Theorem）"></a>3.5 贝叶斯公式（Bayes’ Theorem）</h3><p>贝叶斯公式用于<strong>在已知结果的情况下“倒推出原因”的概率</strong>。它是全概率公式的逆向应用。</p><p>设 ${B_1, B_2, \dots, B_n}$ 是一个样本空间的划分，$P(B_i) &gt; 0$，且 $P(A) &gt; 0$，则：</p><p>$$<br>P(B_i \mid A) &#x3D; \frac{P(B_i) \cdot P(A \mid B_i)}{\sum_{j&#x3D;1}^{n} P(B_j) \cdot P(A \mid B_j)}<br>$$</p><blockquote><p>🔍 <strong>通俗理解</strong>：已知事件 $A$ 发生，求“是谁导致了 $A$”，概率最大的那个 $B_i$ 通常被认为是最可能的原因。</p></blockquote><hr><h3 id="3-6-示例：诊断问题中的贝叶斯公式"><a href="#3-6-示例：诊断问题中的贝叶斯公式" class="headerlink" title="3.6 示例：诊断问题中的贝叶斯公式"></a>3.6 示例：诊断问题中的贝叶斯公式</h3><ul><li><p>某疾病的患病率为 $P(D) &#x3D; 0.01$</p></li><li><p>检测准确率如下：</p><ul><li>真阳性率：$P(\text{Pos} \mid D) &#x3D; 0.99$</li><li>假阳性率：$P(\text{Pos} \mid D^c) &#x3D; 0.05$</li></ul></li></ul><p>问：一个人检测为阳性，实际患病的概率是多少？即求：</p><p>$$<br>P(D \mid \text{Pos}) &#x3D; \frac{P(D) \cdot P(\text{Pos} \mid D)}{P(D) \cdot P(\text{Pos} \mid D) + P(D^c) \cdot P(\text{Pos} \mid D^c)}<br>$$</p><p>代入得：</p><p>$$<br>P(D \mid \text{Pos}) &#x3D; \frac{0.01 \cdot 0.99}{0.01 \cdot 0.99 + 0.99 \cdot 0.05} \approx 0.1667<br>$$</p><blockquote><p>✅ 即使测试很准，但因为总体患病率低，**阳性者真的患病的概率只有约 16.7%**，这就是贝叶斯定理的威力。</p></blockquote><h2 id="4-全概率公式（Law-of-Total-Probability）"><a href="#4-全概率公式（Law-of-Total-Probability）" class="headerlink" title="4. 全概率公式（Law of Total Probability）"></a>4. 全概率公式（Law of Total Probability）</h2><h3 id="4-1-定义与背景"><a href="#4-1-定义与背景" class="headerlink" title="4.1 定义与背景"></a>4.1 定义与背景</h3><p>在很多实际问题中，我们很难直接计算一个事件 $A$ 的概率，但我们可以将样本空间划分成若干个互不相交的子事件 $B_1, B_2, \dots, B_n$，然后利用这些子事件来<strong>间接求 $A$ 的概率</strong>，这就是<strong>全概率公式</strong>的思想。</p><hr><h3 id="4-2-全概率公式内容"><a href="#4-2-全概率公式内容" class="headerlink" title="4.2 全概率公式内容"></a>4.2 全概率公式内容</h3><p>设事件组 ${B_1, B_2, \dots, B_n}$ 满足：</p><ul><li>两两互不相交（即 $B_i \cap B_j &#x3D; \varnothing,\ i \ne j$）</li><li>它们构成对样本空间 $\Omega$ 的一个划分（即 $\bigcup_{i&#x3D;1}^n B_i &#x3D; \Omega$）</li><li>每个 $B_i$ 的概率都大于 0，即 $P(B_i) &gt; 0$</li></ul><p>则对于任意事件 $A$，有：</p><p>$$<br>P(A) &#x3D; \sum_{i&#x3D;1}^{n} P(B_i) \cdot P(A \mid B_i)<br>$$</p><hr><h3 id="4-3-通俗理解"><a href="#4-3-通俗理解" class="headerlink" title="4.3 通俗理解"></a>4.3 通俗理解</h3><p>可以理解为：</p><blockquote><p><strong>“事件 $A$ 的发生可能由若干种不同的原因 $B_i$ 导致，分别计算在每种原因下 $A$ 的条件概率，然后按每种原因发生的概率加权求和。”</strong></p></blockquote><hr><h3 id="4-4-推导思路"><a href="#4-4-推导思路" class="headerlink" title="4.4 推导思路"></a>4.4 推导思路</h3><p>根据乘法公式：</p><p>$$<br>P(A \cap B_i) &#x3D; P(B_i) \cdot P(A \mid B_i)<br>$$</p><p>又因为 $A$ 可以表示为：</p><p>$$<br>A &#x3D; (A \cap B_1) \cup (A \cap B_2) \cup \dots \cup (A \cap B_n)<br>$$</p><p>且这些交集事件互不相交，于是有：</p><p>$$<br>P(A) &#x3D; \sum_{i&#x3D;1}^{n} P(A \cap B_i) &#x3D; \sum_{i&#x3D;1}^{n} P(B_i) \cdot P(A \mid B_i)<br>$$</p><hr><h3 id="4-5-经典例题"><a href="#4-5-经典例题" class="headerlink" title="4.5 经典例题"></a>4.5 经典例题</h3><blockquote><p>一个工厂有三台机器 $M_1$, $M_2$, $M_3$ 生产产品，它们分别生产 30%、50%、20% 的产品，次品率分别是 2%、3%、4%。问：<strong>随机取出一个产品，它是次品的概率是多少？</strong></p></blockquote><p>设：</p><ul><li>$B_1$：来自 $M_1$，$P(B_1) &#x3D; 0.3$，$P(\text{次品} \mid B_1) &#x3D; 0.02$</li><li>$B_2$：来自 $M_2$，$P(B_2) &#x3D; 0.5$，$P(\text{次品} \mid B_2) &#x3D; 0.03$</li><li>$B_3$：来自 $M_3$，$P(B_3) &#x3D; 0.2$，$P(\text{次品} \mid B_3) &#x3D; 0.04$</li></ul><p>代入全概率公式：</p><p>$$<br>\begin{aligned}<br>P(\text{次品}) &amp;&#x3D; P(B_1) \cdot P(\text{次品} \mid B_1) + P(B_2) \cdot P(\text{次品} \mid B_2) + P(B_3) \cdot P(\text{次品} \mid B_3) \\<br>&amp;&#x3D; 0.3 \cdot 0.02 + 0.5 \cdot 0.03 + 0.2 \cdot 0.04 \\<br>&amp;&#x3D; 0.006 + 0.015 + 0.008 &#x3D; 0.029<br>\end{aligned}<br>$$</p><blockquote><p>所以产品是次品的概率为2.9%。</p></blockquote><h2 id="5-独立性与条件独立性（Independence-Conditional-Independence）"><a href="#5-独立性与条件独立性（Independence-Conditional-Independence）" class="headerlink" title="5. 独立性与条件独立性（Independence &amp; Conditional Independence）"></a>5. 独立性与条件独立性（Independence &amp; Conditional Independence）</h2><h3 id="5-1-两个事件的独立性（Independence-of-Two-Events）"><a href="#5-1-两个事件的独立性（Independence-of-Two-Events）" class="headerlink" title="5.1 两个事件的独立性（Independence of Two Events）"></a>5.1 两个事件的独立性（Independence of Two Events）</h3><p>👉 定义：</p><p>若两个事件 $A$ 和 $B$ 满足：</p><p>$$<br>P(A \cap B) &#x3D; P(A) \cdot P(B)<br>$$</p><p>则称 <strong>$A$ 与 $B$ 相互独立（independent）</strong>，记作：</p><p>$$<br>A \perp B<br>$$</p><blockquote><p>如果 $A$ 与 $B$ 独立，<strong>一个事件是否发生不会影响另一个事件的发生概率</strong>。</p></blockquote><p>即：</p><p>$$<br>P(A \mid B) &#x3D; P(A), \quad P(B \mid A) &#x3D; P(B)<br>$$</p><hr><h3 id="5-2-多个事件的独立性（Mutual-Independence）"><a href="#5-2-多个事件的独立性（Mutual-Independence）" class="headerlink" title="5.2 多个事件的独立性（Mutual Independence）"></a>5.2 多个事件的独立性（Mutual Independence）</h3><p>三个及以上事件的独立性必须满足更强的条件：</p><p>事件 $A_1, A_2, \dots, A_n$ <strong>相互独立</strong> 当且仅当，对任意子集 ${i_1, i_2, \dots, i_k}$ 都有：</p><p>$$<br>P(A_{i_1} \cap A_{i_2} \cap \dots \cap A_{i_k}) &#x3D; P(A_{i_1}) \cdot P(A_{i_2}) \cdots P(A_{i_k})<br>$$</p><p>例如，$A_1, A_2, A_3$ 三个事件独立需要满足：</p><ul><li>$P(A_1 \cap A_2) &#x3D; P(A_1)P(A_2)$</li><li>$P(A_1 \cap A_3) &#x3D; P(A_1)P(A_3)$</li><li>$P(A_2 \cap A_3) &#x3D; P(A_2)P(A_3)$</li><li>$P(A_1 \cap A_2 \cap A_3) &#x3D; P(A_1)P(A_2)P(A_3)$</li></ul><blockquote><p>✅ 所以 <strong>两两独立不代表完全独立（mutual independence）</strong>！</p></blockquote><hr><h3 id="5-3-条件独立性（Conditional-Independence）"><a href="#5-3-条件独立性（Conditional-Independence）" class="headerlink" title="5.3 条件独立性（Conditional Independence）"></a>5.3 条件独立性（Conditional Independence）</h3><p>👉 定义：</p><p>给定事件 $C$，如果事件 $A$ 和 $B$ 满足：</p><p>$$<br>P(A \cap B \mid C) &#x3D; P(A \mid C) \cdot P(B \mid C)<br>$$</p><p>则称 <strong>$A$ 与 $B$ 在 $C$ 条件下独立</strong>，记作：</p><p>$$<br>A \perp B \mid C<br>$$</p><blockquote><p>虽然 $A$ 与 $B$ 在总体上可能有关，但<strong>在知道 $C$ 发生的前提下，它们变得无关</strong>。</p></blockquote><p>举个例子：</p><ul><li>$A$：某人感冒</li><li>$B$：某人发烧</li><li>$C$：该人感染了病毒</li></ul><p>则 $A$ 和 $B$ 在总体上可能有关联，但在给定 $C$（病毒感染）的前提下，$A$ 和 $B$ 的概率分布是独立的。</p><hr><h3 id="5-4-常见误区说明："><a href="#5-4-常见误区说明：" class="headerlink" title="5.4 常见误区说明："></a>5.4 常见误区说明：</h3><table><thead><tr><th>概念</th><th>要点</th><th>易错点</th></tr></thead><tbody><tr><td>独立性</td><td>$P(A \cap B) &#x3D; P(A)P(B)$</td><td>与“互斥”不同，互斥事件不能同时发生，但可能不独立</td></tr><tr><td>条件独立性</td><td>$P(A \cap B \mid C) &#x3D; P(A \mid C)P(B \mid C)$</td><td>条件独立 ≠ 无条件独立</td></tr><tr><td>两两独立</td><td>任意两个事件独立</td><td>不等价于相互独立（mutual independence）</td></tr></tbody></table><hr><h3 id="5-5-示例题（简要）"><a href="#5-5-示例题（简要）" class="headerlink" title="5.5 示例题（简要）"></a>5.5 示例题（简要）</h3><blockquote><p>已知 $P(A) &#x3D; 0.5,\ P(B) &#x3D; 0.6,\ P(A \cap B) &#x3D; 0.3$，判断 $A$ 与 $B$ 是否独立？</p></blockquote><p>计算：</p><p>$$<br>P(A) \cdot P(B) &#x3D; 0.5 \cdot 0.6 &#x3D; 0.3<br>$$</p><p>因为 $P(A \cap B) &#x3D; 0.3$，所以：</p><p>✅ <strong>$A$ 与 $B$ 是独立的</strong></p><h2 id="6-随机变量（Random-Variable）"><a href="#6-随机变量（Random-Variable）" class="headerlink" title="6. 随机变量（Random Variable）"></a>6. 随机变量（Random Variable）</h2><h3 id="6-1-随机变量的定义"><a href="#6-1-随机变量的定义" class="headerlink" title="6.1 随机变量的定义"></a>6.1 随机变量的定义</h3><p>在概率论中，<strong>随机变量</strong>是对试验结果进行<strong>数值表示</strong>的函数。</p><p><strong>👉 数学定义：</strong></p><p>设样本空间为 $\Omega$，一个<strong>随机变量 $X$</strong> 是一个函数：</p><p>$$<br>X: \Omega \rightarrow \mathbb{R}<br>$$</p><p>它将样本空间中的每一个元素 $\omega \in \Omega$ 映射为实数 $X(\omega)$。</p><blockquote><p>✅ 通俗理解：随机变量是把“事件结果”转化为“数值”的工具。</p></blockquote><hr><h3 id="6-2-随机变量的分类"><a href="#6-2-随机变量的分类" class="headerlink" title="6.2 随机变量的分类"></a>6.2 随机变量的分类</h3><h4 id="1-离散型随机变量（Discrete-Random-Variable）"><a href="#1-离散型随机变量（Discrete-Random-Variable）" class="headerlink" title="1. 离散型随机变量（Discrete Random Variable）"></a>1. <strong>离散型随机变量（Discrete Random Variable）</strong></h4><p>如果随机变量的<strong>取值是有限个或可数无限个</strong>，称为离散型。</p><p>例子：</p><ul><li>投掷骰子：$X &#x3D; \text{点数} \in {1,2,3,4,5,6}$</li><li>抛硬币若干次直到第一次正面：$X \in {1,2,3,\dots}$</li></ul><hr><h4 id="2-连续型随机变量（Continuous-Random-Variable）"><a href="#2-连续型随机变量（Continuous-Random-Variable）" class="headerlink" title="2. 连续型随机变量（Continuous Random Variable）"></a>2. <strong>连续型随机变量（Continuous Random Variable）</strong></h4><p>如果随机变量可以在一个实数区间内<strong>连续取值</strong>，则称为连续型。</p><p>例子：</p><ul><li>一根木棍长度 $X \in [0, 100]$</li><li>电压 $X \in \mathbb{R}$</li></ul><hr><h3 id="6-3-随机变量的事件定义"><a href="#6-3-随机变量的事件定义" class="headerlink" title="6.3 随机变量的事件定义"></a>6.3 随机变量的事件定义</h3><p>随机变量定义完后，我们可以通过它来描述事件，例如：</p><ul><li>“事件 $X &#x3D; 2$” 实际表示的是 $X^{-1}({2}) &#x3D; {\omega \in \Omega \mid X(\omega) &#x3D; 2}$</li><li>“事件 $X &lt; 5$” 表示的是 $X^{-1}((-\infty, 5))$</li></ul><p>这使我们能在数轴上处理事件，而不是抽象的样本空间。</p><hr><h3 id="6-4-分布函数（Distribution-Function）"><a href="#6-4-分布函数（Distribution-Function）" class="headerlink" title="6.4 分布函数（Distribution Function）"></a>6.4 分布函数（Distribution Function）</h3><p>设 $X$ 是一个随机变量，其分布函数（CDF）定义为：</p><p>$$<br>F_X(x) &#x3D; P(X \leq x)<br>$$</p><blockquote><p>这是描述随机变量最重要的工具之一。</p></blockquote><p><strong>✅ 分布函数的性质：</strong></p><ol><li><p>单调非减：</p><p>$$<br>x_1 &lt; x_2 \Rightarrow F_X(x_1) \leq F_X(x_2)<br>$$</p></li><li><p>左连续：</p><p>$$<br>\lim_{t \to x^-} F_X(t) &#x3D; F_X(x)<br>$$</p></li><li><p>极限性质：</p><p>$$<br>\lim_{x \to -\infty} F_X(x) &#x3D; 0,\quad \lim_{x \to +\infty} F_X(x) &#x3D; 1<br>$$</p></li></ol><hr><h3 id="6-5-常见随机变量举例"><a href="#6-5-常见随机变量举例" class="headerlink" title="6.5 常见随机变量举例"></a>6.5 常见随机变量举例</h3><table><thead><tr><th>名称</th><th>类型</th><th>常用记号</th><th>定义域</th><th>示例</th></tr></thead><tbody><tr><td>伯努利分布</td><td>离散型</td><td>$X \sim \text{Bern}(p)$</td><td>${0,1}$</td><td>抛一次硬币</td></tr><tr><td>二项分布</td><td>离散型</td><td>$X \sim B(n, p)$</td><td>${0,1,\dots,n}$</td><td>抛硬币 $n$ 次</td></tr><tr><td>几何分布</td><td>离散型</td><td>$X \sim \text{Geom}(p)$</td><td>${1,2,3,\dots}$</td><td>第一次成功的试验次数</td></tr><tr><td>均匀分布</td><td>连续型</td><td>$X \sim U(a, b)$</td><td>$[a,b]$</td><td>等概率抽取</td></tr><tr><td>正态分布</td><td>连续型</td><td>$X \sim N(\mu, \sigma^2)$</td><td>$\mathbb{R}$</td><td>自然现象、误差</td></tr><tr><td>指数分布</td><td>连续型</td><td>$X \sim \text{Exp}(\lambda)$</td><td>$[0, \infty)$</td><td>等待时间</td></tr></tbody></table><hr><h3 id="6-6-小结"><a href="#6-6-小结" class="headerlink" title="6.6 小结"></a>6.6 小结</h3><ul><li>随机变量是从事件到数值的桥梁。</li><li>离散型和连续型是两大类。</li><li>分布函数 $F_X(x) &#x3D; P(X \leq x)$ 是描述随机变量行为的核心工具。</li></ul><h2 id="7-累积分布函数（CDF）"><a href="#7-累积分布函数（CDF）" class="headerlink" title="7. 累积分布函数（CDF）"></a>7. 累积分布函数（CDF）</h2><p>设 $X$ 是一个随机变量，其<strong>累积分布函数</strong>（CDF）定义为：</p><p>$$<br>F_X(x) &#x3D; P(X \leq x)<br>$$</p><p>即，随机变量 $X$ 取值小于等于 $x$ 的概率。</p><hr><h3 id="7-1-CDF-的基本性质："><a href="#7-1-CDF-的基本性质：" class="headerlink" title="7.1 CDF 的基本性质："></a>7.1 CDF 的基本性质：</h3><p>对于任意随机变量 $X$，其 CDF $F_X(x)$ 满足以下性质：</p><ol><li><p><strong>非递减性（Monotonicity）</strong>：</p><p>$$<br>x_1 &lt; x_2 \Rightarrow F_X(x_1) \leq F_X(x_2)<br>$$</p></li><li><p><strong>右连续性（Right-continuity）</strong>：</p><p>$$<br>\lim_{\varepsilon \to 0^+} F_X(x + \varepsilon) &#x3D; F_X(x)<br>$$</p></li><li><p><strong>取值范围（Range）</strong>：</p><p>$$<br>\lim_{x \to -\infty} F_X(x) &#x3D; 0,\quad \lim_{x \to +\infty} F_X(x) &#x3D; 1<br>$$</p></li><li><p><strong>概率的区间表示</strong>：<br>对任意 $a &lt; b$，</p><p>$$<br>P(a &lt; X \leq b) &#x3D; F_X(b) - F_X(a)<br>$$</p></li></ol><hr><h3 id="7-2-离散型随机变量的-CDF："><a href="#7-2-离散型随机变量的-CDF：" class="headerlink" title="7.2 离散型随机变量的 CDF："></a>7.2 离散型随机变量的 CDF：</h3><p>若 $X$ 为离散型随机变量，具有概率质量函数（PMF） $p(x_i) &#x3D; P(X &#x3D; x_i)$，则：</p><p>$$<br>F_X(x) &#x3D; \sum_{x_i \leq x} p(x_i)<br>$$</p><p><strong>例子</strong>：设 $X$ 的取值为 $1, 2, 3$，且：</p><ul><li>$P(X&#x3D;1)&#x3D;0.2$，</li><li>$P(X&#x3D;2)&#x3D;0.5$，</li><li>$P(X&#x3D;3)&#x3D;0.3$。</li></ul><p>则 $F_X(x)$ 为：</p><ul><li>$F_X(1) &#x3D; 0.2$</li><li>$F_X(2) &#x3D; 0.7$</li><li>$F_X(3) &#x3D; 1.0$</li></ul><hr><h3 id="7-3-连续型随机变量的-CDF："><a href="#7-3-连续型随机变量的-CDF：" class="headerlink" title="7.3 连续型随机变量的 CDF："></a>7.3 连续型随机变量的 CDF：</h3><p>若 $X$ 为连续型随机变量，其概率密度函数（PDF）为 $f(x)$，则：</p><p>$$<br>F_X(x) &#x3D; \int_{-\infty}^{x} f(t) , dt<br>$$</p><p>并且：</p><p>$$<br>f(x) &#x3D; \frac{d}{dx}F_X(x)<br>$$</p><hr><h3 id="7-4-常见分布的-CDF-示例："><a href="#7-4-常见分布的-CDF-示例：" class="headerlink" title="7.4 常见分布的 CDF 示例："></a>7.4 常见分布的 CDF 示例：</h3><ol><li><p>**均匀分布 $U(a, b)$**：</p><p>$$<br>F_X(x) &#x3D; \begin{cases}<br>0 &amp; x &lt; a \\<br>\frac{x - a}{b - a} &amp; a \leq x \leq b \\<br>1 &amp; x &gt; b<br>\end{cases}<br>$$</p></li><li><p>**标准正态分布 $\mathcal{N}(0, 1)$**：</p><p>$$<br>F_X(x) &#x3D; \Phi(x) &#x3D; \int_{-\infty}^x \frac{1}{\sqrt{2\pi}} e^{-t^2&#x2F;2} , dt<br>$$</p></li></ol><p>（注意：$\Phi(x)$ 无解析表达式，通常查表或用数值方法）</p><p><strong>📎 注意事项：</strong></p><ul><li>CDF 是每个随机变量都存在的，即使它既不是纯粹离散也不是纯粹连续（如混合型）。</li><li>CDF 是研究概率分布的基本工具，能完全刻画一个随机变量的分布。</li></ul><h2 id="8-期望和方差"><a href="#8-期望和方差" class="headerlink" title="8. 期望和方差"></a>8. 期望和方差</h2><h3 id="8-1-期望（Expectation）"><a href="#8-1-期望（Expectation）" class="headerlink" title="8.1. 期望（Expectation）"></a>8.1. 期望（Expectation）</h3><p>离散型随机变量 $X$</p><p>如果 $X$ 的概率质量函数为 $P(X &#x3D; x_i) &#x3D; p_i$，则其期望定义为：</p><p>$$<br>\mathbb{E}[X] &#x3D; \sum_i x_i \cdot p_i<br>$$</p><p>连续型随机变量 $X$</p><p>如果 $X$ 的概率密度函数为 $f(x)$，则期望为：</p><p>$$<br>\mathbb{E}[X] &#x3D; \int_{-\infty}^{\infty} x \cdot f(x) , dx<br>$$</p><p><strong>期望的性质</strong></p><ul><li><p><strong>线性性</strong>：对任意常数 $a, b$ 和随机变量 $X, Y$ 有：</p><p>$$<br>\mathbb{E}[aX + bY] &#x3D; a \mathbb{E}[X] + b \mathbb{E}[Y]<br>$$</p></li><li><p>若 $c$ 为常数，则：</p><p>$$<br>\mathbb{E}[c] &#x3D; c<br>$$</p></li></ul><hr><h3 id="8-2-方差（Variance）"><a href="#8-2-方差（Variance）" class="headerlink" title="8.2. 方差（Variance）"></a>8.2. 方差（Variance）</h3><p>方差衡量随机变量与其期望的偏离程度。</p><p>$$<br>\mathrm{Var}(X) &#x3D; \mathbb{E}[(X - \mathbb{E}[X])^2]<br>$$</p><p>也可以表示为：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \mathbb{E}[X^2] - (\mathbb{E}[X])^2<br>$$</p><p><strong>方差的性质</strong></p><ul><li><p><strong>常数的方差为 0</strong>：</p><p>$$<br>\mathrm{Var}(c) &#x3D; 0<br>$$</p></li><li><p><strong>常数乘积</strong>：</p><p>$$<br>\mathrm{Var}(aX + b) &#x3D; a^2 \cdot \mathrm{Var}(X)<br>$$</p></li></ul><hr><h3 id="8-3-协方差与相关系数"><a href="#8-3-协方差与相关系数" class="headerlink" title="8.3. 协方差与相关系数"></a>8.3. 协方差与相关系数</h3><ul><li><p><strong>协方差定义</strong>：</p><p>$$<br>\mathrm{Cov}(X, Y) &#x3D; \mathbb{E}[(X - \mathbb{E}[X])(Y - \mathbb{E}[Y])]<br>$$</p></li><li><p><strong>相关系数</strong>（标准化的协方差）：</p><p>$$<br>\rho_{X,Y} &#x3D; \frac{\mathrm{Cov}(X, Y)}{\sqrt{\mathrm{Var}(X)} \cdot \sqrt{\mathrm{Var}(Y)}}<br>$$</p></li></ul><h2 id="9-Markov-不等式（Markov’s-Inequality）"><a href="#9-Markov-不等式（Markov’s-Inequality）" class="headerlink" title="9. Markov 不等式（Markov’s Inequality）"></a>9. Markov 不等式（Markov’s Inequality）</h2><p>$$<br>\mathbb{P}(X \ge a) \le \frac{\mathbb{E}[X]}{a}<br>$$</p><h2 id="10-Chebyshev-不等式（Chebyshev’s-Inequality）"><a href="#10-Chebyshev-不等式（Chebyshev’s-Inequality）" class="headerlink" title="10. Chebyshev 不等式（Chebyshev’s Inequality）"></a>10. Chebyshev 不等式（Chebyshev’s Inequality）</h2><p>设随机变量 $X$ 的期望为 $\mu &#x3D; \mathbb{E}[X]$，方差为 $\sigma^2 &#x3D; \mathrm{Var}(X)$，那么对于任意 $\varepsilon &gt; 0$，有：</p><p>$$<br>\mathbb{P}(|X - \mu| \ge \varepsilon) \le \frac{\sigma^2}{\varepsilon^2}<br>$$</p><p>令 $Y &#x3D; (X - \mu)^2$，因为 $Y \ge 0$，可以对其使用 <strong>Markov 不等式</strong>：</p><p>$$<br>\mathbb{P}(Y \ge \varepsilon^2) \le \frac{\mathbb{E}[Y]}{\varepsilon^2}<br>$$</p><p>又因为：</p><p>$$<br>Y &#x3D; (X - \mu)^2,\quad \mathbb{E}[Y] &#x3D; \mathrm{Var}(X) &#x3D; \sigma^2<br>$$</p><p>所以，</p><p>$$<br>\mathbb{P}((X - \mu)^2 \ge \varepsilon^2) \le \frac{\sigma^2}{\varepsilon^2}<br>$$</p><p>注意到事件 ${(X - \mu)^2 \ge \varepsilon^2}$ 与事件 ${|X - \mu| \ge \varepsilon}$ 是等价的，因此：</p><p>$$<br>\mathbb{P}(|X - \mu| \ge \varepsilon) \le \frac{\sigma^2}{\varepsilon^2}<br>$$</p><p>证毕。</p><h2 id="11-常见离散型分布"><a href="#11-常见离散型分布" class="headerlink" title="11. 常见离散型分布"></a>11. 常见离散型分布</h2><h3 id="11-1-Bernoulli-分布（伯努利分布）"><a href="#11-1-Bernoulli-分布（伯努利分布）" class="headerlink" title="11.1. Bernoulli 分布（伯努利分布）"></a>11.1. Bernoulli 分布（伯努利分布）</h3><ul><li><p><strong>定义</strong>：只有两个可能结果（成功或失败），成功的概率为 $p$，失败的概率为 $1 - p$。</p></li><li><p><strong>概率质量函数（PMF）</strong>：</p><p>$$<br>\mathbb{P}(X &#x3D; x) &#x3D;<br>\begin{cases}<br>p, &amp; x &#x3D; 1 \\<br>1 - p, &amp; x &#x3D; 0<br>\end{cases}<br>$$</p></li><li><p><strong>期望</strong>：$\mathbb{E}[X] &#x3D; p$</p></li><li><p><strong>方差</strong>：$\mathrm{Var}(X) &#x3D; p(1 - p)$</p></li></ul><hr><h3 id="11-2-Binomial-分布（二项分布）"><a href="#11-2-Binomial-分布（二项分布）" class="headerlink" title="11.2. Binomial 分布（二项分布）"></a>11.2. Binomial 分布（二项分布）</h3><ul><li><p><strong>定义</strong>：进行 $n$ 次独立伯努利试验，每次成功概率为 $p$，$X$ 表示成功次数。</p></li><li><p><strong>PMF</strong>：</p><p>$$<br>\mathbb{P}(X &#x3D; k) &#x3D; \binom{n}{k} p^k (1 - p)^{n - k},\quad k &#x3D; 0, 1, \dots, n<br>$$</p></li><li><p><strong>期望</strong>：$\mathbb{E}[X] &#x3D; np$</p></li><li><p><strong>方差</strong>：$\mathrm{Var}(X) &#x3D; np(1 - p)$</p></li></ul><hr><h3 id="11-3-Geometric-分布（几何分布）"><a href="#11-3-Geometric-分布（几何分布）" class="headerlink" title="11.3. Geometric 分布（几何分布）"></a>11.3. Geometric 分布（几何分布）</h3><ul><li><p><strong>定义</strong>：第一次成功所需的试验次数（包括成功的那次），每次独立试验成功概率为 $p$。</p></li><li><p><strong>PMF</strong>：</p><p>$$<br>\mathbb{P}(X &#x3D; k) &#x3D; (1 - p)^{k - 1} p,\quad k &#x3D; 1, 2, 3, \dots<br>$$</p></li><li><p><strong>期望</strong>：$\mathbb{E}[X] &#x3D; \frac{1}{p}$</p></li><li><p><strong>方差</strong>：$\mathrm{Var}(X) &#x3D; \frac{1 - p}{p^2}$</p></li></ul><hr><h3 id="11-4-Poisson-分布（泊松分布）"><a href="#11-4-Poisson-分布（泊松分布）" class="headerlink" title="11.4. Poisson 分布（泊松分布）"></a>11.4. Poisson 分布（泊松分布）</h3><ul><li><p><strong>定义</strong>：单位时间或单位面积内发生某事件的次数。常用于稀有事件建模。</p></li><li><p><strong>PMF</strong>：</p><p>$$<br>\mathbb{P}(X &#x3D; k) &#x3D; \frac{\lambda^k e^{-\lambda}}{k!},\quad k &#x3D; 0, 1, 2, \dots<br>$$</p></li><li><p><strong>期望</strong>：$\mathbb{E}[X] &#x3D; \lambda$</p></li><li><p><strong>方差</strong>：$\mathrm{Var}(X) &#x3D; \lambda$</p></li></ul><hr><h3 id="11-5-Hypergeometric-分布（超几何分布）"><a href="#11-5-Hypergeometric-分布（超几何分布）" class="headerlink" title="11.5. Hypergeometric 分布（超几何分布）"></a>11.5. Hypergeometric 分布（超几何分布）</h3><ul><li><p><strong>定义</strong>：从 $N$ 个元素中不放回地抽取 $n$ 个，其中有 $K$ 个是“成功”，$X$ 表示抽到的成功个数。</p></li><li><p><strong>PMF</strong>：</p><p>$$<br>\mathbb{P}(X &#x3D; k) &#x3D; \frac{\binom{K}{k} \binom{N - K}{n - k}}{\binom{N}{n}},\quad \max(0, n - N + K) \le k \le \min(n, K)<br>$$</p></li><li><p><strong>期望</strong>：$\mathbb{E}[X] &#x3D; n \cdot \frac{K}{N}$</p></li><li><p><strong>方差</strong>：<br>$$<br>\mathrm{Var}(X) &#x3D; n \cdot \frac{K}{N} \cdot \left(1 - \frac{K}{N}\right) \cdot \frac{N - n}{N - 1}<br>$$</p></li></ul><h2 id="12-常见连续型分布"><a href="#12-常见连续型分布" class="headerlink" title="12. 常见连续型分布"></a>12. 常见连续型分布</h2><h3 id="12-1-均匀分布（Uniform-Distribution）"><a href="#12-1-均匀分布（Uniform-Distribution）" class="headerlink" title="12.1 均匀分布（Uniform Distribution）"></a>12.1 均匀分布（Uniform Distribution）</h3><ul><li><p><strong>定义域</strong>：$X \sim U(a, b)$，其中 $a &lt; b$</p></li><li><p><strong>概率密度函数（PDF）</strong>：</p><p>$$<br>f(x) &#x3D; \begin{cases}<br>\frac{1}{b - a}, &amp; a \leq x \leq b \\<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p></li><li><p><strong>期望与方差</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \frac{a + b}{2}, \quad \mathrm{Var}(X) &#x3D; \frac{(b - a)^2}{12}<br>$$</p></li></ul><hr><h3 id="12-2-指数分布（Exponential-Distribution）"><a href="#12-2-指数分布（Exponential-Distribution）" class="headerlink" title="12.2 指数分布（Exponential Distribution）"></a>12.2 指数分布（Exponential Distribution）</h3><ul><li><p><strong>定义</strong>：$X \sim \mathrm{Exp}(\lambda)$，其中 $\lambda &gt; 0$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \begin{cases}<br>\lambda e^{-\lambda x}, &amp; x \geq 0 \\<br>0, &amp; x &lt; 0<br>\end{cases}<br>$$</p></li><li><p><strong>期望与方差</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \frac{1}{\lambda}, \quad \mathrm{Var}(X) &#x3D; \frac{1}{\lambda^2}<br>$$</p></li><li><p><strong>记忆性</strong>：$\mathbb{P}(X &gt; s + t \mid X &gt; s) &#x3D; \mathbb{P}(X &gt; t)$</p></li></ul><hr><h3 id="12-3-正态分布（Normal-Distribution）"><a href="#12-3-正态分布（Normal-Distribution）" class="headerlink" title="12.3 正态分布（Normal Distribution）"></a>12.3 正态分布（Normal Distribution）</h3><ul><li><p><strong>定义</strong>：$X \sim \mathcal{N}(\mu, \sigma^2)$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \frac{1}{\sqrt{2\pi \sigma^2}} \exp\left( -\frac{(x - \mu)^2}{2\sigma^2} \right)<br>$$</p></li><li><p><strong>期望与方差</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \mu, \quad \mathrm{Var}(X) &#x3D; \sigma^2<br>$$</p></li><li><p><strong>标准正态分布</strong>：$Z \sim \mathcal{N}(0, 1)$</p></li></ul><hr><h3 id="12-4-伽马分布（Gamma-Distribution）"><a href="#12-4-伽马分布（Gamma-Distribution）" class="headerlink" title="12.4 伽马分布（Gamma Distribution）"></a>12.4 伽马分布（Gamma Distribution）</h3><ul><li><p><strong>定义</strong>：$X \sim \mathrm{Gamma}(\alpha, \lambda)$，其中 $\alpha &gt; 0$ 是形状参数，$\lambda &gt; 0$ 是率参数</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \frac{\lambda^\alpha x^{\alpha - 1} e^{-\lambda x}}{\Gamma(\alpha)}, \quad x &gt; 0<br>$$</p></li><li><p><strong>期望与方差</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \frac{\alpha}{\lambda}, \quad \mathrm{Var}(X) &#x3D; \frac{\alpha}{\lambda^2}<br>$$</p></li><li><p><strong>特别情况</strong>：</p><ul><li>$\alpha &#x3D; 1$ 时为指数分布</li><li>$\alpha &#x3D; n$（正整数）时为 Erlang 分布</li></ul></li></ul><hr><h3 id="12-5-卡方分布（Chi-Square-Distribution）"><a href="#12-5-卡方分布（Chi-Square-Distribution）" class="headerlink" title="12.5 卡方分布（Chi-Square Distribution）"></a>12.5 卡方分布（Chi-Square Distribution）</h3><ul><li><p><strong>定义</strong>：$\chi^2_k$ 是 $k$ 个独立标准正态变量平方和的分布</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \frac{1}{2^{k&#x2F;2} \Gamma(k&#x2F;2)} x^{k&#x2F;2 - 1} e^{-x&#x2F;2}, \quad x &gt; 0<br>$$</p></li><li><p><strong>期望与方差</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; k, \quad \mathrm{Var}(X) &#x3D; 2k<br>$$</p></li></ul><hr><h3 id="12-6-t-分布（Student’s-t-Distribution）"><a href="#12-6-t-分布（Student’s-t-Distribution）" class="headerlink" title="12.6 t 分布（Student’s t Distribution）"></a>12.6 t 分布（Student’s t Distribution）</h3><ul><li><p><strong>定义</strong>：$T &#x3D; \frac{Z}{\sqrt{V&#x2F;k}}$，其中 $Z \sim \mathcal{N}(0,1)$，$V \sim \chi^2_k$ 且独立</p></li><li><p><strong>期望与方差</strong>：</p><p>$$<br>\mathbb{E}[T] &#x3D; 0 \quad (k &gt; 1), \quad \mathrm{Var}(T) &#x3D; \frac{k}{k - 2} \quad (k &gt; 2)<br>$$</p></li></ul><hr><h3 id="12-7-F-分布（Fisher-Distribution）"><a href="#12-7-F-分布（Fisher-Distribution）" class="headerlink" title="12.7 F 分布（Fisher Distribution）"></a>12.7 F 分布（Fisher Distribution）</h3><ul><li><p><strong>定义</strong>：$F &#x3D; \frac{(U_1&#x2F;d_1)}{(U_2&#x2F;d_2)}$，其中 $U_1 \sim \chi^2_{d_1}$，$U_2 \sim \chi^2_{d_2}$</p></li><li><p><strong>期望</strong>（$d_2 &gt; 2$）：</p><p>$$<br>\mathbb{E}[F] &#x3D; \frac{d_2}{d_2 - 2}<br>$$</p></li></ul><h2 id="13-常见离散型概率分布（含重要性质）"><a href="#13-常见离散型概率分布（含重要性质）" class="headerlink" title="13. 常见离散型概率分布（含重要性质）"></a>13. 常见离散型概率分布（含重要性质）</h2><h3 id="13-1-伯努利分布（Bernoulli-Distribution）"><a href="#13-1-伯努利分布（Bernoulli-Distribution）" class="headerlink" title="13.1. 伯努利分布（Bernoulli Distribution）"></a>13.1. 伯努利分布（Bernoulli Distribution）</h3><p><strong>定义</strong>：表示一次只有“成功”（1）或“失败”（0）两种结果的随机试验。</p><p><strong>参数</strong>：$p \in [0, 1]$（成功的概率）</p><p><strong>概率质量函数（PMF）</strong>：</p><p>$$<br>P(X &#x3D; x) &#x3D; p^x (1 - p)^{1 - x}, \quad x \in {0, 1}<br>$$</p><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; p<br>$$</p><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; p(1 - p)<br>$$</p><p><strong>性质</strong>：</p><ul><li>伯努利分布是二项分布 $B(n, p)$ 在 $n&#x3D;1$ 情况下的特例。</li></ul><hr><h3 id="13-2-二项分布（Binomial-Distribution）"><a href="#13-2-二项分布（Binomial-Distribution）" class="headerlink" title="13.2. 二项分布（Binomial Distribution）"></a>13.2. 二项分布（Binomial Distribution）</h3><p><strong>定义</strong>：$n$ 次独立的伯努利试验中成功的次数。</p><p><strong>参数</strong>：$n \in \mathbb{N}$，$p \in [0, 1]$</p><p><strong>概率质量函数</strong>：</p><p>$$<br>P(X &#x3D; k) &#x3D; \binom{n}{k} p^k (1 - p)^{n - k}, \quad k &#x3D; 0, 1, \dots, n<br>$$</p><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; np<br>$$</p><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; np(1 - p)<br>$$</p><p><strong>性质</strong>：</p><ul><li>当 $n \to \infty$, $p \to 0$ 且 $np &#x3D; \lambda$ 保持常数时，二项分布趋近于泊松分布 $P(\lambda)$。</li></ul><hr><h3 id="13-3-几何分布（Geometric-Distribution）"><a href="#13-3-几何分布（Geometric-Distribution）" class="headerlink" title="13.3. 几何分布（Geometric Distribution）"></a>13.3. 几何分布（Geometric Distribution）</h3><p><strong>定义</strong>：第一次成功出现前失败的次数。</p><p><strong>参数</strong>：$p \in (0, 1]$</p><p><strong>概率质量函数（失败次数版）</strong>：</p><p>$$<br>P(X &#x3D; k) &#x3D; (1 - p)^k p, \quad k &#x3D; 0, 1, 2, \dots<br>$$</p><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \frac{1 - p}{p}<br>$$</p><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \frac{1 - p}{p^2}<br>$$</p><p><strong>性质</strong>：</p><ul><li><p>几何分布具有 <strong>无记忆性（memoryless）</strong>：</p><p>$$<br>P(X &gt; m + n \mid X &gt; m) &#x3D; P(X &gt; n)<br>$$</p></li></ul><hr><h3 id="13-4-负二项分布（Negative-Binomial-Distribution）"><a href="#13-4-负二项分布（Negative-Binomial-Distribution）" class="headerlink" title="13.4. 负二项分布（Negative Binomial Distribution）"></a>13.4. 负二项分布（Negative Binomial Distribution）</h3><p><strong>定义</strong>：第 $r$ 次成功出现前的失败次数。</p><p><strong>参数</strong>：$r \in \mathbb{N}$，$p \in (0, 1)$</p><p><strong>概率质量函数</strong>：</p><p>$$<br>P(X &#x3D; k) &#x3D; \binom{k + r - 1}{k} (1 - p)^k p^r, \quad k &#x3D; 0, 1, 2, \dots<br>$$</p><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \frac{r(1 - p)}{p}<br>$$</p><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \frac{r(1 - p)}{p^2}<br>$$</p><p><strong>性质</strong>：</p><ul><li>负二项分布是几何分布的推广，几何分布是 $r &#x3D; 1$ 的特例。</li></ul><hr><h3 id="13-5-超几何分布（Hypergeometric-Distribution）"><a href="#13-5-超几何分布（Hypergeometric-Distribution）" class="headerlink" title="13.5. 超几何分布（Hypergeometric Distribution）"></a>13.5. 超几何分布（Hypergeometric Distribution）</h3><p><strong>定义</strong>：从 $N$ 个物品中抽取 $n$ 个，其中 $K$ 个为成功，$X$ 表示抽到成功的个数。</p><p><strong>参数</strong>：$N$（总体大小），$K$（成功元素个数），$n$（抽样数）</p><p><strong>概率质量函数</strong>：</p><p>$$<br>P(X &#x3D; k) &#x3D; \frac{\binom{K}{k} \binom{N - K}{n - k}}{\binom{N}{n}}, \quad \max(0, n - N + K) \leq k \leq \min(n, K)<br>$$</p><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; n \cdot \frac{K}{N}<br>$$</p><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; n \cdot \frac{K}{N} \cdot \left(1 - \frac{K}{N}\right) \cdot \frac{N - n}{N - 1}<br>$$</p><p><strong>性质</strong>：</p><ul><li>超几何分布是 <strong>无放回抽样</strong> 下的模型；当 $N \to \infty$ 且 $K&#x2F;N \to p$ 时，趋近于二项分布 $B(n, p)$。</li></ul><hr><h3 id="13-6-泊松分布（Poisson-Distribution）"><a href="#13-6-泊松分布（Poisson-Distribution）" class="headerlink" title="13.6. 泊松分布（Poisson Distribution）"></a>13.6. 泊松分布（Poisson Distribution）</h3><p><strong>定义</strong>：单位时间内某事件发生的次数，适用于稀疏事件。</p><p><strong>参数</strong>：$\lambda &gt; 0$（单位时间内平均发生次数）</p><p><strong>概率质量函数</strong>：</p><p>$$<br>P(X &#x3D; k) &#x3D; \frac{\lambda^k e^{-\lambda}}{k!}, \quad k &#x3D; 0, 1, 2, \dots<br>$$</p><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \lambda<br>$$</p><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \lambda<br>$$</p><p><strong>性质</strong>：</p><ul><li><p>泊松分布的多个独立随机变量之和仍服从泊松分布：</p><p>$$<br>X_1 \sim P(\lambda_1), \quad X_2 \sim P(\lambda_2) \Rightarrow X_1 + X_2 \sim P(\lambda_1 + \lambda_2)<br>$$</p></li></ul><hr><h3 id="13-7-离散均匀分布（Discrete-Uniform-Distribution）"><a href="#13-7-离散均匀分布（Discrete-Uniform-Distribution）" class="headerlink" title="13.7. 离散均匀分布（Discrete Uniform Distribution）"></a>13.7. 离散均匀分布（Discrete Uniform Distribution）</h3><p><strong>定义</strong>：在 $a, a+1, \dots, b$ 之间均匀分布的整数。</p><p><strong>参数</strong>：$a, b \in \mathbb{Z}$ 且 $a \leq b$</p><p><strong>概率质量函数</strong>：</p><p>$$<br>P(X &#x3D; k) &#x3D; \frac{1}{b - a + 1}, \quad k &#x3D; a, a+1, \dots, b<br>$$</p><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \frac{a + b}{2}<br>$$</p><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \frac{(b - a + 1)^2 - 1}{12}<br>$$</p><p><strong>性质</strong>：</p><ul><li>离散均匀分布具有最大熵（信息量）属性：在已知最小值与最大值的条件下，它是熵最大的分布。</li></ul><h2 id="14-常见连续型概率分布"><a href="#14-常见连续型概率分布" class="headerlink" title="14. 常见连续型概率分布"></a>14. 常见连续型概率分布</h2><p>连续型分布的随机变量可以取无限多个值，它的概率是通过概率密度函数（PDF）定义的。</p><p>常见的连续型分布包括：</p><h3 id="14-1-均匀分布（Uniform-Distribution）"><a href="#14-1-均匀分布（Uniform-Distribution）" class="headerlink" title="14.1. 均匀分布（Uniform Distribution）"></a>14.1. 均匀分布（Uniform Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in [a, b]$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \begin{cases}<br>\dfrac{1}{b - a}, &amp; a \le x \le b \\<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p></li><li><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \dfrac{a + b}{2}<br>$$</p></li><li><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \dfrac{(b - a)^2}{12}<br>$$</p></li><li><p><strong>性质补充</strong>：所有区间等可能，呈现“完全不偏”状态。</p></li></ul><hr><h3 id="14-2-正态分布（Normal-Distribution）"><a href="#14-2-正态分布（Normal-Distribution）" class="headerlink" title="14.2. 正态分布（Normal Distribution）"></a>14.2. 正态分布（Normal Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in (-\infty, +\infty)$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \dfrac{1}{\sqrt{2\pi\sigma^2}} \exp\left( -\dfrac{(x - \mu)^2}{2\sigma^2} \right)<br>$$</p></li><li><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \mu<br>$$</p></li><li><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \sigma^2<br>$$</p></li><li><p><strong>性质补充</strong>：具有对称性；中心极限定理的核心；标准正态分布是 $\mu &#x3D; 0,\ \sigma^2 &#x3D; 1$。</p></li></ul><p>🧠 正态分布的<strong>独立可加性</strong>性质（Additivity）</p><p>✅ 性质描述：</p><p>如果 $X_1, X_2, \dots, X_n$ 是 <strong>相互独立</strong> 且都服从正态分布的随机变量，即：</p><p>$$<br>X_i \sim \mathcal{N}(\mu_i, \sigma_i^2),\quad i &#x3D; 1, 2, \dots, n<br>$$</p><p>那么它们的<strong>加和</strong>：</p><p>$$<br>S_n &#x3D; X_1 + X_2 + \dots + X_n<br>$$</p><p>也服从正态分布：</p><p>$$<br>S_n \sim \mathcal{N}(\mu_1 + \mu_2 + \dots + \mu_n,\ \sigma_1^2 + \sigma_2^2 + \dots + \sigma_n^2)<br>$$</p><p>换句话说：</p><blockquote><p>✅ <strong>正态分布的独立线性组合仍然服从正态分布</strong>！</p></blockquote><p>📌 举个例子：</p><p>假设：</p><ul><li>$X_1 \sim \mathcal{N}(3, 4)$</li><li>$X_2 \sim \mathcal{N}(1, 9)$</li><li>且 $X_1$ 和 $X_2$ 相互独立</li></ul><p>那么：</p><p>$$<br>X_1 + X_2 \sim \mathcal{N}(3 + 1,\ 4 + 9) &#x3D; \mathcal{N}(4,\ 13)<br>$$</p><p>📌 更一般地说：</p><p>对任意实数常数 $a, b$，如果 $X \sim \mathcal{N}(\mu_X, \sigma_X^2)$，$Y \sim \mathcal{N}(\mu_Y, \sigma_Y^2)$ 且 $X, Y$ 独立，</p><p>那么线性组合 $Z &#x3D; aX + bY$ 也服从正态分布：</p><p>$$<br>Z \sim \mathcal{N}(a\mu_X + b\mu_Y,\ a^2\sigma_X^2 + b^2\sigma_Y^2)<br>$$</p><p>❗ 注意事项：</p><ul><li>独立性是<strong>必要条件</strong>。如果 $X_i$ 之间有相关性，加和不一定服从正态分布。</li><li>即使是不同参数的正态分布，加和仍然是正态的，只要它们是独立的。</li></ul><p>📖 为什么重要？</p><ol><li><strong>正态分布封闭性</strong>：这是正态分布的“封闭性”之一（加法下封闭），其他常见分布（如指数、卡方）都<strong>不具有这个性质</strong>。</li><li><strong>中心极限定理基础</strong>：虽然中心极限定理适用于很多分布，但在正态分布的情形下，加和就<strong>精确地</strong>是正态分布，而不是近似。</li><li><strong>在统计中的广泛应用</strong>：例如，样本均值、误差项建模、线性回归等，都是利用这个性质。</li></ol><hr><h3 id="14-3-指数分布（Exponential-Distribution）"><a href="#14-3-指数分布（Exponential-Distribution）" class="headerlink" title="14.3. 指数分布（Exponential Distribution）"></a>14.3. 指数分布（Exponential Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in [0, +\infty)$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \lambda e^{-\lambda x},\quad \lambda &gt; 0<br>$$</p></li><li><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \dfrac{1}{\lambda}<br>$$</p></li><li><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \dfrac{1}{\lambda^2}<br>$$</p></li><li><p><strong>性质补充</strong>：具有无记忆性：$P(X &gt; s + t \mid X &gt; s) &#x3D; P(X &gt; t)$</p></li></ul><hr><h3 id="14-4-伽马分布（Gamma-Distribution）"><a href="#14-4-伽马分布（Gamma-Distribution）" class="headerlink" title="14.4. 伽马分布（Gamma Distribution）"></a>14.4. 伽马分布（Gamma Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in [0, +\infty)$</p></li><li><p><strong>概率密度函数</strong>（形状参数 $k$，率参数 $\lambda$）：</p><p>$$<br>f(x) &#x3D; \dfrac{\lambda^k}{\Gamma(k)} x^{k-1} e^{-\lambda x},\quad x &gt; 0<br>$$</p></li><li><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \dfrac{k}{\lambda}<br>$$</p></li><li><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \dfrac{k}{\lambda^2}<br>$$</p></li><li><p><strong>性质补充</strong>：$k &#x3D; 1$ 时退化为指数分布。</p></li></ul><hr><h3 id="14-5-卡方分布（Chi-Square-Distribution）"><a href="#14-5-卡方分布（Chi-Square-Distribution）" class="headerlink" title="14.5. 卡方分布（Chi-Square Distribution）"></a>14.5. 卡方分布（Chi-Square Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in [0, +\infty)$</p></li><li><p><strong>参数</strong>：自由度 $k$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \dfrac{1}{2^{k&#x2F;2}\Gamma(k&#x2F;2)} x^{k&#x2F;2 - 1} e^{-x&#x2F;2}<br>$$</p></li><li><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; k<br>$$</p></li><li><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; 2k<br>$$</p></li><li><p><strong>性质补充</strong>：是 $k$ 个标准正态分布平方和；用于假设检验中。</p></li></ul><hr><h3 id="14-6-贝塔分布（Beta-Distribution）"><a href="#14-6-贝塔分布（Beta-Distribution）" class="headerlink" title="14.6. 贝塔分布（Beta Distribution）"></a>14.6. 贝塔分布（Beta Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in [0, 1]$</p></li><li><p><strong>参数</strong>：$\alpha, \beta &gt; 0$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \dfrac{x^{\alpha - 1}(1 - x)^{\beta - 1}}{B(\alpha, \beta)}<br>$$</p><p>其中 $B(\alpha, \beta)$ 是贝塔函数：</p><p>$$<br>B(\alpha, \beta) &#x3D; \dfrac{\Gamma(\alpha)\Gamma(\beta)}{\Gamma(\alpha + \beta)}<br>$$</p></li><li><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; \dfrac{\alpha}{\alpha + \beta}<br>$$</p></li><li><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \dfrac{\alpha\beta}{(\alpha + \beta)^2(\alpha + \beta + 1)}<br>$$</p></li><li><p><strong>性质补充</strong>：广泛用于贝叶斯推断中表示概率分布的先验。</p></li></ul><hr><h3 id="14-7-柯西分布（Cauchy-Distribution）"><a href="#14-7-柯西分布（Cauchy-Distribution）" class="headerlink" title="14.7. 柯西分布（Cauchy Distribution）"></a>14.7. 柯西分布（Cauchy Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in (-\infty, +\infty)$</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \dfrac{1}{\pi} \cdot \dfrac{1}{1 + x^2}<br>$$</p></li><li><p><strong>期望&#x2F;方差</strong>：均不存在</p></li><li><p><strong>性质补充</strong>：尾部非常厚，不满足大数定律。</p></li></ul><hr><h3 id="14-8-对数正态分布（Log-Normal-Distribution）"><a href="#14-8-对数正态分布（Log-Normal-Distribution）" class="headerlink" title="14.8. 对数正态分布（Log-Normal Distribution）"></a>14.8. 对数正态分布（Log-Normal Distribution）</h3><ul><li><p><strong>定义域</strong>：$x \in (0, +\infty)$</p></li><li><p><strong>定义</strong>：若 $Y &#x3D; \ln X \sim \mathcal{N}(\mu, \sigma^2)$，则 $X$ 服从对数正态分布。</p></li><li><p><strong>概率密度函数</strong>：</p><p>$$<br>f(x) &#x3D; \dfrac{1}{x\sigma\sqrt{2\pi}} \exp\left( -\dfrac{(\ln x - \mu)^2}{2\sigma^2} \right)<br>$$</p></li><li><p><strong>期望</strong>：</p><p>$$<br>\mathbb{E}[X] &#x3D; e^{\mu + \frac{\sigma^2}{2}}<br>$$</p></li><li><p><strong>方差</strong>：</p><p>$$<br>\mathrm{Var}(X) &#x3D; \left(e^{\sigma^2} - 1\right) e^{2\mu + \sigma^2}<br>$$</p></li><li><p><strong>性质补充</strong>：常见于收入分布、股票价格建模等。</p></li></ul><h2 id="15-多元随机变量及其分布"><a href="#15-多元随机变量及其分布" class="headerlink" title="15. 多元随机变量及其分布"></a>15. 多元随机变量及其分布</h2><p>多元随机变量是由多个单一随机变量组成的向量，用于描述多个变量之间的联合行为。</p><h3 id="15-1-多元随机变量定义"><a href="#15-1-多元随机变量定义" class="headerlink" title="15.1. 多元随机变量定义"></a>15.1. 多元随机变量定义</h3><p>设有 $n$ 个随机变量 $X_1, X_2, \dots, X_n$，我们定义一个<strong>多元随机变量（Random Vector）</strong>：</p><p>$$<br>\mathbf{X} &#x3D; \begin{bmatrix} X_1 \\ X_2 \\ \vdots \\ X_n \end{bmatrix}<br>$$</p><p>若每个 $X_i$ 都是连续型随机变量，则称 $\mathbf{X}$ 是<strong>多元连续型随机变量</strong>。</p><h3 id="15-2-联合分布函数（Joint-Distribution-Function）"><a href="#15-2-联合分布函数（Joint-Distribution-Function）" class="headerlink" title="15.2. 联合分布函数（Joint Distribution Function）"></a>15.2. 联合分布函数（Joint Distribution Function）</h3><p>✅ 定义：</p><p>设 $(X, Y)$ 是二维随机变量，其<strong>联合分布函数</strong>定义为：</p><p>$$<br>F(x, y) &#x3D; P(X \le x,\ Y \le y)<br>$$</p><p>对于更高维的 $(X_1, X_2, \dots, X_n)$：</p><p>$$<br>F(x_1, x_2, \dots, x_n) &#x3D; P(X_1 \le x_1,\ X_2 \le x_2,\ \dots,\ X_n \le x_n)<br>$$</p><hr><h4 id="15-2-1-联合分布函数的基本性质（二维情况）"><a href="#15-2-1-联合分布函数的基本性质（二维情况）" class="headerlink" title="15.2.1. 联合分布函数的基本性质（二维情况）"></a>15.2.1. 联合分布函数的基本性质（二维情况）</h4><p>设 $F(x, y) &#x3D; P(X \le x,\ Y \le y)$，则它满足以下性质：</p><ol><li><p><strong>单调性（Monotonicity）</strong>：</p><p>$$<br>x_1 \le x_2,\ y_1 \le y_2 \Rightarrow F(x_1, y_1) \le F(x_2, y_2)<br>$$</p></li><li><p><strong>有界性（Boundedness）</strong>：</p><p>$$<br>0 \le F(x, y) \le 1<br>$$</p></li><li><p><strong>右连续性（Right Continuity）</strong>：</p><p>$$<br>\lim_{h \to 0^+,\ k \to 0^+} F(x + h,\ y + k) &#x3D; F(x, y)<br>$$</p></li><li><p><strong>极限性质（Limits at Infinity）</strong>：</p><ul><li>$F(+\infty,\ +\infty) &#x3D; 1$</li><li>$F(-\infty,\ y) &#x3D; F(x,\ -\infty) &#x3D; 0$</li><li>$F(+\infty,\ y) &#x3D; P(Y \le y)$，即为 $Y$ 的边缘分布函数</li></ul></li><li><p><strong>概率计算（由 CDF 得出某区域概率）</strong>：</p><p>$$<br>P(a &lt; X \le b,\ c &lt; Y \le d) &#x3D; F(b, d) - F(a, d) - F(b, c) + F(a, c)<br>$$</p></li></ol><hr><h4 id="15-2-2-联合分布函数的非负性（在密度函数意义下）"><a href="#15-2-2-联合分布函数的非负性（在密度函数意义下）" class="headerlink" title="15.2.2. 联合分布函数的非负性（在密度函数意义下）"></a>15.2.2. 联合分布函数的非负性（在密度函数意义下）</h4><p>若 $X, Y$ 连续，存在联合密度函数 $f(x, y)$，则：</p><ul><li><p>$f(x, y) \ge 0$</p></li><li><p>联合分布函数由密度函数积分给出：</p><p>$$<br>F(x, y) &#x3D; \int_{-\infty}^x \int_{-\infty}^y f(s, t), dt, ds<br>$$</p></li></ul><hr><h3 id="15-3-联合分布列（Joint-Probability-Mass-Function-Joint-PMF）"><a href="#15-3-联合分布列（Joint-Probability-Mass-Function-Joint-PMF）" class="headerlink" title="15.3 联合分布列（Joint Probability Mass Function, Joint PMF）"></a>15.3 联合分布列（Joint Probability Mass Function, Joint PMF）</h3><p>当 $X, Y$ 为<strong>离散随机变量</strong>时，我们用<strong>联合分布列</strong>来描述它们的联合行为。</p><p>✅ 定义：</p><p>联合概率质量函数（Joint PMF）定义为：</p><p>$$<br>p(x_i, y_j) &#x3D; P(X &#x3D; x_i,\ Y &#x3D; y_j)<br>$$</p><p>所有可能的取值 $(x_i, y_j)$ 组成一个二维表格或函数，满足：</p><ol><li><p><strong>非负性</strong>：</p><p>$$<br>p(x_i, y_j) \ge 0<br>$$</p></li><li><p><strong>归一性</strong>：</p><p>$$<br>\sum_i \sum_j p(x_i, y_j) &#x3D; 1<br>$$</p></li></ol><p>📌 相关概念：</p><ul><li><p><strong>边缘分布</strong>：</p><p>$$<br>p_X(x_i) &#x3D; \sum_j p(x_i, y_j),\quad p_Y(y_j) &#x3D; \sum_i p(x_i, y_j)<br>$$</p></li><li><p><strong>条件分布</strong>：</p><p>$$<br>P(X &#x3D; x_i \mid Y &#x3D; y_j) &#x3D; \frac{p(x_i, y_j)}{p_Y(y_j)},\quad \text{若 } p_Y(y_j) &gt; 0<br>$$</p></li><li><p><strong>独立性</strong>：</p><p>若对所有 $(x_i, y_j)$ 都满足：</p><p>$$<br>p(x_i, y_j) &#x3D; p_X(x_i) \cdot p_Y(y_j)<br>$$</p><p>则 $X$ 与 $Y$ 相互独立。</p></li></ul><p>✅ 示例：联合分布列表格（X, Y 为离散）</p><table><thead><tr><th>$Y \backslash X$</th><th>$x_1$</th><th>$x_2$</th><th>$x_3$</th></tr></thead><tbody><tr><td>$y_1$</td><td>0.1</td><td>0.2</td><td>0.1</td></tr><tr><td>$y_2$</td><td>0.1</td><td>0.3</td><td>0.2</td></tr></tbody></table><ul><li><p>检查归一性：$0.1 + 0.2 + 0.1 + 0.1 + 0.3 + 0.2 &#x3D; 1$</p></li><li><p>边缘分布：</p><ul><li>$p_X(x_1) &#x3D; 0.1 + 0.1 &#x3D; 0.2$</li><li>$p_Y(y_1) &#x3D; 0.1 + 0.2 + 0.1 &#x3D; 0.4$</li></ul></li></ul><h3 id="15-4-边缘分布（Marginal-Distribution）"><a href="#15-4-边缘分布（Marginal-Distribution）" class="headerlink" title="15.4. 边缘分布（Marginal Distribution）"></a>15.4. 边缘分布（Marginal Distribution）</h3><p>设 $(X, Y)$ 是二维连续型随机变量，联合密度为 $f_{X,Y}(x, y)$，则：</p><ul><li><p>$X$ 的边缘密度：</p><p>$$<br>f_X(x) &#x3D; \int_{-\infty}^{\infty} f_{X,Y}(x, y), dy<br>$$</p></li><li><p>$Y$ 的边缘密度：</p><p>$$<br>f_Y(y) &#x3D; \int_{-\infty}^{\infty} f_{X,Y}(x, y), dx<br>$$</p></li></ul><hr><h3 id="15-5-条件分布（Conditional-Distribution）"><a href="#15-5-条件分布（Conditional-Distribution）" class="headerlink" title="15.5. 条件分布（Conditional Distribution）"></a>15.5. 条件分布（Conditional Distribution）</h3><p>条件密度函数：</p><p>二维情形下，$X$ 在给定 $Y &#x3D; y$ 条件下的密度函数为：</p><p>$$<br>f_{X \mid Y}(x \mid y) &#x3D; \frac{f_{X,Y}(x, y)}{f_Y(y)}<br>$$</p><p>前提是 $f_Y(y) &gt; 0$。</p><hr><h3 id="15-6-独立性"><a href="#15-6-独立性" class="headerlink" title="15.6. 独立性"></a>15.6. 独立性</h3><p>如果：</p><p>$$<br>f_{X,Y}(x, y) &#x3D; f_X(x) \cdot f_Y(y)<br>$$</p><p>则 $X$ 和 $Y$ <strong>相互独立</strong>。</p><p>更一般地，$X_1, \dots, X_n$ 彼此独立，当且仅当：</p><p>$$<br>f_{X_1, \dots, X_n}(x_1, \dots, x_n) &#x3D; \prod_{i&#x3D;1}^n f_{X_i}(x_i)<br>$$</p><hr><h3 id="15-7-协方差与相关系数（Covariance-and-Correlation）"><a href="#15-7-协方差与相关系数（Covariance-and-Correlation）" class="headerlink" title="15.7. 协方差与相关系数（Covariance and Correlation）"></a>15.7. 协方差与相关系数（Covariance and Correlation）</h3><ul><li><p><strong>协方差</strong>：</p><p>对 $(X, Y)$：</p><p>$$<br>\mathrm{Cov}(X, Y) &#x3D; \mathbb{E}[(X - \mu_X)(Y - \mu_Y)] &#x3D; \mathbb{E}[XY] - \mathbb{E}[X] \mathbb{E}[Y]<br>$$</p></li><li><p><strong>相关系数</strong>：</p><p>$$<br>\rho_{X,Y} &#x3D; \frac{\mathrm{Cov}(X, Y)}{\sigma_X \sigma_Y}<br>$$</p><p>$\rho$ 范围为 $[-1, 1]$，$\rho &#x3D; 0$ 不代表独立。</p></li></ul><hr><h3 id="15-8-协方差矩阵（Covariance-Matrix）"><a href="#15-8-协方差矩阵（Covariance-Matrix）" class="headerlink" title="15.8. 协方差矩阵（Covariance Matrix）"></a>15.8. 协方差矩阵（Covariance Matrix）</h3><p>若 $\mathbf{X} &#x3D; [X_1, X_2, \dots, X_n]^\top$，定义其协方差矩阵为：</p><p>$$<br>\Sigma &#x3D; \mathrm{Cov}(\mathbf{X}) &#x3D; \mathbb{E}[(\mathbf{X} - \mu)(\mathbf{X} - \mu)^\top]<br>$$</p><p>其元素为：</p><p>$$<br>\Sigma_{ij} &#x3D; \mathrm{Cov}(X_i, X_j)<br>$$</p><hr><h3 id="15-9-多元正态分布（Multivariate-Normal-Distribution）"><a href="#15-9-多元正态分布（Multivariate-Normal-Distribution）" class="headerlink" title="15.9. 多元正态分布（Multivariate Normal Distribution）"></a>15.9. 多元正态分布（Multivariate Normal Distribution）</h3><p>定义：</p><p>随机向量 $\mathbf{X} \in \mathbb{R}^n$ 服从<strong>多元正态分布</strong>，记作：</p><p>$$<br>\mathbf{X} \sim \mathcal{N}(\mu, \Sigma)<br>$$</p><p>其中：</p><ul><li>$\mu$ 是均值向量</li><li>$\Sigma$ 是协方差矩阵（对称正定）</li></ul><p>密度函数：</p><p>$$<br>f(\mathbf{x}) &#x3D; \frac{1}{(2\pi)^{n&#x2F;2}|\Sigma|^{1&#x2F;2}} \exp\left( -\frac{1}{2}(\mathbf{x} - \mu)^\top \Sigma^{-1} (\mathbf{x} - \mu) \right)<br>$$</p><p>性质：</p><ul><li>多元正态分布的<strong>任意线性组合仍是正态分布</strong></li><li>边缘分布仍为正态</li><li>条件分布仍为正态</li></ul><h2 id="16-联合密度函数（Joint-Probability-Density-Function）"><a href="#16-联合密度函数（Joint-Probability-Density-Function）" class="headerlink" title="16. 联合密度函数（Joint Probability Density Function）"></a>16. 联合密度函数（Joint Probability Density Function）</h2><h3 id="16-1-定义"><a href="#16-1-定义" class="headerlink" title="16.1. 定义"></a>16.1. 定义</h3><p>设 $(X, Y)$ 是二维连续型随机变量，如果存在函数 $f(x, y)$ 满足：</p><p>$$<br>P((X, Y) \in A) &#x3D; \iint_A f(x, y), dx, dy<br>$$</p><p>则称 $f(x, y)$ 是 $(X, Y)$ 的 <strong>联合概率密度函数（joint PDF）</strong>。</p><hr><h3 id="16-2-条件（必须满足）"><a href="#16-2-条件（必须满足）" class="headerlink" title="16.2. 条件（必须满足）"></a>16.2. 条件（必须满足）</h3><ul><li>$f(x, y) \ge 0$</li><li>$\iint_{\mathbb{R}^2} f(x, y), dx, dy &#x3D; 1$</li></ul><hr><h3 id="16-3-与联合分布函数的关系"><a href="#16-3-与联合分布函数的关系" class="headerlink" title="16.3. 与联合分布函数的关系"></a>16.3. 与联合分布函数的关系</h3><p>若 $F(x, y)$ 是 $(X, Y)$ 的<strong>联合分布函数</strong>，则：</p><p>$$<br>f(x, y) &#x3D; \frac{\partial^2 F(x, y)}{\partial x , \partial y}<br>$$</p><p>反过来，联合分布函数也可以通过密度函数积分得出：</p><p>$$<br>F(x, y) &#x3D; \int_{-\infty}^x \int_{-\infty}^y f(s, t), dt, ds<br>$$</p><hr><h3 id="16-4-联合密度函数的重要性质与推导"><a href="#16-4-联合密度函数的重要性质与推导" class="headerlink" title="16.4. 联合密度函数的重要性质与推导"></a>16.4. 联合密度函数的重要性质与推导</h3><p>性质 1：非负性（Non-negativity）</p><p>$$<br>f(x, y) \ge 0,\quad \forall (x, y)<br>$$</p><p><strong>解释</strong>：这是概率的基本性质，密度函数不能为负值。</p><hr><p>性质 2：归一性（Normalization）</p><p>$$<br>\iint_{\mathbb{R}^2} f(x, y), dx, dy &#x3D; 1<br>$$</p><p><strong>推导说明</strong>：</p><p>这是联合随机变量在整个二维平面上的总概率，必须为 1。</p><hr><p>性质 3：边缘密度（Marginal Density）</p><p>通过积分“消去”一个变量来获得边缘密度函数：</p><ul><li><p>$X$ 的边缘密度函数：</p><p>$$<br>f_X(x) &#x3D; \int_{-\infty}^{+\infty} f(x, y), dy<br>$$</p></li><li><p>$Y$ 的边缘密度函数：</p><p>$$<br>f_Y(y) &#x3D; \int_{-\infty}^{+\infty} f(x, y), dx<br>$$</p></li></ul><p><strong>推导说明</strong>：</p><p>$$<br>f_X(x) &#x3D; \frac{d}{dx} P(X \le x) &#x3D; \frac{d}{dx} \left( \int_{-\infty}^x \int_{-\infty}^{\infty} f(s, t), dt, ds \right)<br>&#x3D; \int_{-\infty}^{\infty} f(x, y), dy<br>$$</p><hr><p>性质 4：概率计算公式</p><p>对于任意矩形区域：</p><p>$$<br>P(a &lt; X \le b,\ c &lt; Y \le d) &#x3D; \int_a^b \int_c^d f(x, y), dy, dx<br>$$</p><hr><p>性质 5：独立性的充要条件</p><p>随机变量 $X$ 和 $Y$ 独立 <strong>当且仅当</strong>：</p><p>$$<br>f(x, y) &#x3D; f_X(x) \cdot f_Y(y)<br>$$</p><hr><p>性质 6：条件密度函数（Conditional Density）</p><ul><li><p>条件密度 $X \mid Y &#x3D; y$：</p><p>$$<br>f_{X \mid Y}(x \mid y) &#x3D; \frac{f(x, y)}{f_Y(y)},\quad f_Y(y) &gt; 0<br>$$</p></li><li><p>条件密度 $Y \mid X &#x3D; x$：</p><p>$$<br>f_{Y \mid X}(y \mid x) &#x3D; \frac{f(x, y)}{f_X(x)},\quad f_X(x) &gt; 0<br>$$</p></li></ul><hr><h3 id="16-5-推导实例：边缘密度和条件密度"><a href="#16-5-推导实例：边缘密度和条件密度" class="headerlink" title="16.5. 推导实例：边缘密度和条件密度"></a>16.5. 推导实例：边缘密度和条件密度</h3><p>已知联合密度函数：</p><p>$$<br>f(x, y) &#x3D; \begin{cases}<br>6xy, &amp; 0 &lt; x &lt; 1,\ 0 &lt; y &lt; 1,\ x + y &lt; 1 \\<br>0, &amp; \text{otherwise}<br>\end{cases}<br>$$</p><p>步骤 1：验证是否为联合密度函数</p><p>我们要验证归一性：</p><p>$$<br>\iint_{D} f(x, y), dx, dy &#x3D; \int_0^1 \int_0^{1 - x} 6xy, dy, dx<br>$$</p><p>先对 $y$ 积分：</p><p>$$<br>\int_0^{1 - x} 6xy, dy &#x3D; 6x \cdot \int_0^{1 - x} y, dy &#x3D; 6x \cdot \left[ \frac{y^2}{2} \right]_0^{1 - x}<br>&#x3D; 6x \cdot \frac{(1 - x)^2}{2}<br>$$</p><p>再对 $x$ 积分：</p><p>$$<br>\int_0^1 3x(1 - x)^2, dx &#x3D; 3 \int_0^1 x(1 - 2x + x^2), dx<br>&#x3D; 3 \int_0^1 (x - 2x^2 + x^3), dx<br>&#x3D; 3 \left[ \frac{x^2}{2} - \frac{2x^3}{3} + \frac{x^4}{4} \right]_0^1<br>$$</p><p>计算：</p><p>$$<br>3 \left( \frac{1}{2} - \frac{2}{3} + \frac{1}{4} \right) &#x3D; 3 \cdot \left( \frac{6 - 8 + 3}{12} \right) &#x3D; 3 \cdot \frac{1}{12} &#x3D; \frac{1}{4}<br>$$</p><p>❌ 所以 <strong>不满足归一性</strong>，我们应将 $f(x, y)$ 调整为：</p><p>$$<br>f(x, y) &#x3D; \frac{6xy}{1&#x2F;4} &#x3D; 24xy<br>$$</p><p>使得积分为 1。</p>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Probability Theory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>한국어 어휘</title>
    <link href="/2025/03/28/%ED%95%9C%EA%B5%AD%EC%96%B4-%EC%96%B4%ED%9C%98/"/>
    <url>/2025/03/28/%ED%95%9C%EA%B5%AD%EC%96%B4-%EC%96%B4%ED%9C%98/</url>
    
    <content type="html"><![CDATA[<p>이 세상은 나에게 국연수를 빚지고 있다.</p><p>우리는 더 먼 곳에서 다시 만나게 될 거예요.</p><p>과일</p>]]></content>
    
    
    <categories>
      
      <category>韩语学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>한국어</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Calculus</title>
    <link href="/2025/02/21/Calculus/"/>
    <url>/2025/02/21/Calculus/</url>
    
    <content type="html"><![CDATA[<h1 id="Calculus"><a href="#Calculus" class="headerlink" title="Calculus"></a>Calculus</h1><p>本篇微积分内容主要回顾一些重要结论的推导证明，全文没有严格上下文关系。</p><blockquote><p>绘图我是实在肝不动了…索性用个草图好了，将个烂就</p></blockquote><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-三角函数"><a href="#1-三角函数" class="headerlink" title="1. 三角函数"></a>1. 三角函数</h2><p>三角函数涉及到三角换元，反函数图像，积化和差公式等等..</p><h3 id="1-1-三角换元"><a href="#1-1-三角换元" class="headerlink" title="1.1 三角换元"></a>1.1 三角换元</h3><ul><li>正割：</li></ul><p>$$<br>\sec x &#x3D; \frac{1}{\cos x}<br>$$</p><ul><li>余割：</li></ul><p>$$<br>\csc x &#x3D; \frac{1}{\sin x}<br>$$</p><ul><li>常见换元：</li></ul><p>$$<br>\begin{cases}<br>\sin^2 x + \cos^2 x &#x3D; 1 \\<br>1 + \tan^2 x &#x3D; \sec^2 &#x3D; \frac{1}{\cos^2}<br>\end{cases}<br>$$</p><h3 id="1-2-反三角函数"><a href="#1-2-反三角函数" class="headerlink" title="1.2 反三角函数"></a>1.2 反三角函数</h3><p>这里我觉得认识图像非常重要，当然还有后面的反三角函数求导，这里暂不做讲解。</p><h4 id="1-2-1-反正弦函数（arcsin-x-）"><a href="#1-2-1-反正弦函数（arcsin-x-）" class="headerlink" title="1.2.1 反正弦函数（arcsin(x)）"></a>1.2.1 反正弦函数（arcsin(x)）</h4><p>反正弦函数，记作 $\arcsin(x)$，是正弦函数的反函数。它的定义域为 $[-1, 1]$，值域为 $[-\frac{\pi}{2}, \frac{\pi}{2}]$。即对于任意 $y &#x3D; \arcsin(x)$，有：</p><p>$$<br>\sin(y) &#x3D; x, \quad y \in \left[-\frac{\pi}{2}, \frac{\pi}{2}\right]<br>$$</p><h4 id="1-2-2-反余弦函数（arccos-x-）"><a href="#1-2-2-反余弦函数（arccos-x-）" class="headerlink" title="1.2.2 反余弦函数（arccos(x)）"></a>1.2.2 反余弦函数（arccos(x)）</h4><p>反余弦函数，记作 $\arccos(x)$，是余弦函数的反函数。它的定义域为 $[-1, 1]$，值域为 $[0, \pi]$。即对于任意 $y &#x3D; \arccos(x)$，有：</p><p>$$<br>\cos(y) &#x3D; x, \quad y \in [0, \pi]<br>$$</p><h4 id="1-2-3-反正切函数（arctan-x-）"><a href="#1-2-3-反正切函数（arctan-x-）" class="headerlink" title="1.2.3 反正切函数（arctan(x)）"></a>1.2.3 反正切函数（arctan(x)）</h4><p>反正切函数，记作 $\arctan(x)$，是正切函数的反函数。它的定义域为 $(-\infty, +\infty)$，值域为 $(-\frac{\pi}{2}, \frac{\pi}{2})$。即对于任意 $y &#x3D; \arctan(x)$，有：</p><p>$$<br>\tan(y) &#x3D; x, \quad y \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><img src="/img/Calculus/arcsin.jpg" alt="反三角函数" style="max-width: 100%; height: auto;" /><h3 id="1-3-积化和差公式"><a href="#1-3-积化和差公式" class="headerlink" title="1.3 积化和差公式"></a>1.3 积化和差公式</h3><p>$$<br>\sin(x \pm y) &#x3D; \sin(x)\cos(y) \pm \cos(x)\sin(y)<br>$$</p><p>$$<br>\cos(x \pm y) &#x3D; \cos(x)\cos(y) \mp \sin(x)\sin(y)<br>$$</p><p>$$<br>\tan(x \pm y) &#x3D; \frac{\tan(x) \pm \tan(y)}{1 \mp \tan(x)\tan(y)}<br>$$</p><p>$$<br>\sin(x) \cos(y) &#x3D; \frac{1}{2} \left[ \sin(x + y) + \sin(x - y) \right]<br>$$</p><p>$$<br>\cos(x) \sin(y) &#x3D; \frac{1}{2} \left[ \sin(x + y) - \sin(x - y) \right]<br>$$</p><p>$$<br>\cos(x) \cos(y) &#x3D; \frac{1}{2} \left[ \cos(x + y) + \cos(x - y) \right]<br>$$</p><p>$$<br>\sin(x) \sin(y) &#x3D; \frac{1}{2} \left[ \cos(x - y) - \cos(x + y) \right]<br>$$</p><h3 id="1-4-倍角-半角公式"><a href="#1-4-倍角-半角公式" class="headerlink" title="1.4 倍角&#x2F;半角公式"></a>1.4 倍角&#x2F;半角公式</h3><p>$$<br>\sin(2x) &#x3D; 2 \sin(x) \cos(x)<br>$$</p><p>$$<br>\cos(2x) &#x3D; \cos^2(x) - \sin^2(x) &#x3D; 2\cos^2(x) - 1 &#x3D; 1 - 2\sin^2(x)<br>$$</p><p>$$<br>\tan(2x) &#x3D; \frac{2\tan(x)}{1 - \tan^2(x)}<br>$$</p><p>$$<br>\sin\left(\frac{x}{2}\right) &#x3D; \pm \sqrt{\frac{1 - \cos(x)}{2}}<br>$$</p><p>$$<br>\cos\left(\frac{x}{2}\right) &#x3D; \pm \sqrt{\frac{1 + \cos(x)}{2}}<br>$$</p><p>$$<br>\tan\left(\frac{x}{2}\right) &#x3D; \pm \sqrt{\frac{1 - \cos(x)}{1 + \cos(x)}} &#x3D; \frac{\sin(x)}{1 + \cos(x)} &#x3D; \frac{1 - \cos(x)}{\sin(x)}<br>$$</p><h3 id="1-5-万能公式"><a href="#1-5-万能公式" class="headerlink" title="1.5 万能公式"></a>1.5 万能公式</h3><p>设 $u &#x3D; \tan\left(\frac{x}{2}\right)$，则有：<br>$$<br>\sin x &#x3D; \frac{2u}{1 + u^2}, \quad x \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><p>$$<br>\cos x &#x3D; \frac{1 - u^2}{1 + u^2}, \quad x \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><p>$$<br>\tan x &#x3D; \frac{2u}{1 - u^2}, \quad x \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)<br>$$</p><h2 id="2-一元二次方程"><a href="#2-一元二次方程" class="headerlink" title="2. 一元二次方程"></a>2. 一元二次方程</h2><p>一元二次方程的标准形式是：</p><p>$$<br>ax^2 + bx + c &#x3D; 0<br>$$</p><p>其中，$a$、$b$ 和 $c$ 是常数，且 $a \neq 0$。</p><p>一元二次方程的解的存在与否可以通过判别式 $\Delta$ 来判断，判别式的表达式是：</p><p>$$<br>\Delta &#x3D; b^2 - 4ac<br>$$</p><p>根据 $\Delta$ 的值，可以判断方程的解的情况：</p><ul><li>如果 $\Delta &gt; 0$，方程有 <strong>两个不相等的实数解</strong>。</li><li>如果 $\Delta &#x3D; 0$，方程有 <strong>一个实数解</strong>，也叫做 <strong>重根</strong>。</li><li>如果 $\Delta &lt; 0$，方程没有实数解，只有 <strong>两个共轭复数解</strong>。</li></ul><p>根据判别式 $\Delta$，方程的解可以通过求根公式来表示：</p><p>$$<br>x &#x3D; \frac{-b \pm \sqrt{\Delta}}{2a}<br>$$</p><p>其中，“$\pm$”表示可以有两个解，分别是：</p><p>$$<br>x_1 &#x3D; \frac{-b + \sqrt{\Delta}}{2a}, \quad x_2 &#x3D; \frac{-b - \sqrt{\Delta}}{2a}<br>$$</p><ol><li>$\Delta &#x3D; b^2 - 4ac$ 是判别式，它决定了方程解的个数和类型。</li><li>根据 $\Delta$ 的值，分别有不同的解的情况。</li></ol><h2 id="3-等差-等比数列"><a href="#3-等差-等比数列" class="headerlink" title="3. 等差&#x2F;等比数列"></a>3. 等差&#x2F;等比数列</h2><h3 id="3-1-等差数列的相关公式"><a href="#3-1-等差数列的相关公式" class="headerlink" title="3.1 等差数列的相关公式"></a>3.1 等差数列的相关公式</h3><p>等差数列是指每一项与前一项的差都相等的数列，常常用符号 $a_n$ 表示。</p><p>假设等差数列的首项为 $a_1$，公差为 $d$，则该数列的第 $n$ 项可以表示为：</p><p>$$<br>a_n &#x3D; a_1 + (n - 1) d<br>$$</p><p><strong>求和公式：</strong> 等差数列前 $n$ 项的和可以通过以下公式计算：</p><p>$$<br>S_n &#x3D; \frac{n}{2} \left(2a_1 + (n - 1) d \right)<br>$$</p><p>或者</p><p>$$<br>S_n &#x3D; \frac{n}{2} \left(a_1 + a_n \right)<br>$$</p><p>其中，$a_n$ 是数列的第 $n$ 项。</p><p><strong>总结：</strong></p><ol><li>等差数列的第 $n$ 项公式：$a_n &#x3D; a_1 + (n - 1)d$</li><li>等差数列前 $n$ 项的和公式：$S_n &#x3D; \frac{n}{2} \left(2a_1 + (n - 1) d \right)$ 或者 $S_n &#x3D; \frac{n}{2} \left(a_1 + a_n \right)$</li></ol><hr><h3 id="3-2-等比数列的相关公式"><a href="#3-2-等比数列的相关公式" class="headerlink" title="3.2 等比数列的相关公式"></a>3.2 等比数列的相关公式</h3><p>等比数列是指每一项与前一项的比都相等的数列，常常用符号 $b_n$ 表示。</p><p>假设等比数列的首项为 $b_1$，公比为 $r$，则该数列的第 $n$ 项可以表示为：</p><p>$$<br>b_n &#x3D; b_1 r^{n-1}<br>$$</p><p><strong>求和公式：</strong> 等比数列前 $n$ 项的和可以通过以下公式计算：</p><ul><li>当 $r \neq 1$ 时，前 $n$ 项的和为：</li></ul><p>$$<br>S_n &#x3D; \frac{b_1 (1 - r^n)}{1 - r}<br>$$</p><ul><li>当 $r &#x3D; 1$ 时，前 $n$ 项的和为：</li></ul><p>$$<br>S_n &#x3D; n \cdot b_1<br>$$</p><p><strong>总结：</strong></p><ol><li>等比数列的第 $n$ 项公式：$b_n &#x3D; b_1 r^{n-1}$</li><li>等比数列前 $n$ 项的和公式（当 $r \neq 1$）：$S_n &#x3D; \frac{b_1 (1 - r^n)}{1 - r}$</li><li>等比数列前 $n$ 项的和公式（当 $r &#x3D; 1$）：$S_n &#x3D; n \cdot b_1$</li></ol><h2 id="4-二项定理-组合数"><a href="#4-二项定理-组合数" class="headerlink" title="4. 二项定理&#x2F;组合数"></a>4. 二项定理&#x2F;组合数</h2><p><strong>二项式定理</strong>是用于展开 $(a + b)^n$ 的一个公式，它可以表示为：</p><p>$$<br>(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k<br>$$</p><p>其中，$\binom{n}{k}$ 是 <strong>组合数</strong>，表示从 $n$ 个不同的元素中选取 $k$ 个元素的方式数。它的公式为：</p><p>$$<br>\binom{n}{k} &#x3D; \frac{n!}{k!(n-k)!}<br>$$</p><p><strong>组合数的性质：</strong></p><ol><li><strong>对称性：</strong></li></ol><p>$$<br>\binom{n}{k} &#x3D; \binom{n}{n-k}<br>$$</p><ol start="2"><li><strong>递推公式：</strong></li></ol><p>$$<br>\binom{n}{k} &#x3D; \binom{n-1}{k-1} + \binom{n-1}{k}<br>$$</p><ol start="3"><li><strong>边界条件：</strong></li></ol><p>$$<br>\binom{n}{0} &#x3D; 1, \quad \binom{n}{n} &#x3D; 1<br>$$</p><ol start="4"><li><strong>与阶乘的关系：</strong></li></ol><p>$$<br>\binom{n}{k} &#x3D; \frac{n!}{k!(n-k)!}<br>$$</p><p><strong>二项式展开公式的应用：</strong><br>二项式定理展开式中的每一项 $\binom{n}{k} a^{n-k} b^k$ 表示的是 $(a + b)^n$ 展开后的第 $k$ 项，其中 $\binom{n}{k}$ 是对应的组合数，它可以用来计算每一项的系数。</p><p><strong>总结：</strong></p><ul><li>二项式定理展开式：$(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k$</li><li>组合数公式：$\binom{n}{k} &#x3D; \frac{n!}{k!(n-k)!}$</li><li>组合数的一些性质：<ul><li>$\binom{n}{k} &#x3D; \binom{n}{n-k}$</li><li>$\binom{n}{k} &#x3D; \binom{n-1}{k-1} + \binom{n-1}{k}$</li><li>$\binom{n}{0} &#x3D; 1, \quad \binom{n}{n} &#x3D; 1$</li></ul></li></ul><hr><h3 id="4-1-二项定理的证明"><a href="#4-1-二项定理的证明" class="headerlink" title="4.1 二项定理的证明"></a>4.1 二项定理的证明</h3><p>二项式定理的证明可以通过<strong>数学归纳法</strong>来进行，下面是详细的证明过程：</p><p><strong>基本步骤：</strong><br>我们希望证明对于任意自然数 $n$，都有：</p><p>$$<br>(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k<br>$$</p><p>其中，$\binom{n}{k}$ 是组合数，表示从 $n$ 个元素中选出 $k$ 个元素的方法数。</p><p>1.<strong>归纳基础：</strong> $n &#x3D; 0$<br>首先，我们验证当 $n &#x3D; 0$ 时，公式是否成立：</p><p>对于 $n &#x3D; 0$：</p><p>$$<br>(a + b)^0 &#x3D; 1<br>$$</p><p>而右边的展开式为：</p><p>$$<br>\sum_{k&#x3D;0}^{0} \binom{0}{k} a^{0-k} b^k &#x3D; \binom{0}{0} a^0 b^0 &#x3D; 1<br>$$</p><p>显然，当 $n &#x3D; 0$ 时，公式成立。</p><p>2.<strong>归纳假设：</strong> 假设对于 $n &#x3D; k$ 时成立<br>假设对于某个自然数 $k$，我们有：</p><p>$$<br>(a + b)^k &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i<br>$$</p><p>我们现在需要证明对于 $n &#x3D; k+1$ 时，公式也成立。</p><p>3.<strong>归纳步骤：</strong> 证明 $n &#x3D; k+1$ 时公式成立<br>考虑 $(a + b)^{k+1}$，我们可以将其分解为：</p><p>$$<br>(a + b)^{k+1} &#x3D; (a + b)(a + b)^k<br>$$</p><p>根据归纳假设，$(a + b)^k$ 可以展开为：</p><p>$$<br>(a + b)^{k+1} &#x3D; (a + b) \left( \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i \right)<br>$$</p><p>接下来，展开右边的乘积：</p><p>$$<br>(a + b) \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i &#x3D; a \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i + b \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i<br>$$</p><p>将每项展开：</p><ol><li>第一项是：</li></ol><p>$$<br>a \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k+1-i} b^i<br>$$</p><ol start="2"><li>第二项是：</li></ol><p>$$<br>b \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^i &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^{i+1}<br>$$</p><p>为了便于合并，我们将第二个求和的指标进行变换。令 $j &#x3D; i+1$，则 $i &#x3D; j-1$，且当 $i$ 从 $0$ 到 $k$ 变化时，$j$ 从 $1$ 到 $k+1$ 变化。因此：</p><p>$$<br>\sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k-i} b^{i+1} &#x3D; \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k-(j-1)} b^j &#x3D; \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k+1-j} b^j<br>$$</p><p>现在我们可以改写为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \sum_{i&#x3D;0}^{k} \binom{k}{i} a^{k+1-i} b^i + \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k+1-j} b^j<br>$$</p><p>为了合并这两个和式，我们将第一个和式的指标也改为 $j$。对于第一个和式，当 $i &#x3D; j$，范围从 $0$ 到 $k$：</p><p>$$<br>(a + b)^{k+1} &#x3D; \sum_{j&#x3D;0}^{k} \binom{k}{j} a^{k+1-j} b^j + \sum_{j&#x3D;1}^{k+1} \binom{k}{j-1} a^{k+1-j} b^j<br>$$</p><p>注意到：</p><ol><li>在 $j&#x3D;0$ 时，只有第一个和式有贡献，为 $\binom{k}{0}a^{k+1}b^0 &#x3D; a^{k+1}$</li><li>在 $j&#x3D;k+1$ 时，只有第二个和式有贡献，为 $\binom{k}{k}a^0b^{k+1} &#x3D; b^{k+1}$</li><li>对于 $1 \leq j \leq k$，两个和式都有贡献</li></ol><p>因此，我们可以将其重写为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \binom{k}{0}a^{k+1} + \sum_{j&#x3D;1}^{k} \left( \binom{k}{j} + \binom{k}{j-1} \right) a^{k+1-j} b^j + \binom{k}{k}b^{k+1}<br>$$</p><p>根据组合数的<strong>递推关系</strong>(关键结论)：$\binom{k+1}{j} &#x3D; \binom{k}{j-1} + \binom{k}{j}$，上式可以写为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \binom{k+1}{0}a^{k+1} + \sum_{j&#x3D;1}^{k} \binom{k+1}{j} a^{k+1-j} b^j + \binom{k+1}{k+1}b^{k+1}<br>$$</p><p>这可以进一步简化为：</p><p>$$<br>(a + b)^{k+1} &#x3D; \sum_{j&#x3D;0}^{k+1} \binom{k+1}{j} a^{k+1-j} b^j<br>$$</p><p>这正是我们需要的展开式，因此，二项式定理对于 $n &#x3D; k+1$ 也成立。</p><p>4.<strong>结论</strong><br>由归纳法可知，二项式定理对所有自然数 $n$ 都成立：</p><p>$$<br>(a + b)^n &#x3D; \sum_{k&#x3D;0}^{n} \binom{n}{k} a^{n-k} b^k<br>$$</p><h2 id="5-常见等价无穷小"><a href="#5-常见等价无穷小" class="headerlink" title="5. 常见等价无穷小"></a>5. 常见等价无穷小</h2><p>在 $x \to 0$时，以下等价无穷小成立：</p><h3 id="5-1-基本等价无穷小"><a href="#5-1-基本等价无穷小" class="headerlink" title="5.1. 基本等价无穷小"></a>5.1. 基本等价无穷小</h3><p>$$ \sin x \sim x $$</p><p>$$ \tan x \sim x $$</p><p>$$ \arcsin x \sim x $$</p><p>$$ \arctan x \sim x $$</p><p>$$ 1 - \cos x \sim \frac{x^2}{2} $$</p><p>$$ x - \sin x \sim \frac{x^3}{6} $$</p><p>$$ e^x - 1 \sim x $$</p><p>$$ \ln(1 + x) \sim x $$</p><h3 id="5-2-组合与扩展"><a href="#5-2-组合与扩展" class="headerlink" title="5.2. 组合与扩展"></a>5.2. 组合与扩展</h3><p>$$ \ln(1 - x) \sim -x $$</p><p>$$ a^x - 1 \sim x \ln a \quad (a &gt; 0, a \neq 1) $$</p><p>$$ (1 + x)^a - 1 \sim ax \quad (a \text{ 为常数}) $$</p><h3 id="5-3-其他常见形式"><a href="#5-3-其他常见形式" class="headerlink" title="5.3. 其他常见形式"></a>5.3. 其他常见形式</h3><p>$$ \sqrt{1 + x} - 1 \sim \frac{x}{2} $$</p><p>$$ \frac{1}{1 + x} \sim 1 - x $$</p><h2 id="6-常见重要极限"><a href="#6-常见重要极限" class="headerlink" title="6. 常见重要极限"></a>6. 常见重要极限</h2><p>在 $x \to 0$ 时，以下极限成立：</p><h3 id="6-1-经典初等极限"><a href="#6-1-经典初等极限" class="headerlink" title="6.1. 经典初等极限"></a>6.1. 经典初等极限</h3><p>$$ \lim\limits_{x \to 0} \frac{\sin x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\tan x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\arcsin x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\arctan x}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{1 - \cos x}{x^2} &#x3D; \frac{1}{2} $$</p><h3 id="6-2-指数与对数相关极限"><a href="#6-2-指数与对数相关极限" class="headerlink" title="6.2. 指数与对数相关极限"></a>6.2. 指数与对数相关极限</h3><p>$$ \lim\limits_{x \to 0} \frac{e^x - 1}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\ln(1 + x)}{x} &#x3D; 1 $$</p><p>$$ \lim\limits_{x \to 0} \frac{\ln(1 - x)}{x} &#x3D; -1 $$</p><p>$$ \lim\limits_{x \to \infty} \left( 1 + \frac{1}{x} \right)^x &#x3D; e $$</p><p>$$ \lim\limits_{x \to 0} (1 + x)^{\frac{1}{x}} &#x3D; e $$</p><h3 id="6-3-重要无穷小极限"><a href="#6-3-重要无穷小极限" class="headerlink" title="6.3. 重要无穷小极限"></a>6.3. 重要无穷小极限</h3><p>$$ \lim\limits_{x \to 0} \frac{x - \sin x}{x^3} &#x3D; \frac{1}{6} $$</p><p>$$ \lim\limits_{x \to 0} \frac{\tan x - x}{x^3} &#x3D; \frac{1}{3} $$</p><p>$$ \lim\limits_{x \to 0} \frac{e^x - 1 - x}{x^2} &#x3D; \frac{1}{2} $$</p><p>$$ \lim\limits_{x \to 0} \frac{\ln(1 + x) - x}{x^2} &#x3D; -\frac{1}{2} $$</p><h3 id="6-4-其他重要极限"><a href="#6-4-其他重要极限" class="headerlink" title="6.4. 其他重要极限"></a>6.4. 其他重要极限</h3><p>$$ \lim\limits_{x \to 0} \left( 1 + x \right)^{\frac{1}{x}} &#x3D; e $$</p><p>$$ \lim\limits_{n \to \infty} \left( 1 + \frac{k}{n} \right)^n &#x3D; e^k, \quad k \text{ 为常数} $$</p><p>$$ \lim\limits_{x \to 0} \frac{a^x - 1}{x} &#x3D; \ln a, \quad (a &gt; 0, a \neq 1) $$</p><h2 id="7-函数连续性"><a href="#7-函数连续性" class="headerlink" title="7. 函数连续性"></a>7. 函数连续性</h2><h3 id="7-1-极限存在"><a href="#7-1-极限存在" class="headerlink" title="7.1. 极限存在"></a>7.1. 极限存在</h3><p>$$ \lim\limits_{x \to a} f(x) &#x3D; L $$</p><p>极限存在是后续所有概念的基础。当函数 $f(x)$ 在点 $a$ 的邻域内有定义，且当 $x$ 无限接近 $a$ 时，函数值能够无限接近某个确定的常数 $L$，我们称该极限存在。</p><p>极限存在的条件：</p><ul><li>左极限和右极限相等</li><li>极限值不依赖于函数在 $a$ 点的具体定义</li><li>可以通过 $\epsilon-\delta$ 语言严格定义</li></ul><h3 id="7-2-连续"><a href="#7-2-连续" class="headerlink" title="7.2. 连续"></a>7.2. 连续</h3><p>$$ \lim\limits_{x \to a} f(x) &#x3D; f(a) $$</p><p>连续是对极限的进一步要求：</p><ul><li>函数在点 $a$ 处有定义</li><li>极限存在</li><li>极限值等于函数在该点的函数值</li></ul><p>连续的类型：</p><ul><li>点连续</li><li>区间连续</li><li>一致连续</li></ul><h3 id="7-3-可导（derivative）"><a href="#7-3-可导（derivative）" class="headerlink" title="7.3. 可导（derivative）"></a>7.3. 可导（derivative）</h3><p>$$ f’(a) &#x3D; \lim\limits_{x \to a} \frac{f(x) - f(a)}{x - a} $$</p><p>可导是连续的进一步强化条件：</p><ul><li>函数在点 $a$ 处连续</li><li>函数在点 $a$ 处存在唯一的切线</li><li>导数存在，表示函数在该点的瞬时变化率</li></ul><p>可导的充要条件：</p><ul><li>左导数和右导数存在且相等</li></ul><h3 id="7-4-可微（differentiable）"><a href="#7-4-可微（differentiable）" class="headerlink" title="7.4. 可微（differentiable）"></a>7.4. 可微（differentiable）</h3><p>$$ f(x + \Delta x) &#x3D; f(x) + f’(x)\Delta x + o(\Delta x) $$</p><p>可微是可导的更强条件：</p><ul><li>函数可导</li><li>在点 $a$ 处可以用线性函数进行局部近似</li><li>误差项 $o(\Delta x)$ 是高阶无穷小</li></ul><p>可微的特点：</p><ul><li>提供了函数局部线性逼近</li><li>在微积分和泰勒展开中有重要应用</li></ul><h3 id="7-5-可偏导（partially-differentiable）"><a href="#7-5-可偏导（partially-differentiable）" class="headerlink" title="7.5. 可偏导（partially differentiable）"></a>7.5. 可偏导（partially differentiable）</h3><p>$$ \frac{\partial f}{\partial x_i} &#x3D; \lim\limits_{h \to 0} \frac{f(x_1, \ldots, x_i + h, \ldots, x_n) - f(x_1, \ldots, x_n)}{h} $$</p><p>可偏导是多变量函数的导数概念：</p><ul><li>定义在多元函数上</li><li>固定其他变量，对某一变量求导</li><li>每个自变量都存在偏导数</li></ul><p>可偏导的条件：</p><ul><li>每个方向的导数都存在</li><li>不要求所有偏导数连续</li></ul><h3 id="7-6-关系总结"><a href="#7-6-关系总结" class="headerlink" title="7.6 关系总结"></a>7.6 关系总结</h3><ol><li><p>极限存在 $\Rightarrow$ 连续</p><ul><li>极限存在是连续的必要条件</li><li>但极限存在不一定保证连续</li></ul></li><li><p>连续 $\Rightarrow$ 可导</p><ul><li>连续是可导的必要条件</li><li>但连续不一定保证可导</li></ul></li><li><p>可导 $\Rightarrow$ 可微</p><ul><li>可导是可微的必要条件</li><li>可导函数一定可微</li></ul></li><li><p>可导 $\Rightarrow$ 连续</p><ul><li>可导函数一定连续</li><li>连续是可导的必要条件</li></ul></li><li><p>多元函数的可偏导</p><ul><li>要求每个方向的导数存在</li><li>不要求偏导数连续或存在</li></ul></li></ol><p><strong>典型反例</strong></p><ul><li>$f(x) &#x3D; |x|$ 在 $x &#x3D; 0$ 处连续但不可导</li><li>$f(x) &#x3D; x \sin(\frac{1}{x})$（$x \neq 0$）在 $x &#x3D; 0$ 处极限存在但不连续</li></ul><img src="/img/Calculus/relation.svg" alt="关系总结" style="max-width: 100%; height: auto;" /><p>考虑函数：</p><p>$$<br>f(x) &#x3D; \begin{cases}<br>x \sin\left(\frac{1}{x}\right), &amp; x \ne 0 \\<br>0, &amp; x &#x3D; 0<br>\end{cases}<br>$$</p><p>我们想研究它在 $x &#x3D; 0$ 处的极限是否存在，以及是否连续。</p><p>第一步：计算 $\displaystyle \lim_{x \to 0} x \sin\left(\frac{1}{x}\right)$ 是否存在</p><p>分析：</p><ul><li>$\sin\left(\frac{1}{x}\right)$ 在 $x \to 0$ 时没有极限，因为 $\frac{1}{x}$ 趋向于无穷大，$\sin$ 在 $[-1, 1]$ 之间来回震荡，没有收敛。</li><li>但是，$x$ 趋近于 $0$，我们可以尝试<strong>夹逼准则</strong>（夹挤准则）：</li></ul><p>$$<br>\lim_{x \to 0} x \sin\left(\frac{1}{x}\right) &#x3D; 0<br>$$</p><p>第二步：分析函数在 $x &#x3D; 0$ 处是否<strong>连续</strong></p><p>连续的定义是：</p><p>$$<br>\lim_{x \to 0} f(x) &#x3D; f(0)<br>$$</p><p>我们刚才算出极限是 $0$，而题目中也定义 $f(0) &#x3D; 0$，看起来似乎是连续？</p><p>但 <strong>小心！</strong></p><p>上面我们讨论的是 $x \sin(1&#x2F;x)$ 的极限存在为 $0$，所以<strong>如果我们定义 $f(0) &#x3D; 0$，那么函数就连续</strong>！</p><p>而如果我们定义 $f(0)$ 为其它数，比如没有定义或者定义为 $1$，那函数就<strong>不连续</strong>了。</p><p><strong>那为什么有时候说这个函数“极限存在但不连续”？</strong></p><p>这是因为有时候题目只给你 $f(x) &#x3D; x \sin\left(\frac{1}{x}\right)$，<strong>但没有定义 $f(0)$<strong>，也就是说函数在 $x&#x3D;0$ 处</strong>没有定义</strong>，你只能讨论<strong>极限是否存在</strong>，不能说连续不连续。</p><p>最终结论：</p><ul><li>$f(x) &#x3D; x \sin\left(\frac{1}{x}\right)$ 的极限在 $x&#x3D;0$ 处是存在的，值为 $0$。</li><li>若定义 $f(0) &#x3D; 0$，则该函数在 $x &#x3D; 0$ 连续。</li><li>若 $f(0)$ 没定义，或者定义为不等于 0 的值，那么函数在 $x&#x3D;0$ 极限存在但不连续。</li></ul><h2 id="8-常见函数的导数"><a href="#8-常见函数的导数" class="headerlink" title="8. 常见函数的导数"></a>8. 常见函数的导数</h2><h3 id="8-1-基本初等函数的导数"><a href="#8-1-基本初等函数的导数" class="headerlink" title="8.1. 基本初等函数的导数"></a>8.1. 基本初等函数的导数</h3><p>$$ (C)’ &#x3D; 0, \quad C \text{ 为常数} $$</p><p>$$ (x^n)’ &#x3D; nx^{n-1} $$</p><p>$$ (e^x)’ &#x3D; e^x $$</p><p>$$ (\ln x)’ &#x3D; \frac{1}{x} $$</p><p>$$ (\sin x)’ &#x3D; \cos x $$</p><p>$$ (\cos x)’ &#x3D; -\sin x $$</p><p>$$ (\tan x)’ &#x3D; \sec^2 x $$</p><p>$$ (\cot x)’ &#x3D; -\csc^2 x $$</p><p>$$ (\sec x)’ &#x3D; \sec x \tan x $$</p><p>$$ (\csc x)’ &#x3D; -\csc x \cot x $$</p><h3 id="8-2-反三角函数的导数"><a href="#8-2-反三角函数的导数" class="headerlink" title="8.2. 反三角函数的导数"></a>8.2. 反三角函数的导数</h3><p>$$ (\arcsin x)’ &#x3D; \frac{1}{\sqrt{1-x^2}} $$</p><p>$$ (\arccos x)’ &#x3D; -\frac{1}{\sqrt{1-x^2}} $$</p><p>$$ (\arctan x)’ &#x3D; \frac{1}{1+x^2} $$</p><p>$$ (\text{arccot } x)’ &#x3D; -\frac{1}{1+x^2} $$</p><p>$$ (\text{arcsec } x)’ &#x3D; \frac{1}{|x|\sqrt{x^2-1}} $$</p><p>$$ (\text{arccsc } x)’ &#x3D; -\frac{1}{|x|\sqrt{x^2-1}} $$</p><h3 id="8-3-指数与对数函数的导数"><a href="#8-3-指数与对数函数的导数" class="headerlink" title="8.3. 指数与对数函数的导数"></a>8.3. 指数与对数函数的导数</h3><p>$$ (a^x)’ &#x3D; a^x \ln a, \quad (a &gt; 0, a \neq 1) $$</p><p>$$ (\log_a x)’ &#x3D; \frac{1}{x \ln a}, \quad (a &gt; 0, a \neq 1) $$</p><h3 id="8-4-复合函数、积、商的导数"><a href="#8-4-复合函数、积、商的导数" class="headerlink" title="8.4. 复合函数、积、商的导数"></a>8.4. 复合函数、积、商的导数</h3><p>$$ [f(g(x))]’ &#x3D; f’(g(x)) \cdot g’(x) $$</p><p>$$ (u \cdot v)’ &#x3D; u’ \cdot v + u \cdot v’ $$</p><p>$$ \left(\frac{u}{v}\right)’ &#x3D; \frac{u’ \cdot v - u \cdot v’}{v^2} $$</p><h3 id="8-5-双曲函数的导数"><a href="#8-5-双曲函数的导数" class="headerlink" title="8.5. 双曲函数的导数"></a>8.5. 双曲函数的导数</h3><p>$$ (\sinh x)’ &#x3D; \cosh x $$</p><p>$$ (\cosh x)’ &#x3D; \sinh x $$</p><p>$$ (\tanh x)’ &#x3D; \text{sech}^2 x $$</p><p>$$ (\coth x)’ &#x3D; -\text{csch}^2 x $$</p><p>$$ (\text{sech } x)’ &#x3D; -\text{sech } x \tanh x $$</p><p>$$ (\text{csch } x)’ &#x3D; -\text{csch } x \coth x $$</p><h2 id="9-常见不等式"><a href="#9-常见不等式" class="headerlink" title="9. 常见不等式"></a>9. 常见不等式</h2><h3 id="9-1-基本不等式"><a href="#9-1-基本不等式" class="headerlink" title="9.1. 基本不等式"></a>9.1. 基本不等式</h3><p>$$ a \geq b \Rightarrow a^n \geq b^n, \quad (a,b &gt; 0, n &gt; 0) $$</p><p>$$ |a + b| \leq |a| + |b| $$</p><p>$$ |a - b| \geq \left| |a| - |b| \right| $$</p><p>$$ \frac{a+b}{2} \geq \sqrt{ab}, \quad (a,b &gt; 0) $$</p><p>$$ \frac{a_1 + a_2 + \cdots + a_n}{n} \geq \sqrt[n]{a_1 a_2 \cdots a_n}, \quad (a_i &gt; 0) $$</p><h3 id="9-2-三角函数不等式"><a href="#9-2-三角函数不等式" class="headerlink" title="9.2. 三角函数不等式"></a>9.2. 三角函数不等式</h3><p>$$ \sin x &lt; x &lt; \tan x, \quad (0 &lt; x &lt; \frac{\pi}{2}) $$</p><p>$$ \sin x \geq \frac{2x}{\pi}, \quad (0 \leq x \leq \frac{\pi}{2}) $$</p><p>$$ \cos x \geq 1 - \frac{x^2}{2}, \quad (x \in \mathbb{R}) $$</p><p>$$ |\sin x| \leq |x|, \quad (x \in \mathbb{R}) $$</p><p>$$ 1 - \cos x \leq \frac{x^2}{2}, \quad (x \in \mathbb{R}) $$</p><h3 id="9-3-指数与对数不等式"><a href="#9-3-指数与对数不等式" class="headerlink" title="9.3. 指数与对数不等式"></a>9.3. 指数与对数不等式</h3><p>$$ e^x \geq 1 + x, \quad (x \in \mathbb{R}) $$</p><p>$$ e^x \geq 1 + x + \frac{x^2}{2}, \quad (x \geq 0) $$</p><p>$$ \ln(1+x) \leq x, \quad (x &gt; -1) $$</p><p>$$ \ln x \leq x - 1, \quad (x &gt; 0) $$</p><p>$$ x^a &lt; x^b, \quad (0 &lt; x &lt; 1, a &gt; b) $$</p><p>$$ x^a &gt; x^b, \quad (x &gt; 1, a &gt; b) $$</p><h3 id="9-4-柯西不等式与其扩展"><a href="#9-4-柯西不等式与其扩展" class="headerlink" title="9.4. 柯西不等式与其扩展"></a>9.4. 柯西不等式与其扩展</h3><p>$$ \left( \sum_{i&#x3D;1}^{n} a_i b_i \right)^2 \leq \left( \sum_{i&#x3D;1}^{n} a_i^2 \right) \left( \sum_{i&#x3D;1}^{n} b_i^2 \right) $$</p><p>$$ \left( \frac{a_1 + a_2 + \cdots + a_n}{n} \right)^2 \leq \frac{a_1^2 + a_2^2 + \cdots + a_n^2}{n} $$</p><p>$$ \frac{1}{a_1} + \frac{1}{a_2} + \cdots + \frac{1}{a_n} \geq \frac{n^2}{a_1 + a_2 + \cdots + a_n}, \quad (a_i &gt; 0) $$</p><h3 id="9-5-经典不等式"><a href="#9-5-经典不等式" class="headerlink" title="9.5. 经典不等式"></a>9.5. 经典不等式</h3><p>$$ \frac{a^n + b^n}{2} \geq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, n \geq 1) $$</p><p>$$ \frac{a^n + b^n}{2} \leq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, 0 &lt; n &lt; 1) $$</p><p>$$ a^b \cdot b^a \leq a^a \cdot b^b, \quad (a, b &gt; 0) $$</p><p>$$ \sqrt{1+x} &lt; 1 + \frac{x}{2}, \quad (x &gt; 0) $$</p><p>$$ (1+x)^n \geq 1 + nx, \quad (x &gt; -1, n &gt; 1) $$</p><h2 id="10-函数凹凸性"><a href="#10-函数凹凸性" class="headerlink" title="10. 函数凹凸性"></a>10. 函数凹凸性</h2><h3 id="10-1-函数的凹凸性定义"><a href="#10-1-函数的凹凸性定义" class="headerlink" title="10.1. 函数的凹凸性定义"></a><strong>10.1. 函数的凹凸性定义</strong></h3><ul><li><p><strong>凸函数（上凸函数）：</strong> 若函数 $f(x)$ 在区间 $I$ 内满足：</p><p>$$ f(\lambda x_1 + (1 - \lambda)x_2) \leq \lambda f(x_1) + (1 - \lambda) f(x_2), \quad (\lambda \in [0,1]) $$</p><p>则称 $f(x)$ <strong>在 $I$ 上是凸函数（Convex Function）</strong>。</p></li><li><p><strong>凹函数（下凸函数）：</strong> 若函数 $f(x)$ 在区间 $I$ 内满足：</p><p>$$ f(\lambda x_1 + (1 - \lambda)x_2) \geq \lambda f(x_1) + (1 - \lambda) f(x_2), \quad (\lambda \in [0,1]) $$</p><p>则称 $f(x)$ <strong>在 $I$ 上是凹函数（Concave Function）</strong>。</p></li></ul><p>几何上，<strong>凸函数的图像在任意两点之间的弦线之下，凹函数的图像在弦线之上。</strong></p><hr><h3 id="10-2-通过二阶导数判断凹凸性"><a href="#10-2-通过二阶导数判断凹凸性" class="headerlink" title="10.2. 通过二阶导数判断凹凸性"></a><strong>10.2. 通过二阶导数判断凹凸性</strong></h3><p>若 $f(x)$ 在区间 $I$ <strong>二阶可导</strong>，则：</p><ul><li>若 $f’’(x) &gt; 0$，则 $f(x)$ 在 $I$ <strong>上凸（凸函数）</strong>；</li><li>若 $f’’(x) &lt; 0$，则 $f(x)$ 在 $I$ <strong>下凸（凹函数）</strong>；</li><li>若 $f’’(x) &#x3D; 0$，需要进一步分析高阶导数或函数的局部行为。</li></ul><p><strong>示例：</strong></p><ul><li>$f(x) &#x3D; x^2$，二阶导数 $f’’(x) &#x3D; 2 &gt; 0$，是<strong>凸函数</strong>（向上弯曲）。</li><li>$f(x) &#x3D; -x^2$，二阶导数 $f’’(x) &#x3D; -2 &lt; 0$，是<strong>凹函数</strong>（向下弯曲）。</li></ul><img src="/img/Calculus/convex.jpg" alt="凹凸性" style="max-width: 100%; height: auto;" /><div class="note note-success">            <p>⚠️注意国内定义的凹凸性和国际上的凹凸性是反过来的…这里以国际定义为准</p>          </div><hr><h3 id="10-3-拐点（Inflection-Point）"><a href="#10-3-拐点（Inflection-Point）" class="headerlink" title="10.3. 拐点（Inflection Point）"></a><strong>10.3. 拐点（Inflection Point）</strong></h3><p>若 $f(x)$ 的二阶导数在某点 $x &#x3D; c$ 发生符号变化，即满足：</p><p>$$ f’’(c) &#x3D; 0, \quad \text{且} \quad f’’(x) \text{ 在 } c \text{ 处改变符号} $$</p><p>则称 $x &#x3D; c$ 为函数的<strong>拐点</strong>，即函数从凸变凹或从凹变凸的点。</p><p><strong>示例：</strong></p><ul><li>$f(x) &#x3D; x^3$，二阶导数 $f’’(x) &#x3D; 6x$，在 $x &#x3D; 0$ 处由负变正，因此 $x &#x3D; 0$ 是拐点。</li></ul><hr><h3 id="10-4-经典结论"><a href="#10-4-经典结论" class="headerlink" title="10.4. 经典结论"></a><strong>10.4. 经典结论</strong></h3><ol><li><strong>指数函数</strong> $f(x) &#x3D; e^x$，二阶导数 $f’’(x) &#x3D; e^x &gt; 0$，是<strong>凸函数</strong>。</li><li><strong>对数函数</strong> $f(x) &#x3D; \ln x$，二阶导数 $f’’(x) &#x3D; -\frac{1}{x^2} &lt; 0$，是<strong>凹函数</strong>。</li><li><strong>幂函数</strong> $f(x) &#x3D; x^p$：<ul><li>若 $p \geq 1$ 或 $0 &lt; p &lt; 1$，则 $f(x)$ <strong>在 $x &gt; 0$ 上是凸函数</strong>。</li><li>若 $p &lt; 0$，则 $f(x)$ <strong>在 $x &gt; 0$ 上是凹函数</strong>。</li></ul></li></ol><hr><h3 id="10-5-例题解析"><a href="#10-5-例题解析" class="headerlink" title="10.5. 例题解析"></a><strong>10.5. 例题解析</strong></h3><h4 id="例-1：判断函数-f-x-x-4-4x-3-6x-2-的凹凸性及拐点"><a href="#例-1：判断函数-f-x-x-4-4x-3-6x-2-的凹凸性及拐点" class="headerlink" title="例 1：判断函数 $f(x) &#x3D; x^4 - 4x^3 + 6x^2$ 的凹凸性及拐点"></a><strong>例 1：判断函数 $f(x) &#x3D; x^4 - 4x^3 + 6x^2$ 的凹凸性及拐点</strong></h4><p><strong>解：</strong></p><ul><li><p>一阶导数：</p><p>$$ f’(x) &#x3D; 4x^3 - 12x^2 + 12x $$</p></li><li><p>二阶导数：</p><p>$$ f’’(x) &#x3D; 12x^2 - 24x + 12 $$</p></li><li><p>令 $f’’(x) &#x3D; 0$ 求拐点：</p><p>$$ 12(x^2 - 2x + 1) &#x3D; 0 $$</p><p>$$ 12(x - 1)^2 &#x3D; 0 \Rightarrow x &#x3D; 1 $$</p></li><li><p>由于 $f’’(x)$ 在 $x &#x3D; 1$ 两侧符号没有变化，说明<strong>函数在整个定义域内都是凸的</strong>。</p></li></ul><hr><h3 id="10-6-重要不等式"><a href="#10-6-重要不等式" class="headerlink" title="10.6. 重要不等式"></a><strong>10.6. 重要不等式</strong></h3><ul><li><p><strong>Jensen 不等式（对凸函数成立）：</strong></p><p>$$ f\left(\frac{x_1 + x_2}{2}\right) \leq \frac{f(x_1) + f(x_2)}{2} $$</p><p>若 $f(x)$ 是<strong>凹函数</strong>，则不等号方向相反。</p></li><li><p><strong>均值不等式（对幂函数成立）：</strong></p><p>$$ \frac{a^n + b^n}{2} \geq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, n \geq 1) $$</p><p>$$ \frac{a^n + b^n}{2} \leq \left( \frac{a + b}{2} \right)^n, \quad (a, b &gt; 0, 0 &lt; n &lt; 1) $$</p></li><li><p><strong>指数与对数的不等式（由凹凸性推出）：</strong></p><p>$$ a^b \cdot b^a \leq a^a \cdot b^b, \quad (a, b &gt; 0) $$</p><p>$$ \sqrt{1+x} &lt; 1 + \frac{x}{2}, \quad (x &gt; 0) $$</p><p>$$ (1+x)^n \geq 1 + nx, \quad (x &gt; -1, n &gt; 1) $$</p></li></ul><hr><h3 id="10-7-总结"><a href="#10-7-总结" class="headerlink" title="10.7. 总结"></a><strong>10.7. 总结</strong></h3><ul><li><strong>凸函数</strong>满足 $f’’(x) &gt; 0$，图像向上弯曲。</li><li><strong>凹函数</strong>满足 $f’’(x) &lt; 0$，图像向下弯曲。</li><li><strong>拐点</strong>是函数从凹变凸或从凸变凹的点，满足 $f’’(x) &#x3D; 0$ 且符号发生变化。</li><li><strong>经典结论</strong>：<ul><li>$e^x$ 是凸函数</li><li>$\ln x$ 是凹函数</li><li>$x^p$ 的凹凸性取决于 $p$ 的大小</li></ul></li></ul><hr><h3 id="10-8-Jesen不等式"><a href="#10-8-Jesen不等式" class="headerlink" title="10.8. Jesen不等式"></a>10.8. Jesen不等式</h3><p><strong>Jensen不等式的基本形式</strong></p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) \leq \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为凸函数}) $$</p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) \geq \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为凹函数}) $$</p><p>$$ \text{其中} \sum_{i&#x3D;1}^n \lambda_i &#x3D; 1, \lambda_i \geq 0, i&#x3D;1,2,\ldots,n $$</p><p>等号成立当且仅当满足以下任一条件：</p><ol><li><p>$x_1 &#x3D; x_2 &#x3D; \cdots &#x3D; x_n$</p><p>即所有的 $x_i$ 都相等。</p></li><li><p>$\varphi(x) \text{ 在包含所有 } x_i \text{ 的区间上是线性函数}$ 即 $\varphi(x) &#x3D; ax + b$，其中 $a, b$ 为常数。</p></li></ol><p><strong>这两个条件可以这样理解：</strong></p><p>当所有点 $x_i$ 相同时，无论权重 $\lambda_i$ 如何分配，加权平均值都等于这个公共值，因此等号成立。</p><p>当 $\varphi(x)$ 是线性函数时，它既不是严格凸的也不是严格凹的（$\varphi’’(x) &#x3D; 0$），这种情况下，函数值的加权平均恰好等于函数在加权平均点的值，从而等号成立。</p><p>对于严格凸函数（$\varphi’’(x) &gt; 0$）或严格凹函数（$\varphi’’(x) &lt; 0$），等号成立当且仅当所有 $x_i$ 都相等。</p><hr><p><strong>连续形式的Jensen不等式</strong></p><p>$$ \varphi\left(\int_a^b f(x) g(x) dx\right) \leq \int_a^b \varphi(f(x)) g(x) dx, \quad (\varphi \text{ 为凸函数}) $$</p><p>$$ \varphi\left(\int_a^b f(x) g(x) dx\right) \geq \int_a^b \varphi(f(x)) g(x) dx, \quad (\varphi \text{ 为凹函数}) $$</p><p>$$ \text{其中} \int_a^b g(x) dx &#x3D; 1, g(x) \geq 0 $$</p><hr><p><strong>概率形式的Jensen不等式</strong></p><p>$$ \varphi(E[X]) \leq E[\varphi(X)], \quad (\varphi \text{ 为凸函数}) $$</p><p>$$ \varphi(E[X]) \geq E[\varphi(X)], \quad (\varphi \text{ 为凹函数}) $$</p><p>$$ \text{其中} E[X] \text{ 表示随机变量 } X \text{ 的期望} $$</p><hr><p><strong>典型应用案例</strong></p><p>$$ \left(\frac{a_1 + a_2 + \cdots + a_n}{n}\right)^p \leq \frac{a_1^p + a_2^p + \cdots + a_n^p}{n}, \quad (a_i &gt; 0, p &gt; 1) $$</p><p>$$ \left(\frac{a_1 + a_2 + \cdots + a_n}{n}\right)^p \geq \frac{a_1^p + a_2^p + \cdots + a_n^p}{n}, \quad (a_i &gt; 0, 0 &lt; p &lt; 1) $$</p><p>$$ \ln\left(\frac{a_1 + a_2 + \cdots + a_n}{n}\right) \geq \frac{\ln a_1 + \ln a_2 + \cdots + \ln a_n}{n}, \quad (a_i &gt; 0) $$</p><hr><p><strong>Jensen不等式的几何解释</strong></p><p>$$ \varphi(tx_1 + (1-t)x_2) \leq t\varphi(x_1) + (1-t)\varphi(x_2), \quad (0 \leq t \leq 1, \varphi \text{ 为凸函数}) $$</p><p>$$ \varphi(tx_1 + (1-t)x_2) \geq t\varphi(x_1) + (1-t)\varphi(x_2), \quad (0 \leq t \leq 1, \varphi \text{ 为凹函数}) $$</p><p>$$ \text{即凸函数图像上任意两点的连线位于图像上方，凹函数则位于图像下方} $$</p><hr><p><strong>严格不等式条件</strong></p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) &lt; \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为严格凸函数且不是所有 } x_i \text{ 都相等}) $$</p><p>$$ \varphi\left(\sum_{i&#x3D;1}^n \lambda_i x_i\right) &gt; \sum_{i&#x3D;1}^n \lambda_i \varphi(x_i), \quad (\varphi \text{ 为严格凹函数且不是所有 } x_i \text{ 都相等}) $$</p><h2 id="11-泰勒公式-麦克劳林公式"><a href="#11-泰勒公式-麦克劳林公式" class="headerlink" title="11. 泰勒公式&amp;麦克劳林公式"></a>11. 泰勒公式&amp;麦克劳林公式</h2><h3 id="11-1-泰勒公式"><a href="#11-1-泰勒公式" class="headerlink" title="11.1 泰勒公式"></a>11.1 泰勒公式</h3><p>泰勒公式是一种用多项式函数近似表示光滑函数的方法。它使我们能够在某点附近用幂级数展开函数。</p><p>假设函数 $f(x)$ 在点 $x&#x3D;a$ 的某个邻域内具有 $n+1$ 阶连续导数，那么对于该邻域内的任意点 $x$，函数 $f(x)$ 可以表示为：</p><p>$$ f(x) &#x3D; f(a) + f’(a)(x-a) + \frac{f’’(a)}{2!}(x-a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n + R_n(x) $$</p><p>其中 $R_n(x)$ 是拉格朗日余项，表示为：</p><p>$$ R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-a)^{n+1} $$</p><p>这里 $\xi$ 是介于 $a$ 和 $x$ 之间的某个值。</p><p>泰勒公式的另一种常见形式是带有皮亚诺余项：</p><p>$$ f(x) &#x3D; f(a) + f’(a)(x-a) + \frac{f’’(a)}{2!}(x-a)^2 + \cdots + \frac{f^{(n)}(a)}{n!}(x-a)^n + o((x-a)^n) $$</p><h3 id="11-2-麦克劳林公式"><a href="#11-2-麦克劳林公式" class="headerlink" title="11.2 麦克劳林公式"></a>11.2 麦克劳林公式</h3><p>麦克劳林公式是泰勒公式的特殊情况，即在点 $a&#x3D;0$ 处展开：</p><p>$$ f(x) &#x3D; f(0) + f’(0)x + \frac{f’’(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n + R_n(x) $$</p><p>其中余项 $R_n(x)$ 表示为：</p><p>$$ R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!}x^{n+1} $$</p><p>这里 $\xi$ 是介于 $0$ 和 $x$ 之间的某个值。</p><p>让我们看一个例子，计算 $\sin(0.1)$ 的近似值：</p><p>使用麦克劳林公式展开到 $x^5$ 项：<br>$$ \sin(0.1) \approx 0.1 - \frac{(0.1)^3}{3!} + \frac{(0.1)^5}{5!} $$<br>$$ \sin(0.1) \approx 0.1 - \frac{0.001}{6} + \frac{0.00001}{120} $$<br>$$ \sin(0.1) \approx 0.1 - 0.000167 + 0.000000083 \approx 0.099833 $$</p><p>实际值 $\sin(0.1) \approx 0.0998334$，所以这个近似是相当准确的。</p><h3 id="11-3-常见函数的麦克劳林展开"><a href="#11-3-常见函数的麦克劳林展开" class="headerlink" title="11.3 常见函数的麦克劳林展开"></a>11.3 常见函数的麦克劳林展开</h3><p>以下是一些常见函数的麦克劳林展开式：</p><ol><li><p>指数函数：<br>$$ e^x &#x3D; 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{x^n}{n!} $$</p></li><li><p>正弦函数：<br>$$ \sin x &#x3D; x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n+1}}{(2n+1)!} $$</p></li><li><p>余弦函数：<br>$$ \cos x &#x3D; 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n}}{(2n)!} $$</p></li><li><p>自然对数函数：<br>$$ \ln(1+x) &#x3D; x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots &#x3D; \sum_{n&#x3D;1}^{\infty} \frac{(-1)^{n+1}x^n}{n}, \quad |x| &lt; 1 $$</p></li><li><p>反正切函数：<br>$$ \arctan x &#x3D; x - \frac{x^3}{3} + \frac{x^5}{5} - \frac{x^7}{7} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n+1}}{2n+1}, \quad |x| \leq 1 $$</p></li><li><p>双曲正弦函数：<br>$$ \sinh x &#x3D; x + \frac{x^3}{3!} + \frac{x^5}{5!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{x^{2n+1}}{(2n+1)!} $$</p></li><li><p>双曲余弦函数：<br>$$ \cosh x &#x3D; 1 + \frac{x^2}{2!} + \frac{x^4}{4!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{x^{2n}}{(2n)!} $$</p></li><li><p>$(1+x)^{\alpha}$ 的二项式展开（广义二项式定理）：<br>$$ (1+x)^{\alpha} &#x3D; 1 + \alpha x + \frac{\alpha(\alpha-1)}{2!}x^2 + \frac{\alpha(\alpha-1)(\alpha-2)}{3!}x^3 + \cdots, \quad |x| &lt; 1 $$<br>$$ &#x3D; \sum_{n&#x3D;0}^{\infty} \binom{\alpha}{n} x^n, \quad |x| &lt; 1 $$<br>其中 $\binom{\alpha}{n} &#x3D; \frac{\alpha(\alpha-1)(\alpha-2)\cdots(\alpha-n+1)}{n!}$</p></li><li><p>正切函数：<br>$$ \tan x &#x3D; x + \frac{x^3}{3} + \frac{2x^5}{15} + \frac{17x^7}{315} + \cdots, \quad |x| &lt; \frac{\pi}{2} $$</p></li><li><p>反正弦函数：<br>$$ \arcsin x &#x3D; x + \frac{1}{2} \cdot \frac{x^3}{3} + \frac{1 \cdot 3}{2 \cdot 4} \cdot \frac{x^5}{5} + \frac{1 \cdot 3 \cdot 5}{2 \cdot 4 \cdot 6} \cdot \frac{x^7}{7} + \cdots, \quad |x| \leq 1 $$</p></li><li><p>平方根函数：<br>$$ \sqrt{1+x} &#x3D; 1 + \frac{1}{2}x - \frac{1}{8}x^2 + \frac{1}{16}x^3 - \frac{5}{128}x^4 + \cdots, \quad |x| &lt; 1 $$</p></li><li><p>倒数函数：<br>$$ \frac{1}{1-x} &#x3D; 1 + x + x^2 + x^3 + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} x^n, \quad |x| &lt; 1 $$</p></li><li><p>双曲正切函数：<br>$$ \tanh x &#x3D; x - \frac{x^3}{3} + \frac{2x^5}{15} - \frac{17x^7}{315} + \cdots, \quad |x| &lt; \frac{\pi}{2} $$</p></li><li><p>余切函数级数：<br>$$ \cot x &#x3D; \frac{1}{x} - \frac{x}{3} - \frac{x^3}{45} - \frac{2x^5}{945} - \cdots, \quad 0 &lt; |x| &lt; \pi $$</p></li><li><p>正割函数：<br>$$ \sec x &#x3D; 1 + \frac{x^2}{2} + \frac{5x^4}{24} + \frac{61x^6}{720} + \cdots, \quad |x| &lt; \frac{\pi}{2} $$</p></li></ol><h3 id="11-4-复合函数的麦克劳林展开"><a href="#11-4-复合函数的麦克劳林展开" class="headerlink" title="11.4 复合函数的麦克劳林展开"></a>11.4 复合函数的麦克劳林展开</h3><ol start="16"><li><p>$e^{-x^2}$ 的麦克劳林展开：<br>$$ e^{-x^2} &#x3D; 1 - x^2 + \frac{x^4}{2!} - \frac{x^6}{3!} + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{(-1)^n x^{2n}}{n!} $$</p></li><li><p>$\ln(1-x)$ 的麦克劳林展开：<br>$$ \ln(1-x) &#x3D; -x - \frac{x^2}{2} - \frac{x^3}{3} - \frac{x^4}{4} - \cdots &#x3D; -\sum_{n&#x3D;1}^{\infty} \frac{x^n}{n}, \quad |x| &lt; 1 $$</p></li><li><p>$\frac{1}{(1-x)^2}$ 的麦克劳林展开：<br>$$ \frac{1}{(1-x)^2} &#x3D; 1 + 2x + 3x^2 + 4x^3 + \cdots &#x3D; \sum_{n&#x3D;0}^{\infty} (n+1)x^n, \quad |x| &lt; 1 $$</p></li></ol><h2 id="12-常见积分的基本公式"><a href="#12-常见积分的基本公式" class="headerlink" title="12. 常见积分的基本公式"></a>12. 常见积分的基本公式</h2><h3 id="12-1-基本不定积分公式"><a href="#12-1-基本不定积分公式" class="headerlink" title="12.1. 基本不定积分公式"></a>12.1. 基本不定积分公式</h3><ol><li><p>常数积分：<br>$$ \int k , dx &#x3D; kx + C $$</p></li><li><p>幂函数积分：<br>$$ \int x^n , dx &#x3D; \frac{x^{n+1}}{n+1} + C, \quad (n \neq -1) $$</p></li><li><p>对数函数积分：<br>$$ \int \frac{1}{x} , dx &#x3D; \ln|x| + C $$</p></li><li><p>指数函数积分：<br>$$ \int e^x , dx &#x3D; e^x + C $$<br>$$ \int a^x , dx &#x3D; \frac{a^x}{\ln a} + C, \quad (a &gt; 0, a \neq 1) $$</p></li><li><p>三角函数积分：<br>$$ \int \sin x , dx &#x3D; -\cos x + C $$<br>$$ \int \cos x , dx &#x3D; \sin x + C $$<br>$$ \int \tan x , dx &#x3D; -\ln|\cos x| + C &#x3D; \ln|\sec x| + C $$<br>$$ \int \cot x , dx &#x3D; \ln|\sin x| + C $$<br>$$ \int \sec x , dx &#x3D; \ln|\sec x + \tan x| + C $$<br>$$ \int \csc x , dx &#x3D; \ln|\csc x - \cot x| + C &#x3D; \ln|\tan(x&#x2F;2)| + C $$</p></li><li><p>反三角函数积分：<br>$$ \int \frac{1}{\sqrt{1-x^2}} , dx &#x3D; \arcsin x + C &#x3D; -\arccos x + C $$<br>$$ \int \frac{1}{1+x^2} , dx &#x3D; \arctan x + C $$<br>$$ \int \frac{1}{|x|\sqrt{x^2-1}} , dx &#x3D; \arccos\frac{1}{|x|} + C $$</p></li><li><p>双曲函数积分：<br>$$ \int \sinh x , dx &#x3D; \cosh x + C $$<br>$$ \int \cosh x , dx &#x3D; \sinh x + C $$<br>$$ \int \tanh x , dx &#x3D; \ln(\cosh x) + C $$<br>$$ \int \coth x , dx &#x3D; \ln|\sinh x| + C $$</p></li></ol><h3 id="12-2-特殊形式积分"><a href="#12-2-特殊形式积分" class="headerlink" title="12.2. 特殊形式积分"></a>12.2. 特殊形式积分</h3><ol start="8"><li><p>分式积分：<br>$$ \int \frac{1}{a^2+x^2} , dx &#x3D; \frac{1}{a}\arctan\frac{x}{a} + C, \quad (a &gt; 0) $$<br>$$ \int \frac{1}{a^2-x^2} , dx &#x3D; \frac{1}{2a}\ln\left|\frac{a+x}{a-x}\right| + C, \quad (|x| &lt; a) $$<br>$$ \int \frac{1}{x^2-a^2} , dx &#x3D; \frac{1}{2a}\ln\left|\frac{x-a}{x+a}\right| + C, \quad (|x| &gt; a) $$</p></li><li><p>根式积分：<br>$$ \int \frac{1}{\sqrt{a^2-x^2}} , dx &#x3D; \arcsin\frac{x}{a} + C, \quad (|x| &lt; a, a &gt; 0) $$<br>$$ \int \frac{1}{\sqrt{x^2-a^2}} , dx &#x3D; \ln|x + \sqrt{x^2-a^2}| + C, \quad (x &gt; a &gt; 0) $$<br>$$ \int \frac{1}{\sqrt{x^2+a^2}} , dx &#x3D; \ln|x + \sqrt{x^2+a^2}| + C, \quad (a &gt; 0) $$<br>$$ \int \sqrt{a^2-x^2} , dx &#x3D; \frac{x\sqrt{a^2-x^2}}{2} + \frac{a^2}{2}\arcsin\frac{x}{a} + C, \quad (|x| &lt; a, a &gt; 0) $$<br>$$ \int \sqrt{x^2+a^2} , dx &#x3D; \frac{x\sqrt{x^2+a^2}}{2} + \frac{a^2}{2}\ln|x + \sqrt{x^2+a^2}| + C, \quad (a &gt; 0) $$<br>$$ \int \sqrt{x^2-a^2} , dx &#x3D; \frac{x\sqrt{x^2-a^2}}{2} - \frac{a^2}{2}\ln|x + \sqrt{x^2-a^2}| + C, \quad (x &gt; a &gt; 0) $$</p></li><li><p>特殊乘积结构：<br>$$ \int x\sin x , dx &#x3D; \sin x - x\cos x + C $$<br>$$ \int x\cos x , dx &#x3D; \cos x + x\sin x + C $$<br>$$ \int x^n e^x , dx &#x3D; x^n e^x - n\int x^{n-1}e^x , dx $$<br>$$ \int x^n \ln x , dx &#x3D; \frac{x^{n+1}}{n+1}\ln x - \frac{x^{n+1}}{(n+1)^2} + C, \quad (n \neq -1) $$</p></li><li><p>有理三角函数变形：<br>$$ \int \sin^2 x , dx &#x3D; \frac{x}{2} - \frac{\sin 2x}{4} + C $$<br>$$ \int \cos^2 x , dx &#x3D; \frac{x}{2} + \frac{\sin 2x}{4} + C $$<br>$$ \int \sin^n x , dx &#x3D; -\frac{\sin^{n-1}x \cos x}{n} + \frac{n-1}{n}\int \sin^{n-2}x , dx, \quad (n &gt; 1) $$<br>$$ \int \cos^n x , dx &#x3D; \frac{\cos^{n-1}x \sin x}{n} + \frac{n-1}{n}\int \cos^{n-2}x , dx, \quad (n &gt; 1) $$</p></li><li><p>平方和与差的积分：<br>$$ \int \frac{1}{x^2+a^2} , dx &#x3D; \frac{1}{a}\arctan\frac{x}{a} + C, \quad (a &gt; 0) $$<br>$$ \int \frac{x}{x^2+a^2} , dx &#x3D; \frac{1}{2}\ln(x^2+a^2) + C $$<br>$$ \int \frac{x^2}{x^2+a^2} , dx &#x3D; x - a\arctan\frac{x}{a} + C, \quad (a &gt; 0) $$</p></li></ol><h3 id="12-3-特殊定积分"><a href="#12-3-特殊定积分" class="headerlink" title="12.3. 特殊定积分"></a>12.3. 特殊定积分</h3><ol start="13"><li><p>常见定积分：<br>$$ \int_0^{\pi&#x2F;2} \sin^n x , dx &#x3D; \int_0^{\pi&#x2F;2} \cos^n x , dx &#x3D; \begin{cases}<br>\frac{(n-1)!!}{n!!} \cdot \frac{\pi}{2}, &amp; \text{n 为偶数} \<br>\frac{(n-1)!!}{n!!}, &amp; \text{n 为奇数}<br>\end{cases} $$<br>其中 $n!! &#x3D; n(n-2)(n-4)\cdots$</p></li><li><p>对称区间上的奇偶性质：<br>$$ \int_{-a}^{a} f(x) , dx &#x3D; 2\int_0^a f(x) , dx, \quad \text{当 } f \text{ 为偶函数} $$<br>$$ \int_{-a}^{a} f(x) , dx &#x3D; 0, \quad \text{当 } f \text{ 为奇函数} $$</p></li><li><p>华里士公式：<br>$$ \int_0^{\pi&#x2F;2} \sin^m x \cos^n x , dx &#x3D; \frac{1}{2}B\left(\frac{m+1}{2}, \frac{n+1}{2}\right) &#x3D; \frac{\Gamma\left(\frac{m+1}{2}\right)\Gamma\left(\frac{n+1}{2}\right)}{2\Gamma\left(\frac{m+n+2}{2}\right)} $$<br>其中 $B$ 是贝塔函数，$\Gamma$ 是伽马函数</p></li><li><p>$\Gamma$ 函数相关积分：<br>$$ \int_0^{\infty} x^{n-1}e^{-x} , dx &#x3D; \Gamma(n), \quad (n &gt; 0) $$<br>$$ \int_0^{\infty} e^{-x^2} , dx &#x3D; \frac{\sqrt{\pi}}{2} $$</p></li><li><p>重要极限类型定积分：<br>$$ \lim_{n \to \infty} \int_0^1 (1-x^n)^n , dx &#x3D; \frac{1}{e} $$<br>$$ \lim_{n \to \infty} \int_0^{\infty} \frac{x^n}{n^{n+1}} e^{-x&#x2F;n} , dx &#x3D; 1 $$</p></li></ol><h3 id="12-4-换元积分法的典型例子"><a href="#12-4-换元积分法的典型例子" class="headerlink" title="12.4. 换元积分法的典型例子"></a>12.4. 换元积分法的典型例子</h3><ol start="18"><li><p>三角换元：<br>$$ \int \sqrt{a^2-x^2} , dx &#x3D; \frac{a^2}{2}\arcsin\frac{x}{a} + \frac{x\sqrt{a^2-x^2}}{2} + C, \quad (|x| &lt; a) $$<br>（令 $x &#x3D; a\sin t$）</p></li><li><p>双曲换元：<br>$$ \int \sqrt{x^2+a^2} , dx &#x3D; \frac{x\sqrt{x^2+a^2}}{2} + \frac{a^2}{2}\ln|x + \sqrt{x^2+a^2}| + C $$<br>（令 $x &#x3D; a\sinh t$）</p></li><li><p>有理分式积分：<br>$$ \int \frac{1}{(x-a)(x-b)} , dx &#x3D; \frac{1}{a-b}\ln\left|\frac{x-a}{x-b}\right| + C, \quad (a \neq b) $$<br>$$ \int \frac{1}{(x-a)^2} , dx &#x3D; -\frac{1}{x-a} + C $$</p></li></ol><h2 id="13-Gamma函数"><a href="#13-Gamma函数" class="headerlink" title="13. Gamma函数"></a>13. Gamma函数</h2><h3 id="1-Gamma-函数的定义"><a href="#1-Gamma-函数的定义" class="headerlink" title="1. Gamma 函数的定义"></a><strong>1. Gamma 函数的定义</strong></h3><p>Gamma 函数的基本定义为：<br>$$<br>\Gamma(x) &#x3D; \int_0^\infty t^{x-1} e^{-t} , dt, \quad x &gt; 0<br>$$<br>它是阶乘的连续扩展，并且在所有正实数 $x$ 上收敛。  </p><hr><h3 id="2-Gamma-函数与阶乘的关系"><a href="#2-Gamma-函数与阶乘的关系" class="headerlink" title="2. Gamma 函数与阶乘的关系"></a><strong>2. Gamma 函数与阶乘的关系</strong></h3><p>Gamma 函数在正整数点满足：<br>$$<br>\Gamma(n) &#x3D; (n-1)!<br>$$<br>即对于任意正整数 $n$：<br>$$<br>\Gamma(n) &#x3D; \int_0^\infty t^{n-1} e^{-t} , dt &#x3D; (n-1)!<br>$$<br>这表明 Gamma 函数是阶乘的推广，使得非整数的阶乘也可以计算。  </p><hr><h3 id="3-Gamma-函数的性质"><a href="#3-Gamma-函数的性质" class="headerlink" title="3. Gamma 函数的性质"></a><strong>3. Gamma 函数的性质</strong></h3><h4 id="1-递推关系"><a href="#1-递推关系" class="headerlink" title="(1) 递推关系"></a><strong>(1) 递推关系</strong></h4><p>$$<br>\Gamma(x+1) &#x3D; x \Gamma(x)<br>$$<br>这类似于阶乘的递推公式：<br>$$<br>n! &#x3D; n \times (n-1)!<br>$$<br>但适用于所有实数 $x$。  </p><h4 id="2-特殊值"><a href="#2-特殊值" class="headerlink" title="(2) 特殊值"></a><strong>(2) 特殊值</strong></h4><p>$$<br>\Gamma(1) &#x3D; \int_0^\infty e^{-t} dt &#x3D; 1<br>$$<br>$$<br>\Gamma\left(\frac{1}{2}\right) &#x3D; \sqrt{\pi}<br>$$  </p><h4 id="3-反射公式（欧拉反射公式）"><a href="#3-反射公式（欧拉反射公式）" class="headerlink" title="(3) 反射公式（欧拉反射公式）"></a><strong>(3) 反射公式（欧拉反射公式）</strong></h4><p>$$<br>\Gamma(x) \Gamma(1-x) &#x3D; \frac{\pi}{\sin(\pi x)}<br>$$<br>这在计算某些特殊值时非常有用。  </p><h4 id="4-斯特林近似公式"><a href="#4-斯特林近似公式" class="headerlink" title="(4) 斯特林近似公式"></a><strong>(4) 斯特林近似公式</strong></h4><p>对于 $x \to \infty$，Gamma 函数可以近似为：<br>$$<br>\Gamma(x) \approx \sqrt{2\pi} x^{x-\frac{1}{2}} e^{-x}<br>$$<br>这表明它在大数时的增长速度类似于阶乘。  </p><hr><h3 id="4-Gamma-函数的应用"><a href="#4-Gamma-函数的应用" class="headerlink" title="4. Gamma 函数的应用"></a><strong>4. Gamma 函数的应用</strong></h3><h4 id="1-在概率统计中的应用"><a href="#1-在概率统计中的应用" class="headerlink" title="(1) 在概率统计中的应用"></a><strong>(1) 在概率统计中的应用</strong></h4><p>Gamma 分布的概率密度函数：<br>$$<br>f(x; k, \theta) &#x3D; \frac{x^{k-1} e^{-x&#x2F;\theta}}{\theta^k \Gamma(k)}<br>$$<br>在贝叶斯统计、可靠性分析等领域有重要作用。  </p><h4 id="2-在积分计算中的应用"><a href="#2-在积分计算中的应用" class="headerlink" title="(2) 在积分计算中的应用"></a><strong>(2) 在积分计算中的应用</strong></h4><p>一个重要的积分公式：<br>$$<br>\int_0^\infty x^{s-1} e^{-ax} dx &#x3D; \frac{\Gamma(s)}{a^s}, \quad a &gt; 0<br>$$<br>这在傅里叶变换、Laplace 变换等领域广泛使用。  </p><h4 id="3-物理学中的应用"><a href="#3-物理学中的应用" class="headerlink" title="(3) 物理学中的应用"></a><strong>(3) 物理学中的应用</strong></h4><p>Gamma 函数出现在玻尔兹曼统计、量子场论等许多物理理论中。例如，在统计物理中，配分函数的计算可能涉及 Gamma 函数。  </p><hr><h3 id="5-Gamma-函数的推广"><a href="#5-Gamma-函数的推广" class="headerlink" title="5. Gamma 函数的推广"></a><strong>5. Gamma 函数的推广</strong></h3><p>Gamma 函数可以推广到<strong>复数域</strong>，并且除了 $x &#x3D; 0, -1, -2, -3, \dots$ 这些点（它们是极点），在整个复平面都是解析的。这种推广在复分析和特殊函数理论中非常重要。  </p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li>Gamma 函数是阶乘的推广，并满足 $\Gamma(n) &#x3D; (n-1)!$。  </li><li>它具有递推关系 $\Gamma(x+1) &#x3D; x\Gamma(x)$。  </li><li>重要特殊值：$\Gamma(1) &#x3D; 1$，$\Gamma(1&#x2F;2) &#x3D; \sqrt{\pi}$。  </li><li>反射公式 $\Gamma(x)\Gamma(1-x) &#x3D; \frac{\pi}{\sin(\pi x)}$。  </li><li>斯特林公式可用于近似计算 Gamma 函数。</li></ol><h2 id="14-Beta函数"><a href="#14-Beta函数" class="headerlink" title="14. Beta函数"></a>14. Beta函数</h2><h3 id="1-Beta-函数的定义"><a href="#1-Beta-函数的定义" class="headerlink" title="1. Beta 函数的定义"></a><strong>1. Beta 函数的定义</strong></h3><p>Beta 函数 $B(x, y)$ 是一个重要的特殊函数，定义为：<br>$$<br>B(x, y) &#x3D; \int_0^1 t^{x-1} (1 - t)^{y-1} dt, \quad x &gt; 0, \ y &gt; 0<br>$$<br>它在许多数学分析、概率论和物理学问题中有广泛的应用。  </p><hr><h3 id="2-Beta-函数与-Gamma-函数的关系"><a href="#2-Beta-函数与-Gamma-函数的关系" class="headerlink" title="2. Beta 函数与 Gamma 函数的关系"></a><strong>2. Beta 函数与 Gamma 函数的关系</strong></h3><p>Beta 函数可以通过 Gamma 函数表示，其最重要的性质是：<br>$$<br>B(x, y) &#x3D; \frac{\Gamma(x) \Gamma(y)}{\Gamma(x + y)}<br>$$<br>其中 $ \Gamma(x) $ 是 Gamma 函数。这一性质表明 Beta 函数可以看作 Gamma 函数的比值。  </p><hr><h3 id="3-Beta-函数的性质"><a href="#3-Beta-函数的性质" class="headerlink" title="3. Beta 函数的性质"></a><strong>3. Beta 函数的性质</strong></h3><h4 id="1-对称性"><a href="#1-对称性" class="headerlink" title="(1) 对称性"></a><strong>(1) 对称性</strong></h4><p>Beta 函数满足交换律，即：<br>$$<br>B(x, y) &#x3D; B(y, x)<br>$$<br>这可以直接从定义式中 $t \to (1-t)$ 的变量代换推导出。  </p><h4 id="2-递推关系"><a href="#2-递推关系" class="headerlink" title="(2) 递推关系"></a><strong>(2) 递推关系</strong></h4><p>Beta 函数的递推关系类似于 Gamma 函数：<br>$$<br>B(x+1, y) &#x3D; \frac{x}{x + y} B(x, y)<br>$$<br>$$<br>B(x, y+1) &#x3D; \frac{y}{x + y} B(x, y)<br>$$  </p><h4 id="3-结合积分计算"><a href="#3-结合积分计算" class="headerlink" title="(3) 结合积分计算"></a><strong>(3) 结合积分计算</strong></h4><p>在计算某些积分时，Beta 函数提供了有用的公式：<br>$$<br>\int_0^\infty \frac{t^{x-1}}{(1+t)^{x+y}} dt &#x3D; B(x, y)<br>$$<br>这个积分在概率论和随机变量分析中常见。  </p><h4 id="4-通过-Gamma-函数计算特殊值"><a href="#4-通过-Gamma-函数计算特殊值" class="headerlink" title="(4) 通过 Gamma 函数计算特殊值"></a><strong>(4) 通过 Gamma 函数计算特殊值</strong></h4><p>利用 $\Gamma(x)$ 的性质，可以计算 $B(x, y)$ 的一些具体值。例如，当 $x &#x3D; y &#x3D; 1&#x2F;2$ 时：<br>$$<br>B\left(\frac{1}{2}, \frac{1}{2}\right) &#x3D; \frac{\Gamma(1&#x2F;2) \Gamma(1&#x2F;2)}{\Gamma(1)}<br>$$<br>由于 $\Gamma(1&#x2F;2) &#x3D; \sqrt{\pi}$，且 $\Gamma(1) &#x3D; 1$，所以：<br>$$<br>B\left(\frac{1}{2}, \frac{1}{2}\right) &#x3D; \frac{\pi}{\Gamma(1)} &#x3D; \pi<br>$$  </p><hr><h3 id="4-Beta-函数的应用"><a href="#4-Beta-函数的应用" class="headerlink" title="4. Beta 函数的应用"></a><strong>4. Beta 函数的应用</strong></h3><h4 id="1-在概率论中的应用"><a href="#1-在概率论中的应用" class="headerlink" title="(1) 在概率论中的应用"></a><strong>(1) 在概率论中的应用</strong></h4><p>Beta 分布是一个常见的概率分布，其概率密度函数（PDF）为：<br>$$<br>f(x; \alpha, \beta) &#x3D; \frac{x^{\alpha - 1} (1 - x)^{\beta - 1}}{B(\alpha, \beta)}, \quad 0 &lt; x &lt; 1<br>$$<br>Beta 分布在贝叶斯统计、顺序检验等领域有广泛应用。  </p><h4 id="2-在组合数学中的应用"><a href="#2-在组合数学中的应用" class="headerlink" title="(2) 在组合数学中的应用"></a><strong>(2) 在组合数学中的应用</strong></h4><p>Beta 函数可以用于计算某些组合数公式，例如：<br>$$<br>B(n, m) &#x3D; \frac{(n-1)! (m-1)!}{(n+m-1)!}<br>$$<br>这在组合分析和统计物理中有所应用。  </p><h4 id="3-在积分计算中的应用"><a href="#3-在积分计算中的应用" class="headerlink" title="(3) 在积分计算中的应用"></a><strong>(3) 在积分计算中的应用</strong></h4><p>Beta 函数常用于计算涉及二项式的积分，例如：<br>$$<br>\int_0^1 x^{m-1} (1 - x)^{n-1} dx &#x3D; B(m, n)<br>$$<br>这在数学分析和应用数学中经常出现。  </p><hr><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><ol><li>Beta 函数的定义为 $B(x, y) &#x3D; \int_0^1 t^{x-1} (1 - t)^{y-1} dt$，适用于 $x, y &gt; 0$。  </li><li>Beta 函数与 Gamma 函数的关系：$B(x, y) &#x3D; \frac{\Gamma(x) \Gamma(y)}{\Gamma(x + y)}$。  </li><li>具有对称性：$B(x, y) &#x3D; B(y, x)$。  </li><li>递推关系：$B(x+1, y) &#x3D; \frac{x}{x + y} B(x, y)$。  </li><li>重要特殊值：$B(1&#x2F;2, 1&#x2F;2) &#x3D; \pi$。  </li><li>在概率论（Beta 分布）、组合数学和积分计算中有广泛应用。</li></ol><h2 id="15-向量乘法相关"><a href="#15-向量乘法相关" class="headerlink" title="15. 向量乘法相关"></a>15. 向量乘法相关</h2><h3 id="15-1-向量点乘"><a href="#15-1-向量点乘" class="headerlink" title="15.1 向量点乘"></a><strong>15.1 向量点乘</strong></h3><p>向量点乘（内积）是两个向量相乘的一种方式，其结果是一个标量，反映了两个向量在同一方向上的相似程度。它在几何、物理和计算机科学中具有重要应用，如计算投影、夹角以及能量计算等。  </p><p>给定两个 $n$ 维向量 $\mathbf{A} &#x3D; (a_1, a_2, \dots, a_n)$ 和 $\mathbf{B} &#x3D; (b_1, b_2, \dots, b_n)$，它们的点乘定义为：  </p><p>$$<br>\mathbf{A} \cdot \mathbf{B} &#x3D; \sum_{i&#x3D;1}^{n} a_i b_i<br>$$  </p><p>在三维空间中，点乘可以表示为：  </p><p>$$<br>\mathbf{A} \cdot \mathbf{B} &#x3D; a_x b_x + a_y b_y + a_z b_z<br>$$  </p><p><strong>重要公式</strong>  </p><ol><li><strong>代数定义</strong>（坐标形式）：</li></ol><p>$$<br>   \mathbf{A} \cdot \mathbf{B} &#x3D; \sum_{i&#x3D;1}^{n} a_i b_i<br>$$  </p><ol start="2"><li><strong>几何定义</strong>（角度关系）：</li></ol><p>$$<br>   \mathbf{A} \cdot \mathbf{B} &#x3D; |\mathbf{A}| |\mathbf{B}| \cos \theta<br>$$  </p><p>   其中 $|\mathbf{A}|$ 和 $|\mathbf{B}|$ 分别是 $\mathbf{A}$ 和 $\mathbf{B}$ 的模，$\theta$ 是它们之间的夹角。  </p><ol start="3"><li><strong>单位向量的点乘</strong>：</li></ol><p>$$<br>   \mathbf{i} \cdot \mathbf{i} &#x3D; \mathbf{j} \cdot \mathbf{j} &#x3D; \mathbf{k} \cdot \mathbf{k} &#x3D; 1<br>$$  </p><p>$$<br>   \mathbf{i} \cdot \mathbf{j} &#x3D; \mathbf{j} \cdot \mathbf{k} &#x3D; \mathbf{k} \cdot \mathbf{i} &#x3D; 0<br>$$  </p><ol start="4"><li><p><strong>投影公式</strong>：  </p><p>向量 $\mathbf{A}$ 在向量 $\mathbf{B}$ 方向上的投影：<br>$$<br>\text{proj}_{\mathbf{B}} \mathbf{A} &#x3D; \frac{\mathbf{A} \cdot \mathbf{B}}{|\mathbf{B}|}<br>$$  </p></li><li><p><strong>正交判别</strong>（向量垂直的条件）：<br>若 $\mathbf{A} \cdot \mathbf{B} &#x3D; 0$，则 $\mathbf{A}$ 与 $\mathbf{B}$ 垂直。</p></li></ol><hr><h3 id="15-2-向量叉乘"><a href="#15-2-向量叉乘" class="headerlink" title="15.2 向量叉乘"></a><strong>15.2 向量叉乘</strong></h3><p><strong>相关概念</strong><br>向量叉乘（外积）是另一种向量乘法，它适用于三维向量，并且结果是一个新的向量，而不是标量。它在物理（如力矩、磁场计算）和计算机图形学（如法向量计算）中有广泛应用。  </p><p>给定两个三维向量 $\mathbf{A} &#x3D; (a_x, a_y, a_z)$ 和 $\mathbf{B} &#x3D; (b_x, b_y, b_z)$，它们的叉乘 $\mathbf{A} \times \mathbf{B}$ 计算如下：  </p><p>$$<br>\mathbf{A} \times \mathbf{B} &#x3D;<br>\begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\<br>a_x &amp; a_y &amp; a_z \\<br>b_x &amp; b_y &amp; b_z<br>\end{vmatrix}<br>$$  </p><p>展开行列式得：  </p><p>$$<br>\mathbf{A} \times \mathbf{B} &#x3D;<br>\begin{bmatrix}<br>a_y b_z - a_z b_y \\<br>a_z b_x - a_x b_z \\<br>a_x b_y - a_y b_x<br>\end{bmatrix}<br>$$  </p><p><strong>重要公式</strong>  </p><ol><li><strong>代数定义（坐标形式）</strong>：</li></ol><p>$$<br>   \mathbf{A} \times \mathbf{B} &#x3D;<br>   \begin{bmatrix}<br>   a_y b_z - a_z b_y \\<br>   a_z b_x - a_x b_z \\<br>   a_x b_y - a_y b_x<br>   \end{bmatrix}<br>$$  </p><ol start="2"><li><strong>几何定义（模长）</strong>：<br>叉乘的模长为：</li></ol><p>$$<br>   |\mathbf{A} \times \mathbf{B}| &#x3D; |\mathbf{A}| |\mathbf{B}| \sin \theta<br>$$  </p><p>   其中 $\theta$ 是 $\mathbf{A}$ 和 $\mathbf{B}$ 之间的夹角。</p><ul><li>$|\mathbf{A}| |\mathbf{B}| \sin \theta$ 表示 $\mathbf{A}$ 和 $\mathbf{B}$为邻边的<strong>平行四边形</strong>的面积</li></ul><ol start="3"><li><p><strong>方向判定（右手定则）</strong>：<br>叉乘的方向由右手定则确定：右手四指从 $\mathbf{A}$ 指向 $\mathbf{B}$，大拇指的方向就是 $\mathbf{A} \times \mathbf{B}$ 的方向。  </p></li><li><p><strong>单位向量的叉乘</strong>：</p></li></ol><p>$$<br>   \mathbf{i} \times \mathbf{j} &#x3D; \mathbf{k}, \quad<br>   \mathbf{j} \times \mathbf{k} &#x3D; \mathbf{i}, \quad<br>   \mathbf{k} \times \mathbf{i} &#x3D; \mathbf{j}<br>$$  </p><p>$$<br>   \mathbf{j} \times \mathbf{i} &#x3D; -\mathbf{k}, \quad<br>   \mathbf{k} \times \mathbf{j} &#x3D; -\mathbf{i}, \quad<br>   \mathbf{i} \times \mathbf{k} &#x3D; -\mathbf{j}<br>$$  </p><ol start="5"><li><p><strong>平行向量的叉乘</strong>（零向量）：</p><p>若 $\mathbf{A} \parallel \mathbf{B}$，则 $\mathbf{A} \times \mathbf{B} &#x3D; \mathbf{0}$。  </p></li><li><p><strong>混合积（体积计算）</strong>：</p><p>三个向量 $\mathbf{A}, \mathbf{B}, \mathbf{C}$ 组成的平行六面体体积可通过混合积计算：</p></li></ol><p>$$<br>   V &#x3D; |\mathbf{A} \cdot (\mathbf{B} \times \mathbf{C})|<br>$$  </p><hr><h3 id="15-3-总结"><a href="#15-3-总结" class="headerlink" title="15.3 总结"></a>15.3 <strong>总结</strong></h3><ol><li><p><strong>向量点乘</strong>：</p><ul><li>计算公式：$\mathbf{A} \cdot \mathbf{B} &#x3D; |\mathbf{A}| |\mathbf{B}| \cos \theta$。  </li><li>结果是一个<strong>标量</strong>，表示两个向量的相似程度。  </li><li>用于计算投影、角度、正交性等。</li></ul></li><li><p><strong>向量叉乘</strong>：</p><ul><li>计算公式：$\mathbf{A} \times \mathbf{B} &#x3D; (a_y b_z - a_z b_y, a_z b_x - a_x b_z, a_x b_y - a_y b_x)$。  </li><li>结果是一个<strong>向量</strong>，垂直于原向量所在平面。  </li><li>用于计算法向量、角动量、力矩等。</li></ul></li></ol><h2 id="16-三维空间的平面方程"><a href="#16-三维空间的平面方程" class="headerlink" title="16. 三维空间的平面方程"></a><strong>16. 三维空间的平面方程</strong></h2><p>在三维空间中，平面是由一点和一个法向量唯一确定的。平面方程可以有不同的表示方式，包括一般式、点法式和截距式，每种形式在不同的应用场景下有不同的优势。  </p><h3 id="16-1-一般式"><a href="#16-1-一般式" class="headerlink" title="16.1. 一般式"></a><strong>16.1. 一般式</strong></h3><p>平面的<strong>一般式</strong>是最常见的平面方程形式，它描述了平面上的所有点满足的一个线性方程。  </p><p>$$<br>Ax + By + Cz + D &#x3D; 0<br>$$  </p><p>其中：  </p><ul><li>$(A, B, C)$ 是平面的法向量，表示平面<strong>垂直于</strong>该方向。  </li><li>$D$ 是常数项，决定了平面与坐标轴的相对位置。  </li><li>任意在该平面上的点 $(x, y, z)$ 都满足该方程。</li></ul><p><strong>特点</strong>  </p><ul><li><strong>通用性强</strong>，适用于解析几何和计算交点问题。  </li><li><strong>法向量 $(A, B, C)$ 直观地表示平面的方向</strong>。  </li><li>通过已知三点 $(x_1, y_1, z_1)$, $(x_2, y_2, z_2)$, $(x_3, y_3, z_3)$，可求出平面方程：</li></ul><p>$$<br>  \begin{vmatrix}<br>  x - x_1 &amp; y - y_1 &amp; z - z_1 \\<br>  x_2 - x_1 &amp; y_2 - y_1 &amp; z_2 - z_1 \\<br>  x_3 - x_1 &amp; y_3 - y_1 &amp; z_3 - z_1<br>  \end{vmatrix} &#x3D; 0<br>$$  </p><hr><h3 id="16-2-点法式"><a href="#16-2-点法式" class="headerlink" title="16.2. 点法式"></a><strong>16.2. 点法式</strong></h3><p>平面的点法式（点法向量式）方程由平面上一点和法向量来唯一确定。  </p><p>$$<br>A(x - x_0) + B(y - y_0) + C(z - z_0) &#x3D; 0<br>$$  </p><p>其中：  </p><ul><li>$(x_0, y_0, z_0)$ 是已知的平面上一点。  </li><li>$(A, B, C)$ 是平面的法向量，表示平面的方向。</li></ul><p><strong>特点</strong>  </p><ul><li><strong>形式直观</strong>，直接体现了平面经过某一点，并由法向量决定方向。  </li><li>适用于已知一点和法向量的情况，如物理中的力场计算。  </li><li>适用于计算点到平面的距离：</li></ul><p>$$<br>  d &#x3D; \frac{|Ax_1 + By_1 + Cz_1 + D|}{\sqrt{A^2 + B^2 + C^2}}<br>$$<br>  其中 $(x_1, y_1, z_1)$ 是平外一点。  </p><hr><h3 id="16-3-截距式"><a href="#16-3-截距式" class="headerlink" title="16.3. 截距式"></a><strong>16.3. 截距式</strong></h3><p>截距式描述了平面与坐标轴的交点，适用于平面与坐标轴都有交点的情况。  </p><p>$$<br>\frac{x}{a} + \frac{y}{b} + \frac{z}{c} &#x3D; 1<br>$$  </p><p>其中：  </p><ul><li>$a, b, c$ 分别是平面在 $x$、$y$ 和 $z$ 轴上的截距，即平面与坐标轴的交点 $(a, 0, 0)$，$(0, b, 0)$，$(0, 0, c)$。</li></ul><p><strong>特点</strong>  </p><ul><li>适用于平面与三坐标轴均有交点的情况。  </li><li>若平面平行于某坐标轴，则该坐标轴方向上的截距不存在，不能使用该公式。  </li><li>形式简洁，适用于几何分析。</li></ul><h3 id="16-4-总结"><a href="#16-4-总结" class="headerlink" title="16.4. 总结"></a><strong>16.4. 总结</strong></h3><ol><li><p><strong>一般式</strong>：  </p><ul><li>公式：$Ax + By + Cz + D &#x3D; 0$。  </li><li>适用于解析几何计算，法向量 $(A, B, C)$ 直观表示平面方向。</li></ul></li><li><p><strong>点法式（点法向量式）</strong>：  </p><ul><li>公式：$A(x - x_0) + B(y - y_0) + C(z - z_0) &#x3D; 0$。  </li><li>适用于已知一点和法向量的情况，可用于计算点到平面的距离。</li></ul></li><li><p><strong>截距式</strong>：  </p><ul><li>公式：$\frac{x}{a} + \frac{y}{b} + \frac{z}{c} &#x3D; 1$。  </li><li>适用于平面与三坐标轴都有交点的情况，形式直观。</li></ul></li></ol><p>三维空间的平面方程在物理、计算机图形学、工程计算等领域中有广泛应用！</p><h2 id="17-三维空间的直线方程"><a href="#17-三维空间的直线方程" class="headerlink" title="17. 三维空间的直线方程"></a><strong>17. 三维空间的直线方程</strong></h2><p>在三维空间中，直线不再仅由一个斜率描述，而是需要用方向向量或参数来表示。常见的三维直线方程形式包括一般式、点法式和截距式。  </p><h3 id="17-1-一般式"><a href="#17-1-一般式" class="headerlink" title="17.1. 一般式"></a><strong>17.1. 一般式</strong></h3><p>一般式是三维直线的隐式方程，它由两个平面的交集表示。由于两个平面唯一确定一条直线，因此可以用两个线性方程组来描述三维直线。  </p><p>若直线是两个平面方程的交线，则可以表示为：  </p><p>$$<br>A_1x + B_1y + C_1z + D_1 &#x3D; 0<br>$$</p><p>$$<br>A_2x + B_2y + C_2z + D_2 &#x3D; 0<br>$$  </p><p>其中，$(A_1, B_1, C_1)$ 和 $(A_2, B_2, C_2)$ 分别是两个平面的法向量，两个方程联立可以唯一确定直线。<br><strong>特点</strong>  </p><ul><li>适用于解析几何中的直线求交问题。  </li><li>通过解方程组求出直线上的点。  </li><li>适用于与平面方程配合使用，但不够直观。</li></ul><hr><h3 id="17-2-点法式"><a href="#17-2-点法式" class="headerlink" title="17.2. 点法式"></a><strong>17.2. 点法式</strong></h3><p>点法式（参数方程）使用直线上一点和一个方向向量来唯一确定直线。方向向量 $\mathbf{d} &#x3D; (l, m, n)$ 表示直线的方向，而直线上一点 $P_0(x_0, y_0, z_0)$ 用于定位。  </p><p><strong>重要公式</strong><br>直线的点法式方程（参数方程）：  </p><p>$$<br>x &#x3D; x_0 + lt<br>$$  </p><p>$$<br>y &#x3D; y_0 + mt<br>$$  </p><p>$$<br>z &#x3D; z_0 + nt<br>$$  </p><p>其中：  </p><ul><li>$P_0(x_0, y_0, z_0)$ 是直线上已知的一点。  </li><li>方向向量 $\mathbf{d} &#x3D; (l, m, n)$ 决定了直线的方向。  </li><li>$t$ 是参数，表示不同的点。</li></ul><p><strong>特点</strong>  </p><ul><li>直观且易于计算，适用于物理和工程中的轨迹问题。  </li><li>可以直接用于计算直线与平面的交点（代入平面方程）。  </li><li>方向向量不能为零向量，否则无法确定方向。</li></ul><hr><h3 id="17-3-截距式"><a href="#17-3-截距式" class="headerlink" title="17.3. 截距式"></a><strong>17.3. 截距式</strong></h3><p>截距式描述了直线在各坐标轴上的截距。当直线与坐标轴有明确交点时，可以使用这种形式。  </p><p>三维空间中的直线截距式可以表示为：  </p><p>$$<br>\frac{x}{a} &#x3D; \frac{y}{b} &#x3D; \frac{z}{c}<br>$$  </p><p>其中：  </p><ul><li>$a, b, c$ 为直线在 $x$、$y$、$z$ 轴上的截距。  </li><li>若直线经过原点，则该式不适用（因分母不能为零）。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li>适用于直线与三坐标轴都有交点的情况。  </li><li>形式简洁，直观显示直线与坐标轴的关系。  </li><li>不能用于方向向量平行于某坐标轴的情况。</li></ul><hr><h3 id="17-4-总结"><a href="#17-4-总结" class="headerlink" title="17.4.总结"></a><strong>17.4.总结</strong></h3><ol><li><p><strong>一般式</strong>：  </p><ul><li>由两个平面方程的交集表示：<br>$A_1x + B_1y + C_1z + D_1 &#x3D; 0$，$A_2x + B_2y + C_2z + D_2 &#x3D; 0$。  </li><li>适用于解析几何问题，如直线交点计算。</li></ul></li><li><p><strong>点法式（参数方程）</strong>：  </p><ul><li>直线上一点 $P_0(x_0, y_0, z_0)$ 和方向向量 $\mathbf{d} &#x3D; (l, m, n)$。  </li><li>公式：<br>$x &#x3D; x_0 + lt$，<br>$y &#x3D; y_0 + mt$，<br>$z &#x3D; z_0 + nt$。  </li><li>适用于运动轨迹和计算交点问题。</li></ul></li><li><p><strong>截距式</strong>：  </p><ul><li>适用于直线与坐标轴有截距的情况。  </li><li>公式：$\frac{x}{a} &#x3D; \frac{y}{b} &#x3D; \frac{z}{c}$。  </li><li>不能用于直线经过原点的情况。</li></ul></li></ol><h2 id="18-平面与平面的关系"><a href="#18-平面与平面的关系" class="headerlink" title="18. 平面与平面的关系"></a><strong>18. 平面与平面的关系</strong></h2><p>在三维空间中，两个平面可以是平行的、相交的或重合的。我们可以通过法向量的关系来判断它们的几何关系，并计算它们的夹角。  </p><hr><h3 id="18-1-如何判断两个平面平行"><a href="#18-1-如何判断两个平面平行" class="headerlink" title="18.1. 如何判断两个平面平行"></a><strong>18.1. 如何判断两个平面平行</strong></h3><p>两个平面平行，当且仅当它们的<strong>法向量共线</strong>，即法向量成比例。  </p><p>设两个平面方程为：  </p><p>$$<br>A_1x + B_1y + C_1z + D_1 &#x3D; 0<br>$$  </p><p>$$<br>A_2x + B_2y + C_2z + D_2 &#x3D; 0<br>$$  </p><p>若它们的法向量 $\mathbf{n_1} &#x3D; (A_1, B_1, C_1)$ 和 $\mathbf{n_2} &#x3D; (A_2, B_2, C_2)$ <strong>成比例</strong>，即存在非零常数 $k$ 使得：  </p><p>$$<br>(A_2, B_2, C_2) &#x3D; k (A_1, B_1, C_1)<br>$$  </p><p>则两个平面平行。  </p><hr><h3 id="18-2-如何判断两个平面垂直"><a href="#18-2-如何判断两个平面垂直" class="headerlink" title="18.2. 如何判断两个平面垂直"></a><strong>18.2. 如何判断两个平面垂直</strong></h3><p>两个平面垂直，当且仅当它们的<strong>法向量垂直</strong>，即法向量的点积为零。  </p><p>$$<br>\mathbf{n_1} \cdot \mathbf{n_2} &#x3D; A_1 A_2 + B_1 B_2 + C_1 C_2 &#x3D; 0<br>$$  </p><p>若满足此条件，则两个平面垂直。  </p><hr><h3 id="18-3-如何计算两个平面的夹角"><a href="#18-3-如何计算两个平面的夹角" class="headerlink" title="18.3. 如何计算两个平面的夹角"></a><strong>18.3. 如何计算两个平面的夹角</strong></h3><p>两个平面的夹角等于它们<strong>法向量的夹角</strong>，由点积公式计算。  </p><p>设两个法向量 $\mathbf{n_1}$ 和 $\mathbf{n_2}$ 的夹角为 $\theta$，则：  </p><p>$$<br>\cos\theta &#x3D; \frac{\mathbf{n_1} \cdot \mathbf{n_2}}{|\mathbf{n_1}| |\mathbf{n_2}|}<br>$$  </p><p>其中：  </p><ul><li>$|\mathbf{n_1}| &#x3D; \sqrt{A_1^2 + B_1^2 + C_1^2}$ 是 $\mathbf{n_1}$ 的模长。  </li><li>$|\mathbf{n_2}| &#x3D; \sqrt{A_2^2 + B_2^2 + C_2^2}$ 是 $\mathbf{n_2}$ 的模长。</li></ul><h2 id="19-直线与直线的关系"><a href="#19-直线与直线的关系" class="headerlink" title="19. 直线与直线的关系"></a><strong>19. 直线与直线的关系</strong></h2><p>在三维空间中，两个直线可以是平行的、相交的或异面的。我们可以通过它们的方向向量来判断它们的关系，并计算夹角。  </p><hr><h3 id="19-1-如何判断两条直线平行"><a href="#19-1-如何判断两条直线平行" class="headerlink" title="19.1. 如何判断两条直线平行"></a><strong>19.1. 如何判断两条直线平行</strong></h3><p>两条直线平行，当且仅当它们的<strong>方向向量共线</strong>，即方向向量成比例。  </p><p>设两条直线的方向向量分别为 $\mathbf{d_1} &#x3D; (l_1, m_1, n_1)$ 和 $\mathbf{d_2} &#x3D; (l_2, m_2, n_2)$，若存在非零常数 $k$ 使得：  </p><p>$$<br>(l_2, m_2, n_2) &#x3D; k (l_1, m_1, n_1)<br>$$  </p><p>则两条直线平行。  </p><hr><h3 id="19-2-如何判断两条直线垂直"><a href="#19-2-如何判断两条直线垂直" class="headerlink" title="19.2. 如何判断两条直线垂直"></a><strong>19.2. 如何判断两条直线垂直</strong></h3><p>两条直线垂直，当且仅当它们的<strong>方向向量垂直</strong>，即方向向量的点积为零。  </p><p>$$<br>\mathbf{d_1} \cdot \mathbf{d_2} &#x3D; l_1 l_2 + m_1 m_2 + n_1 n_2 &#x3D; 0<br>$$  </p><p>若满足此条件，则两条直线垂直。  </p><hr><h3 id="19-3-如何计算两条直线的夹角"><a href="#19-3-如何计算两条直线的夹角" class="headerlink" title="19.3. 如何计算两条直线的夹角"></a><strong>19.3. 如何计算两条直线的夹角</strong></h3><p>两条直线的夹角等于它们<strong>方向向量的夹角</strong>，由点积公式计算。  </p><p>设两条直线的方向向量 $\mathbf{d_1}$ 和 $\mathbf{d_2}$ 夹角为 $\theta$，则：  </p><p>$$<br>\cos\theta &#x3D; \frac{\mathbf{d_1} \cdot \mathbf{d_2}}{|\mathbf{d_1}| |\mathbf{d_2}|}<br>$$  </p><p>其中：  </p><ul><li>$|\mathbf{d_1}| &#x3D; \sqrt{l_1^2 + m_1^2 + n_1^2}$ 是 $\mathbf{d_1}$ 的模长。  </li><li>$|\mathbf{d_2}| &#x3D; \sqrt{l_2^2 + m_2^2 + n_2^2}$ 是 $\mathbf{d_2}$ 的模长。</li></ul><h2 id="20-直线与平面的关系"><a href="#20-直线与平面的关系" class="headerlink" title="20. 直线与平面的关系"></a><strong>20. 直线与平面的关系</strong></h2><p>直线与平面可能是相交的、平行的或在平面内。我们可以通过方向向量和法向量的关系来判断它们的几何关系，并计算夹角。  </p><hr><h3 id="20-1-如何判断直线与平面垂直"><a href="#20-1-如何判断直线与平面垂直" class="headerlink" title="20.1. 如何判断直线与平面垂直"></a><strong>20.1. 如何判断直线与平面垂直</strong></h3><p>直线与平面垂直，当且仅当<strong>直线的方向向量与平面的法向量平行</strong>，即方向向量成比例。  </p><p>设直线的方向向量为 $\mathbf{d} &#x3D; (l, m, n)$，平面的法向量为 $\mathbf{n} &#x3D; (A, B, C)$，若存在非零常数 $k$ 使得：  </p><p>$$<br>(A, B, C) &#x3D; k (l, m, n)<br>$$  </p><p>则直线与平面垂直。  </p><hr><h3 id="20-2-如何判断直线在平面上"><a href="#20-2-如何判断直线在平面上" class="headerlink" title="20.2. 如何判断直线在平面上"></a><strong>20.2. 如何判断直线在平面上</strong></h3><p>直线在平面上，当且仅当直线的<strong>方向向量与平面的法向量垂直</strong>，且直线上一点满足平面方程。  </p><p><strong>重要公式</strong><br>(1) 直线的方向向量 $\mathbf{d} &#x3D; (l, m, n)$ 满足：  </p><p>$$<br>\mathbf{d} \cdot \mathbf{n} &#x3D; lA + mB + nC &#x3D; 0<br>$$  </p><p>(2) 直线上一点 $(x_0, y_0, z_0)$ 代入平面方程：  </p><p>$$<br>A x_0 + B y_0 + C z_0 + D &#x3D; 0<br>$$  </p><p>若两者均满足，则直线在平面上。  </p><hr><h3 id="20-3-如何求直线和平面的夹角"><a href="#20-3-如何求直线和平面的夹角" class="headerlink" title="20.3. 如何求直线和平面的夹角"></a><strong>20.3. 如何求直线和平面的夹角</strong></h3><p>直线与平面的夹角是指<strong>直线方向向量与平面法向量的夹角的补角</strong>。  </p><p>设直线方向向量为 $\mathbf{d} &#x3D; (l, m, n)$，平面法向量为 $\mathbf{n} &#x3D; (A, B, C)$，夹角 $\theta$ 满足：  </p><p>$$<br>\sin\theta &#x3D; \frac{|\mathbf{d} \cdot \mathbf{n}|}{|\mathbf{d}| |\mathbf{n}|}<br>$$  </p><p>其中 $\theta$ 为直线与平面的夹角（取锐角）。  </p><h2 id="21-偏导数（partial-derivative）"><a href="#21-偏导数（partial-derivative）" class="headerlink" title="21. 偏导数（partial derivative）"></a><strong>21. 偏导数（partial derivative）</strong></h2><p>偏导数是多元函数在某一方向上的变化率，描述了函数对某个特定变量的变化率，而其他变量保持不变。  </p><hr><h3 id="21-1-偏导数的几何意义"><a href="#21-1-偏导数的几何意义" class="headerlink" title="21.1. 偏导数的几何意义"></a><strong>21.1. 偏导数的几何意义</strong></h3><p>在单变量微积分中，导数表示曲线在某点的切线斜率，而在多元函数中，偏导数描述函数在某个方向上的变化率。  </p><p>设 $z &#x3D; f(x, y)$ 是一个二元函数，其偏导数的几何意义为：</p><ul><li>$\frac{\partial f}{\partial x}$：表示在 $y$ 固定时，函数沿 $x$ 方向的变化率，对应于曲面 $z &#x3D; f(x, y)$ 在 $x$ 方向的切线斜率。</li><li>$\frac{\partial f}{\partial y}$：表示在 $x$ 固定时，函数沿 $y$ 方向的变化率，对应于曲面 $z &#x3D; f(x, y)$ 在 $y$ 方向的切线斜率。</li></ul><p>偏导数的定义：</p><p>$$<br>\frac{\partial f}{\partial x} &#x3D; \lim\limits_{h \to 0} \frac{f(x+h, y) - f(x, y)}{h}<br>$$  </p><p>$$<br>\frac{\partial f}{\partial y} &#x3D; \lim\limits_{h \to 0} \frac{f(x, y+h) - f(x, y)}{h}<br>$$  </p><p>若 $f(x, y)$ 可微，则其全微分为：</p><p>$$<br>dz &#x3D; \frac{\partial f}{\partial x} dx + \frac{\partial f}{\partial y} dy<br>$$  </p><p>表示函数在 $x$ 和 $y$ 方向上的变化综合作用。  </p><hr><h3 id="21-2-多元函数求偏导数"><a href="#21-2-多元函数求偏导数" class="headerlink" title="21.2. 多元函数求偏导数"></a><strong>21.2. 多元函数求偏导数</strong></h3><p>在求偏导数时，只对指定的变量求导，将其他变量视为常数。例如：</p><ul><li>求 $\frac{\partial f}{\partial x}$ 时，$y$ 视为常数；</li><li>求 $\frac{\partial f}{\partial y}$ 时，$x$ 视为常数。</li></ul><p>设 $f(x, y) &#x3D; x^2y + e^x \sin y$，则：</p><p>$$<br>\frac{\partial f}{\partial x} &#x3D; 2xy + e^x \sin y<br>$$  </p><p>$$<br>\frac{\partial f}{\partial y} &#x3D; x^2 + e^x \cos y<br>$$  </p><p>若 $f(x, y, z) &#x3D; x^2 y + yz^3 + \ln z$，则：</p><p>$$<br>\frac{\partial f}{\partial x} &#x3D; 2xy<br>$$  </p><p>$$<br>\frac{\partial f}{\partial y} &#x3D; x^2 + z^3<br>$$  </p><p>$$<br>\frac{\partial f}{\partial z} &#x3D; 3yz^2 + \frac{1}{z}<br>$$  </p><hr><h3 id="21-3-偏导数的链式法则"><a href="#21-3-偏导数的链式法则" class="headerlink" title="21.3. 偏导数的链式法则"></a><strong>21.3. 偏导数的链式法则</strong></h3><p>当 $z &#x3D; f(x, y)$ 且 $x, y$ 由另一个变量 $t$ 变化时，可以使用链式法则计算 $z$ 对 $t$ 的变化率。  </p><p><strong>重要公式</strong><br><strong>(1) 单参数情况</strong><br>若 $x &#x3D; x(t)$，$y &#x3D; y(t)$，则：</p><p>$$<br>\frac{dz}{dt} &#x3D; \frac{\partial f}{\partial x} \frac{dx}{dt} + \frac{\partial f}{\partial y} \frac{dy}{dt}<br>$$  </p><p><strong>(2) 多参数情况</strong><br>若 $z &#x3D; f(x, y)$，其中 $x &#x3D; x(u, v)$，$y &#x3D; y(u, v)$，则：</p><p>$$<br>\frac{\partial z}{\partial u} &#x3D; \frac{\partial f}{\partial x} \frac{\partial x}{\partial u} + \frac{\partial f}{\partial y} \frac{\partial y}{\partial u}<br>$$  </p><p>$$<br>\frac{\partial z}{\partial v} &#x3D; \frac{\partial f}{\partial x} \frac{\partial x}{\partial v} + \frac{\partial f}{\partial y} \frac{\partial y}{\partial v}<br>$$  </p><img src="/img/Calculus/pds.jpg" alt="偏导数" style="max-width: 100%; height: auto;" /><p><strong>示例</strong><br>设 $z &#x3D; x^2 + xy$，其中 $x &#x3D; t^2, y &#x3D; e^t$，则：</p><p>$$<br>\frac{\partial f}{\partial x} &#x3D; 2x + y, \quad \frac{\partial f}{\partial y} &#x3D; x<br>$$  </p><p>$$<br>\frac{dx}{dt} &#x3D; 2t, \quad \frac{dy}{dt} &#x3D; e^t<br>$$  </p><p>则：</p><p>$$<br>\frac{dz}{dt} &#x3D; (2x + y) \cdot 2t + x \cdot e^t<br>$$  </p><p>代入 $x &#x3D; t^2, y &#x3D; e^t$，得：</p><p>$$<br>\frac{dz}{dt} &#x3D; (2t^2 + e^t) \cdot 2t + t^2 e^t<br>$$  </p><p><strong>总结</strong>  </p><ol><li>偏导数描述多元函数在某个方向上的变化率，几何上表示曲面的切线斜率。  </li><li>求偏导时，仅对指定变量求导，其余变量视为常数。  </li><li>偏导数的链式法则用于计算复合函数的变化率，在多元微积分和物理中广泛应用。</li></ol><h2 id="22-二元函数的极值判断"><a href="#22-二元函数的极值判断" class="headerlink" title="22. 二元函数的极值判断"></a><strong>22. 二元函数的极值判断</strong></h2><p>在二元函数 $f(x, y)$ 中，极值点是使函数达到局部最大值或最小值的点。我们可以通过 <strong>二阶偏导数判别法</strong>（即 $\Delta$ 方法）来判断极值。  </p><hr><h3 id="22-1-关键概念"><a href="#22-1-关键概念" class="headerlink" title="22.1. 关键概念"></a><strong>22.1. 关键概念</strong></h3><p>设 $f(x, y)$ 是二元可微函数，若在点 $(x_0, y_0)$ 处有：</p><p>$$<br>\frac{\partial f}{\partial x} &#x3D; 0, \quad \frac{\partial f}{\partial y} &#x3D; 0<br>$$  </p><p>则称 $(x_0, y_0)$ 为<strong>驻点（临界点）</strong>，可能是极大值、极小值或鞍点。  </p><p>为了进一步判断驻点的性质，需要计算 <strong>二阶偏导数判别式</strong>：</p><p>$$<br>\Delta &#x3D; f_{xx} f_{yy} - (f_{xy})^2<br>$$  </p><p>其中：</p><ul><li>$f_{xx} &#x3D; \frac{\partial^2 f}{\partial x^2}$ 是 $x$ 方向的二阶偏导数。</li><li>$f_{yy} &#x3D; \frac{\partial^2 f}{\partial y^2}$ 是 $y$ 方向的二阶偏导数。</li><li>$f_{xy} &#x3D; \frac{\partial^2 f}{\partial x \partial y}$ 是混合偏导数。</li></ul><hr><h3 id="22-2-极值判断方法（-Delta-方法）"><a href="#22-2-极值判断方法（-Delta-方法）" class="headerlink" title="22.2. 极值判断方法（$\Delta$ 方法）"></a>22.2. 极值判断方法（$\Delta$ 方法）</h3><ol><li>若 $\Delta &gt; 0$ 且 $f_{xx} &gt; 0$，则 $(x_0, y_0)$ 为局部极小值。</li><li>若 $\Delta &gt; 0$ 且 $f_{xx} &lt; 0$，则 $(x_0, y_0)$ 为局部极大值。</li><li>若 $\Delta &lt; 0$，则 $(x_0, y_0)$ 为鞍点（既不是极大值也不是极小值）。</li><li>若 $\Delta &#x3D; 0$，无法判断，需要进一步分析。</li></ol><hr><h3 id="22-3-重要公式"><a href="#22-3-重要公式" class="headerlink" title="22.3. 重要公式"></a><strong>22.3. 重要公式</strong></h3><ul><li><p><strong>一阶条件（求驻点）：</strong>  </p><p>$$<br>\frac{\partial f}{\partial x} &#x3D; 0, \quad \frac{\partial f}{\partial y} &#x3D; 0<br>$$  </p></li><li><p><strong>二阶判别式（判断极值）：</strong>  </p><p>$$<br>\Delta &#x3D; f_{xx} f_{yy} - (f_{xy})^2<br>$$<br>根据 $\Delta$ 的取值判断极值类型。</p></li></ul><hr><h3 id="22-4-示例"><a href="#22-4-示例" class="headerlink" title="22.4. 示例"></a><strong>22.4. 示例</strong></h3><p>例 1：判断函数 $f(x, y) &#x3D; x^3 + y^3 - 3xy$ 的极值*</p><p><strong>第一步：求驻点</strong>  </p><p>计算一阶偏导数：</p><p>$$<br>f_x &#x3D; 3x^2 - 3y &#x3D; 0<br>$$</p><p>$$<br>f_y &#x3D; 3y^2 - 3x &#x3D; 0<br>$$  </p><p>解方程组：</p><p>$$<br>\begin{cases}<br>3x^2 - 3y &#x3D; 0 \quad \Rightarrow \quad y &#x3D; x^2 \\<br>3y^2 - 3x &#x3D; 0 \quad \Rightarrow \quad x &#x3D; y^2<br>\end{cases}<br>$$  </p><p>代入 $y &#x3D; x^2$ 到 $x &#x3D; y^2$：</p><p>$$<br>x &#x3D; (x^2)^2 &#x3D; x^4<br>$$  </p><p>即：</p><p>$$<br>x^4 - x &#x3D; 0 \quad \Rightarrow \quad x(x^3 - 1) &#x3D; 0<br>$$  </p><p>解得：</p><p>$$<br>x &#x3D; 0, \quad x &#x3D; 1, \quad x &#x3D; -1<br>$$  </p><p>代入 $y &#x3D; x^2$：</p><p>$$<br>(0,0), \quad (1,1), \quad (-1,1)<br>$$  </p><p><strong>第二步：计算二阶偏导数</strong>  </p><p>$$<br>f_{xx} &#x3D; 6x, \quad f_{yy} &#x3D; 6y, \quad f_{xy} &#x3D; -3<br>$$  </p><p>计算 $\Delta$：</p><p>$$<br>\Delta &#x3D; f_{xx} f_{yy} - (f_{xy})^2 &#x3D; (6x)(6y) - (-3)^2<br>$$  </p><p><strong>第三步：判断极值</strong>  </p><ul><li><p>点 $(0,0)$：</p><p>$$<br>\Delta &#x3D; (6 \cdot 0)(6 \cdot 0) - (-3)^2 &#x3D; -9 &lt; 0<br>$$  </p><p>由于 $\Delta &lt; 0$，$(0,0)$ 是<strong>鞍点</strong>。</p></li><li><p>点 $(1,1)$：  </p><p>$$<br>\Delta &#x3D; (6 \cdot 1)(6 \cdot 1) - (-3)^2 &#x3D; 36 - 9 &#x3D; 27 &gt; 0<br>$$  </p><p>由于 $\Delta &gt; 0$ 且 $f_{xx} &#x3D; 6 &gt; 0$，$(1,1)$ 是<strong>局部极小值</strong>。</p></li><li><p>点 $(-1,1)$：  </p><p>$$<br>\Delta &#x3D; (6 \cdot (-1))(6 \cdot 1) - (-3)^2 &#x3D; -36 - 9 &#x3D; -45 &lt; 0<br>$$  </p><p>由于 $\Delta &lt; 0$，$(-1,1)$ 也是<strong>鞍点</strong>。</p></li></ul><hr><p><strong>总结</strong>  </p><ol><li><strong>求驻点</strong>：令 $\frac{\partial f}{\partial x} &#x3D; 0, \frac{\partial f}{\partial y} &#x3D; 0$，解方程组。  </li><li><strong>计算二阶偏导数</strong>：$f_{xx}, f_{yy}, f_{xy}$。  </li><li>计算 $\Delta &#x3D; f_{xx} f_{yy} - (f_{xy})^2$ 并判断极值：  <ul><li>若 $\Delta &gt; 0$ 且 $f_{xx} &gt; 0$，则是<strong>局部极小值</strong>。  </li><li>若 $\Delta &gt; 0$ 且 $f_{xx} &lt; 0$，则是<strong>局部极大值</strong>。  </li><li>若 $\Delta &lt; 0$，则是<strong>鞍点</strong>。  </li><li>若 $\Delta &#x3D; 0$，需进一步分析。</li></ul></li></ol><h2 id="23-梯度（Gradient）"><a href="#23-梯度（Gradient）" class="headerlink" title="23. 梯度（Gradient）"></a>23. 梯度（Gradient）</h2><p>在微积分中，<strong>梯度（Gradient）</strong>描述的是一个多元函数在某一点处的最大变化率及其方向。梯度是一个向量，表示函数在该点的最陡上升方向。</p><p>设 $f(x,y)$ 是一个二元函数，其梯度记为 $\nabla f$（nabla 读作“纳布拉”），定义如下：</p><p>$$<br>\nabla f &#x3D; \left( \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y} \right)<br>$$</p><p>若 $f$ 是三元函数 $f(x,y,z)$，其梯度则为：</p><p>$$<br>\nabla f &#x3D; \left( \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z} \right)<br>$$</p><p><strong>梯度的几何意义</strong>：<br>梯度向量 $\nabla f$ 指向函数值增长最快的方向，其模长 $|\nabla f|$ 代表该方向上的最大变化率。</p><ul><li>若 $\nabla f &#x3D; 0$，则函数在该点处达到极值或是一个平稳点。</li><li>梯度的方向与<strong>等高线</strong>（即 $f(x,y) &#x3D; c$ 的曲线）垂直。</li></ul><p><strong>梯度的应用：</strong></p><ul><li><p><strong>最速上升方向</strong>：梯度的方向是函数增长最快的方向。</p></li><li><p><strong>法向量</strong>：在某点 $(x_0, y_0)$ 处，$\nabla f(x_0, y_0)$ 代表等高线 $f(x,y) &#x3D; c$ 的法向量。</p></li><li><p><strong>方向导数</strong>：沿任意方向 $\mathbf{v} &#x3D; (v_x, v_y)$ 的变化率可由梯度计算：</p><p>$$<br>D_{\mathbf{v}} f &#x3D; \nabla f \cdot \mathbf{v} &#x3D; \frac{\partial f}{\partial x} v_x + \frac{\partial f}{\partial y} v_y<br>$$</p></li></ul><hr><p><strong>示例</strong><br>设 $f(x,y) &#x3D; x^2 + y^2$，计算其梯度：<br>$$<br>\nabla f &#x3D; \left( \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y} \right) &#x3D; (2x, 2y)<br>$$</p><p>在点 $(1,2)$ 处：</p><p>$$<br>\nabla f(1,2) &#x3D; (2,4)<br>$$</p><p>表示该点处函数增长最快的方向为 $(2,4)$，即沿着该方向移动时 $f(x,y)$ 变化最快。</p><p><strong>总结</strong></p><ol><li><strong>梯度的定义</strong>：$\nabla f &#x3D; (\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \cdots)$</li><li><strong>梯度的几何意义</strong>：指向函数值增长最快的方向，且与等高线垂直。</li><li><strong>梯度的应用</strong>：<ul><li>确定最速上升方向</li><li>计算方向导数</li><li>作为等高线的法向量</li></ul></li></ol><h2 id="24-散度（Divergence）"><a href="#24-散度（Divergence）" class="headerlink" title="24. 散度（Divergence）"></a>24. 散度（Divergence）</h2><p>在微积分中，<strong>散度（Divergence）</strong> 描述的是一个向量场在某一点的“发散”或“汇聚”程度。它衡量的是向量场的体积膨胀或收缩趋势。</p><p>设 $\mathbf{F}$ 是一个三维向量场：</p><p>$$<br>\mathbf{F} &#x3D; (P, Q, R)<br>$$</p><p>其中 $P, Q, R$ 分别是 $x, y, z$ 的函数，则<strong>散度</strong>（记作 $\nabla \cdot \mathbf{F}$）定义为：</p><p>$$<br>\nabla \cdot \mathbf{F} &#x3D; \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}<br>$$</p><p>若 $\mathbf{F}$ 是二维向量场 $\mathbf{F} &#x3D; (P, Q)$，则散度为：</p><p>$$<br>\nabla \cdot \mathbf{F} &#x3D; \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y}<br>$$</p><h3 id="24-1-散度的物理意义"><a href="#24-1-散度的物理意义" class="headerlink" title="24.1. 散度的物理意义"></a>24.1. <strong>散度的物理意义</strong></h3><ul><li><strong>正散度</strong>（$\nabla \cdot \mathbf{F} &gt; 0$）：向量场在该点处“发散”，即周围有“源”。</li><li><strong>负散度</strong>（$\nabla \cdot \mathbf{F} &lt; 0$）：向量场在该点处“汇聚”，即周围有“汇”。</li><li><strong>零散度</strong>（$\nabla \cdot \mathbf{F} &#x3D; 0$）：表示该点附近没有净体积膨胀或收缩。</li></ul><hr><h3 id="24-2-示例"><a href="#24-2-示例" class="headerlink" title="24.2. 示例"></a>24.2. <strong>示例</strong></h3><p>设向量场：<br>$$<br>\mathbf{F} &#x3D; (x^2, y^2, z^2)<br>$$<br>计算散度：<br>$$<br>\nabla \cdot \mathbf{F} &#x3D; \frac{\partial}{\partial x} (x^2) + \frac{\partial}{\partial y} (y^2) + \frac{\partial}{\partial z} (z^2)<br>$$<br>$$<br>&#x3D; 2x + 2y + 2z<br>$$<br>在点 $(1,1,1)$ 处：<br>$$<br>\nabla \cdot \mathbf{F} &#x3D; 2(1) + 2(1) + 2(1) &#x3D; 6<br>$$<br>表示该点处的向量场有较强的发散趋势。</p><hr><h3 id="24-3-总结"><a href="#24-3-总结" class="headerlink" title="24.3 总结"></a>24.3 <strong>总结</strong></h3><ol><li><strong>散度的定义</strong>：<br>$$<br>\nabla \cdot \mathbf{F} &#x3D; \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}<br>$$</li><li><strong>散度的几何意义</strong>：<ul><li>$\nabla \cdot \mathbf{F} &gt; 0$：源（向外发散）。</li><li>$\nabla \cdot \mathbf{F} &lt; 0$：汇（向内收缩）。</li><li>$\nabla \cdot \mathbf{F} &#x3D; 0$：无散场。</li></ul></li><li><strong>散度的应用</strong>：<ul><li>流体力学：表示流体的局部膨胀或压缩。</li><li>电磁学：高斯定理用于描述电场的散度。</li><li>向量场分析：判断向量场是否为无散场。</li></ul></li></ol><h2 id="25-旋度（Curl）"><a href="#25-旋度（Curl）" class="headerlink" title="25. 旋度（Curl）"></a>25. 旋度（Curl）</h2><p>在微积分中，<strong>旋度（Curl）</strong>描述的是一个向量场在某一点的<strong>旋转</strong>或<strong>绕流</strong>程度。它衡量的是向量场的<strong>局部旋转趋势</strong>，即围绕某点的小范围流体是否存在旋转效应。</p><p>设 $\mathbf{F}$ 是三维向量场：</p><p>$$<br>\mathbf{F} &#x3D; (P, Q, R)<br>$$</p><p>其中 $P, Q, R$ 分别是 $x, y, z$ 的函数，则旋度（记作 $\nabla \times \mathbf{F}$）定义为：</p><p>$$<br>\nabla \times \mathbf{F} &#x3D;<br>\begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\<br>\frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z} \\<br>P &amp; Q &amp; R<br>\end{vmatrix}<br>$$</p><p>展开行列式后：</p><p>$$<br>\nabla \times \mathbf{F} &#x3D;<br>\left(<br>\frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z},<br>\frac{\partial P}{\partial z} - \frac{\partial R}{\partial x},<br>\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}<br>\right)<br>$$</p><p>若 $\mathbf{F}$ 是二维向量场 $\mathbf{F} &#x3D; (P, Q)$，则旋度可以写为：</p><p>$$<br>\nabla \times \mathbf{F} &#x3D; \frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}<br>$$</p><p>此时旋度是一个<strong>标量</strong>，而在三维中旋度是一个<strong>向量</strong>。</p><h3 id="25-1-旋度的几何意义"><a href="#25-1-旋度的几何意义" class="headerlink" title="25.1. 旋度的几何意义"></a>25.1. <strong>旋度的几何意义</strong></h3><ul><li><strong>$\nabla \times \mathbf{F} \neq 0$<strong>：向量场在该点附近</strong>存在旋转趋势</strong>，表示局部旋转效应。</li><li><strong>$\nabla \times \mathbf{F} &#x3D; 0$<strong>：向量场在该点附近</strong>无旋转趋势</strong>，即场是<strong>无旋场</strong>。</li></ul><p>旋度的方向给出流体旋转的<strong>轴向方向</strong>，而旋度的模长表示旋转的强度。</p><h3 id="25-2-示例"><a href="#25-2-示例" class="headerlink" title="25.2. 示例"></a>25.2. <strong>示例</strong></h3><p>设向量场：</p><p>$$<br>\mathbf{F} &#x3D; (y, -x, 0)<br>$$</p><p>计算旋度：<br>$$<br>\nabla \times \mathbf{F} &#x3D;<br>\begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\<br>\frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z} \\<br>y &amp; -x &amp; 0<br>\end{vmatrix}<br>$$</p><p>$$<br>&#x3D; \left( \frac{\partial 0}{\partial y} - \frac{\partial (-x)}{\partial z}, \frac{\partial y}{\partial z} - \frac{\partial 0}{\partial x}, \frac{\partial (-x)}{\partial x} - \frac{\partial y}{\partial y} \right)<br>$$</p><p>$$<br>&#x3D; (0 - 0, 0 - 0, -1 - 1) &#x3D; (0,0,-2)<br>$$<br>表示该向量场在 $z$ 方向上有一个<strong>逆时针旋转</strong>的趋势。</p><hr><h3 id="25-3-总结"><a href="#25-3-总结" class="headerlink" title="25.3. 总结"></a>25.3. <strong>总结</strong></h3><ol><li><p><strong>旋度的定义</strong>：</p></li><li><p> $$<br> \nabla \times \mathbf{F} &#x3D;<br> \begin{vmatrix}<br> \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\<br> \frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z} \\<br> P &amp; Q &amp; R<br> \end{vmatrix}<br> $$</p></li><li><p><strong>旋度的几何意义</strong>：</p><ul><li>$\nabla \times \mathbf{F} \neq 0$：表示向量场具有旋转趋势。</li><li>$\nabla \times \mathbf{F} &#x3D; 0$：表示无旋场。</li></ul></li><li><p><strong>旋度的应用</strong>：</p><ul><li>流体力学：判断流体是否有旋转效应。</li><li>电磁学：麦克斯韦方程描述电磁场的旋度。</li><li>向量场分析：判断向量场是否可由势函数表示。</li></ul></li></ol><h2 id="26-雅可比行列式（Jacobian-Determinant）"><a href="#26-雅可比行列式（Jacobian-Determinant）" class="headerlink" title="26. 雅可比行列式（Jacobian Determinant）"></a>26. 雅可比行列式（Jacobian Determinant）</h2><p>在微积分和向量分析中，<strong>雅可比行列式（Jacobian Determinant）</strong> 描述了多元函数的局部伸缩变换程度。它用于坐标变换、隐函数定理和多重积分的变量代换。</p><p>设一个向量值函数：</p><p>$$<br>\mathbf{F}(x_1, x_2, \dots, x_n) &#x3D; (f_1, f_2, \dots, f_n)<br>$$</p><p>其中，每个 $f_i$ 是 $n$ 个变量的函数，则 <strong>雅可比矩阵（Jacobian Matrix）</strong> 定义为：</p><p>$$<br>J &#x3D;<br>\begin{bmatrix}<br>\frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_2} &amp; \dots &amp; \frac{\partial f_1}{\partial x_n} \\<br>\frac{\partial f_2}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_2} &amp; \dots &amp; \frac{\partial f_2}{\partial x_n} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\frac{\partial f_n}{\partial x_1} &amp; \frac{\partial f_n}{\partial x_2} &amp; \dots &amp; \frac{\partial f_n}{\partial x_n}<br>\end{bmatrix}<br>$$</p><p><strong>雅可比行列式（Jacobian Determinant）</strong>定义为：</p><p>$$<br>\det(J) &#x3D; \begin{vmatrix}<br>\frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_1}{\partial x_2} &amp; \dots &amp; \frac{\partial f_1}{\partial x_n} \\<br>\frac{\partial f_2}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_2} &amp; \dots &amp; \frac{\partial f_2}{\partial x_n} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\frac{\partial f_n}{\partial x_1} &amp; \frac{\partial f_n}{\partial x_2} &amp; \dots &amp; \frac{\partial f_n}{\partial x_n}<br>\end{vmatrix}<br>$$</p><h3 id="26-1-雅可比行列式的几何意义"><a href="#26-1-雅可比行列式的几何意义" class="headerlink" title="26.1. 雅可比行列式的几何意义"></a>26.1. <strong>雅可比行列式的几何意义</strong></h3><ul><li>$\det(J) &gt; 0$：局部变换保持方向（不翻转）。</li><li>$\det(J) &lt; 0$：局部变换导致翻转（如镜像变换）。</li><li>$\det(J) &#x3D; 0$：变换在该点处不可逆（例如折叠或压缩成低维结构）。</li></ul><p>雅可比行列式的绝对值 $|\det(J)|$ 表示变换前后体积的<strong>局部伸缩比例</strong>。在<strong>变量替换的积分计算</strong>中，它用于调整体积元素。</p><h3 id="26-2-示例"><a href="#26-2-示例" class="headerlink" title="26.2. 示例"></a>26.2. <strong>示例</strong></h3><p>设二维坐标变换：</p><p>$$<br>x &#x3D; r\cos\theta, \quad y &#x3D; r\sin\theta<br>$$</p><p> $$<br>\det(J) &#x3D;<br>\begin{vmatrix}<br>\cos\theta &amp; -r\sin\theta \\<br>\sin\theta &amp; r\cos\theta<br>\end{vmatrix}<br>&#x3D; r(\cos^2\theta + \sin^2\theta) &#x3D; r<br> $$</p><p>在极坐标积分中，$dx,dy$ 需要乘以 $|\det(J)| &#x3D; r$，即：</p><p> $$<br>dx,dy &#x3D; r , dr , d\theta<br> $$</p><hr><h3 id="26-3-总结"><a href="#26-3-总结" class="headerlink" title="26.3 总结"></a>26.3 <strong>总结</strong></h3><ol><li><p><strong>雅可比矩阵定义</strong>：</p><p>$$<br>J &#x3D; \left[ \frac{\partial f_i}{\partial x_j} \right]<br>$$</p></li><li><p><strong>雅可比行列式的意义</strong>：</p><ul><li>$\det(J) &gt; 0$：变换保持方向。</li><li>$\det(J) &lt; 0$：变换翻转方向。</li><li>$\det(J) &#x3D; 0$：变换不可逆。</li></ul></li><li><p><strong>雅可比行列式的应用</strong>：</p><ul><li><strong>积分变换</strong>：极坐标、球坐标等。</li><li><strong>隐函数定理</strong>：判断方程组是否可解。</li><li><strong>几何分析</strong>：研究曲面的局部伸缩。</li></ul></li></ol><h2 id="27-二元函数的泰勒展开"><a href="#27-二元函数的泰勒展开" class="headerlink" title="27. 二元函数的泰勒展开"></a>27. <strong>二元函数的泰勒展开</strong></h2><p>在数学分析中，<strong>泰勒展开（Taylor Expansion）</strong>用于用多项式逼近光滑函数。对于<strong>二元函数</strong> $f(x, y)$，泰勒展开可以表示它在某一点的局部近似。</p><p>设 $f(x, y)$ 在点 $(a, b)$ 处具有足够高阶的连续偏导数，则它的 <strong>二阶泰勒展开式</strong> 为：</p><p>$$<br>f(x, y) \approx f(a, b) + f_x (a, b) (x - a) + f_y (a, b) (y - b)<br>$$</p><p>$$<br>+\frac{1}{2} \left[ f_{xx} (a, b) (x - a)^2 + 2 f_{xy} (a, b) (x - a)(y - b) + f_{yy} (a, b) (y - b)^2 \right]<br>$$</p><p>其中：</p><ul><li>$f_x &#x3D; \frac{\partial f}{\partial x}$，$f_y &#x3D; \frac{\partial f}{\partial y}$ 表示<strong>一阶偏导数</strong>；</li><li>$f_{xx} &#x3D; \frac{\partial^2 f}{\partial x^2}$，$f_{yy} &#x3D; \frac{\partial^2 f}{\partial y^2}$，$f_{xy} &#x3D; \frac{\partial^2 f}{\partial x \partial y}$ 表示<strong>二阶偏导数</strong>。</li></ul><p>更一般地，<strong>n 阶泰勒展开</strong>可以写成：<br>$$<br>T_n(x, y) &#x3D; \sum_{i+j \leq n} \frac{1}{i!j!} \frac{\partial^{i+j} f}{\partial x^i \partial y^j} (a, b) (x - a)^i (y - b)^j<br>$$<br>其中求和范围是 $i + j \leq n$，即所有偏导数阶数之和不超过 $n$。</p><hr><h3 id="27-2-几何意义"><a href="#27-2-几何意义" class="headerlink" title="27.2 几何意义"></a>27.2 <strong>几何意义</strong></h3><ul><li><strong>一阶展开</strong> 仅包含线性项，对应于函数在 $(a,b)$ 处的<strong>切平面</strong>。</li><li><strong>二阶展开</strong> 包含二次项，可以更准确地逼近函数，对应于<strong>二次曲面</strong>。</li><li><strong>高阶展开</strong> 可以更精确地近似 $f(x, y)$，但计算复杂度更高。</li></ul><p><strong>应用</strong></p><ul><li><strong>函数近似</strong>：用低阶多项式代替复杂函数，简化计算。</li><li><strong>优化问题</strong>：二阶泰勒展开用于分析临界点，判断极值（如 Hessian 矩阵）。</li><li><strong>物理建模</strong>：在流体力学、量子力学等领域，用于研究微小扰动。</li></ul><hr><h3 id="27-3-示例"><a href="#27-3-示例" class="headerlink" title="27.3. 示例"></a>27.3. <strong>示例</strong></h3><p>设函数：<br>$$<br>f(x, y) &#x3D; e^x \cos y<br>$$<br>在点 $(0,0)$ 处的二阶泰勒展开：</p><ol><li>计算函数值：<br>$$<br>f(0,0) &#x3D; e^0 \cos 0 &#x3D; 1<br>$$</li><li>计算一阶偏导数：<br>$$<br>f_x &#x3D; e^x \cos y, \quad f_x(0,0) &#x3D; 1<br>$$<br>$$<br>f_y &#x3D; -e^x \sin y, \quad f_y(0,0) &#x3D; 0<br>$$</li><li>计算二阶偏导数：<br>$$<br>f_{xx} &#x3D; e^x \cos y, \quad f_{xx}(0,0) &#x3D; 1<br>$$<br>$$<br>f_{yy} &#x3D; -e^x \cos y, \quad f_{yy}(0,0) &#x3D; -1<br>$$<br>$$<br>f_{xy} &#x3D; -e^x \sin y, \quad f_{xy}(0,0) &#x3D; 0<br>$$</li><li>代入二阶泰勒公式：<br>$$<br>f(x, y) \approx 1 + x + \frac{1}{2} (x^2 - y^2)<br>$$</li></ol><hr><h3 id="27-4-总结"><a href="#27-4-总结" class="headerlink" title="27.4. 总结"></a>27.4. <strong>总结</strong></h3><ol><li><strong>一阶泰勒展开</strong>：<br>$$<br>f(x, y) \approx f(a, b) + f_x (a, b) (x - a) + f_y (a, b) (y - b)<br>$$</li><li><strong>二阶泰勒展开</strong>：<br>$$<br>f(x, y) \approx f(a, b) + f_x (a, b) (x - a) + f_y (a, b) (y - b)<br>$$<br>$$<br>+\frac{1}{2} \left[ f_{xx} (a, b) (x - a)^2 + 2 f_{xy} (a, b) (x - a)(y - b) + f_{yy} (a, b) (y - b)^2 \right]<br>$$</li><li><strong>应用</strong>：<ul><li><strong>函数近似</strong></li><li><strong>极值判断</strong></li><li><strong>物理建模</strong></li></ul></li></ol><h2 id="28-计算曲线长度"><a href="#28-计算曲线长度" class="headerlink" title="28. 计算曲线长度"></a>28. <strong>计算曲线长度</strong></h2><p>在微积分中，曲线的长度（弧长）可以通过积分计算。我们通常使用<strong>参数方程</strong>或<strong>极坐标方程</strong>来描述曲线，并根据不同的表达方式推导相应的弧长公式。</p><hr><h3 id="28-1-采用参数方程的曲线长度"><a href="#28-1-采用参数方程的曲线长度" class="headerlink" title="28.1. 采用参数方程的曲线长度"></a><strong>28.1. 采用参数方程的曲线长度</strong></h3><p>若曲线由参数方程：<br>$$<br>x &#x3D; x(t), \quad y &#x3D; y(t), \quad t \in [a, b]<br>$$<br>给出，则其弧长 $L$ 由以下积分计算：<br>$$<br>L &#x3D; \int_a^b \sqrt{\left( \frac{dx}{dt} \right)^2 + \left( \frac{dy}{dt} \right)^2} , dt<br>$$<br>其中：</p><ul><li>$\frac{dx}{dt}$ 和 $\frac{dy}{dt}$ 分别是 $x$ 和 $y$ 对 $t$ 的导数。</li><li>积分的上限和下限 $a, b$ 是参数 $t$ 的取值范围。</li></ul><p><strong>示例</strong><br>计算<strong>圆的四分之一弧长</strong>，参数方程：<br>$$<br>x &#x3D; r\cos t, \quad y &#x3D; r\sin t, \quad t \in [0, \frac{\pi}{2}]<br>$$<br>计算导数：<br>$$<br>\frac{dx}{dt} &#x3D; -r\sin t, \quad \frac{dy}{dt} &#x3D; r\cos t<br>$$<br>代入公式：<br>$$<br>L &#x3D; \int_0^{\frac{\pi}{2}} \sqrt{(-r\sin t)^2 + (r\cos t)^2} , dt<br>$$<br>$$<br>&#x3D; \int_0^{\frac{\pi}{2}} \sqrt{r^2 (\sin^2 t + \cos^2 t)} , dt<br>$$<br>$$<br>&#x3D; \int_0^{\frac{\pi}{2}} r , dt &#x3D; r \frac{\pi}{2}<br>$$<br>因此，圆的四分之一弧长为：<br>$$<br>\frac{\pi r}{2}<br>$$</p><hr><h3 id="28-2-采用极坐标方程的曲线长度"><a href="#28-2-采用极坐标方程的曲线长度" class="headerlink" title="28.2. 采用极坐标方程的曲线长度"></a><strong>28.2. 采用极坐标方程的曲线长度</strong></h3><p>若曲线由极坐标方程：<br>$$<br>r &#x3D; f(\theta), \quad \theta \in [\alpha, \beta]<br>$$<br>给出，则其弧长 $L$ 由以下积分计算：<br>$$<br>L &#x3D; \int_\alpha^\beta \sqrt{ \left( \frac{dr}{d\theta} \right)^2 + r^2 } , d\theta<br>$$<br>其中：</p><ul><li>$r &#x3D; f(\theta)$ 是极坐标曲线的方程。</li><li>$\frac{dr}{d\theta}$ 是 $r$ 对 $\theta$ 的导数。</li></ul><p><strong>示例</strong><br>计算<strong>螺旋线</strong> $r &#x3D; a\theta$ 在 $\theta \in [0, 2\pi]$ 上的弧长：</p><ol><li>计算导数：<br>$$<br>\frac{dr}{d\theta} &#x3D; a<br>$$</li><li>代入弧长公式：<br>$$<br>L &#x3D; \int_0^{2\pi} \sqrt{ a^2 + (a\theta)^2 } , d\theta<br>$$<br>$$<br>&#x3D; \int_0^{2\pi} \sqrt{ a^2(1 + \theta^2) } , d\theta<br>$$</li></ol><p>该积分一般需要数值方法计算。</p><hr><h3 id="28-3-总结"><a href="#28-3-总结" class="headerlink" title="28.3. 总结"></a><strong>28.3. 总结</strong></h3><ol><li><p><strong>参数方程的弧长公式</strong>：<br>$$<br>L &#x3D; \int_a^b \sqrt{\left( \frac{dx}{dt} \right)^2 + \left( \frac{dy}{dt} \right)^2} , dt<br>$$</p><ul><li>适用于<strong>参数化曲线</strong>。</li><li>计算需要求 $x$ 和 $y$ 对参数 $t$ 的导数。</li></ul></li><li><p><strong>极坐标方程的弧长公式</strong>：<br>$$<br>L &#x3D; \int_\alpha^\beta \sqrt{ \left( \frac{dr}{d\theta} \right)^2 + r^2 } , d\theta<br>$$</p><ul><li>适用于<strong>极坐标曲线</strong>。</li><li>计算需要求 $r$ 对 $\theta$ 的导数。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>计算<strong>螺旋线、圆弧、摆线</strong>等曲线的长度。</li><li><strong>物理应用</strong>：如<strong>卫星轨道、波长计算</strong>等。</li></ul></li></ol><h2 id="29-计算平面面积"><a href="#29-计算平面面积" class="headerlink" title="29. 计算平面面积"></a><strong>29. 计算平面面积</strong></h2><p>在微积分中，平面区域的面积可以通过积分计算。根据曲线的表达方式，我们可以使用<strong>参数方程</strong>或<strong>极坐标方程</strong>来推导面积公式。</p><hr><h3 id="29-1-采用参数方程计算面积"><a href="#29-1-采用参数方程计算面积" class="headerlink" title="29.1. 采用参数方程计算面积"></a><strong>29.1. 采用参数方程计算面积</strong></h3><p>若区域由<strong>参数方程</strong>：<br>$$<br>x &#x3D; x(t), \quad y &#x3D; y(t), \quad t \in [a, b]<br>$$<br>给出，我们可以利用<strong>格林公式</strong>计算面积：<br>$$<br>A &#x3D; \int_a^b x(t) \frac{dy}{dt} , dt<br>$$<br>或者：<br>$$<br>A &#x3D; -\int_a^b y(t) \frac{dx}{dt} , dt<br>$$<br>其中：</p><ul><li>$\frac{dx}{dt}$ 和 $\frac{dy}{dt}$ 是 $x$ 和 $y$ 对 $t$ 的导数。</li></ul><p><strong>示例</strong><br>求<strong>椭圆</strong> $\frac{x^2}{a^2} + \frac{y^2}{b^2} &#x3D; 1$ 的面积，参数方程：<br>$$<br>x &#x3D; a\cos t, \quad y &#x3D; b\sin t, \quad t \in [0, 2\pi]<br>$$<br>计算导数：<br>$$<br>\frac{dy}{dt} &#x3D; b\cos t<br>$$<br>代入面积公式：<br>$$<br>A &#x3D; \int_0^{2\pi} a\cos t \cdot b\cos t , dt<br>$$<br>$$<br>&#x3D; ab \int_0^{2\pi} \cos^2 t , dt<br>$$<br>利用 $\int_0^{2\pi} \cos^2 t , dt &#x3D; \pi$，得：<br>$$<br>A &#x3D; ab\pi<br>$$<br>这与椭圆面积公式 $A &#x3D; \pi ab$ 一致。</p><hr><h3 id="29-2-采用极坐标方程计算面积"><a href="#29-2-采用极坐标方程计算面积" class="headerlink" title="29.2. 采用极坐标方程计算面积"></a><strong>29.2. 采用极坐标方程计算面积</strong></h3><p>若区域由<strong>极坐标方程</strong>：<br>$$<br>r &#x3D; f(\theta), \quad \theta \in [\alpha, \beta]<br>$$<br>给出，则面积 $A$ 由以下积分计算：<br>$$<br>A &#x3D; \frac{1}{2} \int_\alpha^\beta r^2 , d\theta<br>$$<br>其中：</p><ul><li>$r &#x3D; f(\theta)$ 是极坐标曲线的方程。</li></ul><p><strong>示例</strong><br>求<strong>极坐标方程</strong> $r &#x3D; a\cos\theta$ 代表的<strong>心形曲线</strong>的面积：</p><ol><li>取对称区域 $0 \leq \theta \leq \pi&#x2F;2$ 计算面积：<br>$$<br>A &#x3D; \frac{1}{2} \int_0^{\frac{\pi}{2}} (a\cos\theta)^2 , d\theta<br>$$</li><li>计算积分：<br>$$<br>A &#x3D; \frac{a^2}{2} \int_0^{\frac{\pi}{2}} \cos^2\theta , d\theta<br>$$<br>利用 $\int \cos^2 \theta , d\theta &#x3D; \frac{\theta}{2} + \frac{\sin 2\theta}{4}$，计算：<br>$$<br>A &#x3D; \frac{a^2}{2} \left( \frac{\pi}{4} + 0 \right) &#x3D; \frac{a^2\pi}{8}<br>$$</li><li>由于曲线关于 $x$ 轴对称，完整的面积为：<br>$$<br>A_{\text{总}} &#x3D; 4 \times \frac{a^2\pi}{8} &#x3D; \frac{a^2\pi}{2}<br>$$</li></ol><hr><h3 id="29-3-总结"><a href="#29-3-总结" class="headerlink" title="29.3. 总结"></a><strong>29.3. 总结</strong></h3><ol><li><p><strong>参数方程的面积公式</strong>：<br>$$<br>A &#x3D; \int_a^b x(t) \frac{dy}{dt} , dt<br>$$<br>或<br>$$<br>A &#x3D; -\int_a^b y(t) \frac{dx}{dt} , dt<br>$$</p><ul><li>适用于<strong>参数化曲线围成的区域</strong>。</li><li>计算时需要求 $x$ 和 $y$ 对 $t$ 的导数。</li></ul></li><li><p><strong>极坐标方程的面积公式</strong>：<br>$$<br>A &#x3D; \frac{1}{2} \int_\alpha^\beta r^2 , d\theta<br>$$</p><ul><li>适用于<strong>极坐标描述的封闭曲线</strong>。</li><li>计算时需要对 $r^2$ 进行积分。</li></ul></li><li><p><strong>应用</strong>：</p><ul><li>计算<strong>椭圆、心形曲线、玫瑰曲线</strong>等的面积。</li><li><strong>物理应用</strong>：如<strong>天文学中的行星轨道面积计算</strong>等。</li></ul></li></ol><h2 id="30-圆锥曲线"><a href="#30-圆锥曲线" class="headerlink" title="30. 圆锥曲线"></a>30. 圆锥曲线</h2><p>设圆锥曲线的一般方程为：<br>$$<br>Ax^2 + Bxy + Cy^2 + Dx + Ey + F &#x3D; 0<br>$$</p><p>将 $f(x, y)$ 写为上面圆锥曲线的一般式，可以求偏导：</p><ul><li>$\frac{\partial f}{\partial x} &#x3D; 2Ax + By + D$</li><li>$\frac{\partial f}{\partial y} &#x3D; 2Cy + Bx + E$</li></ul><p>于是，代入点 $(x_0, y_0)$，切线方程为：<br>$$<br>(2Ax_0 + By_0 + D)(x - x_0) + (2Cy_0 + Bx_0 + E)(y - y_0) &#x3D; 0<br>$$</p><h3 id="30-1-椭圆的切线"><a href="#30-1-椭圆的切线" class="headerlink" title="30.1 椭圆的切线"></a>30.1 椭圆的切线</h3><p>求椭圆 $\displaystyle \frac{x^2}{a^2} + \frac{y^2}{b^2} &#x3D; 1$ 在点 $(x_0, y_0)$ 处的切线。</p><p>将椭圆方程改写为标准形式：<br>$$<br>f(x, y) &#x3D; \frac{x^2}{a^2} + \frac{y^2}{b^2} - 1 &#x3D; 0<br>$$</p><p>对 $x$、$y$ 分别求偏导：</p><ul><li>$\frac{\partial f}{\partial x} &#x3D; \frac{2x}{a^2}$</li><li>$\frac{\partial f}{\partial y} &#x3D; \frac{2y}{b^2}$</li></ul><p>代入点 $(x_0, y_0)$，切线方程为：<br>$$<br>\frac{2x_0}{a^2}(x - x_0) + \frac{2y_0}{b^2}(y - y_0) &#x3D; 0<br>$$</p><p>整理得：<br>$$<br>\frac{x_0x}{a^2} + \frac{y_0y}{b^2} &#x3D; 1<br>$$</p><p>这就是<strong>椭圆在点 $(x_0, y_0)$ 处的切线方程</strong>。</p><hr><h3 id="30-2-抛物线的切线公式"><a href="#30-2-抛物线的切线公式" class="headerlink" title="30.2 抛物线的切线公式"></a>30.2 抛物线的切线公式</h3><p>设标准抛物线为：<br>$$<br>y^2 &#x3D; 2px<br>$$</p><p>将其写为隐函数形式：<br>$$<br>f(x, y) &#x3D; y^2 - 2px &#x3D; 0<br>$$</p><p>求偏导数：</p><ul><li>$\frac{\partial f}{\partial x} &#x3D; -2p$</li><li>$\frac{\partial f}{\partial y} &#x3D; 2y$</li></ul><p>根据切线公式代入得：<br>$$<br>(-2p)(x - x_0) + 2y_0(y - y_0) &#x3D; 0<br>$$</p><p>整理得：<br>$$<br>y_0 y &#x3D; p(x + x_0)<br>$$</p><p>这就是<strong>抛物线 $y^2 &#x3D; 2px$ 在点 $(x_0, y_0)$ 的切线方程</strong>。</p><hr><h3 id="30-3-双曲线的切线公式"><a href="#30-3-双曲线的切线公式" class="headerlink" title="30.3 双曲线的切线公式"></a>30.3 双曲线的切线公式</h3><p>设标准双曲线为：<br>$$<br>\frac{x^2}{a^2} - \frac{y^2}{b^2} &#x3D; 1<br>$$</p><p>写为隐函数形式：<br>$$<br>f(x, y) &#x3D; \frac{x^2}{a^2} - \frac{y^2}{b^2} - 1 &#x3D; 0<br>$$</p><p>求偏导：</p><ul><li>$\frac{\partial f}{\partial x} &#x3D; \frac{2x}{a^2}$</li><li>$\frac{\partial f}{\partial y} &#x3D; -\frac{2y}{b^2}$</li></ul><p>代入切线公式：<br>$$<br>\frac{2x_0}{a^2}(x - x_0) - \frac{2y_0}{b^2}(y - y_0) &#x3D; 0<br>$$</p><p>整理得：<br>$$<br>\frac{x_0 x}{a^2} - \frac{y_0 y}{b^2} &#x3D; 1<br>$$</p><p>这就是<strong>双曲线 $\frac{x^2}{a^2} - \frac{y^2}{b^2} &#x3D; 1$ 在点 $(x_0, y_0)$ 的切线方程</strong>。</p><h2 id="31-定积分求导"><a href="#31-定积分求导" class="headerlink" title="31. 定积分求导"></a>31. 定积分求导</h2><p>设函数 $f(x, t)$ 关于 $t$ 可积，且在 $x$ 上也具有适当的可导性质。考虑以下形式的积分函数：<br>$$<br>F(x) &#x3D; \int_{a}^{b} f(x, t) , dt<br>$$</p><h3 id="31-1-常数上下限的定积分求导（换序法则）"><a href="#31-1-常数上下限的定积分求导（换序法则）" class="headerlink" title="31.1 常数上下限的定积分求导（换序法则）"></a>31.1 常数上下限的定积分求导（换序法则）</h3><p>若 $f(x, t)$ 在 $x$ 关于导数存在，且在 $[a, b]$ 关于 $t$ 连续，则：<br>$$<br>\frac{d}{dx} \left( \int_a^b f(x, t) , dt \right) &#x3D; \int_a^b \frac{\partial f}{\partial x}(x, t) , dt<br>$$</p><blockquote><p>✅ <strong>这称为「在积分号内求导」的法则。</strong></p></blockquote><p><strong>示例 1</strong></p><p>计算：<br>$$<br>\frac{d}{dx} \left( \int_0^1 x t^2 , dt \right)<br>$$</p><p>我们有：<br>$$<br>f(x, t) &#x3D; x t^2 \quad \Rightarrow \quad \frac{\partial f}{\partial x} &#x3D; t^2<br>$$</p><p>所以：<br>$$<br>\frac{d}{dx} \left( \int_0^1 x t^2 , dt \right) &#x3D; \int_0^1 t^2 , dt &#x3D; \frac{1}{3}<br>$$</p><hr><h3 id="31-2-变上限积分函数的导数（基本形式）"><a href="#31-2-变上限积分函数的导数（基本形式）" class="headerlink" title="31.2 变上限积分函数的导数（基本形式）"></a>31.2 变上限积分函数的导数（基本形式）</h3><p>设：<br>$$<br>F(x) &#x3D; \int_a^x f(t) , dt<br>$$</p><p>若 $f(t)$ 在 $[a, x]$ 上连续，则：<br>$$<br>\frac{dF}{dx} &#x3D; f(x)<br>$$</p><blockquote><p>✅ <strong>这就是著名的「微积分基本定理」的一个形式。</strong></p></blockquote><p><strong>示例 2</strong></p><p>设：<br>$$<br>F(x) &#x3D; \int_1^x \ln t , dt<br>$$</p><p>则：<br>$$<br>F’(x) &#x3D; \ln x<br>$$</p><hr><h3 id="31-3-上下限都为函数的情形（莱布尼茨公式）"><a href="#31-3-上下限都为函数的情形（莱布尼茨公式）" class="headerlink" title="31.3 上下限都为函数的情形（莱布尼茨公式）"></a>31.3 上下限都为函数的情形（莱布尼茨公式）</h3><p>若：<br>$$<br>F(x) &#x3D; \int_{u(x)}^{v(x)} f(x, t) , dt<br>$$</p><p>则导数为：<br>$$<br>F’(x) &#x3D; f(x, v(x)) \cdot v’(x) - f(x, u(x)) \cdot u’(x) + \int_{u(x)}^{v(x)} \frac{\partial f}{\partial x}(x, t) , dt<br>$$</p><blockquote><p>✅ <strong>这是最一般形式的定积分求导公式（莱布尼茨公式）。</strong></p></blockquote><p><strong>示例 3</strong></p><p>设：<br>$$<br>F(x) &#x3D; \int_{x}^{x^2} \sin t , dt<br>$$</p><p>此时：</p><ul><li>$u(x) &#x3D; x \Rightarrow u’(x) &#x3D; 1$</li><li>$v(x) &#x3D; x^2 \Rightarrow v’(x) &#x3D; 2x$</li><li>$f(t) &#x3D; \sin t$</li></ul><p>代入公式得：<br>$$<br>F’(x) &#x3D; \sin(x^2) \cdot 2x - \sin(x) \cdot 1 &#x3D; 2x\sin(x^2) - \sin x<br>$$</p><h2 id="32-常见三角函数的积、商、幂的积分整理表"><a href="#32-常见三角函数的积、商、幂的积分整理表" class="headerlink" title="32. 常见三角函数的积、商、幂的积分整理表"></a>32. 常见三角函数的积、商、幂的积分整理表</h2><p>三角代换在处理以下三类无理根号表达式的定积分中非常有效：</p><h3 id="一、遇到-sqrt-a-2-x-2-类型"><a href="#一、遇到-sqrt-a-2-x-2-类型" class="headerlink" title="一、遇到 $\sqrt{a^2 - x^2}$ 类型"></a><strong>一、遇到 $\sqrt{a^2 - x^2}$ 类型</strong></h3><blockquote><p>令 $x &#x3D; a\sin\theta$，$\theta \in \left[-\frac{\pi}{2}, \frac{\pi}{2}\right]$</p></blockquote><p>代换后：<br>$$<br>\sqrt{a^2 - x^2} &#x3D; \sqrt{a^2 - a^2\sin^2\theta} &#x3D; a\cos\theta<br>$$</p><p><strong>示例 1</strong></p><p>计算：<br>$$<br>\int_0^a \sqrt{a^2 - x^2} , dx<br>$$</p><p>令 $x &#x3D; a\sin\theta$，则 $dx &#x3D; a\cos\theta, d\theta$</p><p>当 $x &#x3D; 0 \Rightarrow \theta &#x3D; 0$，$x &#x3D; a \Rightarrow \theta &#x3D; \frac{\pi}{2}$</p><p>积分变为：<br>$$<br>\int_0^{\pi&#x2F;2} a\cos\theta \cdot a\cos\theta , d\theta &#x3D; a^2 \int_0^{\pi&#x2F;2} \cos^2 \theta , d\theta<br>&#x3D; a^2 \cdot \frac{\pi}{4}<br>$$</p><p>所以：<br>$$<br>\int_0^a \sqrt{a^2 - x^2} , dx &#x3D; \frac{\pi a^2}{4}<br>$$</p><p>这实际上是<strong>四分之一圆的面积</strong>！</p><hr><h3 id="二、遇到-sqrt-a-2-x-2-类型"><a href="#二、遇到-sqrt-a-2-x-2-类型" class="headerlink" title="二、遇到 $\sqrt{a^2 + x^2}$ 类型"></a><strong>二、遇到 $\sqrt{a^2 + x^2}$ 类型</strong></h3><blockquote><p>令 $x &#x3D; a\tan\theta$，$\theta \in \left(-\frac{\pi}{2}, \frac{\pi}{2}\right)$</p></blockquote><p>代换后：<br>$$<br>\sqrt{a^2 + x^2} &#x3D; a\sec\theta<br>$$</p><hr><h3 id="三、遇到-sqrt-x-2-a-2-类型"><a href="#三、遇到-sqrt-x-2-a-2-类型" class="headerlink" title="三、遇到 $\sqrt{x^2 - a^2}$ 类型"></a><strong>三、遇到 $\sqrt{x^2 - a^2}$ 类型</strong></h3><blockquote><p>令 $x &#x3D; a\sec\theta$，$\theta \in [0, \frac{\pi}{2}) \cup (\pi, \frac{3\pi}{2})$</p></blockquote><p>代换后：<br>$$<br>\sqrt{x^2 - a^2} &#x3D; a\tan\theta<br>$$</p><p><strong>小结图表：三角代换记忆表</strong></p><table><thead><tr><th>根号类型</th><th>代换方法</th><th>$\sqrt{\cdots}$ 的结果</th></tr></thead><tbody><tr><td>$\sqrt{a^2 - x^2}$</td><td>$x &#x3D; a\sin\theta$</td><td>$a\cos\theta$</td></tr><tr><td>$\sqrt{a^2 + x^2}$</td><td>$x &#x3D; a\tan\theta$</td><td>$a\sec\theta$</td></tr><tr><td>$\sqrt{x^2 - a^2}$</td><td>$x &#x3D; a\sec\theta$</td><td>$a\tan\theta$</td></tr></tbody></table><h2 id="偷偷说"><a href="#偷偷说" class="headerlink" title="偷偷说"></a>偷偷说</h2><p>基本上能把考试要用到的最重要的点Cover掉了；当然求旋转体的体积也是一个很重要的考点，不过偷偷在这里就不赘述了…做数学题这件事仿佛离我的生活越来越远了，但是偷偷一直在用数学的方式在思考:)</p>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Calculus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS Concepts</title>
    <link href="/2025/02/09/CS-Concepts/"/>
    <url>/2025/02/09/CS-Concepts/</url>
    
    <content type="html"><![CDATA[<h1 id="CS-Concepts"><a href="#CS-Concepts" class="headerlink" title="CS Concepts"></a>CS Concepts</h1><p>本章笔记着重对CS相关专业科目的名词进行解释，在修考问答题和面试八股文场景下适用。这些名词都来源于CS相关学科。本篇笔记内容按科目划分，每个科目下面有对应的常见高频名词解释（中&#x2F;英）。</p><h2 id="1-Data-Stucture-Algorithms"><a href="#1-Data-Stucture-Algorithms" class="headerlink" title="1. Data Stucture &amp; Algorithms"></a>1. Data Stucture &amp; Algorithms</h2><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3><p>A Hash Table is a data structure that maps keys to values using a hash function. It stores data in an array-like structure, where each key is hashed to an index. Collisions (when different keys map to the same index) are handled using techniques like chaining or open addressing. Hash tables provide average O(1) time complexity for insertion, deletion, and lookup. They are widely used in databases, caching, and symbol tables.<br><img src="/img/concepts/hash.jpg" alt="Hash Table" style="max-width: 70%; height: auto;" /></p><hr><h3 id="Hash-Collision-Hash-Clash"><a href="#Hash-Collision-Hash-Clash" class="headerlink" title="Hash Collision &#x2F; Hash Clash"></a>Hash Collision &#x2F; Hash Clash</h3><p>A <strong>hash collision (hash clash)</strong> occurs when two different inputs produce the same hash value in a hash function. Since hash functions map a large input space to a smaller output space, collisions are inevitable due to the <strong>pigeonhole principle</strong>. Collisions can weaken security in cryptographic hashes (e.g., MD5, SHA-1) and reduce efficiency in hash tables. Techniques like <strong>chaining, open addressing, and better hash functions</strong> help mitigate collisions. Stronger cryptographic hashes (e.g., SHA-256) minimize the risk of intentional hash clashes (collision attacks).</p><hr><h3 id="Open-Addressing-Closed-Hashing"><a href="#Open-Addressing-Closed-Hashing" class="headerlink" title="Open Addressing &#x2F; Closed Hashing"></a>Open Addressing &#x2F; Closed Hashing</h3><p><strong>Open addressing</strong> is a collision resolution technique in hash tables where all elements are stored directly in the table without external chaining. When a collision occurs, the algorithm searches for the next available slot using a probing sequence (e.g., <strong>linear probing, quadratic probing, or double hashing</strong>). <strong>Linear probing</strong> checks the next slot sequentially, <strong>quadratic probing</strong> uses a quadratic function to find slots, and <strong>double hashing</strong> applies a second hash function for probing. Open addressing avoids linked lists, reducing memory overhead but may suffer from clustering. It works best when the load factor is kept low to maintain efficient lookups.</p><hr><h3 id="Seperate-Chaining"><a href="#Seperate-Chaining" class="headerlink" title="Seperate Chaining"></a>Seperate Chaining</h3><p><strong>Separate chaining</strong> is a collision resolution technique in hash tables where each bucket stores multiple values using a linked list (or another data structure like a BST). When a collision occurs, the new element is simply added to the linked list at that index. This method allows the table to handle an unlimited number of collisions but increases memory usage. Performance depends on the length of the chains; with a well-distributed hash function, the average lookup time remains <strong>O(1) in best case</strong> and <strong>O(n) in worst case</strong>. <strong>Rehashing</strong> or using a larger table can help maintain efficiency.</p><img src="/img/concepts/hash2.jpg" alt="Hash Table" style="max-width: 100%; height: auto;" /><hr><h3 id="P-≠-NP"><a href="#P-≠-NP" class="headerlink" title="P ≠ NP"></a>P ≠ NP</h3><p><strong>P ≠ NP</strong> means that not all problems whose solutions can be <em>verified quickly</em> (in polynomial time) can also be <em>solved quickly</em>.<br><strong>P</strong> is the class of problems that can be <strong>solved</strong> in polynomial time.<br><strong>NP</strong> is the class of problems whose solutions can be <strong>verified</strong> in polynomial time.<br>The question is: if a problem’s solution can be verified quickly, can it also be found quickly?<br>Most experts believe <strong>P ≠ NP</strong>, but it has not been proven yet.</p><img src="/img/concepts/pnp.jpg" alt="Hash Table" style="max-width: 100%; height: auto;" /><hr><h3 id="NP-Hard-Problems"><a href="#NP-Hard-Problems" class="headerlink" title="NP Hard Problems"></a>NP Hard Problems</h3><p>NP-Hard problems are computational problems that are at least as difficult as the hardest problems in NP (nondeterministic polynomial time). Solving an NP-Hard problem quickly would mean we could solve every NP problem quickly too, but no such efficient solution is known. These problems may not even have verifiable solutions in polynomial time. They often involve optimization or decision-making with many possibilities, like scheduling, routing, or packing.Examples include the Traveling Salesman Problem and Knapsack Problem.</p><hr><h3 id="NP-Complete-Problems"><a href="#NP-Complete-Problems" class="headerlink" title="NP-Complete Problems"></a>NP-Complete Problems</h3><p><strong>NP-Complete problems</strong> are a special class of problems that are both:</p><ol><li><strong>In NP</strong> – their solutions can be verified in polynomial time, and</li><li><strong>NP-Hard</strong> – as hard as the hardest problems in NP.</li></ol><p>If you can solve any NP-Complete problem quickly (in polynomial time), you can solve <em>all</em> NP problems quickly. Famous examples include the <strong>Boolean Satisfiability Problem (SAT)</strong> and <strong>Traveling Salesman Problem (decision version)</strong>.</p><hr><h3 id="The-Travelling-Salesman-Problem"><a href="#The-Travelling-Salesman-Problem" class="headerlink" title="The Travelling Salesman Problem"></a>The Travelling Salesman Problem</h3><p>The <strong>Travelling Salesman Problem (TSP)</strong> asks for the shortest possible route that visits each city once and returns to the starting city.<br>It is a classic <strong>combinatorial optimization</strong> problem in computer science and operations research.<br>TSP is <strong>NP-hard</strong>, meaning there’s no known efficient algorithm to solve all cases quickly.<br>Exact solutions use methods like <strong>brute force</strong>, <strong>dynamic programming</strong>, or <strong>branch and bound</strong>.<br>Approximation and heuristic algorithms (e.g. genetic algorithms, simulated annealing) are used for large instances.</p><img src="/img/concepts/tsp.svg" alt="TSP" style="max-width: 100%; height: auto;" /><hr><h3 id="The-Knapsack-Problem"><a href="#The-Knapsack-Problem" class="headerlink" title="The Knapsack Problem"></a>The Knapsack Problem</h3><p>The <strong>Knapsack Problem</strong> asks how to choose items with given weights and values to maximize total value without exceeding a weight limit.<br>Each item can be either included or excluded (0-1 Knapsack).<br>It’s a classic <strong>NP-hard</strong> optimization problem.<br>Dynamic programming is commonly used for exact solutions.<br>Greedy or approximation methods are used for large instances.</p><hr><h3 id="The-SAT-Boolean-Satisfiability-problem"><a href="#The-SAT-Boolean-Satisfiability-problem" class="headerlink" title="The SAT (Boolean Satisfiability) problem"></a>The SAT (Boolean Satisfiability) problem</h3><p>The <strong>SAT (Boolean Satisfiability)</strong> problem asks whether there exists an assignment of true&#x2F;false values to variables that makes a Boolean formula true.<br>It’s the <strong>first problem proven to be NP-complete</strong>.<br>The formula is usually given in <strong>CNF (Conjunctive Normal Form)</strong>.<br>SAT solvers use techniques like backtracking and clause learning.<br>Many real-world problems (e.g. planning, verification) can be reduced to SAT.</p><hr><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><p><strong>Divide and Conquer</strong> is a problem-solving strategy that works in three main steps:</p><ol><li><strong>Divide</strong> the problem into smaller sub-problems of the same type.</li><li><strong>Conquer</strong> each sub-problem by solving them recursively.</li><li><strong>Combine</strong> the solutions of sub-problems to get the final result.</li></ol><p>Classic examples include <strong>Merge Sort</strong>, <strong>Quick Sort</strong>, and <strong>Binary Search</strong>.</p><hr><h3 id="Branch-and-Bound"><a href="#Branch-and-Bound" class="headerlink" title="Branch and Bound"></a>Branch and Bound</h3><p>Branch and Bound is an algorithmic paradigm for solving combinatorial optimization problems efficiently. It systematically divides the solution space into smaller subproblems (branching) and computes bounds to eliminate unpromising branches early (pruning). The method maintains an upper bound from feasible solutions and a lower bound from relaxed problems, allowing it to discard branches that cannot contain the optimal solution. This approach significantly reduces the search space compared to exhaustive enumeration, making it effective for problems like integer programming, traveling salesman, and knapsack problems.</p><img src="/img/concepts/bnb.svg" alt="Branch and Bound" style="max-width: 100%; height: auto;" /><hr><h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h3><p>A <strong>B-tree</strong> is a self-balancing search tree that maintains sorted data for efficient insertion, deletion, and search in <strong>O(log n)</strong> time.<br>It allows each node to have <strong>multiple keys and children</strong>, making it wider and shallower than binary trees.<br>All leaf nodes are at the same level, ensuring the tree stays balanced.<br>It’s widely used in <strong>databases and file systems</strong> for fast disk-based access.</p><img src="/img/concepts/btree.svg" alt="Hash Table" style="max-width: 100%; height: auto;" /><hr><h3 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h3><p><strong>Heap Sort</strong> is a comparison-based sorting algorithm that uses a <strong>binary heap</strong> data structure. It works in two main steps:</p><ol><li><strong>Build a Max Heap</strong> from the input data so that the largest element is at the root.</li><li><strong>Extract the root (maximum element)</strong>, swap it with the last item, reduce the heap size, and <strong>heapify</strong> the root to maintain the max heap. Repeat until the heap is empty.</li></ol><p>Time Complexity: <strong>Best, Average, Worst:</strong> O(n log n)</p><p>Key Characteristics:</p><ul><li><strong>In-place</strong> sorting (no extra space needed)</li><li><strong>Not stable</strong></li><li>Good for scenarios where memory is limited and performance is important.</li></ul><hr><h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><p><strong>Merge Sort</strong> is a <strong>divide and conquer</strong> sorting algorithm that divides the input array into smaller parts, sorts them, and then merges the sorted parts.</p><p>Steps:</p><ol><li><strong>Divide</strong> the array into two halves.</li><li><strong>Recursively sort</strong> each half.</li><li><strong>Merge</strong> the two sorted halves into one sorted array.</li></ol><p>Time Complexity:</p><ul><li><strong>Best, Average, Worst:</strong> O(n log n)</li></ul><p>Key Characteristics:</p><ul><li><strong>Stable</strong> sort</li><li><strong>Not in-place</strong> (uses extra space for merging)</li><li>Great for sorting linked lists or large datasets with consistent performance.</li></ul><hr><h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p><strong>Quick Sort</strong> is a <strong>divide and conquer</strong> sorting algorithm that works by selecting a <strong>pivot</strong> element and partitioning the array into two parts:</p><p>Steps:</p><ol><li><strong>Choose a pivot</strong> (e.g., first, last, or random element).</li><li><strong>Partition</strong> the array: elements less than pivot go left, greater go right.</li><li><strong>Recursively apply</strong> Quick Sort to the left and right parts.</li></ol><p>Time Complexity:</p><ul><li><strong>Best &amp; Average:</strong> O(n log n)</li><li><strong>Worst (unbalanced partition):</strong> O(n²)</li></ul><p>Key Characteristics:</p><ul><li><strong>In-place</strong></li><li><strong>Not stable</strong></li><li>Very fast in practice with good pivot selection</li></ul><hr><h3 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h3><p>The A* algorithm finds the shortest path by combining actual cost from the start (g) and estimated cost to the goal (h).<br>It selects nodes with the lowest total cost <code>f(n) = g(n) + h(n)</code>.<br>It uses a priority queue to explore the most promising paths first.<br>The heuristic <code>h(n)</code> must not overestimate to ensure optimality.<br>It’s widely used in games, maps, and AI for efficient pathfinding.</p><img src="/img/concepts/astar.svg" alt="A* Algorithm" style="max-width: 100%; height: auto;" /><hr><h3 id="Minimax-Algorithm"><a href="#Minimax-Algorithm" class="headerlink" title="Minimax Algorithm"></a>Minimax Algorithm</h3><p>The <strong>Minimax algorithm</strong> is used in two-player games to find the optimal move by assuming both players play optimally.<br>It recursively explores all possible moves, maximizing the player’s score and minimizing the opponent’s.<br>“Max” tries to get the highest score; “Min” tries to get the lowest.<br>The game tree is evaluated using a scoring function at terminal states.<br>It’s often optimized with <strong>alpha-beta pruning</strong> to skip unnecessary branches.</p><img src="/img/concepts/minimax.svg" alt="Minimax Algorithm" style="max-width: 100%; height: auto;" /><hr><h3 id="🤖-Alpha-Beta-Pruning"><a href="#🤖-Alpha-Beta-Pruning" class="headerlink" title="🤖 Alpha-Beta Pruning"></a>🤖 Alpha-Beta Pruning</h3><p><strong>Alpha-Beta Pruning</strong> is an <strong>optimization technique</strong> for the <strong>Minimax algorithm</strong> used in <strong>two-player games</strong> (like chess or tic-tac-toe).<br>It <strong>reduces the number of nodes</strong> evaluated in the game tree <strong>without affecting the final result</strong>.</p><p><strong>🧠 How It Works</strong></p><ul><li><strong>Alpha (α):</strong> the best <strong>already explored</strong> value for the <strong>maximizing</strong> player.</li><li><strong>Beta (β):</strong> the best <strong>already explored</strong> value for the <strong>minimizing</strong> player.</li></ul><p>While traversing the tree:</p><ul><li>If the <strong>current branch</strong> cannot possibly influence the final decision (because it’s worse than previously examined branches), it is <strong>pruned</strong> (skipped).</li></ul><p><strong>✅ Benefits</strong></p><ul><li>Same result as Minimax, but faster</li><li>Reduces time complexity from <strong>O(b^d)</strong> to <strong>O(b^(d&#x2F;2))</strong> in the best case<br>(where <code>b</code> is branching factor, <code>d</code> is depth)</li></ul><p><strong>📌 Example</strong></p><p>In a minimax tree:</p><ul><li>If a <strong>max node</strong> finds a value <strong>≥ β</strong>, it <strong>stops</strong> exploring further children.</li><li>If a <strong>min node</strong> finds a value <strong>≤ α</strong>, it <strong>prunes</strong> the remaining branches.</li></ul><p><strong>🎯 Use Cases</strong></p><ul><li>AI game engines</li><li>Decision-making in adversarial environments</li><li>Game tree search optimization</li></ul><h2 id="2-Operating-System"><a href="#2-Operating-System" class="headerlink" title="2. Operating System"></a>2. Operating System</h2><h3 id="Procss-Thread"><a href="#Procss-Thread" class="headerlink" title="Procss &amp; Thread"></a>Procss &amp; Thread</h3><p>A process is the basic unit of resource allocation and scheduling in an operating system, with its own independent address space and resources. A thread is the basic unit of CPU scheduling, and a process can contain multiple threads that share the process’s memory and resources. Threads switch faster and have lower overhead, making them suitable for concurrent execution. In contrast, processes are independent of each other, with higher switching overhead but greater stability. While multithreading improves execution efficiency, it also introduces challenges such as synchronization and mutual exclusion.</p><img src="/img/concepts/process.svg" alt="Process & Thread" style="max-width: 100%; height: auto;" /><hr><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>A <strong>semaphore</strong> in an operating system is a synchronization tool used to manage <strong>concurrent access to shared resources</strong> by multiple processes or threads.</p><p><strong>Key Points:</strong></p><ul><li><p>It is an <strong>integer variable</strong> that controls access based on its value.</p></li><li><p>There are two main operations:</p><ul><li><strong>wait (P)</strong>: Decreases the semaphore value. If the result is negative, the process is blocked.</li><li><strong>signal (V)</strong>: Increases the semaphore value. If there are blocked processes, one is unblocked.</li></ul></li></ul><p><strong>Types:</strong></p><ol><li><strong>Binary Semaphore</strong>: Takes values 0 or 1, similar to a mutex.</li><li><strong>Counting Semaphore</strong>: Can take non-negative integer values, used to control access to a resource with multiple instances.</li></ol><p><strong>Use Case:</strong></p><p>Semaphores help <strong>avoid race conditions</strong>, <strong>deadlocks</strong>, and ensure <strong>mutual exclusion</strong> in critical sections.</p><p>Example use: Controlling access to a printer shared by multiple processes.</p><hr><h3 id="Critical-Section"><a href="#Critical-Section" class="headerlink" title="Critical Section"></a>Critical Section</h3><p>A <strong>Critical Section</strong> in an operating system is a part of a program where a <strong>shared resource</strong> (like a variable, file, or device) is accessed. Since shared resources can be corrupted if accessed by multiple processes or threads simultaneously, <strong>only one process should enter the critical section at a time</strong>.</p><p><strong>Key Concepts:</strong></p><ul><li><strong>Mutual Exclusion</strong>: Ensures that only one process is in the critical section at any given time.</li><li><strong>Entry Section</strong>: Code that requests entry to the critical section.</li><li><strong>Exit Section</strong>: Code that signals the process is leaving the critical section.</li><li><strong>Remainder Section</strong>: All other code outside the critical section.</li></ul><blockquote><p>Goals of Critical Section Management:</p></blockquote><ol><li><strong>Mutual Exclusion</strong> – Only one process in the critical section at a time.</li><li><strong>Progress</strong> – If no process is in the critical section, one of the waiting processes should be allowed to enter.</li><li><strong>Bounded Waiting</strong> – A process should not wait forever to enter the critical section.</li></ol><p><strong>Tools Used:</strong></p><ul><li><strong>Semaphores</strong></li><li><strong>Mutexes</strong></li><li><strong>Monitors</strong></li><li><strong>Locks</strong></li></ul><p>These tools help implement and manage access to critical sections safely.</p><hr><h2 id="3-Computer-Architecture"><a href="#3-Computer-Architecture" class="headerlink" title="3. Computer Architecture"></a>3. Computer Architecture</h2><h3 id="Pipeline-hazard"><a href="#Pipeline-hazard" class="headerlink" title="Pipeline hazard"></a>Pipeline hazard</h3><p>A <strong>pipeline hazard</strong> in computer architecture refers to a situation that <strong>prevents the next instruction in the pipeline from executing at its expected time</strong>, causing delays.</p><p><strong>Types of Pipeline Hazards:</strong></p><ol><li><p><strong>Data Hazard</strong>:<br>Occurs when instructions <strong>depend on the result of a previous instruction</strong> that hasn’t completed yet.<br>Example:</p><figure><div class="code-wrapper"><pre class="line-numbers language-pgsql" data-language="pgsql"><code class="language-pgsql">ADD R1, R2, R3  SUB R4, R1, R5  ← depends on R1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p><strong>Control Hazard</strong> (Branch Hazard):<br>Happens when the pipeline makes <strong>wrong predictions about instruction flow</strong>, such as branches or jumps.</p></li><li><p><strong>Structural Hazard</strong>:<br>Arises when <strong>hardware resources are insufficient</strong> to support all instructions in parallel (e.g., one memory unit shared by two stages).</p></li></ol><p><strong>Solution Techniques:</strong></p><ul><li><strong>Forwarding (data hazard)</strong></li><li><strong>Stalling (inserting bubbles)</strong></li><li><strong>Branch prediction (control hazard)</strong></li><li><strong>Adding hardware units (structural hazard)</strong></li></ul><p>Pipeline hazards reduce performance and must be carefully handled in modern CPUs.</p><hr><h3 id="Data-hazard"><a href="#Data-hazard" class="headerlink" title="Data hazard"></a>Data hazard</h3><p>A <strong>data hazard</strong> occurs in a pipelined processor when an instruction depends on the <strong>result of a previous instruction</strong> that has not yet completed, causing a conflict in data access.</p><p><strong>Types of Data Hazards:</strong></p><ol><li><p><strong>RAW (Read After Write)</strong> – Most common<br>An instruction needs to <strong>read</strong> a register that a previous instruction will <strong>write</strong>, but the write hasn’t happened yet.<br>Example:</p><figure><div class="code-wrapper"><pre class="line-numbers language-pgsql" data-language="pgsql"><code class="language-pgsql">ADD R1, R2, R3  SUB R4, R1, R5  ← needs R1 before it&#39;s written<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li><li><p><strong>WAR (Write After Read)</strong> – Rare in simple pipelines<br>A later instruction writes to a register <strong>before</strong> an earlier instruction reads it.</p></li><li><p><strong>WAW (Write After Write)</strong> – Happens in out-of-order execution<br>Two instructions write to the same register in the wrong order.</p></li></ol><p><strong>Solutions:</strong></p><ul><li><strong>Forwarding (bypassing)</strong> – Pass result directly to the next instruction.</li><li><strong>Stalling</strong> – Delay the dependent instruction until data is ready.</li></ul><p>Data hazards can slow down pipeline performance if not properly managed.</p><hr><h3 id="Control-hazard"><a href="#Control-hazard" class="headerlink" title="Control hazard"></a>Control hazard</h3><p>A <strong>control hazard</strong> (also called a <strong>branch hazard</strong>) occurs in pipelined processors when the <strong>flow of instruction execution changes</strong>, typically due to <strong>branch or jump instructions</strong>.</p><p><strong>Cause:</strong></p><p>The processor <strong>doesn’t know early enough</strong> whether a branch will be taken, so it may <strong>fetch the wrong instructions</strong>.</p><p><strong>Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">BEQ R1, R2, LABEL   ; Branch if R1 &#x3D;&#x3D; R2ADD R3, R4, R5      ; May be wrongly fetched if branch is taken<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>Solutions:</strong></p><ul><li><strong>Branch Prediction</strong> – Guess whether the branch will be taken.</li><li><strong>Branch Delay Slot</strong> – Always execute the instruction after the branch.</li><li><strong>Pipeline Flushing</strong> – Discard wrongly fetched instructions.</li><li><strong>Early Branch Resolution</strong> – Move branch decision to earlier pipeline stage.</li></ul><p>Control hazards can reduce pipeline efficiency by introducing <strong>stalls or flushes</strong>.</p><hr><h3 id="Structural-hazard"><a href="#Structural-hazard" class="headerlink" title="Structural hazard"></a>Structural hazard</h3><p>A <strong>structural hazard</strong> occurs in a pipelined processor when <strong>two or more instructions compete for the same hardware resource</strong> at the same time, and the hardware <strong>cannot handle all of them simultaneously</strong>.</p><p><strong>Example:</strong></p><p>If the CPU has <strong>one memory unit</strong> shared for both <strong>instruction fetch</strong> and <strong>data access</strong>, a conflict arises when:</p><ul><li>One instruction is being <strong>fetched</strong>, and</li><li>Another instruction needs to <strong>read&#x2F;write data</strong> from memory at the same time.</li></ul><p><strong>Solution:</strong></p><ul><li><strong>Add more hardware resources</strong> (e.g. separate instruction and data memory – like in Harvard architecture)</li><li><strong>Stall one of the instructions</strong> to resolve the conflict</li></ul><p>Structural hazards are <strong>less common</strong> in modern CPUs due to better hardware design but can still occur in resource-limited systems.</p><hr><h3 id="Dynamic-Branch-Prediction"><a href="#Dynamic-Branch-Prediction" class="headerlink" title="Dynamic Branch Prediction"></a>Dynamic Branch Prediction</h3><p><strong>Dynamic Branch Prediction</strong> is a technique used in modern CPUs to <strong>predict the outcome of branch instructions (e.g., if-else, loops) at runtime</strong>, based on the <strong>history of previous executions</strong>.</p><p><strong>Key Features:</strong></p><ul><li><strong>Learns from past behavior</strong> of branches.</li><li><strong>Updates prediction</strong> as the program runs.</li><li>More accurate than static prediction (which always predicts taken&#x2F;not taken).</li></ul><p><strong>Common Methods:</strong></p><ol><li><p><strong>1-bit predictor</strong>:<br>Remembers the last outcome (taken or not taken).</p></li><li><p><strong>2-bit predictor</strong>:<br>More stable; uses a state machine to change prediction only after two mispredictions.</p></li><li><p><strong>Branch History Table (BHT)</strong>:<br>Stores past branch outcomes and uses them for prediction.</p></li><li><p><strong>Global History &amp; Pattern History Table (PHT)</strong>:<br>Tracks patterns of multiple branches for more accuracy (used in <strong>two-level predictors</strong>).</p></li></ol><p><strong>Benefit:</strong></p><p>Improves <strong>pipeline efficiency</strong> by reducing <strong>control hazards</strong> and minimizing <strong>stall cycles</strong> caused by branch mispredictions.</p><img src="/img/concepts/dynamic_branch.svg" alt="Dynamic Branch Prediction" style="max-width: 100%; height: auto;" /><p>–</p><h3 id="Instruction-level-Parallelsim"><a href="#Instruction-level-Parallelsim" class="headerlink" title="Instruction-level Parallelsim"></a>Instruction-level Parallelsim</h3><p><strong>Instruction-Level Parallelism (ILP)</strong> refers to the ability of a CPU to <strong>execute multiple instructions simultaneously</strong> during a single clock cycle.</p><p><strong>Key Idea:</strong></p><p>Many instructions in a program are <strong>independent</strong> and can be executed in <strong>parallel</strong>, rather than strictly one after another.</p><p><strong>Types of ILP:</strong></p><ol><li><p><strong>Compiler-Level ILP (Static ILP)</strong><br>The <strong>compiler rearranges instructions</strong> at compile time to exploit parallelism (e.g., instruction scheduling).</p></li><li><p><strong>Hardware-Level ILP (Dynamic ILP)</strong><br>The <strong>CPU detects parallelism at runtime</strong>, using features like:</p><ul><li><strong>Pipelining</strong></li><li><strong>Superscalar execution</strong> (multiple execution units)</li><li><strong>Out-of-order execution</strong></li><li><strong>Speculative execution</strong></li></ul></li></ol><p><strong>Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ADD R1, R2, R3  MUL R4, R5, R6   ; Independent → can run in parallel with ADD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>Benefits:</strong></p><ul><li>Increases CPU performance <strong>without increasing clock speed</strong></li><li>Makes better use of CPU resources</li></ul><p><strong>Limitations:</strong></p><ul><li><strong>Data, control, and structural hazards</strong> limit ILP</li><li><strong>Dependence between instructions</strong> reduces parallelism</li></ul><p>Modern processors heavily rely on ILP for high-speed performance.</p><img src="/img/concepts/parallelism.svg" alt="Instruction-level Parallelsim" style="max-width: 100%; height: auto;" /><hr><h3 id="Clock-frequency"><a href="#Clock-frequency" class="headerlink" title="Clock frequency"></a>Clock frequency</h3><p><strong>Clock frequency</strong> (also called <strong>clock speed</strong>) is the rate at which a processor executes instructions, measured in <strong>Hertz (Hz)</strong> — typically in <strong>gigahertz (GHz)</strong> for modern CPUs.</p><p><strong>Key Points:</strong></p><ul><li><strong>1 GHz &#x3D; 1 billion cycles per second</strong></li><li>Each <strong>clock cycle</strong> is a tick of the CPU’s internal clock, during which it can perform basic operations (like fetch, decode, execute).</li><li>A <strong>higher clock frequency</strong> generally means the CPU can <strong>perform more operations per second</strong>.</li></ul><blockquote><p>Example: A CPU with <strong>3.0 GHz</strong> can perform <strong>3 billion clock cycles per second</strong>.</p></blockquote><p>Higher clock speed <strong>doesn’t always mean better performance</strong>, because:</p><ul><li>Other factors like <strong>Instruction-Level Parallelism (ILP)</strong>, <strong>number of cores</strong>, <strong>cache</strong>, and <strong>architecture efficiency</strong> also matter.</li><li>Very high clock speeds can cause <strong>more heat and power consumption</strong>.</li></ul><p><strong>Clock frequency &#x3D; speed of instruction processing</strong>, but <strong>not the only factor</strong> in CPU performance.</p><hr><h3 id="Register-renaming"><a href="#Register-renaming" class="headerlink" title="Register renaming"></a>Register renaming</h3><p><strong>Register renaming</strong> is a technique used in modern CPUs to <strong>eliminate false data dependencies</strong> (also called <em>name dependencies</em>) between instructions, allowing for more <strong>instruction-level parallelism (ILP)</strong> and better performance.</p><blockquote><p>Why It’s Needed?</p></blockquote><p>In pipelined or out-of-order execution, instructions may appear dependent due to <strong>using the same register name</strong>, even when there’s <strong>no real data dependency</strong>.</p><p>There are two main false dependencies:</p><ol><li><strong>Write After Write (WAW)</strong></li><li><strong>Write After Read (WAR)</strong></li></ol><p><strong>Example (with false dependency):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">1. ADD R1, R2, R3  2. SUB R1, R4, R5  ← falsely depends on instruction 1 (WAW)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>Both write to <code>R1</code>, but they’re unrelated operations. Register renaming removes this conflict.</p><blockquote><p>How It Works:</p></blockquote><ul><li>The CPU maintains a <strong>larger set of physical registers</strong> than the number of logical (visible) registers.</li><li>It dynamically assigns <strong>different physical registers</strong> to each instruction, even if they use the same logical name.</li><li>This avoids name-based conflicts, enabling <strong>out-of-order</strong> and <strong>parallel execution</strong>.</li></ul><p>Benefits:</p><ul><li><strong>Eliminates false dependencies</strong></li><li><strong>Increases parallelism</strong></li><li><strong>Improves CPU throughput</strong></li></ul><p>Summary:</p><p><strong>Register renaming</strong> helps CPUs <strong>run more instructions in parallel</strong> by resolving unnecessary register name conflicts, boosting performance.</p><hr><h3 id="Sign-Magnitude-Representation-原码"><a href="#Sign-Magnitude-Representation-原码" class="headerlink" title="Sign-Magnitude Representation (原码)"></a>Sign-Magnitude Representation (原码)</h3><p><strong>Sign-Magnitude Representation (原码)</strong> is a binary method for representing signed integers.</p><ul><li><strong>Sign bit</strong>: The most significant bit indicates the sign — <code>0</code> for positive, <code>1</code> for negative.</li><li><strong>Magnitude bits</strong>: The remaining bits represent the absolute value of the number in binary.</li></ul><p><strong>Example (using 8 bits):</strong></p><ul><li><code>+5</code> in sign-magnitude: <code>00000101</code></li><li><code>-5</code> in sign-magnitude: <code>10000101</code></li></ul><p><strong>Features:</strong></p><ul><li>Symmetrical representation for positive and negative numbers</li><li>Has <strong>two representations of zero</strong>: <code>00000000</code> (+0) and <code>10000000</code> (−0)</li></ul><p>Since arithmetic operations with sign-magnitude require handling the sign separately, it is less efficient in hardware compared to two’s complement.</p><hr><h3 id="One’s-Complement-反码"><a href="#One’s-Complement-反码" class="headerlink" title="One’s Complement (反码)"></a><strong>One’s Complement (反码)</strong></h3><p><strong>One’s Complement (反码)</strong> is a binary method for representing signed integers.</p><ul><li><strong>Positive numbers</strong>: Same as in regular binary.</li><li><strong>Negative numbers</strong>: Invert all bits of the positive number (i.e., change 0 to 1 and 1 to 0).</li></ul><p><strong>Example (using 8 bits):</strong></p><ul><li><code>+5</code>: <code>00000101</code></li><li><code>-5</code>: <code>11111010</code> (one’s complement of <code>00000101</code>)</li></ul><p><strong>Features:</strong></p><ul><li>Two representations of zero: <code>00000000</code> (+0) and <code>11111111</code> (−0)</li><li>Subtraction can be done using addition, but still needs end-around carry handling.</li></ul><p>Less efficient than two’s complement for arithmetic operations.</p><hr><h3 id="Two’s-Complement-补码"><a href="#Two’s-Complement-补码" class="headerlink" title="Two’s Complement (补码)"></a>Two’s Complement (补码)</h3><p><strong>Two’s Complement (补码)</strong> is the most common binary method for representing signed integers.</p><ul><li><strong>Positive numbers</strong>: Same as regular binary.</li><li><strong>Negative numbers</strong>: Invert all bits of the positive number (get the one’s complement), then add 1.</li></ul><p><strong>Example (using 8 bits):</strong></p><ul><li><code>+5</code>: <code>00000101</code></li><li><code>-5</code>: <code>11111011</code> (one’s complement of <code>00000101</code> is <code>11111010</code>, plus 1 gives <code>11111011</code>)</li></ul><p><strong>Features:</strong></p><ul><li>Only <strong>one zero</strong>: <code>00000000</code></li><li>Arithmetic operations (addition and subtraction) are simple and efficient</li><li>Widely used in modern computers for signed integer representation</li></ul><hr><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p><strong>Benchmark</strong> refers to a <strong>standardized test or reference</strong> used to evaluate the performance or quality of a system, device, program, or product.</p><p>A <strong>benchmark</strong> is a method of assessing the performance of an object by running a set of standard tests and comparing the results to others. It helps measure efficiency and identify areas for improvement.</p><p><strong>Common Use Cases</strong></p><ol><li><p><strong>Computer Hardware:</strong></p><ul><li>Benchmarking CPUs, GPUs, SSDs, etc., by running performance tests and comparing scores.</li><li>Common tools: Cinebench, Geekbench, PCMark.</li></ul></li><li><p><strong>Software Development:</strong></p><ul><li>Measuring the speed or efficiency of code or algorithms to optimize performance.</li></ul></li><li><p><strong>Business Management:</strong></p><ul><li>Comparing business performance to industry best practices to find room for improvement.</li></ul></li></ol><hr><h3 id="Big-endian"><a href="#Big-endian" class="headerlink" title="Big-endian"></a>Big-endian</h3><p><strong>Big-endian</strong> is a type of <strong>byte order</strong> where the <strong>most significant byte (MSB)</strong> is stored at the <strong>lowest memory address</strong>, and the least significant byte is stored at the highest address.</p><p>Suppose we have a 32-bit hexadecimal number: <code>0x12345678</code></p><p>In <strong>Big-endian</strong> format, it would be stored in memory like this (from low to high address):</p><table><thead><tr><th>Address</th><th>Byte Value</th></tr></thead><tbody><tr><td>0x00</td><td>0x12</td></tr><tr><td>0x01</td><td>0x34</td></tr><tr><td>0x02</td><td>0x56</td></tr><tr><td>0x03</td><td>0x78</td></tr></tbody></table><p><strong>Characteristics:</strong></p><ul><li>Commonly used in <strong>network protocols</strong> (e.g., TCP&#x2F;IP), hence also known as <strong>network byte order</strong>.</li><li>The opposite of Big-endian is <strong>Little-endian</strong>, where the least significant byte comes first.</li></ul><hr><h3 id="Little-endian-Brief-Explanation"><a href="#Little-endian-Brief-Explanation" class="headerlink" title="Little-endian (Brief Explanation)"></a>Little-endian (Brief Explanation)</h3><p><strong>Little-endian</strong> is a type of <strong>byte order</strong> where the <strong>least significant byte (LSB)</strong> is stored at the <strong>lowest memory address</strong>, and the most significant byte is stored at the highest address.</p><p>Suppose we have a 32-bit hexadecimal number: <code>0x12345678</code></p><p>In <strong>Little-endian</strong> format, it would be stored in memory like this (from low to high address):</p><table><thead><tr><th>Address</th><th>Byte Value</th></tr></thead><tbody><tr><td>0x00</td><td>0x78</td></tr><tr><td>0x01</td><td>0x56</td></tr><tr><td>0x02</td><td>0x34</td></tr><tr><td>0x03</td><td>0x12</td></tr></tbody></table><p><strong>Characteristics:</strong></p><ul><li>Commonly used in <strong>x86 architecture</strong> (Intel and AMD CPUs).</li><li>It is the <strong>opposite of Big-endian</strong>, which stores the most significant byte first.</li><li>Easier for some CPUs to handle arithmetic operations on varying byte lengths.</li></ul><hr><h3 id="Temporal-Locality-时间局部性"><a href="#Temporal-Locality-时间局部性" class="headerlink" title="Temporal Locality (时间局部性)"></a>Temporal Locality (时间局部性)</h3><p><strong>Temporal locality</strong> is a common program behavior in computer systems that means:</p><blockquote><p><strong>“If a data item is accessed, it is likely to be accessed again in the near future.”</strong></p></blockquote><p>Consider the following code snippet:</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>When <code>array[0]</code> is accessed, the program will soon access <code>array[1]</code>, <code>array[2]</code>, etc.</li><li>The variable <code>sum</code> is also accessed repeatedly.</li><li>This demonstrates <strong>temporal locality</strong>.</li></ul><p><strong>Additional Notes:</strong></p><ul><li><p><strong>Caches</strong> take advantage of temporal locality to improve performance.</p></li><li><p>Temporal locality commonly appears in:</p><ul><li>Loop variables</li><li>Frequently called functions</li><li>Intermediate computation results</li></ul></li></ul><hr><h3 id="Spatial-Locality-空间局部性"><a href="#Spatial-Locality-空间局部性" class="headerlink" title="Spatial Locality (空间局部性)"></a>Spatial Locality (空间局部性)</h3><p><strong>Spatial locality</strong> is a common program behavior in computer systems that means:</p><blockquote><p><strong>“If a data item is accessed, nearby data items (in memory) are likely to be accessed soon.”</strong></p></blockquote><p>Consider the following code snippet:</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sum <span class="token operator">+=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>When <code>array[0]</code> is accessed, the program will likely access <code>array[1]</code>, <code>array[2]</code>, …, <code>array[99]</code> shortly after.</li><li>These elements are stored in <strong>adjacent memory locations</strong>, so this illustrates <strong>spatial locality</strong>.</li></ul><p><strong>Additional Notes:</strong></p><ul><li><p><strong>Caches</strong> use spatial locality by loading not just a single data item but also <strong>nearby memory blocks</strong> (called a cache line).</p></li><li><p>Spatial locality commonly appears in:</p><ul><li>Sequential array access</li><li>Traversal of linked lists or other data structures with contiguous memory</li><li>Instruction fetches during linear code execution</li></ul></li></ul><hr><h3 id="Hardware-Prefetching-a-k-a-Prefetch"><a href="#Hardware-Prefetching-a-k-a-Prefetch" class="headerlink" title="Hardware Prefetching (a.k.a. Prefetch)"></a>Hardware Prefetching (a.k.a. Prefetch)</h3><p><strong>Hardware Prefetching</strong> is a technique where the CPU automatically predicts and loads data into the cache <strong>before</strong> it is actually needed.<br>It helps reduce memory latency by exploiting <strong>spatial</strong> and <strong>temporal locality</strong>.<br>For example, if a program accesses memory sequentially, the hardware may prefetch the next few addresses.<br>Prefetched data is stored in the cache, making future access faster.<br>This improves overall CPU performance, especially in data-intensive workloads.</p><hr><h3 id="Write-Through（写直达）"><a href="#Write-Through（写直达）" class="headerlink" title="Write Through（写直达）"></a>Write Through（写直达）</h3><p><strong>Write Through</strong> is a <strong>cache writing policy</strong> used in computer architecture to manage how data is written to the memory hierarchy, specifically between the <strong>cache</strong> and <strong>main memory</strong>.</p><p><strong>🔧 Definition:</strong><br>In a <strong>Write Through</strong> policy, <strong>every write operation</strong> to the cache is <strong>immediately and simultaneously written to main memory</strong>. This ensures that the main memory always holds the most up-to-date data.</p><p><strong>✅ Advantages:</strong></p><ul><li><strong>Data consistency</strong>: Main memory always reflects the latest data written by the CPU.</li><li><strong>Simple to implement</strong>: Because memory and cache are always in sync, it simplifies memory coherence in multi-processor systems.</li></ul><p><strong>❌ Disadvantages:</strong></p><ul><li><strong>Slower write performance</strong>: Every write operation must access main memory, which is slower than just writing to cache.</li><li><strong>Higher memory traffic</strong>: Frequent memory writes can increase bus usage and reduce overall system performance.</li></ul><p><strong>🧠 Example:</strong><br>If a CPU writes value <code>42</code> to memory address <code>0xA0</code>:</p><ul><li>The value is written to <strong>L1 cache</strong>.</li><li>At the same time, the value is also written to <strong>main memory</strong>.</li></ul><p><strong>💡 Related Concept:</strong></p><ul><li>Compare with <strong>Write Back</strong> policy, where updates are only made to the cache and written to memory <strong>later</strong>, often when the cache block is replaced.</li></ul><p><strong>Summary:</strong><br>Write Through provides <strong>strong consistency</strong> between cache and memory at the cost of <strong>write speed and efficiency</strong>.</p><hr><h3 id="Write-Back（写回）"><a href="#Write-Back（写回）" class="headerlink" title="Write Back（写回）"></a>Write Back（写回）</h3><p><strong>Write Back</strong> is a <strong>cache writing policy</strong> used in computer architecture to manage how data is written between the <strong>CPU cache</strong> and <strong>main memory</strong>.</p><p><strong>🔧 Definition:</strong><br>In a <strong>Write Back</strong> policy, data is written <strong>only to the cache</strong> at first. The updated data is written to <strong>main memory only when the cache block is replaced</strong> (i.e., evicted). Until then, the main memory may hold stale data.</p><p><strong>✅ Advantages:</strong></p><ul><li><strong>Faster write performance</strong>: Since writes are done only in cache, it reduces the latency of write operations.</li><li><strong>Reduced memory traffic</strong>: Multiple writes to the same memory location are performed only once to main memory when the block is evicted.</li></ul><p><strong>❌ Disadvantages:</strong></p><ul><li><strong>Data inconsistency risk</strong>: Main memory may not reflect the latest data, which complicates memory coherence in multi-core systems.</li><li><strong>More complex control logic</strong>: Needs a <strong>dirty bit</strong> to track whether a cache block has been modified.</li></ul><p><strong>🧠 Example:</strong><br>If the CPU writes value <code>42</code> to memory address <code>0xA0</code>:</p><ul><li>The value is written <strong>only to the cache</strong> (marked as dirty).</li><li>When the cache block containing <code>0xA0</code> is later evicted, <strong>then</strong> the value is written to <strong>main memory</strong>.</li></ul><p><strong>💡 Related Concept:</strong></p><ul><li>Compare with <strong>Write Through</strong>, where every write updates both the cache and main memory <strong>simultaneously</strong>.</li></ul><p><strong>Summary:</strong><br>Write Back improves <strong>write efficiency and performance</strong>, but introduces <strong>complexity and consistency challenges</strong>.</p><img src="/img/concepts/wb.svg" alt="Write Back VS Write Through" style="max-width: 100%; height: auto;" /><table><thead><tr><th>特性</th><th>写回（Write Back）</th><th>写直达（Write Through）</th></tr></thead><tbody><tr><td>写入位置</td><td>只写缓存（先缓存，后主存）</td><td>同时写入缓存和主存</td></tr><tr><td>写入主存时机</td><td>缓存块被替换时才写回主存</td><td>每次写操作都立即写入主存</td></tr><tr><td>性能</td><td>高性能，减少主存访问，延迟更低</td><td>写入慢，因频繁访问主存</td></tr><tr><td>主存数据一致性</td><td>复杂，需要使用“脏位”等一致性机制管理</td><td>简单，主存总是最新数据</td></tr><tr><td>系统总线负载</td><td>较低，减少写操作带来的总线流量</td><td>较高，写操作总是同步主存，增加总线压力</td></tr><tr><td>缓存一致性维护</td><td>较困难，多核系统中需额外一致性协议支持</td><td>较简单，主存作为权威数据源</td></tr><tr><td>适用场景</td><td>写操作频繁、对性能要求高的系统</td><td>对一致性要求高、系统结构简单的场景</td></tr></tbody></table><hr><h3 id="Multicache-Multi-level-Cache"><a href="#Multicache-Multi-level-Cache" class="headerlink" title="Multicache (Multi-level Cache)"></a>Multicache (Multi-level Cache)</h3><p><strong>Multicache</strong>, or <strong>Multi-level Cache</strong>, refers to a hierarchical(分层的) caching system used in modern CPUs to bridge the speed gap between the fast processor and the slower main memory. It typically consists of <strong>multiple levels of cache</strong>, such as <strong>L1</strong>, <strong>L2</strong>, and <strong>L3</strong>, each with different sizes, speeds, and purposes.</p><p><strong>🔧 Definition:</strong> A <strong>multi-level cache</strong> system includes:</p><ul><li><strong>L1 Cache</strong>: Closest to the CPU core, smallest and fastest.</li><li><strong>L2 Cache</strong>: Larger than L1, slower, and may be shared or private per core.</li><li><strong>L3 Cache</strong>: Even larger and slower, typically shared across all CPU cores.</li></ul><p>This layered structure allows faster access to frequently used data while reducing latency and improving CPU efficiency.</p><p><strong>🏗️ Structure Example:</strong></p><table><thead><tr><th>Level</th><th>Size</th><th>Speed</th><th>Shared</th><th>Purpose</th></tr></thead><tbody><tr><td>L1</td><td>~32KB</td><td>Very fast</td><td>No</td><td>Immediate access for the CPU</td></tr><tr><td>L2</td><td>~256KB</td><td>Fast</td><td>Maybe</td><td>Secondary buffer</td></tr><tr><td>L3</td><td>~8MB</td><td>Slower</td><td>Yes</td><td>Shared cache for all cores</td></tr></tbody></table><p><strong>✅ Advantages:</strong></p><ul><li><strong>Improved performance</strong>: Reduces average memory access time.</li><li><strong>Lower latency</strong>: L1 and L2 caches are much faster than main memory.</li><li><strong>Better scalability</strong>: Helps in multi-core systems where data sharing and access times are critical.</li></ul><p><strong>❌ Disadvantages:</strong></p><ul><li><strong>Complex design</strong>: Managing coherence and consistency across multiple levels is challenging.</li><li><strong>Increased cost and power</strong>: More hardware and logic are required.</li><li><strong>Cache misses</strong>: Still possible, especially if working sets exceed cache sizes.</li></ul><p><strong>💡 Notes:</strong></p><ul><li>Most modern processors use <strong>inclusive（包容）</strong>, <strong>exclusive（排他）</strong>, or <strong>non-inclusive（非包容）</strong> cache strategies to determine how data is stored across cache levels.</li><li>Multi-level cache systems often work in tandem with <strong>cache coherence protocols</strong> like MESI in multi-core CPUs.</li></ul><p><strong>📌 Summary</strong></p><p><strong>Multicache systems</strong> provide a hierarchical buffer between the CPU and main memory, optimizing performance and efficiency by leveraging fast, small caches for frequently accessed data and larger, slower caches for broader access.</p><img src="/img/concepts/multicache.svg" alt="multicache" style="max-width: 100%; height: auto;" /><hr><h3 id="Direct-Mapping（直接映射）"><a href="#Direct-Mapping（直接映射）" class="headerlink" title="Direct Mapping（直接映射）"></a>Direct Mapping（直接映射）</h3><p><strong>Direct Mapping</strong> is a simple cache mapping technique used in computer architecture to determine where a memory block will be placed in the cache.</p><p><strong>🔧 Definition:</strong><br>In <strong>Direct Mapping</strong>, each block of main memory maps to <strong>exactly one</strong> cache line. The mapping is usually done using:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Cache Line Index &#x3D; (Main Memory Block Address) mod (Number of Cache Lines)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>This makes it easy and fast to locate data in the cache, but can lead to many <strong>conflicts</strong> if multiple blocks map to the same cache line.</p><p><strong>✅ Advantages:</strong></p><ul><li><strong>Simple and fast</strong> implementation</li><li><strong>Low hardware complexity</strong></li></ul><p><strong>❌ Disadvantages:</strong></p><ul><li><strong>High conflict rate</strong>: Two different memory blocks mapping to the same line will continuously evict each other</li><li><strong>Low flexibility</strong> compared to other mapping techniques (e.g., set-associative)</li></ul><p><strong>🧠 Example:</strong><br>If a cache has 8 lines (0 to 7), and a block from main memory has address 24:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Cache Line &#x3D; 24 mod 8 &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>So this block will always be placed in cache line 0.</p><p><strong>Summary:</strong><br>Direct Mapping provides fast and simple cache access, but is prone to frequent conflicts.</p><hr><h3 id="Set-Associative-Mapping（组相连映射）"><a href="#Set-Associative-Mapping（组相连映射）" class="headerlink" title="Set- Associative Mapping（组相连映射）"></a>Set- Associative Mapping（组相连映射）</h3><p><strong>Set-Associative Mapping</strong> is a cache mapping technique that combines the benefits of both <strong>Direct Mapping</strong> and <strong>Fully Associative Mapping</strong> to balance performance and complexity.</p><p><strong>🔧 Definition:</strong><br>In <strong>Set-Associative Mapping</strong>, the cache is divided into multiple <strong>sets</strong>, and each set contains <strong>multiple cache lines (ways)</strong>. A block from main memory maps to <strong>exactly one set</strong>, but <strong>can be placed in any line (way) within that set</strong>.</p><p>The set is selected using:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Set Index &#x3D; (Main Memory Block Address) mod (Number of Sets)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>Within the set, placement and replacement follow policies like <strong>Least Recently Used (LRU)</strong> or <strong>Random</strong>.</p><p><strong>✅ Advantages:</strong></p><ul><li><strong>Lower conflict rate</strong> than Direct Mapping</li><li><strong>More flexible</strong> placement within sets</li><li><strong>Good balance</strong> between speed and cache hit rate</li></ul><p><strong>❌ Disadvantages:</strong></p><ul><li><strong>More complex</strong> hardware than Direct Mapping</li><li><strong>Slightly slower</strong> lookup due to checking multiple lines in a set</li></ul><p><strong>🧠 Example:</strong><br>If a cache has <strong>4 sets</strong>, each with <strong>2 lines (2-way set-associative)</strong>, and a memory block with address 12:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Set Index &#x3D; 12 mod 4 &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>The block can be placed in <strong>either of the 2 lines in Set 0</strong>.</p><p><strong>Summary:</strong><br>Set-Associative Mapping provides a <strong>balanced approach</strong> with better conflict resolution than Direct Mapping and <strong>less complexity</strong> than Fully Associative Mapping.</p><hr><h3 id="Full-Associative-Mapping（全相联映射）"><a href="#Full-Associative-Mapping（全相联映射）" class="headerlink" title="Full Associative Mapping（全相联映射）"></a>Full Associative Mapping（全相联映射）</h3><p><strong>Full Associative Mapping</strong> is a cache mapping technique in which <strong>a memory block can be placed in any cache line</strong>, offering maximum flexibility and minimal conflict.</p><p><strong>🔧 Definition:</strong><br>In <strong>Full Associative Mapping</strong>, there are <strong>no restrictions</strong> on where a block can be placed in the cache. Any block from main memory can be stored in <strong>any cache line</strong>.</p><p>To find a block, the cache must <strong>search all lines</strong> using <strong>comparators</strong> that match tags.</p><p><strong>✅ Advantages:</strong></p><ul><li><strong>No conflict misses</strong> (except when cache is full)</li><li><strong>Best flexibility</strong> in placement</li><li><strong>Highest cache hit potential</strong></li></ul><p><strong>❌ Disadvantages:</strong></p><ul><li><strong>Complex hardware</strong>: Requires searching the entire cache in parallel</li><li><strong>Slower access time</strong> due to tag comparisons</li><li><strong>Expensive</strong> in terms of power and chip area</li></ul><p><strong>🧠 Example:</strong><br>If a cache has <strong>8 lines</strong>, and a block from memory has address <code>0x2F</code>, it can be placed in <strong>any one</strong> of the 8 lines. When checking for a hit, the cache must compare the block’s tag with the tags of <strong>all 8 lines</strong>.</p><p><strong>Summary:</strong><br>Full Associative Mapping provides <strong>maximum flexibility</strong> and <strong>minimal conflict</strong>, but comes with <strong>higher hardware cost</strong> and <strong>slower lookup times</strong>.</p><hr><h3 id="Comparison-of-Cache-Mapping-Techniques"><a href="#Comparison-of-Cache-Mapping-Techniques" class="headerlink" title="Comparison of Cache Mapping Techniques"></a>Comparison of Cache Mapping Techniques</h3><table><thead><tr><th>Feature</th><th>Direct Mapping</th><th>Set-Associative Mapping</th><th>Full Associative Mapping</th></tr></thead><tbody><tr><td>Placement Rule</td><td>Each block maps to <strong>one line</strong></td><td>Each block maps to <strong>one set</strong>, can go into <strong>any line</strong> in that set</td><td>Each block can go into <strong>any line</strong> in the cache</td></tr><tr><td>Flexibility</td><td>Low</td><td>Medium</td><td>High</td></tr><tr><td>Hardware Complexity</td><td>Low (simplest)</td><td>Medium</td><td>High (most complex)</td></tr><tr><td>Access Speed</td><td>Fast</td><td>Slightly slower</td><td>Slowest (due to parallel comparisons)</td></tr><tr><td>Conflict Misses</td><td>High</td><td>Lower than Direct Mapping</td><td>None (except capacity misses)</td></tr><tr><td>Replacement Policy</td><td>Not needed (only one line)</td><td>Needed within each set (e.g., LRU)</td><td>Needed for the entire cache (e.g., LRU)</td></tr><tr><td>Cost (Power&#x2F;Area)</td><td>Low</td><td>Moderate</td><td>High</td></tr><tr><td>Use Case Suitability</td><td>Simple, low-power systems</td><td>General-purpose CPUs</td><td>High-performance or critical systems</td></tr></tbody></table><img src="/img/concepts/cache3.jpg" alt="三种cache映射" style="max-width: 100%; height: auto;" /><hr><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p><strong>Cache</strong> is a small, high-speed memory that stores frequently used data to speed up access. It sits between the CPU and main memory to reduce latency. It enables fast program access to frequently used addresses.</p><hr><h3 id="Non-blocking-Cache（非阻塞缓存）"><a href="#Non-blocking-Cache（非阻塞缓存）" class="headerlink" title="Non-blocking Cache（非阻塞缓存）"></a>Non-blocking Cache（非阻塞缓存）</h3><p>A <strong>Non-blocking Cache</strong> allows the CPU to continue processing other instructions <strong>while waiting for a cache miss</strong> to be resolved.<br>It supports <strong>multiple outstanding memory requests</strong> simultaneously.<br>This improves overall system performance by reducing CPU idle time.<br>Non-blocking caches are especially useful in <strong>out-of-order execution</strong> and <strong>superscalar processors</strong>.<br>They often use structures like <strong>Miss Status Handling Registers (MSHRs)</strong> to track pending requests.</p><p><strong>非阻塞缓存</strong>允许 CPU 在<strong>等待缓存未命中（Cache Miss）处理完成的同时继续执行其他指令</strong>。<br>它支持<strong>多个未完成的内存请求</strong>同时存在。<br>这通过减少 CPU 空闲时间来提升系统整体性能。<br>非阻塞缓存在<strong>乱序执行</strong>和<strong>超标量处理器</strong>中尤为重要。<br>它通常使用如 <strong>未命中状态处理寄存器（Miss Status Handling Registers, MSHRs）</strong> 的结构来追踪未完成的请求。</p><hr><h3 id="Superscalar-Architecture（超标量架构）"><a href="#Superscalar-Architecture（超标量架构）" class="headerlink" title="Superscalar Architecture（超标量架构）"></a>Superscalar Architecture（超标量架构）</h3><p><strong>Superscalar Architecture</strong> is a CPU design that allows the processor to <strong>fetch, decode, and execute multiple instructions simultaneously</strong> during each clock cycle.<br>It achieves this by using <strong>multiple pipelines</strong> and <strong>parallel execution units</strong> (e.g., ALUs, FPUs).<br>This architecture increases <strong>instruction-level parallelism (ILP)</strong>, boosting performance without raising the clock speed.<br>Superscalar CPUs include features like <strong>out-of-order execution</strong>, <strong>register renaming</strong>, and <strong>branch prediction</strong> to handle dependencies and control flow efficiently.<br>Examples of superscalar processors include modern Intel and AMD CPUs.</p><img src="/img/concepts/superscalar.svg" alt="超标量架构" style="max-width: 100%; height: auto;" /><hr><h3 id="🔍-TLB-Translation-Lookaside-Buffer"><a href="#🔍-TLB-Translation-Lookaside-Buffer" class="headerlink" title="🔍 TLB (Translation Lookaside Buffer)"></a>🔍 TLB (Translation Lookaside Buffer)</h3><p><strong>TLB</strong> stands for <strong>Translation Lookaside Buffer</strong>. It is a small, fast cache used in the memory management unit (MMU) of a computer’s CPU to improve the speed of <strong>virtual-to-physical address translation</strong>.</p><p><strong>📌 Why is TLB needed?</strong></p><p>When a CPU accesses memory using a virtual address, it must be translated into a physical address using the <strong>page table</strong>. This translation is time-consuming. The TLB stores recent translations, so if the virtual address has been accessed recently, the translation can be retrieved quickly without accessing the full page table.</p><p><strong>✅ Key Characteristics</strong></p><ul><li><strong>Cache for page table entries</strong></li><li><strong>Reduces page table access time</strong></li><li>Typically contains <strong>64 to 512 entries</strong></li><li>Can be <strong>fully associative</strong>, <strong>set-associative</strong>, or <strong>direct-mapped</strong></li></ul><p><strong>📈 How it works</strong></p><ol><li><strong>CPU generates a virtual address</strong></li><li><strong>MMU checks the TLB</strong> for the virtual page number (VPN)</li><li>If found (<strong>TLB hit</strong>): use the cached physical page number (PPN)</li><li>If not found (<strong>TLB miss</strong>): access the page table, then update the TLB</li></ol><p><strong>🧠 TLB Hit vs TLB Miss</strong></p><table><thead><tr><th>Event</th><th>Description</th></tr></thead><tbody><tr><td>TLB Hit</td><td>The virtual address is found in the TLB → Fast address translation</td></tr><tr><td>TLB Miss</td><td>The virtual address is not found in the TLB → Page table lookup is required</td></tr></tbody></table><p><strong>🧮 Example</strong></p><p>Let’s say the CPU wants to access virtual address <code>0x00403ABC</code>:</p><ul><li>VPN &#x3D; top bits of address → check if TLB has entry</li><li>If yes → get PPN and combine with offset → access physical memory</li><li>If no → consult page table → update TLB → then access memory</li></ul><p><strong>🔄 TLB Replacement Policy</strong></p><p>When the TLB is full, and a new entry must be loaded, a <strong>replacement policy</strong> is used, such as:</p><ul><li><strong>Least Recently Used (LRU)</strong></li><li><strong>Random replacement</strong></li></ul><p><strong>🚀 Summary</strong> </p><ul><li>TLB significantly <strong>improves performance</strong> of memory access.</li><li>Acts as a <strong>fast cache</strong> for recent address translations.</li><li>Helps bridge the speed gap between the CPU and memory systems.</li></ul><hr><h3 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a>Page Table</h3><p>In computer architecture, a <strong>Page Table</strong> is a data structure used by the <strong>virtual memory system</strong> to manage the mapping between <strong>virtual addresses</strong> and <strong>physical addresses</strong>.</p><p><strong>🧠 What is Virtual Memory?</strong></p><p>Virtual memory allows a program to use a large, continuous address space even if the physical memory (RAM) is smaller. The CPU generates <strong>virtual addresses</strong>, which must be translated into <strong>physical addresses</strong> before accessing actual memory.</p><p><strong>📘 What is a Page Table?</strong></p><p>A <strong>Page Table</strong> stores the mapping between <strong>virtual pages</strong> and <strong>physical frames</strong>. Each entry in the page table is called a <strong>Page Table Entry (PTE)</strong> and contains information such as:</p><ul><li><strong>Frame Number</strong>: the physical frame corresponding to the virtual page.</li><li><strong>Valid&#x2F;Invalid Bit</strong>: indicates if the mapping is valid.</li><li><strong>Protection Bits</strong>: control read&#x2F;write permissions.</li><li><strong>Dirty Bit</strong>: indicates if the page has been modified.</li><li><strong>Accessed Bit</strong>: indicates if the page has been accessed recently.</li></ul><p><strong>🧾 Example Structure</strong></p><table><thead><tr><th>Virtual Page Number</th><th>Physical Frame Number</th><th>Valid Bit</th><th>Protection</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>1</td><td>Read&#x2F;Write</td></tr><tr><td>1</td><td>2</td><td>1</td><td>Read-only</td></tr><tr><td>2</td><td>-</td><td>0</td><td>-</td></tr></tbody></table><p><strong>🧮 Address Translation Steps</strong></p><ol><li><p>The CPU generates a <strong>virtual address</strong>.</p></li><li><p>The virtual address is divided into:</p><ul><li><strong>Page Number</strong></li><li><strong>Offset</strong></li></ul></li><li><p>The <strong>Page Number</strong> is used to index into the Page Table.</p></li><li><p>The Page Table Entry provides the <strong>Frame Number</strong>.</p></li><li><p>The <strong>Physical Address</strong> is formed by combining the Frame Number and the Offset.</p></li></ol><p><strong>🛑 Page Fault</strong></p><p>If the <strong>Valid Bit</strong> is 0, the page is not currently in memory. This triggers a <strong>Page Fault</strong>, and the operating system must load the page from disk into RAM.</p><p><strong>🧭 Types of Page Tables</strong></p><ul><li><strong>Single-Level Page Table</strong>: Simple but not scalable for large address spaces.</li><li><strong>Multi-Level Page Table</strong>: Reduces memory usage by using a tree-like structure.</li><li><strong>Inverted Page Table</strong>: Indexes by physical frame instead of virtual page.</li><li><strong>Hashed Page Table</strong>: Used in systems with large address spaces (like 64-bit).</li></ul><p><strong>📌 Summary</strong></p><ul><li>Page Tables are essential for translating virtual to physical addresses.</li><li>They enable <strong>memory protection</strong>, <strong>process isolation</strong>, and <strong>efficient memory use</strong>.</li><li>Optimized with techniques like <strong>TLB</strong> (Translation Lookaside Buffer) to speed up address translation.</li></ul><img src="/img/concepts/tlb.svg" alt="虚实地址转换" style="max-width: 100%; height: auto;" /><hr><h3 id="🧩-3-Types-of-Cache-Misses"><a href="#🧩-3-Types-of-Cache-Misses" class="headerlink" title="🧩 3 Types of Cache Misses"></a>🧩 3 Types of Cache Misses</h3><p>In computer architecture, a <strong>cache miss</strong> occurs when the data requested by the CPU is <strong>not found in the cache</strong>, requiring access to a slower memory level (like RAM). There are <strong>three main types</strong> of cache misses:</p><p><strong>🧠 Summary Table</strong></p><table><thead><tr><th>Type</th><th>Cause</th><th>Possible Solution</th></tr></thead><tbody><tr><td>Compulsory Miss</td><td>First-time access to a block</td><td>Prefetching, larger block size</td></tr><tr><td>Capacity Miss</td><td>Cache too small for working set</td><td>Larger cache, better algorithms</td></tr><tr><td>Conflict Miss</td><td>Blocks map to the same cache location</td><td>Higher associativity, alignment</td></tr></tbody></table><hr><h3 id="1-Compulsory-Miss-a-k-a-Cold-Miss"><a href="#1-Compulsory-Miss-a-k-a-Cold-Miss" class="headerlink" title="1. Compulsory Miss (a.k.a. Cold Miss)"></a>1. <strong>Compulsory Miss</strong> (a.k.a. Cold Miss)</h3><p><strong>🔹 What is it?</strong></p><p>Occurs the <strong>first time</strong> a block is accessed and <strong>has never been loaded into the cache</strong> before.</p><p><strong>🧠 Cause:</strong></p><ul><li>Cache is empty or data is accessed for the first time.</li></ul><p><strong>📌 Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">Accessing array A[0] for the first time → not in cache → compulsory miss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>✅ Solution:</strong></p><ul><li>Prefetching</li><li>Larger block size (to bring in more adjacent data)</li></ul><hr><h3 id="2-Capacity-Miss"><a href="#2-Capacity-Miss" class="headerlink" title="2. Capacity Miss"></a>2. <strong>Capacity Miss</strong></h3><p><strong>🔹 What is it?</strong></p><p>Happens when the <strong>cache cannot contain all the needed data</strong>, and a previously loaded block gets evicted due to <strong>limited size</strong>.</p><p><strong>🧠 Cause:</strong></p><ul><li>The working set is <strong>larger than the cache</strong>.</li></ul><p><strong>📌 Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">Looping through a large dataset that exceeds cache size → older blocks are evicted → miss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>✅ Solution:</strong></p><ul><li>Increase cache size</li><li>Optimize algorithm locality</li></ul><hr><h3 id="3-Conflict-Miss-a-k-a-Collision-Miss"><a href="#3-Conflict-Miss-a-k-a-Collision-Miss" class="headerlink" title="3. Conflict Miss (a.k.a. Collision Miss)"></a><strong>3. Conflict Miss</strong> (a.k.a. Collision Miss)</h3><p><strong>🔹 What is it?</strong></p><p>Occurs when <strong>multiple blocks map to the same cache line</strong> (in set-associative or direct-mapped caches), causing <strong>unnecessary evictions</strong>.</p><p><strong>🧠 Cause:</strong></p><ul><li>Limited associativity in the cache</li><li>Poor address mapping</li></ul><p><strong>📌 Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">Accessing addresses A and B that both map to cache set 3 → one evicts the other → conflict miss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>✅ Solution:</strong></p><ul><li>Increase associativity</li><li>Use fully associative cache</li><li>Better hash functions or memory alignment</li></ul><hr><h3 id="🔗-Four-Types-of-Data-Dependencies-in-Computer-Architecture"><a href="#🔗-Four-Types-of-Data-Dependencies-in-Computer-Architecture" class="headerlink" title="🔗 Four Types of Data Dependencies in Computer Architecture"></a>🔗 Four Types of Data Dependencies in Computer Architecture</h3><p>In pipelined processors, <strong>data dependencies</strong> occur when instructions depend on the results of previous instructions. These dependencies can cause <strong>pipeline hazards</strong> and impact instruction-level parallelism.</p><p>There are <strong>four types</strong> of data dependencies:</p><p><strong>📊 Summary Table</strong></p><table><thead><tr><th>Type</th><th>Abbreviation</th><th>Cause</th><th>Solution</th></tr></thead><tbody><tr><td>Flow Dependency</td><td>RAW</td><td>Read after write</td><td>Forwarding, Stall</td></tr><tr><td>Anti Dependency</td><td>WAR</td><td>Write after read</td><td>Register renaming</td></tr><tr><td>Output Dependency</td><td>WAW</td><td>Write after write</td><td>Register renaming, in-order commit</td></tr><tr><td>Control Dependency</td><td>–</td><td>Depends on branch outcome</td><td>Branch prediction, speculation</td></tr></tbody></table><hr><h3 id="1-Flow-Dependency-Read-After-Write-RAW"><a href="#1-Flow-Dependency-Read-After-Write-RAW" class="headerlink" title="1. Flow Dependency (Read After Write, RAW)"></a>1. <strong>Flow Dependency</strong> (Read After Write, <strong>RAW</strong>)</h3><p><strong>🔹 What is it?</strong></p><p>Occurs when an instruction needs to <strong>read a value</strong> that has not yet been <strong>written</strong> by a previous instruction.</p><p><strong>🧠 Cause:</strong></p><ul><li>The second instruction <strong>depends</strong> on the result of the first.</li></ul><p><strong>📌 Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">I1: R1 ← R2 + R3I2: R4 ← R1 + R5   ; RAW: I2 reads R1 before I1 writes it<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>✅ Solution:</strong></p><ul><li><strong>Forwarding&#x2F;Bypassing</strong></li><li><strong>Stalling</strong> the pipeline</li></ul><hr><h3 id="2-Anti-Dependency-Write-After-Read-WAR"><a href="#2-Anti-Dependency-Write-After-Read-WAR" class="headerlink" title="2. Anti Dependency (Write After Read, WAR)"></a>2. <strong>Anti Dependency</strong> (Write After Read, <strong>WAR</strong>)</h3><p><strong>🔹 What is it?</strong></p><p>Occurs when a later instruction <strong>writes</strong> to a location that a previous instruction still needs to <strong>read</strong> from.</p><p><strong>🧠 Cause:</strong></p><ul><li>The second instruction must <strong>not overwrite</strong> the value too early.</li></ul><p><strong>📌 Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">I1: R4 ← R1 + R2   ; Reads R1I2: R1 ← R3 + R5   ; WAR: I2 writes R1 before I1 finishes reading<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>✅ Solution:</strong></p><ul><li><strong>Register renaming</strong></li></ul><hr><h3 id="3-Output-Dependency-Write-After-Write-WAW"><a href="#3-Output-Dependency-Write-After-Write-WAW" class="headerlink" title="3. Output Dependency (Write After Write, WAW)"></a>3. <strong>Output Dependency</strong> (Write After Write, <strong>WAW</strong>)</h3><p><strong>🔹 What is it?</strong></p><p>Occurs when two instructions <strong>write</strong> to the <strong>same destination</strong>, and the final result must reflect the correct write order.</p><p><strong>🧠 Cause:</strong></p><ul><li>Later instruction must not overwrite an earlier write <strong>out of order</strong>.</li></ul><p><strong>📌 Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">I1: R1 ← R2 + R3I2: R1 ← R4 + R5   ; WAW: I2 writes R1 before I1 completes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>✅ Solution:</strong></p><ul><li><strong>Register renaming</strong></li><li><strong>In-order commit</strong> in out-of-order execution</li></ul><hr><h3 id="4-Control-Dependency"><a href="#4-Control-Dependency" class="headerlink" title="4. Control Dependency"></a>4. <strong>Control Dependency</strong></h3><p><strong>🔹 What is it?</strong></p><p>Occurs when the <strong>execution</strong> of an instruction depends on the <strong>outcome of a branch</strong>.</p><p><strong>🧠 Cause:</strong></p><ul><li>It’s not clear <strong>whether to execute</strong> the instruction until the branch is resolved.</li></ul><p><strong>📌 Example:</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">I1: if (R1 &#x3D;&#x3D; 0) goto LABELI2: R2 ← R3 + R4   ; Control dependent on I1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>✅ Solution:</strong></p><ul><li><strong>Branch prediction</strong></li><li><strong>Speculative execution</strong></li></ul><hr><h3 id="Microprogramming（微程序设计）"><a href="#Microprogramming（微程序设计）" class="headerlink" title="Microprogramming（微程序设计）"></a>Microprogramming（微程序设计）</h3><p><strong>Microprogramming</strong> is a method of implementing a CPU’s control unit using <strong>a sequence of microinstructions</strong> stored in a special memory called <strong>control memory</strong>.<br>Each <strong>microinstruction</strong> specifies low-level operations like setting control signals, reading&#x2F;writing registers, or ALU actions.<br>It acts as an intermediate layer between machine instructions and hardware control signals.<br>There are two types of control units: <strong>hardwired control</strong> and <strong>microprogrammed control</strong> — the latter is easier to modify and extend.<br>Microprogramming was widely used in classic CISC architectures like IBM System&#x2F;360.</p><hr><h3 id="Snoopy-Cache（监听式缓存）"><a href="#Snoopy-Cache（监听式缓存）" class="headerlink" title="Snoopy Cache（监听式缓存）"></a>Snoopy Cache（监听式缓存）</h3><p><strong>Snoopy Cache</strong> is a cache coherence protocol used in <strong>multiprocessor systems</strong> to maintain data consistency among multiple caches.<br>Each cache monitors (or “snoops”) a shared communication bus to detect if other processors are reading or writing a memory block it has cached.<br>If a write is detected, the snooping cache can <strong>invalidate</strong> or <strong>update</strong> its own copy to keep data coherent.<br>This ensures that all processors work with the <strong>most recent version</strong> of data.<br>Common snoopy-based protocols include <strong>MSI</strong>, <strong>MESI</strong>, and <strong>MOESI</strong>.</p><p><strong>Snoopy Cache（监听式缓存）</strong>是一种用于<strong>多处理器系统</strong>的缓存一致性协议，用于保持多个缓存之间的数据一致性。<br>每个缓存会监听（snoop）共享总线，检测其他处理器是否在读取或写入它缓存中的数据块。<br>当检测到写操作时，监听缓存会<strong>更新</strong>或<strong>无效化</strong>自己的副本，以保持数据的一致性。<br>这样可以确保所有处理器使用的都是<strong>最新版本的数据</strong>。<br>常见的监听式协议包括 <strong>MSI</strong>、<strong>MESI</strong> 和 <strong>MOESI</strong> 协议。</p><hr><h3 id="Out-of-order-Execution-乱序执行"><a href="#Out-of-order-Execution-乱序执行" class="headerlink" title="Out-of-order Execution (乱序执行)"></a>Out-of-order Execution (乱序执行)</h3><p><strong>Out-of-order execution</strong> is a technique used in modern processors to improve performance by allowing instructions to be executed <strong>out of the order they appear</strong> in the program.<br>Instead of waiting for earlier instructions to complete (which might be delayed due to data hazards or memory stalls), the CPU executes instructions that are ready and independent of others.<br>This reduces <strong>idle CPU time</strong> and <strong>increases throughput</strong> by utilizing all available execution units.<br>Dependencies between instructions are tracked, and results are committed in the correct order.<br>Out-of-order execution is common in <strong>superscalar processors</strong> and is part of <strong>dynamic instruction scheduling</strong>.</p><p><strong>乱序执行</strong>是一种现代处理器中常用的技术，通过允许指令<strong>按非顺序</strong>的方式执行来提升性能。<br>CPU 不必等待前面的指令完成（这些指令可能因为数据依赖或内存延迟而被拖慢），而是执行那些准备好且相互独立的指令。<br>这样可以减少<strong>CPU空闲时间</strong>并<strong>增加吞吐量</strong>，充分利用所有可用的执行单元。<br>指令之间的依赖关系会被追踪，结果会按正确的顺序提交。<br>乱序执行在<strong>超标量处理器</strong>中很常见，并且是<strong>动态指令调度</strong>的一部分。</p><hr><h3 id="DMA-Direct-Memory-Access"><a href="#DMA-Direct-Memory-Access" class="headerlink" title="DMA (Direct Memory Access)"></a>DMA (Direct Memory Access)</h3><p><strong>DMA</strong> stands for <strong>Direct Memory Access</strong>, a feature that allows certain hardware components (like disk controllers or network cards) to <strong>transfer data directly to&#x2F;from main memory</strong> without involving the CPU.<br>This improves system efficiency by <strong>freeing the CPU</strong> from managing large or repetitive data transfers.<br>A <strong>DMA controller</strong> handles the data movement and signals the CPU when the transfer is complete.<br>DMA is commonly used for tasks like <strong>disk I&#x2F;O</strong>, <strong>audio&#x2F;video streaming</strong>, and <strong>network communication</strong>.<br>It helps achieve <strong>high-speed data transfer</strong> with minimal CPU overhead.</p><p><strong>DMA</strong> 是 <strong>直接内存访问（Direct Memory Access）</strong> 的缩写，是一种允许某些硬件组件（如磁盘控制器或网卡）<strong>在不经过 CPU 的情况下直接与主存进行数据传输</strong>的技术。<br>它通过<strong>减轻 CPU 的数据搬运负担</strong>，提高了系统效率。<br>数据传输由一个 <strong>DMA 控制器</strong>负责，传输完成后会通知 CPU。<br>DMA 广泛应用于 <strong>磁盘 I&#x2F;O</strong>、<strong>音视频流处理</strong> 和 <strong>网络通信</strong> 等领域。<br>它能以<strong>极低的 CPU 开销实现高速数据传输</strong>。</p><hr><h3 id="RISC-Reduced-Instruction-Set-Computing"><a href="#RISC-Reduced-Instruction-Set-Computing" class="headerlink" title="RISC (Reduced Instruction Set Computing)"></a>RISC (Reduced Instruction Set Computing)</h3><p><strong>RISC</strong> stands for <strong>Reduced Instruction Set Computing</strong>, a CPU design strategy that uses a <strong>small set of simple and fast instructions</strong>.<br>Each instruction typically executes in <strong>one clock cycle</strong>, allowing efficient pipelining and parallelism.<br>RISC emphasizes <strong>hardware simplicity</strong>, <strong>fixed instruction length</strong>, and <strong>a load&#x2F;store architecture</strong>.<br>It is well-suited for modern compilers and high-performance applications.<br>Examples: <strong>ARM</strong>, <strong>RISC-V</strong>, <strong>MIPS</strong>.</p><p><strong>RISC</strong> 是 <strong>精简指令集计算（Reduced Instruction Set Computing）</strong> 的缩写，是一种使用<strong>少量简单指令</strong>的 CPU 设计理念。<br>每条指令通常在<strong>一个时钟周期内完成</strong>，便于实现流水线和并行处理。<br>RISC 强调<strong>硬件简化</strong>、<strong>固定长度指令</strong>以及<strong>Load&#x2F;Store 架构</strong>。<br>这种架构非常适合现代编译器和高性能应用。<br>代表架构：<strong>ARM</strong>、<strong>RISC-V</strong>、<strong>MIPS</strong>。</p><hr><h3 id="CISC-Complex-Instruction-Set-Computing"><a href="#CISC-Complex-Instruction-Set-Computing" class="headerlink" title="CISC (Complex Instruction Set Computing)"></a>CISC (Complex Instruction Set Computing)</h3><p><strong>CISC</strong> stands for <strong>Complex Instruction Set Computing</strong>, which uses a <strong>large and versatile set of instructions</strong>, where some instructions perform <strong>multi-step operations</strong>.<br>This design reduces the number of instructions per program but increases the complexity of the CPU.<br>CISC instructions often have <strong>variable lengths</strong> and require <strong>multiple clock cycles</strong> to execute.<br>It was originally designed to minimize memory usage and support simpler compilers.<br>Example: <strong>x86 architecture</strong> (Intel, AMD).</p><p><strong>CISC</strong> 是 <strong>复杂指令集计算（Complex Instruction Set Computing）</strong> 的缩写，采用<strong>数量多、功能强的指令集</strong>，其中一些指令能完成<strong>多个低层次操作</strong>。<br>这种设计可以减少程序中所需的指令数量，但会增加 CPU 的实现复杂度。<br>CISC 指令通常是<strong>不固定长度</strong>，并且执行时<strong>可能需要多个时钟周期</strong>。<br>它最初为了减少内存使用、便于早期编译器设计而提出。<br>代表架构：<strong>x86 架构</strong>（如 Intel 和 AMD 处理器）。</p><hr><h3 id="SIMD-Single-Instruction-Multiple-Data"><a href="#SIMD-Single-Instruction-Multiple-Data" class="headerlink" title="SIMD (Single Instruction, Multiple Data)"></a>SIMD (Single Instruction, Multiple Data)</h3><p><strong>SIMD</strong> stands for <strong>Single Instruction, Multiple Data</strong>, a parallel computing model where <strong>one instruction</strong> operates on <strong>multiple data elements simultaneously</strong>.<br>It is especially useful for tasks like <strong>image processing</strong>, <strong>audio&#x2F;video encoding</strong>, <strong>machine learning</strong>, and <strong>scientific computing</strong>.<br>SIMD improves performance by exploiting <strong>data-level parallelism</strong>.<br>Modern CPUs include SIMD instruction sets such as <strong>SSE</strong>, <strong>AVX</strong> (Intel&#x2F;AMD), and <strong>NEON</strong> (ARM).<br>It is a core concept in <strong>vector processing</strong> and used in <strong>GPUs</strong> as well.</p><p><strong>SIMD</strong> 是 <strong>单指令多数据流（Single Instruction, Multiple Data）</strong> 的缩写，是一种并行计算模型，其中<strong>一条指令</strong>可以同时作用于<strong>多个数据元素</strong>。<br>它非常适用于图像处理、音视频编解码、机器学习和科学计算等场景。<br>SIMD 通过挖掘数据级并行性（Data-level Parallelism）来提升性能。<br>现代 CPU 提供了 SIMD 指令集，如 <strong>SSE</strong>、<strong>AVX</strong>（Intel&#x2F;AMD）和 <strong>NEON</strong>（ARM）。<br>它是向量处理（Vector Processing）的核心思想，并广泛用于 <strong>GPU</strong> 中。</p><h2 id="4-Formal-Language-Automata"><a href="#4-Formal-Language-Automata" class="headerlink" title="4. Formal Language &amp; Automata"></a>4. Formal Language &amp; Automata</h2><h3 id="Regular-Grammar"><a href="#Regular-Grammar" class="headerlink" title="Regular Grammar"></a>Regular Grammar</h3><p>A <strong>Regular Grammar</strong> is the simplest type of grammar in the Chomsky hierarchy. It is used to define <strong>regular languages</strong>, which can also be recognized by <strong>finite automata</strong>. Regular grammars are widely used in lexical analysis, pattern matching, and simple parsing tasks.</p><p><strong>📘 Definition</strong></p><p>A <strong>Regular Grammar</strong> is a type of <strong>context-free grammar (CFG)</strong> with special restrictions on its production rules. It consists of:</p><ul><li>A finite set of <strong>non-terminal symbols</strong></li><li>A finite set of <strong>terminal symbols</strong></li><li>A <strong>start symbol</strong></li><li>A finite set of <strong>production rules</strong></li></ul><p><strong>🧾 Types of Regular Grammar</strong></p><p>There are <strong>two forms</strong> of regular grammars:</p><ol><li><strong>Right-Linear Grammar</strong></li></ol><p>All production rules are of the form:</p><ul><li>$A \rightarrow aB$</li><li>$A \rightarrow a$</li><li>$A \rightarrow \varepsilon$ (optional for generating empty string)</li></ul><p>Where:</p><ul><li>$A, B$ are non-terminal symbols</li><li>$a$ is a terminal symbol</li></ul><p>✅ This is the <strong>most common</strong> form used to generate regular languages.</p><ol start="2"><li><strong>Left-Linear Grammar</strong></li></ol><p>All production rules are of the form:</p><ul><li>$A \rightarrow Ba$</li><li>$A \rightarrow a$</li><li>$A \rightarrow \varepsilon$</li></ul><p>Both right-linear and left-linear grammars generate <strong>regular languages</strong>, but <strong>mixing them is not allowed</strong> in regular grammar.</p><p><strong>🧮 Example of a Right-Linear Grammar</strong></p><p>Let’s define a grammar for the regular language $L &#x3D; { a^n b \mid n \geq 0 }$:</p><p><strong>Non-terminals</strong>: ${S, A}$<br><strong>Terminals</strong>: ${a, b}$<br><strong>Start symbol</strong>: $S$<br><strong>Production rules</strong>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">S → aS  S → b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>This generates strings like:</p><ul><li><code>b</code></li><li><code>ab</code></li><li><code>aab</code></li><li><code>aaab</code>, etc.</li></ul><p><strong>🤖 Equivalent Automata</strong></p><p>Every regular grammar corresponds to a <strong>finite automaton</strong>, and vice versa:</p><table><thead><tr><th>Model</th><th>Description</th></tr></thead><tbody><tr><td>Regular Grammar</td><td>Generates strings by rules</td></tr><tr><td>Finite Automaton</td><td>Accepts strings by state transitions</td></tr></tbody></table><p>So, regular grammar and finite automaton are <strong>equivalent in expressive power</strong>.</p><p><strong>📊 Closure Properties</strong></p><p>Regular grammars inherit all the closure properties of regular languages:</p><ul><li>✅ Union</li><li>✅ Concatenation</li><li>✅ Kleene Star</li><li>✅ Intersection with regular sets</li><li>✅ Complement</li></ul><p><strong>🚫 Limitations</strong></p><ul><li>Cannot handle <strong>nested structures</strong> (e.g., balanced parentheses)</li><li>Cannot count or match multiple dependencies (e.g., $a^n b^n$)</li></ul><p><strong>✅ Summary</strong></p><table><thead><tr><th>Feature</th><th>Regular Grammar</th></tr></thead><tbody><tr><td>Structure</td><td>Right- or left-linear rules</td></tr><tr><td>Generates</td><td>Regular languages</td></tr><tr><td>Equivalent to</td><td>Finite Automaton</td></tr><tr><td>Used in</td><td>Lexical analysis, pattern matching</td></tr><tr><td>Can generate $a^n$</td><td>✅ Yes</td></tr><tr><td>Can generate $a^n b^n$</td><td>❌ No</td></tr></tbody></table><hr><h3 id="Regular-Language"><a href="#Regular-Language" class="headerlink" title="Regular Language"></a>Regular Language</h3><p>A <strong>Regular Language</strong> is a class of formal languages that can be <strong>recognized by finite automata</strong>. It can be described by:</p><ul><li><strong>Deterministic Finite Automata (DFA)</strong></li><li><strong>Non-deterministic Finite Automata (NFA)</strong></li><li><strong>Regular expressions</strong></li></ul><p>If a language can be represented using any of the above methods, it is a <strong>regular language</strong>.</p><p><strong>🔹 Examples</strong></p><ol><li><p>Language of all strings over <code>&#123;a, b&#125;</code> that contain <strong>only</strong> <code>a</code>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">L &#x3D; &#123; ε, a, aa, aaa, ... &#125; &#x3D; a*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>Language of all strings that start with <code>a</code> and end with <code>b</code>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">L &#x3D; a(a|b)*b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li><li><p>Language of all strings with even number of <code>0</code>s over <code>&#123;0,1&#125;</code>:</p><ul><li>This can be recognized by a DFA with two states toggling on <code>0</code>.</li></ul></li></ol><ul><li><p>They can be <strong>expressed using regular expressions</strong>, and there is an equivalence between:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">DFA ⇄ NFA ⇄ Regular Expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><hr><h3 id="Non-Regular-Languages"><a href="#Non-Regular-Languages" class="headerlink" title="Non-Regular Languages"></a>Non-Regular Languages</h3><p>Some languages <strong>cannot</strong> be described by regular expressions or finite automata. For example:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">L &#x3D; &#123; aⁿbⁿ | n ≥ 0 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>This language requires memory to keep track of the number of <code>a</code>s and <code>b</code>s, which finite automata do not have.</p><p>To prove that a language is <strong>not regular</strong>, we can use the <strong>Pumping Lemma</strong>, which states:</p><p>If a language <code>L</code> is regular, there exists an integer <code>p &gt; 0</code> (pumping length) such that any string <code>s ∈ L</code> with length ≥ <code>p</code> can be split into <code>s = xyz</code> such that:</p><ul><li>|y| &gt; 0</li><li>|xy| ≤ p</li><li>For all <code>i ≥ 0</code>, the string <code>xyⁱz ∈ L</code></li></ul><p>If no such decomposition exists for a string, the language is <strong>not regular</strong>.</p><hr><h3 id="Closure-Properties-of-Regular-Languages"><a href="#Closure-Properties-of-Regular-Languages" class="headerlink" title="Closure Properties of Regular Languages"></a>Closure Properties of Regular Languages</h3><blockquote><p>🔹 What is “Closure”?</p></blockquote><p>In automata theory, a class of languages is said to be <strong>closed under an operation</strong> if <strong>applying that operation</strong> to languages in the class <strong>results in a language that is also in the class</strong>.</p><p>For <strong>regular languages</strong>, they are closed under many operations. This means if you take <strong>regular languages</strong> and apply these operations, the result will <strong>still be a regular language</strong>.</p><blockquote><p>🔹 Closure Under Common Operations</p></blockquote><table><thead><tr><th>Operation</th><th>Description</th><th>Result</th></tr></thead><tbody><tr><td><strong>Union</strong></td><td>If L₁ and L₂ are regular, then L₁ ∪ L₂ is also regular.</td><td>✅ Regular</td></tr><tr><td><strong>Intersection</strong></td><td>If L₁ and L₂ are regular, then L₁ ∩ L₂ is also regular.</td><td>✅ Regular</td></tr><tr><td><strong>Complement</strong></td><td>If L is regular, then its complement ¬L is also regular.</td><td>✅ Regular</td></tr><tr><td><strong>Concatenation</strong></td><td>If L₁ and L₂ are regular, then L₁L₂ is also regular.</td><td>✅ Regular</td></tr><tr><td><strong>Kleene Star</strong></td><td>If L is regular, then L* (zero or more repetitions) is also regular.</td><td>✅ Regular</td></tr><tr><td><strong>Reversal</strong></td><td>If L is regular, then the reverse of L is also regular.</td><td>✅ Regular</td></tr><tr><td><strong>Difference</strong></td><td>If L₁ and L₂ are regular, then L₁ - L₂ is also regular.</td><td>✅ Regular</td></tr><tr><td><strong>Homomorphism</strong></td><td>Applying a homomorphism to a regular language gives a regular language.</td><td>✅ Regular</td></tr><tr><td><strong>Inverse Homomorphism</strong></td><td>Inverse images of regular languages under homomorphisms are regular.</td><td>✅ Regular</td></tr><tr><td><strong>Substitution</strong></td><td>Regular languages are closed under substitution with regular languages.</td><td>✅ Regular</td></tr></tbody></table><blockquote><p>🔹 Example: Union Closure</p></blockquote><p>Let:</p><ul><li>L₁ &#x3D; { w | w contains only a’s } &#x3D; <code>a*</code></li><li>L₂ &#x3D; { w | w contains only b’s } &#x3D; <code>b*</code></li></ul><p>Then:</p><ul><li>L₁ ∪ L₂ &#x3D; { w | w contains only a’s or only b’s } &#x3D; <code>a* ∪ b*</code></li><li>This is still a regular language.</li></ul><blockquote><p>🔹 Why Closure is Useful</p></blockquote><ul><li>Closure properties help us <strong>construct complex regular languages</strong> from simpler ones.</li><li>They are essential in <strong>proving properties</strong> of languages.</li><li>They are used in <strong>compiler design</strong>, <strong>regex engines</strong>, and <strong>automated verification</strong>.</li></ul><hr><h3 id="🤖-DFA-Deterministic-Finite-Automaton"><a href="#🤖-DFA-Deterministic-Finite-Automaton" class="headerlink" title="🤖 DFA (Deterministic Finite Automaton)"></a>🤖 DFA (Deterministic Finite Automaton)</h3><p><strong>🔹 Definition</strong></p><p>A <strong>DFA</strong> is a type of <strong>finite automaton</strong> used to <strong>recognize regular languages</strong>. It reads an input string <strong>symbol by symbol</strong>, and <strong>at any point</strong> in time, it is in <strong>exactly one state</strong>.</p><p>A DFA is defined as a <strong>5-tuple</strong>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">DFA &#x3D; (Q, Σ, δ, q₀, F)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>Where:</p><ul><li><code>Q</code> → Finite set of <strong>states</strong></li><li><code>Σ</code> → Finite set of <strong>input symbols</strong> (alphabet)</li><li><code>δ</code> → <strong>Transition function</strong>: δ : Q × Σ → Q</li><li><code>q₀</code> → <strong>Start state</strong>, where the computation begins (<code>q₀ ∈ Q</code>)</li><li><code>F</code> → Set of <strong>accepting&#x2F;final states</strong> (<code>F ⊆ Q</code>)</li></ul><p><strong>🔹 Characteristics</strong></p><ul><li><strong>Deterministic</strong>: For every state <code>q ∈ Q</code> and every input symbol <code>a ∈ Σ</code>, <strong>there is exactly one transition</strong> defined:<br>δ(q, a) &#x3D; q’</li><li><strong>No epsilon (ε) transitions</strong>: Input must be read <strong>one symbol at a time</strong></li><li>DFA <strong>always knows</strong> what to do next</li></ul><p><strong>🔹 Example DFA</strong></p><p>Let’s define a DFA that accepts all strings over <code>&#123;0,1&#125;</code> that end with <code>01</code>.</p><ul><li><code>Q = &#123;q0, q1, q2&#125;</code></li><li><code>Σ = &#123;0, 1&#125;</code></li><li><code>q₀ = q0</code></li><li><code>F = &#123;q2&#125;</code></li></ul><p>Transition table:</p><table><thead><tr><th>Current State</th><th>Input</th><th>Next State</th></tr></thead><tbody><tr><td>q0</td><td>0</td><td>q1</td></tr><tr><td>q0</td><td>1</td><td>q0</td></tr><tr><td>q1</td><td>0</td><td>q1</td></tr><tr><td>q1</td><td>1</td><td>q2</td></tr><tr><td>q2</td><td>0</td><td>q1</td></tr><tr><td>q2</td><td>1</td><td>q0</td></tr></tbody></table><p>This DFA accepts strings like: <code>01</code>, <code>1001</code>, <code>1101</code>, etc.</p><p><strong>🔹 DFA vs NFA</strong></p><table><thead><tr><th>Feature</th><th>DFA</th><th>NFA</th></tr></thead><tbody><tr><td>Transition</td><td>One unique next state</td><td>May have multiple next states</td></tr><tr><td>ε-transitions</td><td>Not allowed</td><td>Allowed</td></tr><tr><td>Simplicity</td><td>Easier to implement</td><td>Easier to design</td></tr><tr><td>Power</td><td><strong>Same (both recognize regular languages)</strong></td><td></td></tr></tbody></table><p><strong>🔹 Applications</strong></p><ul><li>Lexical analysis (token recognition)</li><li>Pattern matching (e.g., <code>grep</code>, <code>regex</code>)</li><li>Protocol design</li><li>Digital circuits</li></ul><hr><h3 id="🔄-NFA-Nondeterministic-Finite-Automaton"><a href="#🔄-NFA-Nondeterministic-Finite-Automaton" class="headerlink" title="🔄 NFA (Nondeterministic Finite Automaton)"></a>🔄 NFA (Nondeterministic Finite Automaton)</h3><p><strong>🔹 Definition</strong></p><p>An <strong>NFA</strong> is a type of <strong>finite automaton</strong> used to recognize <strong>regular languages</strong>, just like a DFA. The key difference is that <strong>multiple transitions</strong> are allowed for the <strong>same input</strong> from a single state, and <strong>ε-transitions</strong> (transitions without consuming input) are permitted.</p><p>An NFA is formally defined as a <strong>5-tuple</strong>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">NFA &#x3D; (Q, Σ, δ, q₀, F)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>Where:</p><ul><li><code>Q</code> → Finite set of <strong>states</strong></li><li><code>Σ</code> → Finite set of <strong>input symbols</strong> (alphabet)</li><li><code>δ</code> → <strong>Transition function</strong>: δ : Q × (Σ ∪ {ε}) → 2^Q</li><li><code>q₀</code> → <strong>Start state</strong>, <code>q₀ ∈ Q</code></li><li><code>F</code> → Set of <strong>accepting&#x2F;final states</strong>, <code>F ⊆ Q</code></li></ul><p><strong>🔹 Characteristics</strong></p><ul><li><p><strong>Non-deterministic</strong>:</p><ul><li>From a given state and input, the NFA can <strong>go to multiple next states</strong>.</li><li>The NFA <strong>accepts</strong> an input string if <strong>at least one possible path</strong> leads to an accepting state.</li></ul></li><li><p><strong>ε-transitions allowed</strong>: The machine can move <strong>without reading input</strong>.</p></li><li><p><strong>Can be in multiple states</strong> at once during computation.</p></li></ul><p><strong>🔹 Example NFA</strong></p><p>Let’s define an NFA that accepts strings over <code>&#123;0,1&#125;</code> ending in <code>01</code>.</p><ul><li><code>Q = &#123;q0, q1, q2&#125;</code></li><li><code>Σ = &#123;0, 1&#125;</code></li><li><code>q₀ = q0</code></li><li><code>F = &#123;q2&#125;</code></li></ul><p>Transition table:</p><table><thead><tr><th>Current State</th><th>Input</th><th>Next States</th></tr></thead><tbody><tr><td>q0</td><td>0</td><td>{q0, q1}</td></tr><tr><td>q0</td><td>1</td><td>{q0}</td></tr><tr><td>q1</td><td>1</td><td>{q2}</td></tr><tr><td>q2</td><td>0,1</td><td>∅</td></tr></tbody></table><p>In this NFA, from <code>q0</code>, if we read <code>0</code>, we can <strong>either</strong> stay in <code>q0</code> or go to <code>q1</code>.</p><p><strong>🔹 NFA vs DFA</strong></p><table><thead><tr><th>Feature</th><th>NFA</th><th>DFA</th></tr></thead><tbody><tr><td>Transitions</td><td>Can go to <strong>multiple</strong> states</td><td>Only <strong>one</strong> next state</td></tr><tr><td>ε-transitions</td><td><strong>Allowed</strong></td><td><strong>Not allowed</strong></td></tr><tr><td>Execution</td><td>Can explore multiple paths in parallel</td><td>Only one deterministic path</td></tr><tr><td>Implementation</td><td>More complex</td><td>Easier</td></tr><tr><td>Expressive Power</td><td><strong>Same</strong> – both recognize regular languages</td><td></td></tr></tbody></table><blockquote><p>💡 Every NFA can be converted into an equivalent DFA (subset construction), though the DFA may have exponentially more states.</p></blockquote><p><strong>🔹 Applications</strong></p><ul><li>Easier to <strong>design</strong> than DFA for complex patterns</li><li>Used in <strong>regular expression engines</strong></li><li>Foundations for <strong>parser generators</strong> and <strong>compiler design</strong></li></ul><hr><h3 id="Finite-State-Machine-FSM"><a href="#Finite-State-Machine-FSM" class="headerlink" title="Finite-State Machine (FSM)"></a>Finite-State Machine (FSM)</h3><p>A <strong>Finite-State Machine (FSM)</strong> is a computational model used to design and describe the behavior of digital systems, software, or processes that are dependent on a sequence of inputs and a finite number of internal states.</p><p><strong>🧠 Key Concepts</strong></p><table><thead><tr><th>Term</th><th>Description</th></tr></thead><tbody><tr><td><strong>State</strong></td><td>A unique configuration or condition of the system at a given time.</td></tr><tr><td><strong>Input</strong></td><td>External data or signal that triggers a transition.</td></tr><tr><td><strong>Transition</strong></td><td>The process of moving from one state to another.</td></tr><tr><td><strong>Initial State</strong></td><td>The state in which the FSM starts.</td></tr><tr><td><strong>Final State(s)</strong></td><td>Some FSMs may have one or more accepting states that signify a successful process.</td></tr></tbody></table><p><strong>🛠 Types of FSM</strong></p><ol><li><p><strong>Deterministic Finite Automaton (DFA)</strong></p><ul><li>Each state has <em>exactly one</em> transition for each possible input.</li><li>There is <em>no ambiguity</em> in state transitions.</li></ul></li><li><p><strong>Nondeterministic Finite Automaton (NFA)</strong></p><ul><li>A state can have <em>multiple transitions</em> for the same input.</li><li>May include <em>ε-transitions</em> (transitions without input).</li></ul></li></ol><p><strong>⚙️ Components of an FSM</strong></p><p>An FSM is formally defined as a 5-tuple:</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p><strong>🧭 How It Works (Example)</strong></p><p>Suppose we have an FSM that accepts binary strings ending in <code>01</code>.</p><ul><li><p><strong>States</strong>: <code>S0</code> (start), <code>S1</code> (seen 0), <code>S2</code> (accepting, seen 01)</p></li><li><p><strong>Input</strong>: <code>0</code>, <code>1</code></p></li><li><p><strong>Transitions</strong>:</p><ul><li>From <code>S0</code>, on <code>0</code> → <code>S1</code></li><li>From <code>S1</code>, on <code>1</code> → <code>S2</code></li><li>From <code>S2</code>, on <code>0</code> → <code>S1</code>, on <code>1</code> → <code>S0</code> (reset if wrong pattern)</li></ul></li></ul><p><strong>📦 Applications</strong></p><ul><li>Lexical analyzers (compilers)</li><li>Protocol design</li><li>Game development (e.g., AI behavior)</li><li>Digital circuit design</li><li>Control systems</li></ul><hr><h3 id="Pumping-Lemma-for-regular-languages"><a href="#Pumping-Lemma-for-regular-languages" class="headerlink" title="Pumping Lemma for regular languages"></a>Pumping Lemma for regular languages</h3><p>The <strong>Pumping Lemma</strong> for regular languages is an important tool in formal language and automata theory, used to prove that a given language is <strong>not</strong> regular. The pumping lemma provides a “pumping” property, which means that certain strings in a regular language can be repeated (or “pumped”) under specific conditions without changing whether the string belongs to the language.</p><p>The pumping lemma mainly applies to regular languages. It states:<br>If a language is regular, then there exists a constant $p$ (called the pumping length), such that for any string $s \in L$ (where $s$ belongs to language $L$) with length greater than or equal to $p$, it is possible to divide $s$ into the following three parts:</p><ul><li><p>$s &#x3D; xyz$, where:</p><ul><li>$x$ is a prefix of $s$ (possibly empty).</li><li>$y$ is the part that can be “pumped”, and $|y| &gt; 0$.</li><li>$z$ is a suffix of $s$ (possibly empty).</li></ul></li></ul><p>Moreover, for any $i \geq 0$, the string $xy^i z$ must also belong to the language $L$. That is, the substring $y$ can be repeated any number of times without affecting whether $s$ belongs to $L$.</p><hr><h3 id="Pumping-Lemma-for-CFLs"><a href="#Pumping-Lemma-for-CFLs" class="headerlink" title="Pumping Lemma for CFLs"></a>Pumping Lemma for CFLs</h3><p>The Pumping Lemma for Context-Free Languages (CFLs) states that for any context-free language $L$, if $L$ is infinite, then there exists a constant $p$ (pumping length), such that for every string $s \in L$ with length greater than or equal to $p$, the string $s$ can be divided into five parts $s &#x3D; uvwxy$, satisfying the following conditions:</p><ol><li>For all $i \geq 0$, $uv^i w x^i y \in L$.</li><li>$|v| + |x| &gt; 0$ (i.e., $v$ and $x$ are not both empty).</li><li>$|vwx| \leq p$ (the total length of $v$, $w$, and $x$ does not exceed the pumping length $p$).</li></ol><p>We assume that $L$ is an infinite context-free language. Since $L$ is a context-free language, based on the structural properties of context-free grammars, it corresponds to a pushdown automaton (PDA). This PDA must satisfy one condition: it can “pump” strings, i.e., repeat certain parts of the string while keeping the resulting string within the language $L$.</p><p>According to the pumping lemma assumption, there exists a pumping length $p$, such that for all strings $s \in L$ with length greater than or equal to $p$, the string $s$ can be decomposed as $s &#x3D; uvwxy$, satisfying the following conditions:</p><ul><li>$|vwx| \leq p$</li><li>$|v| + |x| &gt; 0$</li></ul><p>Context-free languages can be generated by context-free grammars (CFGs) or recognized by pushdown automata (PDAs). We use these structures to demonstrate the pumping lemma.</p><ul><li><p>For any string $s \in L$ with length greater than or equal to $p$, it must be generated by derivation using a context-free grammar.</p></li><li><p>Since $L$ is infinite, there exists a derivation tree for some parts that can be broken down into five parts $uvwxy$, where:</p><ul><li>$v$ and $x$ are the parts that can be “pumped” or repeated.</li><li>The total length of $v$ and $x$ does not exceed $p$.</li><li>This means that for some appropriate $i$, $v$ and $x$ can be repeated without breaking the structure of the language.</li></ul></li></ul><blockquote><p>The proof here also involves the Pigeonhole Principle, which is not elaborated on in detail.</p></blockquote><p>Based on the structure of context-free languages, the string $s$ can be decomposed as $s &#x3D; uvwxy$, satisfying the following conditions:</p><ul><li>$|vwx| \leq p$, which means the total length of $v$ and $x$ does not exceed the pumping length $p$; their lengths are finite.</li><li>$|v| + |x| &gt; 0$, which means $v$ and $x$ cannot both be empty.</li></ul><p>According to the pumping lemma, we know that if we “pump” the parts $v$ and $x$ of the string $s$, i.e., repeat them multiple times, then the new string $uv^i w x^i y$ will still belong to the language $L$, for all $i \geq 0$.</p><p>According to the pumping lemma assumption, for all $i \geq 0$, $uv^i w x^i y \in L$. This means that by increasing the number of repetitions of parts $v$ and $x$, the string remains within the language $L$.</p><p>The key to this process is that through appropriate decomposition and pumping operations, the structure of the language remains unchanged, and therefore it can be accepted by a context-free grammar or pushdown automaton.</p><p>Using the pumping lemma, we can prove that some languages are <strong>not</strong> context-free. A proof by contradiction is often used to show that a language does not satisfy the requirements of a context-free language. By choosing an appropriate string and assuming it satisfies the conditions of the pumping lemma, we can show that certain operations cause the resulting string to no longer belong to the language, thus concluding that the language is not context-free.</p><hr><p>Using the pumping lemma, we can prove that certain languages are not context-free by contradiction. Suppose we want to prove that a language $L$ is not context-free. The process usually involves the following steps:</p><ol><li>Assume that $L$ is a context-free language and that it satisfies the pumping lemma.</li><li>Choose a string $s \in L$ with length greater than or equal to the pumping length $p$, then decompose it as $s &#x3D; uvwxy$ and apply the pumping lemma.</li><li>Expand $uv^i w x^i y$ and prove that for some values of $i$, $uv^i w x^i y \notin L$, thus leading to a contradiction.</li><li>Conclude that $L$ is not a context-free language.</li></ol><p>Example: Prove that $L &#x3D; { a^n b^n c^n \mid n \geq 0 }$ is not a context-free language.</p><p>We use the pumping lemma for context-free languages to prove that $L &#x3D; { a^n b^n c^n \mid n \geq 0 }$ is not context-free.</p><ol><li><p><strong>Assume $L$ is a context-free language:</strong><br>Assume that $L$ is a context-free language and that a pumping length $p$ exists. According to the pumping lemma, any string $s$ with length greater than or equal to $p$ can be decomposed as $s &#x3D; uvwxy$, where $|vwx| \leq p$ and $|v| + |x| &gt; 0$.</p></li><li><p><strong>Choose the string $s &#x3D; a^p b^p c^p$:</strong><br>Choose the string $s &#x3D; a^p b^p c^p$, which clearly belongs to $L$, and its length $|s| &#x3D; 3p \geq p$.</p></li><li><p><strong>Decompose the string $s$:</strong><br>According to the pumping lemma, $s &#x3D; uvwxy$, where $|vwx| \leq p$ and $|v| + |x| &gt; 0$. Since $|vwx| \leq p$, it can only span one portion of the string (i.e., the $a^n$, $b^n$, or $c^n$ part). Also, since $|v| + |x| &gt; 0$, $v$ and $x$ must include some repeating characters.</p></li><li><p><strong>Apply the pumping lemma:</strong><br>According to the pumping lemma, for all $i \geq 0$, $uv^i w x^i y$ should still belong to $L$. However, if we choose $i &gt; 1$, we get a mismatched string such as $uv^2 w x^2 y$. This string would no longer maintain the same number of <code>a</code>s, <code>b</code>s, and <code>c</code>s, and thus would not belong to $L$.</p></li><li><p><strong>Reach a contradiction:</strong><br>Therefore, we conclude that $L$ cannot be a context-free language because the result from the pumping lemma contradicts the definition of $L$.</p></li></ol><p>The pumping lemma for context-free languages demonstrates certain properties of languages by decomposing and repeating parts of their strings. It provides a method to prove by contradiction that certain languages are not context-free.</p><hr><h3 id="Context-Free-Language-CFL"><a href="#Context-Free-Language-CFL" class="headerlink" title="Context-Free Language (CFL)"></a>Context-Free Language (CFL)</h3><p>A <strong>Context-Free Language (CFL)</strong> is a type of formal language that can be generated by a <strong>Context-Free Grammar (CFG)</strong>. It is an essential concept in the theory of computation and plays a major role in compiler design and parsing.</p><p><strong>📘 What is a Context-Free Grammar (CFG)?</strong></p><p>A <strong>Context-Free Grammar</strong> is a set of recursive rewriting rules (productions) used to generate strings in a language. A CFG is formally defined as a 4-tuple:</p><p>$$<br>G &#x3D; (V, \Sigma, R, S)<br>$$</p><p>Where:</p><ul><li>$V$: A finite set of <strong>variables</strong> (non-terminal symbols)</li><li>$\Sigma$: A finite set of <strong>terminal symbols</strong> (alphabet of the language)</li><li>$R$: A finite set of <strong>production rules</strong>, each of the form $A \rightarrow \gamma$, where $A \in V$ and $\gamma \in (V \cup \Sigma)^*$</li><li>$S$: The <strong>start symbol</strong>, $S \in V$</li></ul><p><strong>🧠 Key Characteristics of CFLs</strong></p><ul><li>The <strong>left-hand side</strong> of every production rule in a CFG has exactly <strong>one non-terminal</strong>.</li><li>A string belongs to the CFL if it can be derived from the start symbol using the rules.</li><li>CFLs are more powerful than <strong>regular languages</strong>, but less powerful than <strong>context-sensitive languages</strong>.</li></ul><p><strong>🧮 Example of a Context-Free Grammar</strong></p><p>Let’s define a CFG for the language $L &#x3D; { a^n b^n \mid n \geq 0 }$:</p><p><strong>Grammar:</strong></p><ul><li><p>$V &#x3D; { S }$</p></li><li><p>$\Sigma &#x3D; { a, b }$</p></li><li><p><strong>Production Rules</strong>:</p><ul><li>$S \rightarrow aSb$</li><li>$S \rightarrow \varepsilon$ <em>(epsilon, the empty string)</em></li></ul></li><li><p>$S$: start symbol</p></li></ul><p>This grammar generates:</p><ul><li>$\varepsilon$</li><li>$ab$</li><li>$aabb$</li><li>$aaabbb$, etc.</li></ul><p><strong>📊 Closure Properties of CFLs</strong></p><table><thead><tr><th>Operation</th><th>Closed under?</th></tr></thead><tbody><tr><td>Union</td><td>✅ Yes</td></tr><tr><td>Concatenation</td><td>✅ Yes</td></tr><tr><td>Kleene Star</td><td>✅ Yes</td></tr><tr><td>Intersection</td><td>❌ No</td></tr><tr><td>Complement</td><td>❌ No</td></tr></tbody></table><p><strong>🖥 Recognizing CFLs with Pushdown Automata (PDA)</strong></p><p>A <strong>Pushdown Automaton (PDA)</strong> is a computational model that recognizes context-free languages.<br>It is similar to a finite automaton but with an added <strong>stack</strong>, which allows it to store an unbounded amount of information.</p><blockquote><p>CFLs are <strong>exactly</strong> the class of languages accepted by nondeterministic PDAs.</p></blockquote><p><strong>🚫 Not All Languages Are CFLs</strong></p><p>Some languages are <strong>not</strong> context-free, for example:</p><p>$$<br>L &#x3D; { a^n b^n c^n \mid n \geq 0 }<br>$$</p><p>No CFG can generate this language because it requires <strong>three-way balancing</strong>, which CFGs cannot handle.</p><p><strong>🧪 Applications of CFLs</strong></p><ul><li><strong>Programming languages</strong> (syntax parsing)</li><li><strong>Compilers</strong> (syntax analysis)</li><li><strong>Natural language processing</strong></li><li><strong>XML and structured data parsing</strong></li></ul><hr><h3 id="Pushdown-Automaton-PDA"><a href="#Pushdown-Automaton-PDA" class="headerlink" title="Pushdown Automaton (PDA)"></a>Pushdown Automaton (PDA)</h3><p>A <strong>Pushdown Automaton (PDA)</strong> is a type of computational model that extends the <strong>finite automaton</strong> by adding a <strong>stack</strong> as memory. This additional memory allows it to recognize <strong>context-free languages</strong> (CFLs), which are more powerful than regular languages.</p><p><strong>🧠 Intuition</strong></p><p>A PDA reads input symbols <strong>one at a time</strong>, transitions between states based on the current input <strong>and</strong> the <strong>top of the stack</strong>, and can <strong>push</strong> or <strong>pop</strong> symbols from the stack.</p><ul><li>Think of the <strong>stack</strong> as an unlimited memory that operates in <strong>LIFO</strong> (Last-In, First-Out) order.</li><li>The PDA uses the stack to keep track of nested or recursive patterns (e.g. matching parentheses).</li></ul><p><strong>🧱 Formal Definition</strong></p><p>A <strong>PDA</strong> is a 7-tuple:</p><p>$$<br>M &#x3D; (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)<br>$$</p><p>Where:</p><table><thead><tr><th>Symbol</th><th>Description</th></tr></thead><tbody><tr><td>$Q$</td><td>A finite set of <strong>states</strong></td></tr><tr><td>$\Sigma$</td><td>The <strong>input alphabet</strong></td></tr><tr><td>$\Gamma$</td><td>The <strong>stack alphabet</strong></td></tr><tr><td>$\delta$</td><td>The <strong>transition function</strong>: $Q \times (\Sigma \cup \varepsilon) \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$</td></tr><tr><td>$q_0$</td><td>The <strong>start state</strong>, $q_0 \in Q$</td></tr><tr><td>$Z_0$</td><td>The <strong>initial stack symbol</strong>, $Z_0 \in \Gamma$</td></tr><tr><td>$F$</td><td>A set of <strong>accepting (final) states</strong>, $F \subseteq Q$</td></tr></tbody></table><p><strong>🔁 Transition Function Explanation</strong></p><p>The transition function:</p><p>$$<br>\delta(q, a, X) &#x3D; { (q’, \gamma) }<br>$$</p><p>Means:</p><ul><li><p>In state $q$, if the input symbol is $a$ (or $\varepsilon$), and the <strong>top of the stack</strong> is $X$,</p></li><li><p>Then the machine can:</p><ul><li><strong>Move</strong> to state $q’$</li><li><strong>Replace</strong> $X$ with $\gamma$ on the stack (where $\gamma$ can be multiple symbols or empty)</li></ul></li></ul><p>🧮 Example: PDA for $L &#x3D; { a^n b^n \mid n \geq 0 }$</p><p>We want to accept strings where the number of <code>a</code>s equals the number of <code>b</code>s.</p><p><strong>Idea</strong>:</p><ul><li>Push <code>A</code> onto the stack for each <code>a</code>.</li><li>Pop <code>A</code> from the stack for each <code>b</code>.</li><li>Accept if the stack is empty at the end.</li></ul><table><thead><tr><th>Step</th><th>Stack Operation</th></tr></thead><tbody><tr><td>Read <code>a</code></td><td>Push <code>A</code></td></tr><tr><td>Read <code>b</code></td><td>Pop <code>A</code></td></tr><tr><td>Input done</td><td>Accept if stack empty</td></tr></tbody></table><p><strong>✅ Acceptance Criteria</strong></p><p>There are <strong>two common acceptance methods</strong> for PDAs:</p><ol><li><strong>By final state</strong>: The PDA ends in an accepting state after reading the entire input.</li><li><strong>By empty stack</strong>: The PDA’s stack is empty after reading the entire input.</li></ol><blockquote><p>Both methods define the same class of languages: <strong>context-free languages</strong>.</p></blockquote><p><strong>⚠️ Deterministic vs Nondeterministic PDA</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><strong>NPDA</strong></td><td>Nondeterministic PDA — accepts all CFLs</td></tr><tr><td><strong>DPDA</strong></td><td>Deterministic PDA — accepts only some CFLs</td></tr></tbody></table><p>Not all context-free languages can be recognized by a deterministic PDA.</p><p>🔬 <strong>Applications</strong></p><ul><li><strong>Parsing</strong> expressions in compilers</li><li><strong>Syntax checking</strong> in programming languages (e.g., bracket matching)</li><li>Modeling <strong>recursive structures</strong></li><li><strong>Natural language processing</strong> (nested phrase structures)</li></ul><hr><h3 id="Ambiguity-of-Grammar"><a href="#Ambiguity-of-Grammar" class="headerlink" title="Ambiguity of Grammar"></a>Ambiguity of Grammar</h3><p>In formal language theory, a <strong>grammar is said to be ambiguous</strong> if there exists <strong>at least one string</strong> that can be generated by the grammar in <strong>more than one way</strong> — specifically, it has <strong>more than one parse tree (or derivation)</strong>.</p><p><strong>📚 Definition</strong></p><p>A <strong>context-free grammar (CFG)</strong> $G$ is <strong>ambiguous</strong> if <strong>there exists a string</strong> $w \in L(G)$ such that:</p><ul><li>$w$ has <strong>two or more different parse trees</strong>, or</li><li>$w$ has <strong>two or more leftmost (or rightmost) derivations</strong></li></ul><p><strong>🧠 Why Does Ambiguity Matter?</strong></p><ul><li><strong>Ambiguous grammars</strong> are problematic in <strong>programming language design</strong>, especially during <strong>parsing</strong>, because a compiler may not know which interpretation is correct.</li><li>Some context-free languages are <strong>inherently ambiguous</strong> — no unambiguous CFG can generate them.</li></ul><p><strong>🧮 Example: An Ambiguous Grammar</strong></p><p>Let’s define a simple grammar for arithmetic expressions:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">E → E + E  E → E * E  E → (E)  E → id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>This grammar generates expressions like <code>id + id * id</code>, but it is <strong>ambiguous</strong> because:</p><ul><li>It can be parsed as <code>(id + id) * id</code></li><li>Or as <code>id + (id * id)</code></li></ul><p>Both are valid interpretations but <strong>yield different parse trees</strong>.</p><p><strong>🌲 Two Different Parse Trees for <code>id + id * id</code></strong></p><p><strong>1. Left-associative (Addition first)</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">    E   &#x2F;|\  E + E |    |id   E * E     |   |    id  id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>2. Right-associative (Multiplication first)</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">       E      &#x2F;|\     E * E    |    |   E + E id  |   |id  id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>This shows <strong>ambiguity</strong> in structure and meaning.</p><p><strong>🛠 Disambiguating a Grammar</strong></p><p>To <strong>remove ambiguity</strong>, you can:</p><ul><li><strong>Introduce precedence and associativity rules</strong> (e.g., make <code>*</code> bind tighter than <code>+</code>)</li><li><strong>Refactor the grammar</strong> to eliminate conflicting derivations</li></ul><p>For example:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">E  → E + T | T  T  → T * F | F  F  → (E) | id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>Now:</p><ul><li><code>*</code> has higher precedence than <code>+</code></li><li>Left associativity is enforced</li><li>This grammar is <strong>unambiguous</strong></li></ul><p><strong>🔥 Inherently Ambiguous Languages</strong></p><p>Some CFLs are <strong>inherently ambiguous</strong>, meaning <strong>no matter how you write the grammar</strong>, some strings will always have multiple parse trees.</p><p>Example language:</p><p>$$<br>L &#x3D; { a^i b^j c^k \mid i &#x3D; j \text{ or } j &#x3D; k }<br>$$</p><p>This language is <strong>not inherently unambiguous</strong> because you can’t write a CFG for it that avoids ambiguity in all cases.</p><p><strong>✅ Summary</strong></p><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody><tr><td><strong>Ambiguity</strong></td><td>A string has multiple parse trees or derivations in a grammar</td></tr><tr><td><strong>Unambiguous CFG</strong></td><td>A CFG where every string has <strong>only one</strong> parse tree</td></tr><tr><td><strong>Inherently Ambiguous Language</strong></td><td>A CFL for which <strong>no unambiguous grammar exists</strong></td></tr><tr><td><strong>Solution</strong></td><td>Rewrite grammar with precedence&#x2F;associativity or restructure rules</td></tr></tbody></table><hr><h3 id="Turing-Machine"><a href="#Turing-Machine" class="headerlink" title="Turing Machine"></a>Turing Machine</h3><p>A <strong>Turing Machine</strong> is a powerful abstract computational model introduced by <strong>Alan Turing</strong> in 1936. It forms the foundation of modern computer science and helps define the limits of what can be computed.</p><p><strong>🧱 Definition</strong></p><p>A <strong>Turing Machine (TM)</strong> is a 7-tuple:</p><p>$$<br>M &#x3D; (Q, \Sigma, \Gamma, \delta, q_0, q_{\text{accept}}, q_{\text{reject}})<br>$$</p><p>Where:</p><table><thead><tr><th>Symbol</th><th>Meaning</th></tr></thead><tbody><tr><td>$Q$</td><td>A finite set of <strong>states</strong></td></tr><tr><td>$\Sigma$</td><td>The <strong>input alphabet</strong> (does not include the blank symbol <code>□</code>)</td></tr><tr><td>$\Gamma$</td><td>The <strong>tape alphabet</strong> (includes <code>□</code>, the blank symbol)</td></tr><tr><td>$\delta$</td><td>The <strong>transition function</strong>: $Q \times \Gamma \rightarrow Q \times \Gamma \times {L, R}$</td></tr><tr><td>$q_0$</td><td>The <strong>start state</strong></td></tr><tr><td>$q_{\text{accept}}$</td><td>The <strong>accepting state</strong></td></tr><tr><td>$q_{\text{reject}}$</td><td>The <strong>rejecting state</strong> (≠ $q_{\text{accept}}$)</td></tr></tbody></table><p><strong>🧠 How It Works</strong></p><ol><li><p>The machine has an <strong>infinite tape</strong> divided into cells, each holding one symbol from $\Gamma$.</p></li><li><p>A <strong>tape head</strong> reads and writes symbols on the tape and moves <strong>left (L)</strong> or <strong>right (R)</strong>.</p></li><li><p>The machine starts in the <strong>start state</strong> $q_0$, with the tape containing the input string and blanks elsewhere.</p></li><li><p>Based on the current state and the symbol under the head, the <strong>transition function</strong> determines:</p><ul><li>The next state</li><li>The symbol to write</li><li>The direction to move the head</li></ul></li><li><p>The machine halts when it enters either the <strong>accept state</strong> or the <strong>reject state</strong>.</p></li></ol><p><strong>📋 Example Transition</strong></p><p>If:</p><p>$$<br>\delta(q_1, 1) &#x3D; (q_2, 0, R)<br>$$</p><p>It means:</p><ul><li>In state $q_1$, if reading symbol <code>1</code></li><li>Write <code>0</code>, move <strong>right</strong>, and go to state $q_2$</li></ul><p><strong>✅ Acceptance Criteria</strong></p><p>A string is <strong>accepted</strong> by the Turing Machine if, starting from the initial configuration, the machine <strong>eventually reaches the accept state</strong>.</p><p><strong>🧮 Example Language</strong></p><p>Language:</p><p>$$<br>L &#x3D; { w \in {0,1}^* \mid w \text{ has an even number of 0s} }<br>$$</p><p>A Turing Machine for this language could:</p><ul><li>Track even&#x2F;odd count using states</li><li>Scan the tape and change state upon reading <code>0</code></li><li>Halt in the accept state if the final state indicates even count</li></ul><p><strong>🧰 Types of Turing Machines</strong></p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><strong>Deterministic TM (DTM)</strong></td><td>One possible action per state-symbol pair</td></tr><tr><td><strong>Nondeterministic TM (NTM)</strong></td><td>Multiple possible transitions (theoretical model)</td></tr><tr><td><strong>Multi-tape TM</strong></td><td>Multiple tapes (still equivalent in power to DTM)</td></tr><tr><td><strong>Universal TM</strong></td><td>Simulates any other Turing Machine (like real computers!)</td></tr></tbody></table><p><strong>🔬 Power of Turing Machines</strong></p><p>Turing Machines can simulate:</p><ul><li>Finite automata</li><li>Pushdown automata</li><li>Real programming languages</li></ul><p>They can compute anything that is <strong>computable</strong>, but <strong>some problems are undecidable</strong>, like the <strong>halting problem</strong>.</p><p><strong>🔒 Limitations</strong></p><ul><li><strong>Not all languages are Turing-decidable</strong></li><li><strong>Undecidable problems</strong> exist (e.g., Halting Problem, Post Correspondence Problem)</li></ul><p><strong>✅ Summary</strong></p><table><thead><tr><th>Feature</th><th>Turing Machine</th></tr></thead><tbody><tr><td>Memory</td><td>Infinite tape</td></tr><tr><td>Acceptance</td><td>By entering accept state</td></tr><tr><td>More powerful than</td><td>FA, PDA, CFG</td></tr><tr><td>Can simulate real CPUs</td><td>✅ Yes</td></tr><tr><td>Can solve all problems</td><td>❌ No (some problems are undecidable)</td></tr></tbody></table><h2 id="5-Programming-Language"><a href="#5-Programming-Language" class="headerlink" title="5. Programming Language"></a>5. Programming Language</h2><h2 id="6-Machine-Learning"><a href="#6-Machine-Learning" class="headerlink" title="6. Machine Learning"></a>6. Machine Learning</h2><h3 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h3><p><strong>Random Forest</strong> 是一种基于 <strong>集成学习（Ensemble Learning）</strong> 的分类或回归算法，它将多个 <strong>决策树（Decision Tree）</strong> 组合在一起，通过“投票”或“平均”的方式得到最终结果。</p><blockquote><p>它是一种 <strong>Bagging（Bootstrap Aggregation）</strong> 方法，用于减少过拟合、提升泛化能力。</p></blockquote><p><strong>📦 应用于场景</strong></p><ul><li><strong>分类任务</strong>：判断邮件是否垃圾</li><li><strong>回归任务</strong>：预测房价</li><li><strong>特征重要性分析</strong>：哪些变量对预测结果影响最大？</li></ul><p><strong>🧠 核心思想</strong></p><p><strong>多个“弱学习器”</strong>（即单棵决策树）在数据子集上独立训练，然后<strong>集成</strong>它们的预测结果。</p><p><strong>⚙️ 构造过程（算法流程）</strong></p><p>Step 1️⃣：Bootstrap 采样（有放回抽样）</p><p>从训练数据集中<strong>有放回地随机抽样</strong> $N$ 次，构成若干个训练子集（每棵树用一份）</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">原始数据 D = &#123;x1, x2, ..., xn&#125;→ 样本子集 D1, D2, ..., Dk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>Step 2️⃣：训练多棵决策树（树的多样性来源之一）</p><p>对每个子集 $D_i$ 训练一棵<strong>决策树</strong>，但每个节点划分时只使用<strong>随机选择的部分特征</strong>（通常 $\sqrt{M}$ 个特征）</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">例如：总共有 100 个特征，每个节点只从随机选出的 10 个特征中选择最佳划分<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>Step 3️⃣：集成预测结果</p><ul><li><strong>分类任务</strong>：采用<strong>多数投票</strong>（majority vote）</li><li><strong>回归任务</strong>：采用<strong>平均值</strong>（average）</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 分类投票</span>final_class <span class="token operator">=</span> most_common<span class="token punctuation">(</span><span class="token punctuation">[</span>tree<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> tree <span class="token keyword">in</span> forest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 回归平均</span>final_value <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> tree <span class="token keyword">in</span> forest<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>forest<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>🧩 为什么 Random Forest 有效？</p><p>🎯 降低过拟合</p><ul><li>单棵树容易对噪声拟合（高方差）</li><li>多棵树平均可以“相互抵消”过拟合的部分</li></ul><p>🎯 提高泛化能力</p><ul><li>利用数据和特征的随机性，使得每棵树不太相同，整体更强大</li></ul><p>🎯 可并行训练（每棵树相互独立）</p><p><strong>🔍 特征重要性评估</strong></p><p>每棵树训练后可计算各特征在信息增益或 Gini 指数上的贡献<br>→ 可以评估哪些变量对模型影响最大</p><p>📊 时间与空间复杂度</p><p>设：</p><ul><li>$n$：样本数量</li><li>$m$：特征数量</li><li>$k$：树的数量</li><li>$d$：树的平均深度</li></ul><table><thead><tr><th>操作</th><th>复杂度</th></tr></thead><tbody><tr><td>训练时间</td><td>$O(k \cdot n \cdot \log n \cdot m’)$（$m’ \ll m$）</td></tr><tr><td>推理时间</td><td>$O(k \cdot d)$</td></tr><tr><td>空间复杂度</td><td>$O(k \cdot n)$（每棵树存储路径）</td></tr></tbody></table><p> ✅ 优点总结</p><ul><li>不容易过拟合</li><li>可处理高维数据</li><li>对异常值不敏感</li><li>支持特征重要性排序</li><li>适合并行处理</li></ul><p>⚠️ 缺点</p><ul><li>相比单棵树可解释性较差</li><li>训练时间较长</li><li>若样本不平衡，分类性能可能下降</li></ul><p>📌 Python示例（使用 <code>sklearn</code>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> RandomForestClassifier<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_iris<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token comment"># 加载数据</span>X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_iris<span class="token punctuation">(</span>return_X_y<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>X_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token comment"># 训练随机森林</span>clf <span class="token operator">=</span> RandomForestClassifier<span class="token punctuation">(</span>n_estimators<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> max_features<span class="token operator">=</span><span class="token string">'sqrt'</span><span class="token punctuation">)</span>clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token comment"># 预测</span>y_pred <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>📖 总结表格</strong></p><table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td>模型类型</td><td>集成学习（Bagging）</td></tr><tr><td>基学习器</td><td>决策树</td></tr><tr><td>多样性来源</td><td>数据采样 + 特征子集选择</td></tr><tr><td>聚合方式</td><td>多数投票（分类） &#x2F; 平均（回归）</td></tr><tr><td>优点</td><td>抗过拟合、稳定、能评估特征重要性</td></tr><tr><td>常用库</td><td><code>scikit-learn</code>、<code>xgboost</code>、<code>lightgbm</code>（变种）</td></tr></tbody></table><img src="/img/concepts/random.svg" alt="随机森林" style="max-width: 100%; height: auto;" /><hr><h3 id="线性回归（Linear-Regression）"><a href="#线性回归（Linear-Regression）" class="headerlink" title="线性回归（Linear Regression）"></a>线性回归（Linear Regression）</h3><p><strong>线性回归</strong>是一种基础的监督学习算法，用于建立<strong>特征变量（自变量）</strong> 与 <strong>目标变量（因变量）</strong> 之间的<strong>线性关系</strong>模型：</p><p>$$<br>\hat{y} &#x3D; w_1x_1 + w_2x_2 + \dots + w_nx_n + b &#x3D; \mathbf{w}^\top \mathbf{x} + b<br>$$</p><ul><li>$\hat{y}$：预测值</li><li>$\mathbf{x}$：输入特征向量（如 $[x_1, x_2, …, x_n]$）</li><li>$\mathbf{w}$：权重向量（参数）</li><li>$b$：偏置项（intercept）</li></ul><p>🎯 目标</p><p>找到一组参数 $(\mathbf{w}, b)$，使得预测值 $\hat{y}$ <strong>尽可能接近真实值 $y$</strong>。</p><p>📐 损失函数（Loss Function）</p><p>我们最常用的是<strong>均方误差（Mean Squared Error, MSE）</strong>：</p><p>$$<br>J(\mathbf{w}, b) &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} \left( \hat{y}^{(i)} - y^{(i)} \right)^2<br>&#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} \left( \mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)} \right)^2<br>$$</p><ul><li>$m$：样本数</li><li>最小化 $J(\mathbf{w}, b)$ 就是训练过程的目标</li></ul><p>⚙️ 求解方法</p><p>1️⃣ <strong>正规方程法（Normal Equation）</strong> —— 精确解法</p><p>直接对损失函数求导并解方程：</p><p>$$<br>\mathbf{w} &#x3D; (\mathbf{X}^\top \mathbf{X})^{-1} \mathbf{X}^\top \mathbf{y}<br>$$</p><ul><li>$\mathbf{X}$：$m \times n$ 的特征矩阵</li><li>$\mathbf{y}$：$m \times 1$ 的目标值向量</li><li>要求 $\mathbf{X}^\top \mathbf{X}$ 可逆（数值稳定性差时需用伪逆）</li></ul><blockquote><p>优点：计算精确<br>缺点：复杂度高 $O(n^3)$，不适合高维大数据</p></blockquote><p>2️⃣ <strong>梯度下降法（Gradient Descent）</strong> —— 近似解法</p><p>对损失函数求偏导，使用迭代方式逼近最优：</p><p>参数更新公式：</p><ul><li><p>对权重：</p><p>$$<br>w_j \leftarrow w_j - \alpha \cdot \frac{\partial J}{\partial w_j}<br>$$</p></li><li><p>对偏置：</p><p>$$<br>b \leftarrow b - \alpha \cdot \frac{\partial J}{\partial b}<br>$$</p></li></ul><p>导数计算结果：</p><p>$$<br>\frac{\partial J}{\partial w_j} &#x3D; \frac{2}{m} \sum_{i&#x3D;1}^{m} \left( \hat{y}^{(i)} - y^{(i)} \right) x_j^{(i)}<br>$$</p><p>$$<br>\frac{\partial J}{\partial b} &#x3D; \frac{2}{m} \sum_{i&#x3D;1}^{m} \left( \hat{y}^{(i)} - y^{(i)} \right)<br>$$</p><p>梯度下降伪代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">repeat until converge<span class="token punctuation">:</span>    w <span class="token operator">-=</span> alpha <span class="token operator">*</span> gradient_w    b <span class="token operator">-=</span> alpha <span class="token operator">*</span> gradient_b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>优点：适用于大数据集；可在线学习<br>缺点：需调学习率 $\alpha$，收敛较慢</p></blockquote><p>📊 时间复杂度对比</p><table><thead><tr><th>方法</th><th>时间复杂度</th><th>特点</th></tr></thead><tbody><tr><td>正规方程法</td><td>$O(n^3)$</td><td>精确但慢</td></tr><tr><td>梯度下降</td><td>$O(knm)$（$k$ 次迭代）</td><td>可调，适合大数据</td></tr></tbody></table><p>📚 Python 示例代码（使用 sklearn）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LinearRegression<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> make_regressionX<span class="token punctuation">,</span> y <span class="token operator">=</span> make_regression<span class="token punctuation">(</span>n_samples<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> n_features<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> noise<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>model <span class="token operator">=</span> LinearRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"权重:"</span><span class="token punctuation">,</span> model<span class="token punctuation">.</span>coef_<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"偏置:"</span><span class="token punctuation">,</span> model<span class="token punctuation">.</span>intercept_<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>📈 可视化例子</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">房价预测：x = 面积（㎡），y = 房价（万）训练后模型为：y = 1.5x + 20→ 当输入 x = 100㎡，预测 y = 170万<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p> ✅ 总结</p><table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td>输入</td><td>多维特征 $\mathbf{x}$</td></tr><tr><td>输出</td><td>连续变量 $\hat{y}$</td></tr><tr><td>模型形式</td><td>线性函数：$\hat{y} &#x3D; \mathbf{w}^\top \mathbf{x} + b$</td></tr><tr><td>损失函数</td><td>均方误差 MSE</td></tr><tr><td>求解方式</td><td>正规方程 or 梯度下降</td></tr><tr><td>适用场景</td><td>预测问题（价格、评分、趋势）</td></tr></tbody></table><img src="/img/concepts/linear.svg" alt="线性回归" style="max-width: 100%; height: auto;" /><hr><h3 id="逻辑回归（Logistic-Regression）"><a href="#逻辑回归（Logistic-Regression）" class="headerlink" title="逻辑回归（Logistic Regression）"></a>逻辑回归（Logistic Regression）</h3><p>逻辑回归用于预测事件发生的<strong>概率</strong>，并将其映射为 0 或 1 等类别。</p><blockquote><p><strong>目标</strong>：学习一个模型，输入特征 $\mathbf{x}$，输出 $\mathbb{P}(y &#x3D; 1 \mid \mathbf{x})$。</p></blockquote><p>⚙️ 模型结构</p><p>逻辑回归的基本模型是：</p><p>$$<br>\hat{y} &#x3D; \sigma(\mathbf{w}^\top \mathbf{x} + b)<br>$$</p><p>其中：</p><ul><li>$\mathbf{x}$ 是输入特征向量</li><li>$\mathbf{w}$ 是权重向量</li><li>$b$ 是偏置项</li><li>$\sigma(z)$ 是<strong>sigmoid 激活函数</strong>，将任意实数压缩到 $(0,1)$ 区间</li></ul><p>🔁 Sigmoid 函数定义：</p><p>$$<br>\sigma(z) &#x3D; \frac{1}{1 + e^{-z}}<br>$$</p><p>图像如下：</p><ul><li>当 $z \gg 0$，$\sigma(z) \approx 1$</li><li>当 $z \ll 0$，$\sigma(z) \approx 0$</li><li>当 $z &#x3D; 0$，$\sigma(z) &#x3D; 0.5$</li></ul><p>🎯 输出解释</p><p>逻辑回归输出的是一个<strong>概率</strong>：</p><p>$$<br>\hat{y} &#x3D; \mathbb{P}(y &#x3D; 1 \mid \mathbf{x})<br>$$</p><p>决策规则（threshold）：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">if 𝑃(y=1 | x) ≥ 0.5 → 预测为类1else → 预测为类0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><img src="/img/concepts/logistic.svg" alt="逻辑回归" style="max-width: 100%; height: auto;" /><p>📉 损失函数（对数似然损失）</p><p>使用的是<strong>对数损失函数（Log Loss）</strong>，源自最大似然估计：</p><p>$$<br>\mathcal{L}(\mathbf{w}, b) &#x3D; -\frac{1}{m} \sum_{i&#x3D;1}^{m} \left[<br>y^{(i)} \log \hat{y}^{(i)} + (1 - y^{(i)}) \log (1 - \hat{y}^{(i)})<br>\right]<br>$$</p><blockquote><ul><li>如果预测 $\hat{y} \to y$，损失很小；</li><li>如果预测相反，损失急剧上升（比如预测为 0.01 实际为 1）</li></ul></blockquote><p>🔁 参数求解方法：梯度下降</p><p>由于损失函数非线性，无法用正规方程解，需使用<strong>数值优化方法</strong>：</p><p>梯度更新公式（对损失函数求偏导）：</p><ul><li>对 $w_j$ 的梯度：</li></ul><p>$$<br>\frac{\partial \mathcal{L}}{\partial w_j} &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} (\hat{y}^{(i)} - y^{(i)}) x_j^{(i)}<br>$$</p><ul><li>对 $b$ 的梯度：</li></ul><p>$$<br>\frac{\partial \mathcal{L}}{\partial b} &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} (\hat{y}^{(i)} - y^{(i)})<br>$$</p><p>更新方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">w <span class="token operator">-=</span> alpha <span class="token operator">*</span> grad_wb <span class="token operator">-=</span> alpha <span class="token operator">*</span> grad_b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>📊 举例</p><p>假设我们要预测一个人是否患糖尿病：</p><ul><li>$x_1$ &#x3D; 年龄，$x_2$ &#x3D; BMI</li><li>$y \in {0, 1}$ 表示是否患病</li></ul><p>训练后模型为：</p><p>$$<br>\hat{y} &#x3D; \sigma(0.8x_1 + 1.2x_2 - 15)<br>$$</p><p>✅ 优点</p><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>简单高效</td><td>算法易于实现，计算代价低</td></tr><tr><td>输出概率</td><td>可用于风险建模、排序等任务</td></tr><tr><td>可解释性强</td><td>系数可表示每个特征对结果的影响方向与强度</td></tr><tr><td>可扩展为多分类 Softmax</td><td>支持逻辑回归的多类扩展</td></tr></tbody></table><p>⚠️ 缺点</p><table><thead><tr><th>缺点</th><th>描述</th></tr></thead><tbody><tr><td>线性可分性假设</td><td>不能处理复杂非线性关系</td></tr><tr><td>对异常值敏感</td><td>特征未归一化时，模型不稳定</td></tr><tr><td>容易欠拟合</td><td>如果数据不是线性可分，拟合效果差</td></tr></tbody></table><p>📚 Python 示例代码（<code>sklearn</code>）</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_iris<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token comment"># 加载数据（仅用前两个类别做二分类）</span>X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_iris<span class="token punctuation">(</span>return_X_y<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>X<span class="token punctuation">,</span> y <span class="token operator">=</span> X<span class="token punctuation">[</span>y <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>y <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">]</span>X_train<span class="token punctuation">,</span> X_test<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_test <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>model <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"预测概率:"</span><span class="token punctuation">,</span> model<span class="token punctuation">.</span>predict_proba<span class="token punctuation">(</span>X_test<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"预测结果:"</span><span class="token punctuation">,</span> model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_test<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>🔄 与线性回归的区别</p><table><thead><tr><th>项目</th><th>线性回归</th><th>逻辑回归</th></tr></thead><tbody><tr><td>输出</td><td>实数</td><td>概率值 $\in (0, 1)$</td></tr><tr><td>用途</td><td>回归问题（连续值）</td><td>分类问题（二分类&#x2F;多分类）</td></tr><tr><td>激活函数</td><td>无</td><td>Sigmoid &#x2F; Softmax</td></tr><tr><td>损失函数</td><td>均方误差 MSE</td><td>对数损失 Log Loss</td></tr><tr><td>拟合方式</td><td>最小二乘或梯度下降</td><td>最大似然估计（MLE） + 梯度下降</td></tr></tbody></table><h2 id="7-Digital-Circuit"><a href="#7-Digital-Circuit" class="headerlink" title="7. Digital Circuit"></a>7. Digital Circuit</h2><h2 id="8-Computer-Networks"><a href="#8-Computer-Networks" class="headerlink" title="8. Computer Networks"></a>8. Computer Networks</h2><h3 id="Distributed-Hash-Table-DHT"><a href="#Distributed-Hash-Table-DHT" class="headerlink" title="Distributed Hash Table (DHT)"></a>Distributed Hash Table (DHT)</h3><p>A <strong>Distributed Hash Table (DHT)</strong> is a decentralized system that provides a lookup service similar to a hash table: it stores <strong>(key, value)</strong> pairs and allows efficient retrieval of the value given a key. Instead of relying on a central server, DHT distributes the data across a network of nodes (often used in <strong>peer-to-peer networks</strong> and <strong>IoT</strong> systems).</p><p>Key Features:</p><ul><li><strong>Scalable</strong>: Works well even with thousands of nodes.</li><li><strong>Fault-tolerant</strong>: Data is replicated, so the system can handle node failures.</li><li><strong>Efficient</strong>: Most DHTs (like Chord or Kademlia) can find data in <strong>O(log n)</strong> time.</li></ul><p>DHTs are often used in applications like <strong>BitTorrent</strong> and <strong>distributed file systems</strong>, and are relevant in wireless and digital communication contexts, which aligns well with your research interests in IoT.</p><img src="/img/concepts/dht.svg" alt="DHT" style="max-width: 100%; height: auto;" /><h2 id="9-Cryptography"><a href="#9-Cryptography" class="headerlink" title="9. Cryptography"></a>9. Cryptography</h2><h3 id="🔐-Digital-Signatures"><a href="#🔐-Digital-Signatures" class="headerlink" title="🔐 Digital Signatures"></a>🔐 Digital Signatures</h3><p>A <strong>digital signature</strong> is a <strong>cryptographic technique</strong> used to <strong>verify the authenticity and integrity</strong> of a digital message or document.<br>It is a <strong>secure form of electronic signature</strong> based on <strong>public-key cryptography</strong>.</p><p><strong>🛠️ How It Works</strong></p><ol><li><p>The sender signs the document using a <strong>private key</strong>.</p></li><li><p>The recipient verifies the signature using the sender’s <strong>public key</strong>.</p></li><li><p>If the verification succeeds, the document:</p><ul><li><strong>Came from the sender</strong></li><li><strong>Was not altered</strong> in transit</li></ul></li></ol><p><strong>✅ Key Properties</strong></p><ul><li><strong>Authentication</strong>: Confirms the sender’s identity</li><li><strong>Integrity</strong>: Ensures the content has not been tampered with</li><li><strong>Non-repudiation</strong>: The sender cannot deny having signed it</li></ul><p><strong>📌 Common Use Cases</strong></p><ul><li>Signing software and updates</li><li>Securing emails (e.g., with S&#x2F;MIME or PGP)</li><li>Digital contracts and government forms</li><li>Blockchain and cryptocurrencies (e.g., Bitcoin transactions)</li></ul><h2 id="10-Digital-Signal-Processing"><a href="#10-Digital-Signal-Processing" class="headerlink" title="10. Digital Signal Processing"></a>10. Digital Signal Processing</h2><h2 id="11-Control-Engineering"><a href="#11-Control-Engineering" class="headerlink" title="11. Control Engineering"></a>11. Control Engineering</h2><h2 id="12-Software-Development"><a href="#12-Software-Development" class="headerlink" title="12. Software Development"></a>12. Software Development</h2><h2 id="13-Robotics"><a href="#13-Robotics" class="headerlink" title="13. Robotics"></a>13. Robotics</h2><h2 id="14-Numerical-Computing"><a href="#14-Numerical-Computing" class="headerlink" title="14. Numerical Computing"></a>14. Numerical Computing</h2><h3 id="💥-Loss-of-Significance"><a href="#💥-Loss-of-Significance" class="headerlink" title="💥 Loss of Significance"></a>💥 Loss of Significance</h3><p><strong>Definition</strong>:<br>Loss of significance occurs when <strong>two nearly equal numbers are subtracted</strong>, causing the <strong>most significant digits to cancel out</strong>, leaving behind only less significant digits. This results in a <strong>large relative error</strong> due to the limited precision of floating-point arithmetic.</p><p><strong>Example</strong>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">Let a = 123456.78    b = 123456.71Then a - b = 0.07 (correct result)However, in floating-point representation (with limited digits):    a ≈ 1.2345678 × 10^5    b ≈ 1.2345671 × 10^5The subtraction may cause significant digit loss!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>Why it matters</strong>:</p><ul><li>It reduces <strong>numerical accuracy</strong>.</li><li>It’s especially dangerous in algorithms involving derivatives, roots, or iterative methods.</li></ul><p><strong>Typical scenario</strong>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">f(x) = (1 - cos(x)) / x^2, when x → 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>This can lead to significant errors because <code>1 - cos(x)</code> is a subtraction of two nearly equal numbers.</p><hr><h3 id="🧮-Loss-of-Trailing-Digits"><a href="#🧮-Loss-of-Trailing-Digits" class="headerlink" title="🧮 Loss of Trailing Digits"></a>🧮 Loss of Trailing Digits</h3><p><strong>Definition</strong>:<br>Loss of trailing digits occurs when a <strong>large and a small number are added together</strong>, and the <strong>small number is too small to affect the sum</strong> due to the limits of floating-point precision.</p><p><strong>Example</strong>:</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">Let a = 1.000000000000000    b = 0.000000000000001In floating-point (double precision), a + b ≈ 1.000000000000000The small value of b is 'lost' — this is loss of trailing digits.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>Why it matters</strong>:</p><ul><li>It causes <strong>rounding errors</strong> in accumulation.</li><li>In long summation processes (e.g., numerical integration), many small contributions may be <strong>entirely ignored</strong>.</li></ul><hr><p><strong>🧠 Summary Table</strong></p><table><thead><tr><th>Concept</th><th>Trigger</th><th>Effect</th><th>Example</th></tr></thead><tbody><tr><td><strong>Loss of Significance</strong></td><td>Subtraction of close numbers</td><td>Large <strong>relative error</strong></td><td><code>(1 - cos(x)) / x^2</code></td></tr><tr><td><strong>Loss of Trailing Digits</strong></td><td>Addition of large + small number</td><td>Small number gets ignored</td><td><code>1.0 + 1e-15 = 1.0</code></td></tr></tbody></table><h2 id="15-Information-Theory"><a href="#15-Information-Theory" class="headerlink" title="15. Information Theory"></a>15. Information Theory</h2><h3 id="📦-Run-Length-Encoding-RLE"><a href="#📦-Run-Length-Encoding-RLE" class="headerlink" title="📦 Run-Length Encoding (RLE)"></a>📦 Run-Length Encoding (RLE)</h3><p><strong>🧠 What is it?</strong></p><p><strong>Run-Length Encoding</strong> is a <strong>lossless compression algorithm</strong> that works by compressing sequences of repeated data elements (called <strong>runs</strong>) into a single value and a count.</p><p><strong>⚙️ How it works</strong></p><p>When the same character appears multiple times in a row, RLE replaces it with a single character and the number of repetitions.</p><p><strong>✅ Example</strong></p><p>Original data:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">AAAAABBBCCDAA<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>RLE encoded:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">5A3B2C1D2A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>This means:</p><ul><li>5 A’s</li><li>3 B’s</li><li>2 C’s</li><li>1 D</li><li>2 A’s</li></ul><p><strong>📌 Use Cases</strong></p><ul><li>Bitmap image compression (e.g., simple black and white images)</li><li>Fax machines</li><li>Data with lots of repetition</li></ul><p><strong>⚠️ Limitation</strong></p><ul><li>Not efficient if the data doesn’t have many repeated characters (may even increase size).</li></ul><hr><h3 id="🌲-Huffman-Encoding"><a href="#🌲-Huffman-Encoding" class="headerlink" title="🌲 Huffman Encoding"></a>🌲 Huffman Encoding</h3><p><strong>🧠 What is it?</strong></p><p><strong>Huffman Encoding</strong> is a <strong>lossless compression technique</strong> that assigns <strong>variable-length binary codes</strong> to characters based on their <strong>frequency</strong>. More frequent characters get <strong>shorter codes</strong>, while less frequent ones get <strong>longer codes</strong>.</p><p><strong>⚙️ How it works</strong></p><ol><li>Count the frequency of each character.</li><li>Build a <strong>Huffman Tree</strong> using a greedy algorithm.</li><li>Assign binary codes to characters by traversing the tree.</li></ol><p><strong>✅ Example</strong></p><p>Given character frequencies:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">A: 45%, B: 13%, C: 12%, D: 16%, E: 14%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>Possible Huffman codes:</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">A: 0B: 101C: 100D: 111E: 110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>More frequent characters like <code>A</code> get shorter codes.</p><p><strong>📌 Use Cases</strong></p><ul><li>JPEG and PNG image compression</li><li>MP3 and audio compression</li><li>ZIP file compression</li><li>Data transmission and storage</li></ul><p><strong>⚠️ Limitation</strong></p><ul><li>Needs to store or transmit the code table (or tree structure).</li><li>Slightly more complex to implement than RLE.</li></ul><p><strong>🧾 Comparison Table</strong></p><table><thead><tr><th>Feature</th><th>Run-Length Encoding</th><th>Huffman Encoding</th></tr></thead><tbody><tr><td>Type</td><td>Lossless</td><td>Lossless</td></tr><tr><td>Strategy</td><td>Compress repeated values</td><td>Compress based on frequency</td></tr><tr><td>Best for</td><td>Repetitive data</td><td>Skewed frequency distributions</td></tr><tr><td>Efficiency</td><td>Very simple, fast</td><td>More efficient, more complex</td></tr><tr><td>Limitation</td><td>Ineffective for random data</td><td>Tree must be constructed</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>CS Concepts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Networks</title>
    <link href="/2025/02/09/computer-networks/"/>
    <url>/2025/02/09/computer-networks/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Networks"><a href="#Computer-Networks" class="headerlink" title="Computer Networks"></a>Computer Networks</h1><p>本篇笔记主要讲解计算机网络的常见网络模型和常见协议。主要应对面试八股文场景和修考简答题。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Networks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra</title>
    <link href="/2025/02/08/Linear-Algebra/"/>
    <url>/2025/02/08/Linear-Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h1><p>本篇线性代数内容主要讲解一下关键的地方，以及一些重要的二级结论推导。全文没有严格的上下文关系。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-哈密尔顿-凯莱定理（Cayley-Hamilton-Theorem）"><a href="#1-哈密尔顿-凯莱定理（Cayley-Hamilton-Theorem）" class="headerlink" title="1. 哈密尔顿-凯莱定理（Cayley-Hamilton Theorem）"></a>1. 哈密尔顿-凯莱定理（Cayley-Hamilton Theorem）</h2><p><strong>哈密尔顿-凯莱定理</strong>是线性代数中的一个重要定理，它描述了<strong>每个方阵都满足自己的特征多项式</strong>。</p><p><strong>定理内容</strong>： <strong>设 $A$ 是一个 $n \times n$ 的方阵，其特征多项式为</strong><br>$$<br>p_A(\lambda) &#x3D; \det(\lambda I - A) &#x3D; c_n \lambda^n + c_{n-1} \lambda^{n-1} + \dots + c_1 \lambda + c_0<br>$$<br>其中 $I$ 是 $n$ 阶单位矩阵，$c_i$ 是多项式的系数。</p><p>那么，将矩阵 $A$ 代入它的特征多项式，会得到：<br>$$<br>p_A(A) &#x3D; c_n A^n + c_{n-1} A^{n-1} + \dots + c_1 A + c_0 I &#x3D; 0<br>$$<br>即 <strong>矩阵 $A$ 代入自己的特征多项式后，结果是零矩阵</strong>。</p><hr><p><strong>证明思路（大致想法）</strong> 哈密尔顿-凯莱定理的证明通常有几种方法，最常见的方法基于矩阵的<strong>最小多项式</strong>：</p><ol><li><p><strong>最小多项式法</strong>：  </p><ul><li>设矩阵 $A$ 的最小多项式是 $m_A(\lambda)$，即 $m_A(A) &#x3D; 0$ 且 $m_A(\lambda)$ 是 $A$ 所满足的次数最低的首一多项式。</li><li>由于特征多项式 $p_A(\lambda)$ 是 $A$ 的一个多项式，并且所有矩阵的特征多项式都能被它的最小多项式整除（即 $p_A(\lambda) &#x3D; m_A(\lambda) q(\lambda)$），因此 $p_A(A) &#x3D; 0$ 也成立。</li></ul></li><li><p><strong>利用行列式展开</strong>：</p><ul><li>设 $A$ 的特征多项式 $p_A(\lambda) &#x3D; \det(\lambda I - A)$。</li><li>将 $A$ 代入 $p_A(\lambda)$ 后，利用矩阵的特征向量与特征值的性质，可以证明 $p_A(A) &#x3D; 0$。</li></ul></li><li><p><strong>外代数法（或幂零矩阵分解）</strong>：</p><ul><li>通过矩阵的分块结构，把 $A$ 表示为若尔当标准形的形式，再分别验证哈密尔顿-凯莱定理成立。</li></ul></li></ol><hr><p><strong>示例计算</strong> 假设我们有矩阵：<br>$$<br>A &#x3D; \begin{bmatrix} 2 &amp; 1 \\<br> 0 &amp; 3 \end{bmatrix}<br>$$</p><ol><li><p><strong>计算特征多项式</strong>：<br>$$<br>p_A(\lambda) &#x3D; \det(\lambda I - A) &#x3D; \begin{vmatrix} \lambda - 2 &amp; -1 \\ 0 &amp; \lambda - 3 \end{vmatrix}<br>$$</p><p>计算行列式：<br>$$<br>(\lambda - 2)(\lambda - 3)<br>$$</p><p>所以特征多项式为：</p><p>$$<br>p_A(\lambda) &#x3D; \lambda^2 - 5\lambda + 6<br>$$</p></li><li><p><strong>代入 $A$ 计算</strong>：</p><p>$$<br>A^2 - 5A + 6I &#x3D; \begin{bmatrix} 2 &amp; 1 \\ 0 &amp; 3 \end{bmatrix}^2 - 5 \begin{bmatrix} 2 &amp; 1 \\ 0 &amp; 3 \end{bmatrix} + 6 \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}<br>$$</p><p>计算 $A^2$：</p><p>$$<br>A^2 &#x3D; \begin{bmatrix} 4 &amp; 5 \\ 0 &amp; 9 \end{bmatrix}<br>$$</p><p>计算：</p><p>$$<br>A^2 - 5A + 6I &#x3D; \begin{bmatrix} 4 &amp; 5 \\ 0 &amp; 9 \end{bmatrix} - \begin{bmatrix} 10 &amp; 5 \\ 0 &amp; 15 \end{bmatrix} + \begin{bmatrix} 6 &amp; 0 \\ 0 &amp; 6 \end{bmatrix}<br>$$<br>$$<br>&#x3D; \begin{bmatrix} 0 &amp; 0 \\ 0 &amp; 0 \end{bmatrix}<br>$$</p><p>所以确实满足 $p_A(A) &#x3D; 0$。</p></li></ol><hr><p><strong>应用</strong></p><ol><li><p><strong>计算矩阵的幂</strong>：<br>由于 $p_A(A) &#x3D; 0$，可以将 $A^n$ 表示为 $A$ 的低次幂的线性组合，从而避免直接计算高次矩阵幂。</p></li><li><p><strong>求矩阵的逆</strong>：<br>若 $A$ 可逆，利用哈密尔顿-凯莱定理，可以通过特征多项式表示 $A^{-1}$：<br>$$<br>A^{-1} &#x3D; \frac{1}{c_0}(-c_1 I - c_2 A - \dots - c_{n-1} A^{n-1})<br>$$<br>这样可以避免高维矩阵的直接求逆运算。</p></li><li><p><strong>微分方程的求解</strong>：<br>在常微分方程中，矩阵指数 $e^{At}$ 可以用哈密尔顿-凯莱定理来化简计算。</p></li><li><p><strong>量子力学与物理学</strong>：<br>在量子力学和经典力学的哈密顿系统中，哈密尔顿-凯莱定理常用于求解动力学系统的演化方程。</p></li></ol><hr><p><strong>总结</strong></p><ul><li><strong>核心思想</strong>：每个矩阵都满足自己的特征多项式。</li><li><strong>证明方法</strong>：常用<strong>最小多项式法</strong>、<strong>行列式展开法</strong>、<strong>若尔当标准形法</strong>等。</li><li><strong>应用</strong>：计算矩阵的幂、求逆矩阵、求解微分方程、应用于物理等。</li></ul><h2 id="2-行列式的-Rank（秩）的几何意义"><a href="#2-行列式的-Rank（秩）的几何意义" class="headerlink" title="2. 行列式的 Rank（秩）的几何意义"></a>2. 行列式的 Rank（秩）的几何意义</h2><h3 id="2-1-线性相关性"><a href="#2-1-线性相关性" class="headerlink" title="2.1. 线性相关性"></a><strong>2.1. 线性相关性</strong></h3><p>矩阵的秩表示其行（或列）向量组的<strong>线性无关个数</strong>。如果一个矩阵的秩为 $r$，则意味着其中最多 $r$ 个行（或列）向量是线性无关的，而其余的行（或列）可以由这 $r$ 个向量线性表示。</p><ul><li>如果秩等于矩阵的行数（或列数），那么所有的行（或列）向量都是线性无关的，矩阵是<strong>满秩</strong>的。</li><li>如果秩小于行（或列）数，则矩阵的行（或列）向量是<strong>线性相关</strong>的，意味着其中的某些行（或列）可以用其他行（或列）表示。</li></ul><h3 id="2-2-维度与子空间"><a href="#2-2-维度与子空间" class="headerlink" title="2.2. 维度与子空间"></a><strong>2.2. 维度与子空间</strong></h3><p>矩阵 $A$ 的秩可以理解为由 $A$ 的列向量张成的<strong>列空间（Column Space）</strong>的维度，也可以理解为由 $A$ 的行向量张成的<strong>行空间（Row Space）</strong>的维度。</p><ul><li><strong>列秩（Column Rank）</strong>：列向量张成的向量空间的维度，表示矩阵映射的目标空间的维度。</li><li><strong>行秩（Row Rank）</strong>：行向量张成的向量空间的维度，表示矩阵映射的定义域的维度。</li></ul><p>根据<strong>基本定理</strong>，列秩和行秩总是相等，因此可以用<strong>矩阵的秩（Rank）</strong>来统一表示。</p><h3 id="2-3-线性变换的几何意义"><a href="#2-3-线性变换的几何意义" class="headerlink" title="2.3. 线性变换的几何意义"></a><strong>2.3. 线性变换的几何意义</strong></h3><p>在几何上，矩阵可以看作是一个<strong>线性变换</strong>，其秩表示该变换所能映射到的空间的维度。</p><ul><li><strong>满秩矩阵（Full Rank）</strong>：如果一个 $m \times n$ 矩阵 $A$ 的秩等于 $\min(m, n)$，则它表示的线性变换是<strong>最大维度</strong>的，即它能够映射到尽可能大的空间。</li><li><strong>降秩矩阵（Rank Deficient）</strong>：如果 $\operatorname{rank}(A) &lt; \min(m, n)$，说明 $A$ 作为一个线性变换时，会把某些维度“压缩”到更低维的空间，可能导致信息丢失或映射不可逆。</li></ul><h3 id="2-4-线性方程组解的情况"><a href="#2-4-线性方程组解的情况" class="headerlink" title="2.4. 线性方程组解的情况"></a><strong>2.4. 线性方程组解的情况</strong></h3><p>矩阵秩决定了线性方程组 $Ax &#x3D; b$ 的解的情况：</p><ul><li><strong>如果 $\operatorname{rank}(A) &#x3D; \operatorname{rank}([A | b])$<strong>，则系统</strong>有解</strong>。</li><li><strong>如果 $\operatorname{rank}(A) &lt; \operatorname{rank}([A | b])$<strong>，则系统</strong>无解</strong>（矛盾方程）。</li><li><strong>如果 $\operatorname{rank}(A) &#x3D; \operatorname{rank}([A | b]) &#x3D; n$<strong>（$A$ 是方阵且满秩），则系统有</strong>唯一解</strong>。</li><li><strong>如果 $\operatorname{rank}(A) &lt; n$，则系统有无穷多解</strong>（自由变量存在）。</li></ul><h3 id="2-5-低秩矩阵的几何解释"><a href="#2-5-低秩矩阵的几何解释" class="headerlink" title="2.5. 低秩矩阵的几何解释"></a><strong>2.5. 低秩矩阵的几何解释</strong></h3><ul><li><strong>秩 1 矩阵</strong>：所有列向量（或行向量）都在同一个方向上，矩阵仅表示一个单一方向的缩放。</li><li><strong>秩 2 矩阵</strong>：表示一个平面（二维空间）上的变换，例如剪切或旋转。</li><li><strong>秩 3 及以上</strong>：随着秩的增加，变换的自由度增加，表示更高维空间的映射。</li></ul><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6. 总结"></a><strong>2.6. 总结</strong></h3><ol><li>秩表示矩阵的行或列向量的<strong>线性无关个数</strong>。</li><li>秩等于矩阵<strong>列空间（或行空间）的维度</strong>，决定了矩阵的线性变换能映射到的维度。</li><li>在几何上，矩阵的秩决定了它如何变换空间，例如投影、压缩、旋转等。</li><li>在线性方程组中，秩决定了方程组是否有解，以及解的个数。</li><li>低秩矩阵通常表示低维空间的结构，比如秩 1 矩阵对应单一方向的变换，秩 2 矩阵对应二维平面上的变换。</li></ol><h2 id="3-范德蒙行列式（Vandermonde-Determinant）"><a href="#3-范德蒙行列式（Vandermonde-Determinant）" class="headerlink" title="3. 范德蒙行列式（Vandermonde Determinant）"></a><strong>3. 范德蒙行列式（Vandermonde Determinant）</strong></h2><p>范德蒙行列式是线性代数中一个重要的行列式，在多项式插值、数值分析、群论和组合数学等领域都有广泛应用。</p><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1. 定义"></a><strong>3.1. 定义</strong></h3><p>范德蒙行列式是一个特殊形式的行列式，其元素由一组数的幂次构成：</p><p>$$<br>V(x_1, x_2, \dots, x_n) &#x3D;<br>\begin{vmatrix}<br>1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{n-1} \\<br>1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{n-1} \\<br>1 &amp; x_3 &amp; x_3^2 &amp; \cdots &amp; x_3^{n-1} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{n-1}<br>\end{vmatrix}<br>$$</p><p>该行列式的值称为<strong>范德蒙行列式</strong>（Vandermonde Determinant）。</p><h3 id="3-2-计算范德蒙行列式"><a href="#3-2-计算范德蒙行列式" class="headerlink" title="3.2. 计算范德蒙行列式"></a><strong>3.2. 计算范德蒙行列式</strong></h3><p>范德蒙行列式的值有一个标准的封闭表达式：</p><p>$$<br>V(x_1, x_2, \dots, x_n) &#x3D; \prod_{1 \leq i &lt; j \leq n} (x_j - x_i)<br>$$</p><p>即，范德蒙行列式等于所有数 $x_1, x_2, \dots, x_n$ 之间两两之差的乘积。</p><p><strong>示例：计算 $n&#x3D;3$ 的范德蒙行列式</strong><br>$$<br>V(x_1, x_2, x_3) &#x3D;<br>\begin{vmatrix}<br>1 &amp; x_1 &amp; x_1^2 \\<br>1 &amp; x_2 &amp; x_2^2 \\<br>1 &amp; x_3 &amp; x_3^2<br>\end{vmatrix}<br>$$</p><p>按照行列式的展开计算：<br>$$<br>V(x_1, x_2, x_3) &#x3D; (x_2 - x_1)(x_3 - x_1)(x_3 - x_2)<br>$$</p><p>与一般公式一致！</p><hr><h3 id="3-3-范德蒙行列式的性质"><a href="#3-3-范德蒙行列式的性质" class="headerlink" title="3.3. 范德蒙行列式的性质"></a><strong>3.3. 范德蒙行列式的性质</strong></h3><h4 id="1-反对称性"><a href="#1-反对称性" class="headerlink" title="(1) 反对称性"></a><strong>(1) 反对称性</strong></h4><p>范德蒙行列式的值对任意两行（或两列）交换后变号：<br>$$<br>V(\dots, x_i, x_j, \dots) &#x3D; -V(\dots, x_j, x_i, \dots)<br>$$<br>因此，如果有两个相同的 $x_i &#x3D; x_j$，则 $(x_j - x_i) &#x3D; 0$，导致整个行列式为零。这说明<strong>范德蒙行列式在变量相等时退化为零</strong>。</p><h4 id="2-递归性质"><a href="#2-递归性质" class="headerlink" title="(2) 递归性质"></a><strong>(2) 递归性质</strong></h4><p>$$<br>V(x_1, x_2, \dots, x_n) &#x3D;<br>V(x_1, x_2, \dots, x_{n-1}) \prod_{j&#x3D;1}^{n-1} (x_n - x_j)<br>$$<br>即，可以通过 $n-1$ 阶范德蒙行列式逐步计算出 $n$ 阶的结果。</p><h3 id="3-4-应用"><a href="#3-4-应用" class="headerlink" title="3.4. 应用"></a><strong>3.4. 应用</strong></h3><h4 id="1-多项式插值"><a href="#1-多项式插值" class="headerlink" title="(1) 多项式插值"></a><strong>(1) 多项式插值</strong></h4><p>在拉格朗日插值法中，范德蒙矩阵用于构造一组线性方程来求解插值系数。如果 $x_1, x_2, \dots, x_n$ 互不相同，则范德蒙矩阵是满秩的，因此该线性系统有唯一解。</p><h4 id="2-线性无关性"><a href="#2-线性无关性" class="headerlink" title="(2) 线性无关性"></a><strong>(2) 线性无关性</strong></h4><p>范德蒙矩阵的行（或列）是线性无关的，当且仅当 $x_i$ 互不相同。这一性质用于多项式插值和数值分析中判断点集是否能构成唯一的插值多项式。</p><h4 id="3-代数和组合数学"><a href="#3-代数和组合数学" class="headerlink" title="(3) 代数和组合数学"></a><strong>(3) 代数和组合数学</strong></h4><p>范德蒙行列式与<strong>牛顿插值公式</strong>、<strong>伽罗瓦理论</strong>、<strong>排列和置换的计数问题</strong>密切相关。</p><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5. 总结"></a><strong>3.5. 总结</strong></h3><ul><li><strong>定义</strong>：范德蒙行列式是一个特殊的行列式，其元素由一组变量的幂构成。</li><li><strong>计算公式</strong>：<br>$$<br>V(x_1, x_2, \dots, x_n) &#x3D; \prod_{1 \leq i &lt; j \leq n} (x_j - x_i)<br>$$</li><li><strong>性质</strong>：<ul><li>反对称性：交换两行（或两列）后变号。</li><li>若存在 $x_i &#x3D; x_j$，则范德蒙行列式为 0。</li><li>可以递归计算。</li></ul></li><li><strong>应用</strong>：<ul><li><strong>多项式插值</strong>（如拉格朗日插值）</li><li><strong>线性无关性判断</strong></li><li><strong>代数与组合数学中的应用</strong></li></ul></li></ul><h2 id="4-行列式的运算规律"><a href="#4-行列式的运算规律" class="headerlink" title="4. 行列式的运算规律"></a>4. 行列式的运算规律</h2><p>设 $A$、$B$ 是 $n \times n$ 的方阵，$|A|$ 表示矩阵 $A$ 的行列式。以下是常见的运算规律：</p><h3 id="4-1-行列式的基本性质"><a href="#4-1-行列式的基本性质" class="headerlink" title="4.1 行列式的基本性质"></a>4.1 行列式的基本性质</h3><ol><li><p><strong>单位矩阵的行列式为 1：</strong><br>$$<br>|I_n| &#x3D; 1<br>$$</p></li><li><p><strong>行列式的转置不变：</strong><br>$$<br>|A^\mathrm{T}| &#x3D; |A|<br>$$</p></li></ol><h3 id="4-2-初等行变换对行列式的影响"><a href="#4-2-初等行变换对行列式的影响" class="headerlink" title="4.2 初等行变换对行列式的影响"></a>4.2 初等行变换对行列式的影响</h3><p>对矩阵 $A$ 进行以下初等行变换时，行列式发生如下变化：</p><table><thead><tr><th>初等行变换</th><th>对行列式的影响</th></tr></thead><tbody><tr><td>两行交换</td><td>行列式变号（乘以 $-1$）</td></tr><tr><td>某行乘以一个数 $k$</td><td>行列式乘以 $k$</td></tr><tr><td>某行加上另一行的若干倍</td><td>行列式不变</td></tr></tbody></table><p>✅ <strong>结论</strong>：可以通过行变换将矩阵化为上三角矩阵，然后通过对角线元素相乘计算行列式，记得调整符号！</p><h3 id="4-3-行列式的乘积法则"><a href="#4-3-行列式的乘积法则" class="headerlink" title="4.3 行列式的乘积法则"></a>4.3 行列式的乘积法则</h3><p>$$<br>|AB| &#x3D; |A||B|<br>$$</p><ul><li><strong>提示</strong>：前提是 $A, B$ 都是 $n \times n$ 的方阵。</li><li><strong>常见用法</strong>：推导可逆条件时使用。比如若 $|A| \ne 0$，则 $A$ 可逆，且：<br>$$<br>|A^{-1}| &#x3D; \frac{1}{|A|}<br>$$</li></ul><h3 id="4-4-行列式与数乘"><a href="#4-4-行列式与数乘" class="headerlink" title="4.4 行列式与数乘"></a>4.4 行列式与数乘</h3><p>如果矩阵 $A$ 是 $n \times n$ 的方阵，$k$ 是数，则：<br>$$<br>|kA| &#x3D; k^n |A|<br>$$</p><blockquote><p>直观理解：每一行都乘以 $k$，相当于 $n$ 个 $k$ 相乘。</p></blockquote><h3 id="4-5-行列式与逆矩阵、幂运算"><a href="#4-5-行列式与逆矩阵、幂运算" class="headerlink" title="4.5 行列式与逆矩阵、幂运算"></a>4.5 行列式与逆矩阵、幂运算</h3><ul><li><p><strong>逆矩阵：</strong><br>$$<br>|A^{-1}| &#x3D; \frac{1}{|A|} \quad \text{前提：}|A| \ne 0<br>$$</p></li><li><p><strong>幂运算（整数次幂）：</strong><br>$$<br>|A^m| &#x3D; |A|^m<br>$$</p></li></ul><h3 id="4-6-常见错误认识（⚠️务必注意）"><a href="#4-6-常见错误认识（⚠️务必注意）" class="headerlink" title="4.6 常见错误认识（⚠️务必注意）"></a>4.6 常见错误认识（⚠️务必注意）</h3><ol><li><p><strong>行列式不能线性拆分：</strong><br>$$<br>|A + B| \ne |A| + |B| \quad \text{一般不成立！}<br>$$</p></li><li><p><strong>不是所有矩阵都有行列式：</strong></p><ul><li>只有<strong>方阵</strong>才有行列式。</li><li>非方阵无法定义行列式。</li></ul></li></ol><hr><h3 id="4-7-特殊矩阵的行列式"><a href="#4-7-特殊矩阵的行列式" class="headerlink" title="4.7 特殊矩阵的行列式"></a>4.7 特殊矩阵的行列式</h3><ul><li><p><strong>上三角&#x2F;下三角矩阵（或对角矩阵）：</strong><br>$$<br>|\text{三角矩阵}| &#x3D; \text{主对角线元素的乘积}<br>$$</p></li><li><p><strong>伴随矩阵（Adjoint Matrix）相关：</strong><br>若 $A$ 是可逆方阵：<br>$$<br>A^{-1} &#x3D; \frac{1}{|A|} \cdot \text{adj}(A)<br>$$</p></li></ul><hr><h3 id="4-8-行列式的列的加法性（线性性）"><a href="#4-8-行列式的列的加法性（线性性）" class="headerlink" title="4.8 行列式的列的加法性（线性性）"></a><strong>4.8 行列式的列的加法性（线性性）</strong></h3><p>设 $A$ 是一个 $n \times n$ 的矩阵，如果第 $j$ 列是两个向量 $\mathbf{v}, \mathbf{w}$ 的和：</p><p>$$<br>\text{col}_j &#x3D; \mathbf{v} + \mathbf{w}<br>$$</p><p>那么行列式满足加法性：</p><p>$$<br>\det A &#x3D; \det A(\text{col}_j &#x3D; \mathbf{v}) + \det A(\text{col}_j &#x3D; \mathbf{w})<br>$$</p><p>同样地，如果该列乘以一个标量 $\lambda$，则有数乘性：</p><p>$$<br>\det A(\text{col}_j &#x3D; \lambda \mathbf{v}) &#x3D; \lambda \cdot \det A(\text{col}_j &#x3D; \mathbf{v})<br>$$</p><p>这说明行列式关于任意一列是<strong>线性的函数</strong>，即具备“列的可拆性”。</p><p><strong>4.3 证明（排列展开法）</strong></p><p>根据行列式定义：</p><p>$$<br>\det A &#x3D; \sum_{\sigma \in S_n} \operatorname{sgn}(\sigma) \cdot a_{1\sigma(1)} a_{2\sigma(2)} \cdots a_{n\sigma(n)}<br>$$</p><p>设第 $j$ 列为 $\mathbf{v} + \mathbf{w}$，则 $a_{ij} &#x3D; v_i + w_i$。</p><p>将其代入行列式展开中，借助乘法对加法的分配律，可以将涉及第 $j$ 列的所有项拆成两部分，从而得到：</p><p>$$<br>\det A &#x3D; \det A(\text{col}_j &#x3D; \mathbf{v}) + \det A(\text{col}_j &#x3D; \mathbf{w})<br>$$</p><p><strong>4.4 示例（$2 \times 2$ 矩阵）</strong></p><p>设矩阵 $A$ 为：</p><p>$$<br>A &#x3D;<br>\begin{bmatrix}<br>1 &amp; a + c \\<br>2 &amp; b + d<br>\end{bmatrix}<br>$$</p><p>计算其行列式：</p><p>$$<br>\det A &#x3D; 1 \cdot (b + d) - 2 \cdot (a + c)<br>&#x3D; (b - 2a) + (d - 2c)<br>$$</p><p>$$<br>\det A_1 &#x3D;<br>\begin{vmatrix}<br>1 &amp; a \\<br>2 &amp; b<br>\end{vmatrix}<br>&#x3D; 1 \cdot b - 2 \cdot a &#x3D; b - 2a<br>$$</p><p>$$<br>\det A_2 &#x3D;<br>\begin{vmatrix}<br>1 &amp; c \\<br>2 &amp; d<br>\end{vmatrix}<br>&#x3D; 1 \cdot d - 2 \cdot c &#x3D; d - 2c<br>$$</p><p>因此：</p><p>$$<br>\det A &#x3D; \det A_1 + \det A_2 &#x3D; (b - 2a) + (d - 2c)<br>$$</p><p>验证了列的加法性成立。</p><p><strong>4.5 总结</strong></p><ul><li><p>行列式对每一列是<strong>线性函数</strong>；</p></li><li><p>包括两条性质：</p><ul><li><strong>加法性</strong>：若某列是 $\mathbf{v} + \mathbf{w}$，则 $\det A &#x3D; \det(\text{col}_j &#x3D; \mathbf{v}) + \det(\text{col}_j &#x3D; \mathbf{w})$；</li><li><strong>数乘性</strong>：若某列为 $\lambda \mathbf{v}$，则 $\det A &#x3D; \lambda \cdot \det(\text{col}_j &#x3D; \mathbf{v})$；</li></ul></li><li><p>此性质称为<strong>多线性性</strong>的一部分，是证明许多行列式性质（如秩判断、线性无关性等）的基础。</p></li></ul><h2 id="5-行列式转置的规律"><a href="#5-行列式转置的规律" class="headerlink" title="5. 行列式转置的规律"></a>5. 行列式转置的规律</h2><h3 id="5-1-行列式转置不变性"><a href="#5-1-行列式转置不变性" class="headerlink" title="5.1. 行列式转置不变性"></a>5.1. 行列式转置不变性</h3><p>对于任意 $n \times n$ 的矩阵 $A$，其转置矩阵为 $A^T$，有以下恒等式：</p><p>$$<br>\det(A^T) &#x3D; \det(A)<br>$$</p><p><strong>解释</strong>：行列式是关于行（或列）的交错多线性函数，转置只是行列互换，不影响行列式的值。</p><hr><h3 id="5-2-对易性与乘法规则"><a href="#5-2-对易性与乘法规则" class="headerlink" title="5.2. 对易性与乘法规则"></a>5.2. 对易性与乘法规则</h3><p>对于两个 $n \times n$ 的矩阵 $A$ 和 $B$：</p><p>$$<br>(AB)^T &#x3D; B^T A^T<br>$$</p><p>进而有：</p><p>$$<br>\det((AB)^T) &#x3D; \det(B^T A^T) &#x3D; \det(B^T) \cdot \det(A^T)<br>$$</p><p>又因为转置不改变行列式值，所以有：</p><p>$$<br>\det(AB) &#x3D; \det(A) \cdot \det(B)<br>$$</p><hr><h3 id="5-3-单位矩阵的转置"><a href="#5-3-单位矩阵的转置" class="headerlink" title="5.3. 单位矩阵的转置"></a>5.3. 单位矩阵的转置</h3><p>单位矩阵 $I_n$ 的转置仍为其本身，且行列式为 1：</p><p>$$<br>I_n^T &#x3D; I_n, \quad \det(I_n) &#x3D; 1<br>$$</p><hr><h3 id="5-4-可逆矩阵的转置"><a href="#5-4-可逆矩阵的转置" class="headerlink" title="5.4. 可逆矩阵的转置"></a>5.4. 可逆矩阵的转置</h3><p>若 $A$ 可逆，则 $A^T$ 也可逆，且：</p><p>$$<br>(A^T)^{-1} &#x3D; (A^{-1})^T<br>$$</p><p>进一步有：</p><p>$$<br>\det((A^T)^{-1}) &#x3D; \det((A^{-1})^T) &#x3D; \det(A^{-1}) &#x3D; \frac{1}{\det(A)}<br>$$</p><hr><h3 id="5-5-特殊矩阵的转置与行列式"><a href="#5-5-特殊矩阵的转置与行列式" class="headerlink" title="5.5. 特殊矩阵的转置与行列式"></a>5.5. 特殊矩阵的转置与行列式</h3><ul><li>对称矩阵：$A^T &#x3D; A$，故 $\det(A^T) &#x3D; \det(A)$ 成立自然；</li><li>反对称矩阵：$A^T &#x3D; -A$，当 $n$ 为奇数时，有：</li></ul><p>$$<br>\det(A^T) &#x3D; \det(-A) &#x3D; (-1)^n \det(A) &#x3D; -\det(A)<br>$$</p><p>所以 $\det(A) &#x3D; -\det(A) \Rightarrow \det(A) &#x3D; 0$</p><h2 id="6-行列式为非零（正则）的条件总结"><a href="#6-行列式为非零（正则）的条件总结" class="headerlink" title="6. 行列式为非零（正则）的条件总结"></a>6. 行列式为非零（正则）的条件总结</h2><p>在线性代数中，一个<strong>矩阵是正则矩阵（Regular Matrix）</strong>，也称<strong>非奇异矩阵（Non-singular Matrix）</strong>，当且仅当它的行列式不为零：</p><p>$$<br>\det(A) \ne 0 \quad \Leftrightarrow \quad A \text{ 是正则矩阵}<br>$$</p><p>正则矩阵具有以下等价条件：</p><hr><h3 id="1-存在逆矩阵"><a href="#1-存在逆矩阵" class="headerlink" title="(1) 存在逆矩阵"></a>(1) 存在逆矩阵</h3><p>$$<br>\det(A) \ne 0 \quad \Leftrightarrow \quad \exists A^{-1},\ A A^{-1} &#x3D; I<br>$$</p><hr><h3 id="2-满秩矩阵"><a href="#2-满秩矩阵" class="headerlink" title="(2) 满秩矩阵"></a>(2) 满秩矩阵</h3><p>$$<br>\det(A) \ne 0 \quad \Leftrightarrow \quad \text{秩}(!A) &#x3D; n<br>$$</p><p>也就是说，$n \times n$ 的矩阵 $A$ 满秩时其行列式非零。</p><hr><h3 id="3-齐次线性方程组-A-mathbf-x-mathbf-0-仅有零解"><a href="#3-齐次线性方程组-A-mathbf-x-mathbf-0-仅有零解" class="headerlink" title="(3) 齐次线性方程组 $A\mathbf{x} &#x3D; \mathbf{0}$ 仅有零解"></a>(3) 齐次线性方程组 $A\mathbf{x} &#x3D; \mathbf{0}$ 仅有零解</h3><p>$$<br>\det(A) \ne 0 \quad \Leftrightarrow \quad A\mathbf{x} &#x3D; \mathbf{0} \text{ 仅有解 } \mathbf{x} &#x3D; \mathbf{0}<br>$$</p><hr><h3 id="4-矩阵列（或行）线性无关"><a href="#4-矩阵列（或行）线性无关" class="headerlink" title="(4) 矩阵列（或行）线性无关"></a>(4) 矩阵列（或行）线性无关</h3><p>$$<br>\det(A) \ne 0 \quad \Leftrightarrow \quad \text{矩阵的行向量或列向量线性无关}<br>$$</p><hr><h3 id="5-可用初等行变换化为单位矩阵"><a href="#5-可用初等行变换化为单位矩阵" class="headerlink" title="(5) 可用初等行变换化为单位矩阵"></a>(5) 可用初等行变换化为单位矩阵</h3><p>$$<br>\det(A) \ne 0 \quad \Rightarrow \quad A \sim I_n<br>$$</p><p>即矩阵 $A$ 可以通过有限次初等行变换（不改变行列式为零与否）变成单位矩阵。</p><hr><h3 id="6-特征值均不为零（针对方阵）"><a href="#6-特征值均不为零（针对方阵）" class="headerlink" title="(6) 特征值均不为零（针对方阵）"></a>(6) 特征值均不为零（针对方阵）</h3><p>若 $A$ 是 $n \times n$ 方阵，且其所有特征值为 $\lambda_1, \lambda_2, \dots, \lambda_n$，则：</p><p>$$<br>\det(A) &#x3D; \prod_{i&#x3D;1}^n \lambda_i<br>$$</p><p>因此：</p><p>$$<br>\det(A) \ne 0 \quad \Leftrightarrow \quad \lambda_i \ne 0,\ \forall i<br>$$</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>一个 $n \times n$ 矩阵正则 ⇔ 行列式非零 ⇔ 满秩 ⇔ 可逆 ⇔ 行&#x2F;列线性无关 ⇔ 齐次方程只有零解。</strong></p><h2 id="7-线性相关和线性无关"><a href="#7-线性相关和线性无关" class="headerlink" title="7. 线性相关和线性无关"></a>7. 线性相关和线性无关</h2><p>在<strong>线性代数</strong>中，理解向量的线性相关性和无关性是判断一个向量组是否冗余、是否能构成基底（basis）或张成空间的关键。</p><p><strong>定义</strong></p><p>设有 $n$ 维向量空间中的向量组：</p><p>$$<br>{\mathbf{v}_1, \mathbf{v}_2, \dots, \mathbf{v}_k}<br>$$</p><p>我们考虑其是否满足以下关系：</p><p>$$<br>c_1 \mathbf{v}_1 + c_2 \mathbf{v}_2 + \cdots + c_k \mathbf{v}_k &#x3D; \mathbf{0}<br>$$</p><p>其中 $c_1, c_2, \dots, c_k \in \mathbb{R}$（或 $\mathbb{C}$，取决于所在的向量空间）</p><hr><h3 id="7-1-线性相关（Linearly-Dependent）"><a href="#7-1-线性相关（Linearly-Dependent）" class="headerlink" title="7.1 线性相关（Linearly Dependent）"></a><strong>7.1 线性相关（Linearly Dependent）</strong></h3><p>如果<strong>存在一组不全为零的系数</strong> $c_1, c_2, \dots, c_k$，使上述等式成立，即：</p><p>$$<br>\exists, c_i \ne 0,\ \text{使得} \ \sum_{i&#x3D;1}^k c_i \mathbf{v}_i &#x3D; \mathbf{0}<br>$$</p><p>则称向量组<strong>线性相关</strong>。</p><p>➡️ 直观理解：至少有一个向量可以用其他向量线性表示。</p><hr><h3 id="7-2-线性无关（Linearly-Independent）"><a href="#7-2-线性无关（Linearly-Independent）" class="headerlink" title="7.2 线性无关（Linearly Independent）"></a><strong>7.2 线性无关（Linearly Independent）</strong></h3><p>如果<strong>只有当所有系数都为零</strong>时上述等式才能成立：</p><p>$$<br>c_1 &#x3D; c_2 &#x3D; \cdots &#x3D; c_k &#x3D; 0<br>$$</p><p>则称该向量组<strong>线性无关</strong>。</p><p>➡️ 直观理解：没有一个向量可以用其他向量线性组合得到。</p><hr><p><strong>线性相关例子：</strong></p><p>$$<br>\mathbf{v}_1 &#x3D; \begin{bmatrix}1\\2\\3\end{bmatrix},\quad<br>\mathbf{v}_2 &#x3D; \begin{bmatrix}2\\4\\6\end{bmatrix}<br>$$</p><p>我们有：</p><p>$$<br>\mathbf{v}_2 &#x3D; 2\mathbf{v}_1<br>$$</p><p>所以它们<strong>线性相关</strong>，因为存在非零系数使得：</p><p>$$<br>-2\mathbf{v}_1 + \mathbf{v}_2 &#x3D; \mathbf{0}<br>$$</p><hr><p><strong>线性无关例子：</strong></p><p>$$<br>\mathbf{v}_1 &#x3D; \begin{bmatrix}1\\0\\0\end{bmatrix},\quad<br>\mathbf{v}_2 &#x3D; \begin{bmatrix}0\\1\\0\end{bmatrix},\quad<br>\mathbf{v}_3 &#x3D; \begin{bmatrix}0\\0\\1\end{bmatrix}<br>$$</p><p>标准正交基，它们线性无关，因为：</p><p>$$<br>c_1\mathbf{v}_1 + c_2\mathbf{v}_2 + c_3\mathbf{v}_3 &#x3D; \mathbf{0} \Rightarrow c_1 &#x3D; c_2 &#x3D; c_3 &#x3D; 0<br>$$</p><hr><h3 id="7-3-等价条件总结"><a href="#7-3-等价条件总结" class="headerlink" title="7.3 等价条件总结"></a><strong>7.3 等价条件总结</strong></h3><p>一个向量组线性无关 ⇔ 下列任一条件成立：</p><ul><li><p>向量组组成的矩阵 $A$ 满秩（即 $\text{rank}(A) &#x3D; k$）</p></li><li><p>行列式非零（若是方阵）：</p><p>$$<br>\det(A) \ne 0 \Rightarrow \text{列向量线性无关}<br>$$</p></li><li><p>对应齐次线性方程组只有零解：</p><p>$$<br>A\mathbf{x} &#x3D; \mathbf{0} \Rightarrow \mathbf{x} &#x3D; \mathbf{0}<br>$$</p></li></ul><h2 id="8-Cramer-法则（Cramer’s-Rule）"><a href="#8-Cramer-法则（Cramer’s-Rule）" class="headerlink" title="8. Cramer 法则（Cramer’s Rule）"></a>8. Cramer 法则（Cramer’s Rule）</h2><p><strong>Cramer 法则</strong> 是一种求解<strong>线性方程组</strong>（特别是 $n$ 元 $n$ 次方程组）的方法，适用于系数矩阵可逆（即行列式非零）的情况。</p><p><strong>✅ 适用前提</strong></p><p>设有一个 $n$ 阶线性方程组：</p><p>$$<br>A\mathbf{x} &#x3D; \mathbf{b}<br>$$</p><p>其中：</p><ul><li>$A$ 是一个 $n \times n$ 的<strong>系数矩阵</strong></li><li>$\mathbf{x} &#x3D; [x_1, x_2, \dots, x_n]^T$ 是<strong>未知向量</strong></li><li>$\mathbf{b}$ 是<strong>常数向量</strong></li></ul><p>如果：</p><p>$$<br>\det(A) \ne 0<br>$$</p><p>则该线性方程组有唯一解，且可以通过 Cramer 法则表示。</p><hr><p><strong>📌 公式表达</strong></p><p>设 $A_i$ 表示用向量 $\mathbf{b}$ 代替 $A$ 的第 $i$ 列后得到的矩阵。</p><p>则未知量 $x_i$ 可表示为：</p><p>$$<br>x_i &#x3D; \frac{\det(A_i)}{\det(A)} \quad \text{for } i &#x3D; 1, 2, \dots, n<br>$$</p><hr><p><strong>🧠 例子</strong></p><p>解方程组：</p><p>$$<br>\begin{cases}<br>2x + 3y &#x3D; 8 \\<br>5x - y &#x3D; 9<br>\end{cases}<br>$$</p><ol><li>构造系数矩阵 $A$：</li></ol><p>$$<br>A &#x3D; \begin{bmatrix}<br>2 &amp; 3 \<br>5 &amp; -1<br>\end{bmatrix},\quad<br>\mathbf{b} &#x3D; \begin{bmatrix}<br>8 \<br>9<br>\end{bmatrix}<br>$$</p><ol start="2"><li>求 $\det(A)$：</li></ol><p>$$<br>\det(A) &#x3D; 2 \cdot (-1) - 5 \cdot 3 &#x3D; -2 - 15 &#x3D; -17<br>$$</p><ol start="3"><li>构造 $A_1$（用 $\mathbf{b}$ 替换第1列）：</li></ol><p>$$<br>A_1 &#x3D; \begin{bmatrix}<br>8 &amp; 3 \<br>9 &amp; -1<br>\end{bmatrix},\quad<br>\det(A_1) &#x3D; 8 \cdot (-1) - 9 \cdot 3 &#x3D; -8 - 27 &#x3D; -35<br>$$</p><ol start="4"><li>构造 $A_2$（用 $\mathbf{b}$ 替换第2列）：</li></ol><p>$$<br>A_2 &#x3D; \begin{bmatrix}<br>2 &amp; 8 \\<br>5 &amp; 9<br>\end{bmatrix},\quad<br>\det(A_2) &#x3D; 2 \cdot 9 - 5 \cdot 8 &#x3D; 18 - 40 &#x3D; -22<br>$$</p><ol start="5"><li>求解：</li></ol><p>$$<br>x &#x3D; \frac{\det(A_1)}{\det(A)} &#x3D; \frac{-35}{-17} &#x3D; \frac{35}{17},\quad<br>y &#x3D; \frac{\det(A_2)}{\det(A)} &#x3D; \frac{-22}{-17} &#x3D; \frac{22}{17}<br>$$</p><p><strong>🧾 总结</strong></p><ul><li>Cramer 法则只能用于 <strong>系数矩阵 $A$ 是方阵且 $\det(A) \ne 0$</strong> 的情形。</li><li>如果 $\det(A) &#x3D; 0$，该方法不适用，需使用高斯消元法等其他方法。</li><li>对于高维度的大型方程组，Cramer 法则计算效率低，适合手算&#x2F;小规模问题。</li></ul><h2 id="9-正交矩阵（Orthogonal-Matrix）的性质总结"><a href="#9-正交矩阵（Orthogonal-Matrix）的性质总结" class="headerlink" title="9. 正交矩阵（Orthogonal Matrix）的性质总结"></a>9. 正交矩阵（Orthogonal Matrix）的性质总结</h2><p><strong>✅ 定义</strong></p><p>一个 $n \times n$ 的实矩阵 $Q$ 被称为<strong>正交矩阵</strong>，当且仅当：</p><p>$$<br>Q^T Q &#x3D; QQ^T &#x3D; I_n<br>$$</p><p>这等价于：</p><p>$$<br>Q^{-1} &#x3D; Q^T<br>$$</p><p><strong>📌 几何意义</strong></p><p>正交矩阵代表一种<strong>保持内积、长度、角度不变</strong>的线性变换，几何上对应：</p><ul><li><strong>旋转（rotation）</strong></li><li><strong>反射（reflection）</strong></li></ul><p><strong>⭐ 常见性质</strong></p><h3 id="9-1-转置等于逆："><a href="#9-1-转置等于逆：" class="headerlink" title="9.1. 转置等于逆："></a>9.1. <strong>转置等于逆：</strong></h3><p>$$<br>Q^{-1} &#x3D; Q^T<br>$$</p><p>这意味着求逆变得非常简单。</p><hr><h3 id="9-2-保持向量长度（范数）不变："><a href="#9-2-保持向量长度（范数）不变：" class="headerlink" title="9.2. 保持向量长度（范数）不变："></a>9.2. <strong>保持向量长度（范数）不变：</strong></h3><p>对任意列向量 $\mathbf{x}$：</p><p>$$<br>| Q\mathbf{x} | &#x3D; | \mathbf{x} |<br>$$</p><hr><h3 id="9-3-保持内积不变："><a href="#9-3-保持内积不变：" class="headerlink" title="9.3. 保持内积不变："></a>9.3. <strong>保持内积不变：</strong></h3><p>对任意两个列向量 $\mathbf{x}, \mathbf{y}$：</p><p>$$<br>\langle Q\mathbf{x}, Q\mathbf{y} \rangle &#x3D; \langle \mathbf{x}, \mathbf{y} \rangle<br>$$</p><p>即保持角度不变。</p><hr><h3 id="9-4-列向量-行向量正交归一："><a href="#9-4-列向量-行向量正交归一：" class="headerlink" title="9.4. 列向量&#x2F;行向量正交归一："></a>9.4. <strong>列向量&#x2F;行向量正交归一：</strong></h3><p>矩阵 $Q$ 的列向量是标准正交组：</p><p>$$<br>\mathbf{q}_i^T \mathbf{q}_j &#x3D; \begin{cases}<br>1 &amp; i &#x3D; j \<br>0 &amp; i \ne j<br>\end{cases}<br>$$</p><hr><h3 id="9-5-行列式为-±1："><a href="#9-5-行列式为-±1：" class="headerlink" title="9.5. 行列式为 ±1："></a>9.5. <strong>行列式为 ±1：</strong></h3><p>$$<br>\det(Q) &#x3D; \pm 1<br>$$</p><ul><li>$\det(Q) &#x3D; 1$ 表示纯旋转</li><li>$\det(Q) &#x3D; -1$ 表示反射变换（如镜像）</li></ul><hr><h3 id="9-6-正交矩阵的乘积仍为正交矩阵："><a href="#9-6-正交矩阵的乘积仍为正交矩阵：" class="headerlink" title="9.6. 正交矩阵的乘积仍为正交矩阵："></a>9.6. <strong>正交矩阵的乘积仍为正交矩阵：</strong></h3><p>若 $Q_1, Q_2$ 均为正交矩阵，则：</p><p>$$<br>Q &#x3D; Q_1 Q_2 \quad \Rightarrow \quad Q \text{ 也是正交矩阵}<br>$$</p><hr><h3 id="9-7-特征值性质："><a href="#9-7-特征值性质：" class="headerlink" title="9.7. 特征值性质："></a>9.7. <strong>特征值性质：</strong></h3><p>正交矩阵的特征值满足：</p><ul><li>模长为 1（即 $|\lambda| &#x3D; 1$）</li><li>可能是复数（例如二维旋转矩阵的特征值为 $e^{\pm i\theta}$）</li></ul><hr><h3 id="9-8-正交矩阵是酉矩阵的实数特例："><a href="#9-8-正交矩阵是酉矩阵的实数特例：" class="headerlink" title="9.8. 正交矩阵是酉矩阵的实数特例："></a>9.8. <strong>正交矩阵是酉矩阵的实数特例：</strong></h3><p>酉矩阵（Unitary Matrix）满足 $U^* U &#x3D; I$（$U^*$ 是共轭转置），正交矩阵是所有元素为实数时的特例。</p><h2 id="10-Schmidt-正交化（Gram-Schmidt-Orthogonalization）"><a href="#10-Schmidt-正交化（Gram-Schmidt-Orthogonalization）" class="headerlink" title="10. Schmidt 正交化（Gram-Schmidt Orthogonalization）"></a>10. Schmidt 正交化（Gram-Schmidt Orthogonalization）</h2><p><strong>Gram-Schmidt 正交化</strong>是一种将一组线性无关的向量，构造为一组 <strong>正交</strong> 或 <strong>标准正交（单位正交）</strong> 向量的方法，常用于：</p><ul><li>求正交（单位正交）基底</li><li>正交投影</li><li>QR 分解</li></ul><p>✅ 输入条件</p><p>设有一组线性无关的向量组：</p><p>$$<br>{\mathbf{v}_1, \mathbf{v}_2, \dots, \mathbf{v}_n}<br>$$</p><p>目标是构造出一组正交向量组：</p><p>$$<br>{\mathbf{u}_1, \mathbf{u}_2, \dots, \mathbf{u}_n}<br>$$</p><p>使得：</p><p>$$<br>\text{span}(\mathbf{v}_1, \dots, \mathbf{v}_k) &#x3D; \text{span}(\mathbf{u}_1, \dots, \mathbf{u}_k),\quad \text{且 } \langle \mathbf{u}_i, \mathbf{u}_j \rangle &#x3D; 0\ (i \ne j)<br>$$</p><p><strong>🧠 正交化步骤（原始版）</strong></p><ol><li>第一个向量直接取：</li></ol><p>$$<br>\mathbf{u}_1 &#x3D; \mathbf{v}_1<br>$$</p><ol start="2"><li>之后每一步都从当前向量中<strong>减去它在前面所有正交向量上的投影</strong>：</li></ol><p>向量在 $\mathbf{u}_j$ 上的投影定义为：</p><p>$$<br>\mathrm{proj}_{\mathbf{u}_j}(\mathbf{v}_k) &#x3D; \frac{\langle \mathbf{v}_k, \mathbf{u}_j \rangle}{\langle \mathbf{u}_j, \mathbf{u}_j \rangle} \mathbf{u}_j<br>$$</p><p><strong>✨ 若要单位正交（正交归一化）</strong></p><p>定义：</p><p>$$<br>\mathbf{e}_k &#x3D; \frac{\mathbf{u}_k}{|\mathbf{u}_k|}<br>$$</p><p>📌 二维实例</p><p>设：</p><p>$$<br>\mathbf{v}_1 &#x3D; \begin{bmatrix} 1 \\ 1 \end{bmatrix},\quad<br>\mathbf{v}_2 &#x3D; \begin{bmatrix} 1 \\ 0 \end{bmatrix}<br>$$</p><p>步骤如下：</p><ul><li>第一步：</li></ul><p>$$<br>  \mathbf{u}_1 &#x3D; \mathbf{v}_1 &#x3D; \begin{bmatrix}1\\1\end{bmatrix}<br>$$</p><ul><li><p>若归一化：</p><p>$$<br>\mathbf{e}_1 &#x3D; \frac{1}{\sqrt{2}} \begin{bmatrix}1\\1\end{bmatrix},\quad<br>\mathbf{e}_2 &#x3D; \frac{1}{\sqrt{2}} \begin{bmatrix}1\\-1\end{bmatrix}<br>$$</p></li></ul><h3 id="10-1-🎯-示例：三个向量的-Gram-Schmidt-正交化"><a href="#10-1-🎯-示例：三个向量的-Gram-Schmidt-正交化" class="headerlink" title="10.1 🎯 示例：三个向量的 Gram-Schmidt 正交化"></a>10.1 🎯 示例：三个向量的 Gram-Schmidt 正交化</h3><p>设向量组：</p><p>$$<br>\mathbf{v}_1 &#x3D; \begin{bmatrix}1\\1\\0\end{bmatrix},\quad<br>\mathbf{v}_2 &#x3D; \begin{bmatrix}1\\0\\1\end{bmatrix},\quad<br>\mathbf{v}_3 &#x3D; \begin{bmatrix}0\\1\\1\end{bmatrix}<br>$$</p><p>我们的目标是构造出一组<strong>正交向量</strong> ${\mathbf{u}_1, \mathbf{u}_2, \mathbf{u}_3}$。</p><p>✅ Step 1: 第一个向量直接取</p><p>$$<br>\mathbf{u}_1 &#x3D; \mathbf{v}_1 &#x3D; \begin{bmatrix}1\\1\\0\end{bmatrix}<br>$$</p><p> ✅ Step 2: 计算 $\mathbf{u}_2$</p><p>首先计算投影：</p><p>$$<br>\mathrm{proj}_{\mathbf{u}_1}(\mathbf{v}_2)<br>&#x3D; \frac{\langle \mathbf{v}_2, \mathbf{u}_1 \rangle}{\langle \mathbf{u}_1, \mathbf{u}_1 \rangle} \mathbf{u}_1<br>$$</p><p>内积：</p><p>$$<br>\langle \mathbf{v}_2, \mathbf{u}_1 \rangle &#x3D; 1 \cdot 1 + 0 \cdot 1 + 1 \cdot 0 &#x3D; 1 \\<br>\langle \mathbf{u}_1, \mathbf{u}_1 \rangle &#x3D; 1^2 + 1^2 + 0^2 &#x3D; 2<br>$$</p><p>所以：</p><p>$$<br>\mathrm{proj}_{\mathbf{u}_1}(\mathbf{v}_2) &#x3D; \frac{1}{2} \begin{bmatrix}1\\1\\0\end{bmatrix} &#x3D; \begin{bmatrix}0.5\\0.5\\0\end{bmatrix}<br>$$</p><p>✅ Step 3: 计算 $\mathbf{u}_3$</p><p>先计算 $\mathrm{proj}_{\mathbf{u}_1}(\mathbf{v}_3)$：</p><p>$$<br>\langle \mathbf{v}_3, \mathbf{u}_1 \rangle &#x3D; 0 \cdot 1 + 1 \cdot 1 + 1 \cdot 0 &#x3D; 1 \\<br>\langle \mathbf{u}_1, \mathbf{u}_1 \rangle &#x3D; 2<br>$$</p><p>$$<br>\mathrm{proj}_{\mathbf{u}_1}(\mathbf{v}_3) &#x3D; \frac{1}{2} \begin{bmatrix}1\\1\\0\end{bmatrix} &#x3D; \begin{bmatrix}0.5\\0.5\\0\end{bmatrix}<br>$$</p><p>再计算 $\mathrm{proj}_{\mathbf{u}_2}(\mathbf{v}_3)$：</p><p>$$<br>\langle \mathbf{v}_3, \mathbf{u}_2 \rangle &#x3D; 0.5 \cdot 0 + (-0.5) \cdot 1 + 1 \cdot 1 &#x3D; -0.5 + 1 &#x3D; 0.5 \\<br>\langle \mathbf{u}_2, \mathbf{u}_2 \rangle &#x3D; 0.5^2 + (-0.5)^2 + 1^2 &#x3D; 0.25 + 0.25 + 1 &#x3D; 1.5<br>$$</p><p>$$<br>\mathrm{proj}_{\mathbf{u}_2}(\mathbf{v}_3) &#x3D; \frac{0.5}{1.5} \begin{bmatrix}0.5\\-0.5\\1\end{bmatrix} &#x3D; \frac{1}{3} \begin{bmatrix}0.5\\-0.5\\1\end{bmatrix} &#x3D; \begin{bmatrix}\frac{1}{6}\\-\frac{1}{6}\\\frac{1}{3}\end{bmatrix}<br>$$</p><p>✅ 最终正交向量组</p><p>$$<br>\mathbf{u}_1 &#x3D; \begin{bmatrix}1\\1\\0\end{bmatrix},\quad<br>\mathbf{u}_2 &#x3D; \begin{bmatrix}0.5\\-0.5\\1\end{bmatrix},\quad<br>\mathbf{u}_3 &#x3D; \begin{bmatrix}-\frac{2}{3}\\\frac{2}{3}\\\frac{2}{3}\end{bmatrix}<br>$$</p><p>也可以将它们归一化（单位化）得到<strong>标准正交基</strong>。</p><h2 id="11-QR-分解（QR-Decomposition）"><a href="#11-QR-分解（QR-Decomposition）" class="headerlink" title="11. QR 分解（QR Decomposition）"></a>11. QR 分解（QR Decomposition）</h2><p><strong>QR 分解</strong>是将一个实矩阵 $A$ 分解成两个矩阵的乘积：</p><p>$$<br>A &#x3D; QR<br>$$</p><p>其中：</p><ul><li>$Q$ 是一个 <strong>正交矩阵</strong>（列向量正交且单位长度，$Q^T Q &#x3D; I$）</li><li>$R$ 是一个 <strong>上三角矩阵</strong></li></ul><p><strong>✅ 适用范围</strong></p><ul><li>$A$ 是任意的 $m \times n$（$m \ge n$）的<strong>列满秩矩阵</strong></li><li>通常用于<strong>求解线性方程组</strong>、<strong>最小二乘拟合</strong>、<strong>特征值计算</strong></li></ul><p><strong>🧠 QR 分解的意义</strong></p><p>QR 分解将矩阵分解为：</p><ul><li>$Q$：正交（或单位正交）基底，保持角度与长度；</li><li>$R$：记录了从标准基变换到原始列向量的投影系数。</li></ul><p>几何上，QR 分解提供了一种将向量分解为<strong>正交基的线性组合</strong>的方式。</p><p><strong>🧪 举例</strong></p><p>设矩阵：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>1 &amp; 1 \\<br>1 &amp; 0 \\<br>0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>我们使用 <strong>Gram-Schmidt 正交化</strong> 对 $A$ 的列向量进行处理。</p><p><strong>✅ Step 1: 拆分列向量</strong></p><p>记 $A &#x3D; [\mathbf{a}_1\ \mathbf{a}_2]$：</p><p>$$<br>\mathbf{a}_1 &#x3D; \begin{bmatrix}1\\1\\0\end{bmatrix},\quad<br>\mathbf{a}_2 &#x3D; \begin{bmatrix}1\\0\\1\end{bmatrix}<br>$$</p><p><strong>✅ Step 2: Gram-Schmidt 正交化</strong></p><p>$\mathbf{u}_1 &#x3D; \mathbf{a}_1$</p><p>单位化得 $\mathbf{q}_1$：</p><p>$$<br>  |\mathbf{u}_1| &#x3D; \sqrt{1^2 + 1^2 + 0^2} &#x3D; \sqrt{2},\quad<br>  \mathbf{q}_1 &#x3D; \frac{1}{\sqrt{2}} \begin{bmatrix}1\\1\\0\end{bmatrix}<br>$$</p><p>投影：</p><p>$$<br>  \mathrm{proj}_{\mathbf{q}_1}(\mathbf{a}_2) &#x3D; \langle \mathbf{a}_2, \mathbf{q}_1 \rangle \cdot \mathbf{q}_1<br>  &#x3D; \left( \frac{1 \cdot 1 + 0 \cdot 1 + 1 \cdot 0}{\sqrt{2}} \right) \cdot \mathbf{q}_1<br>  &#x3D; \frac{1}{\sqrt{2}} \cdot \mathbf{q}_1<br>$$</p><p>$$<br>  \mathbf{u}_2 &#x3D; \begin{bmatrix}1\\0\\1\end{bmatrix} - \frac{1}{\sqrt{2}} \cdot \frac{1}{\sqrt{2}} \begin{bmatrix}1\\1\\0\end{bmatrix}<br>  &#x3D; \begin{bmatrix}1\\0\\1\end{bmatrix} - \frac{1}{2} \begin{bmatrix}1\\1\\0\end{bmatrix}<br>  &#x3D; \begin{bmatrix}0.5\\-0.5\\1\end{bmatrix}<br>$$</p><p>单位化 $\mathbf{u}_2$ 得 $\mathbf{q}_2$：</p><p>$$<br>  |\mathbf{u}_2| &#x3D; \sqrt{0.5^2 + (-0.5)^2 + 1^2} &#x3D; \sqrt{1.5}<br>$$</p><p>$$<br>  \mathbf{q}_2 &#x3D; \frac{1}{\sqrt{1.5}} \begin{bmatrix}0.5\\-0.5\\1\end{bmatrix}<br>$$</p><p><strong>✅ Step 3: 得到 $Q$ 与 $R$</strong></p><p>$Q &#x3D; [\mathbf{q}_1\ \mathbf{q}_2]$</p><p>$R$ 是：</p><p>  $$<br>  R &#x3D; \begin{bmatrix}<br>  \langle \mathbf{a}_1, \mathbf{q}_1 \rangle &amp; \langle \mathbf{a}_2, \mathbf{q}_1 \rangle \\<br>  0 &amp; \langle \mathbf{a}_2, \mathbf{q}_2 \rangle<br>  \end{bmatrix}<br>  $$</p><p>你可以验证：</p><p>$$<br>A &#x3D; QR<br>$$</p><p>🧾 QR 分解的应用</p><table><thead><tr><th>应用场景</th><th>说明</th></tr></thead><tbody><tr><td>解线性方程组</td><td>特别是在最小二乘问题中 $Ax \approx b$</td></tr><tr><td>特征值迭代算法</td><td>QR 算法是一种迭代计算特征值的数值方法</td></tr><tr><td>稳定的矩阵分解</td><td>相较于直接求逆，QR 更稳定、适合数值计算</td></tr></tbody></table><h2 id="12-平面三角形的中点公式-重心公式"><a href="#12-平面三角形的中点公式-重心公式" class="headerlink" title="12. 平面三角形的中点公式 &#x2F; 重心公式"></a>12. 平面三角形的中点公式 &#x2F; 重心公式</h2><h3 id="一、中点公式（Midpoint-Formula）"><a href="#一、中点公式（Midpoint-Formula）" class="headerlink" title="一、中点公式（Midpoint Formula）"></a>一、中点公式（Midpoint Formula）</h3><p>对于二维平面上的两个点 $A(x_1, y_1)$ 和 $B(x_2, y_2)$，线段 $AB$ 的<strong>中点</strong> $M$ 的坐标是：</p><p>$$<br>M &#x3D; \left( \frac{x_1 + x_2}{2},\ \frac{y_1 + y_2}{2} \right)<br>$$</p><p>这个公式的意思是：中点的坐标就是两个端点坐标的平均值。</p><hr><h3 id="二、重心公式（Centroid-of-a-Triangle）"><a href="#二、重心公式（Centroid-of-a-Triangle）" class="headerlink" title="二、重心公式（Centroid of a Triangle）"></a>二、重心公式（Centroid of a Triangle）</h3><p>对于一个三角形，设三个顶点为：</p><ul><li>$A(x_1, y_1)$</li><li>$B(x_2, y_2)$</li><li>$C(x_3, y_3)$</li></ul><p>这个三角形的<strong>重心</strong>（也叫质心、形心）$G$ 的坐标是：</p><p>$$<br>G &#x3D; \left( \frac{x_1 + x_2 + x_3}{3},\ \frac{y_1 + y_2 + y_3}{3} \right)<br>$$</p><p>也就是三角形三个顶点坐标的<strong>平均值</strong>。</p><p><strong>🚩 重心的性质：</strong></p><ol><li>重心是三角形三条<strong>中线</strong>的交点。</li><li>重心将每条中线分成<strong>2:1</strong> 的比例（靠近顶点的部分是较长的那段）。</li><li>重心是三角形“力的平衡点”，如果把每个顶点当作相同质量的点，重心是其平衡中心。</li></ol><p><strong>🧠 举个例子</strong></p><p>设有三角形 $ABC$：</p><ul><li>$A(1, 2)$</li><li>$B(4, 5)$</li><li>$C(7, 1)$</li></ul><p>那么重心 $G$ 的坐标为：</p><p>$$<br>G &#x3D; \left( \frac{1+4+7}{3},\ \frac{2+5+1}{3} \right) &#x3D; \left( \frac{12}{3},\ \frac{8}{3} \right) &#x3D; (4,\ \frac{8}{3})<br>$$</p><h2 id="13-外积（叉积）"><a href="#13-外积（叉积）" class="headerlink" title="13. 外积（叉积）"></a>13. 外积（叉积）</h2><p>外积（<strong>叉积</strong>，Cross Product）是指<strong>三维空间中两个向量相乘</strong>得到一个<strong>垂直于这两个向量的向量</strong>。</p><ul><li><p>设 $\vec{a}$ 和 $\vec{b}$ 是两个三维向量，它们的外积记作：</p><p>$$<br>\vec{a} \times \vec{b}<br>$$</p></li><li><p>运算结果是一个<strong>向量</strong>，其方向由<strong>右手定则</strong>决定，大小为：</p><p>$$<br>|\vec{a} \times \vec{b}| &#x3D; |\vec{a}| \cdot |\vec{b}| \cdot \sin \theta<br>$$</p><p>其中 $\theta$ 是两个向量之间的夹角。</p></li></ul><h3 id="13-1-三维空间两向量的外积公式"><a href="#13-1-三维空间两向量的外积公式" class="headerlink" title="13.1 三维空间两向量的外积公式"></a>13.1 三维空间两向量的外积公式</h3><p>设：</p><p>$$<br>\vec{a} &#x3D; (a_1, a_2, a_3),\quad \vec{b} &#x3D; (b_1, b_2, b_3)<br>$$</p><p>则它们的外积为：</p><p>$$<br>\vec{a} \times \vec{b} &#x3D;<br>\begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\<br>a_1 &amp; a_2 &amp; a_3 \\<br>b_1 &amp; b_2 &amp; b_3<br>\end{vmatrix}<br>&#x3D; \left( a_2 b_3 - a_3 b_2,\ a_3 b_1 - a_1 b_3,\ a_1 b_2 - a_2 b_1 \right)<br>$$</p><h3 id="13-2-外积的演算性质"><a href="#13-2-外积的演算性质" class="headerlink" title="13.2 外积的演算性质"></a>13.2 外积的演算性质</h3><p>📌 1. 反交换性（反对称性）</p><p>$$<br>\vec{a} \times \vec{b} &#x3D; -(\vec{b} \times \vec{a})<br>$$</p><p>📌 2. 与自身的外积为零</p><p>$$<br>\vec{a} \times \vec{a} &#x3D; \vec{0}<br>$$</p><p>📌 3. 分配律</p><p>$$<br>\vec{a} \times (\vec{b} + \vec{c}) &#x3D; \vec{a} \times \vec{b} + \vec{a} \times \vec{c}<br>$$</p><p>📌 4. 数乘结合性</p><p>$$<br>(k\vec{a}) \times \vec{b} &#x3D; k(\vec{a} \times \vec{b}) &#x3D; \vec{a} \times (k\vec{b})<br>$$</p><p>📌 5. 外积垂直于两个原向量</p><p>$$<br>\vec{a} \cdot (\vec{a} \times \vec{b}) &#x3D; 0,\quad \vec{b} \cdot (\vec{a} \times \vec{b}) &#x3D; 0<br>$$</p><h4 id="✅-1-向量-vec-a-times-vec-b-的方向："><a href="#✅-1-向量-vec-a-times-vec-b-的方向：" class="headerlink" title="✅ 1. 向量 $\vec{a} \times \vec{b}$ 的方向："></a>✅ 1. 向量 $\vec{a} \times \vec{b}$ 的<strong>方向</strong>：</h4><p>由<strong>右手定则</strong>决定：用右手四指从 $\vec{a}$ 指向 $\vec{b}$，大拇指所指方向就是 $\vec{a} \times \vec{b}$ 的方向。</p><h4 id="✅-2-向量-vec-a-times-vec-b-的大小："><a href="#✅-2-向量-vec-a-times-vec-b-的大小：" class="headerlink" title="✅ 2. 向量 $\vec{a} \times \vec{b}$ 的大小："></a>✅ 2. 向量 $\vec{a} \times \vec{b}$ 的<strong>大小</strong>：</h4><p>等于由 $\vec{a}$ 和 $\vec{b}$ 构成的<strong>平行四边形的面积</strong>：</p><p>$$<br>|\vec{a} \times \vec{b}| &#x3D; |\vec{a}| |\vec{b}| \sin\theta<br>$$</p><h4 id="✅-五、例题演示"><a href="#✅-五、例题演示" class="headerlink" title="✅ 五、例题演示"></a>✅ 五、例题演示</h4><p>设：</p><p>$$<br>\vec{a} &#x3D; (1, 2, 3),\quad \vec{b} &#x3D; (4, 5, 6)<br>$$</p><p>那么：</p><p>$$<br>\vec{a} \times \vec{b} &#x3D;<br>\left|<br>\begin{array}{ccc}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\<br>1 &amp; 2 &amp; 3 \\<br>4 &amp; 5 &amp; 6<br>\end{array}<br>\right|<br>&#x3D; \left( 2\cdot6 - 3\cdot5,\ 3\cdot4 - 1\cdot6,\ 1\cdot5 - 2\cdot4 \right)<br>&#x3D; (-3, 6, -3)<br>$$</p><h2 id="14-特征值（Eigenvalues）"><a href="#14-特征值（Eigenvalues）" class="headerlink" title="14. 特征值（Eigenvalues）"></a>14. 特征值（Eigenvalues）</h2><p>设 $A$ 是一个 $n \times n$ 的方阵，如果存在一个非零向量 $\vec{x} \ne \vec{0}$ 和一个数 $\lambda$，使得：</p><p>$$<br>A \vec{x} &#x3D; \lambda \vec{x}<br>$$</p><p>那么我们称：</p><ul><li>$\lambda$ 是矩阵 $A$ 的<strong>特征值（Eigenvalue）</strong></li><li>$\vec{x}$ 是对应的<strong>特征向量（Eigenvector）</strong></li></ul><hr><h3 id="📌-二、求特征值的方法"><a href="#📌-二、求特征值的方法" class="headerlink" title="📌 二、求特征值的方法"></a>📌 二、求特征值的方法</h3><p>将 $A \vec{x} &#x3D; \lambda \vec{x}$ 改写为：</p><p>$$<br>(A - \lambda I)\vec{x} &#x3D; 0<br>$$</p><p>要使其有<strong>非零解</strong>，需要：</p><p>$$<br>\det(A - \lambda I) &#x3D; 0<br>$$</p><p>这个方程叫做 <strong>特征方程</strong>，解出$\lambda$ 就是特征值。</p><hr><h3 id="📌-三、特征值的性质"><a href="#📌-三、特征值的性质" class="headerlink" title="📌 三、特征值的性质"></a>📌 三、特征值的性质</h3><p>设 $A$ 是 $n \times n$ 的矩阵，$\lambda_1, \dots, \lambda_n$ 是其特征值，则有以下重要性质：</p><p>✅ 1. 特征值之和 &#x3D; $\operatorname{tr}(A)$（矩阵的迹）</p><p>$$<br>\lambda_1 + \lambda_2 + \dots + \lambda_n &#x3D; \operatorname{tr}(A)<br>$$</p><p>迹（trace）定义为矩阵主对角线元素之和：</p><p>$$<br>\operatorname{tr}(A) &#x3D; a_{11} + a_{22} + \dots + a_{nn}<br>$$</p><p>✅ 2. 特征值之积 &#x3D; $\det(A)$（矩阵的行列式）</p><p>$$<br>\lambda_1 \cdot \lambda_2 \cdots \lambda_n &#x3D; \det(A)<br>$$</p><p>✅ 3. 相似矩阵有相同特征值</p><p>如果 $A \sim B$（$A$ 与 $B$ 相似），那么它们的特征值完全相同（包括重数）：</p><p>$$<br>A \sim B \Rightarrow \text{Spec}(A) &#x3D; \text{Spec}(B)<br>$$</p><h2 id="15-矩阵相似（Matrix-Similarity）"><a href="#15-矩阵相似（Matrix-Similarity）" class="headerlink" title="15. 矩阵相似（Matrix Similarity）"></a>15. 矩阵相似（Matrix Similarity）</h2><p>两个 $n \times n$ 矩阵 $A$ 和 $B$，若存在一个可逆矩阵 $P$，使得：</p><p>$$<br>B &#x3D; P^{-1} A P<br>$$</p><p>则称 $A$ 和 $B$ <strong>相似</strong>，记作：</p><p>$$<br>A \sim B<br>$$</p><h3 id="📌-15-1-相似矩阵的性质"><a href="#📌-15-1-相似矩阵的性质" class="headerlink" title="📌 15.1 相似矩阵的性质"></a>📌 15.1 相似矩阵的性质</h3><p><strong>✅ 1. 相似矩阵具有相同的：</strong></p><ul><li>特征值</li><li>行列式（$\det A &#x3D; \det B$）</li><li>迹（$\operatorname{tr}(A) &#x3D; \operatorname{tr}(B)$）</li><li>特征多项式</li></ul><p>✅ 2. 相似矩阵可以视为是<strong>同一个线性变换在不同基下的矩阵表示</strong>。</p><p><strong>✅ 举个例子</strong></p><p>设：</p><p>$$<br>A &#x3D; \begin{bmatrix} 2 &amp; 1 \\ 0 &amp; 3 \end{bmatrix}<br>$$</p><p>我们求其特征值：</p><p>$$<br>\det(A - \lambda I) &#x3D; \begin{vmatrix} 2 - \lambda &amp; 1 \\ 0 &amp; 3 - \lambda \end{vmatrix} &#x3D; (2 - \lambda)(3 - \lambda)<br>$$</p><p>得到特征值：$\lambda &#x3D; 2,\ 3$</p><p>验证性质：</p><ul><li><p>$\operatorname{tr}(A) &#x3D; 2 + 3 &#x3D; 5 &#x3D; \lambda_1 + \lambda_2$</p></li><li><p>$\det(A) &#x3D; 2 \cdot 3 &#x3D; 6 &#x3D; \lambda_1 \cdot \lambda_2$</p></li></ul><h2 id="16-相似对角化（Matrix-Diagonalization）"><a href="#16-相似对角化（Matrix-Diagonalization）" class="headerlink" title="16. 相似对角化（Matrix Diagonalization）"></a>16. 相似对角化（Matrix Diagonalization）</h2><p>设 $A$ 是一个 $n \times n$ 的方阵，如果存在一个<strong>可逆矩阵</strong> $P$ 和一个<strong>对角矩阵</strong> $D$，使得：</p><p>$$<br>A &#x3D; P D P^{-1}<br>$$</p><p>或者写作：</p><p>$$<br>P^{-1} A P &#x3D; D<br>$$</p><p>则称 <strong>$A$ 可对角化（diagonalizable）</strong>，$D$ 是 $A$ 的对角矩阵形式，$P$ 是构造它的特征向量矩阵。</p><p>这就是一个<strong>相似变换</strong>，所以称为<strong>相似对角化</strong>。</p><p><strong>📌 对角化的意义</strong></p><p>对角矩阵 $D$ 形式非常简单，只在主对角线上有数，其余为 0，比如：</p><p>$$<br>D &#x3D; \begin{bmatrix}<br>\lambda_1 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; \lambda_2 &amp; \cdots &amp; 0 \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>0 &amp; 0 &amp; \cdots &amp; \lambda_n<br>\end{bmatrix}<br>$$</p><p>如果 $A &#x3D; PDP^{-1}$，那么：</p><ul><li>$A^k &#x3D; P D^k P^{-1}$（非常容易计算 $A$ 的高次幂）</li><li>可以简化矩阵函数，如 $e^A &#x3D; P e^D P^{-1}$（线性微分方程中常见）</li></ul><p><strong>📌 对角化的充分必要条件</strong></p><p>一个 $n \times n$ 的矩阵 $A$ <strong>可以对角化</strong>，当且仅当：</p><blockquote><p><strong>$A$ 有 $n$ 个线性无关的特征向量</strong></p></blockquote><p>这相当于说，矩阵 $A$ 是<strong>相似于某个对角矩阵</strong>的充要条件。</p><p><strong>📌 对角化的步骤</strong></p><p>设矩阵 $A$ 是 $n \times n$：</p><p>✅ 步骤1：求特征值 $\lambda$</p><p>解特征方程：</p><p>$$<br>\det(A - \lambda I) &#x3D; 0<br>$$</p><p> ✅ 步骤2：求每个特征值对应的特征向量</p><p>对于每个 $\lambda$，解：</p><p>$$<br>(A - \lambda I)\vec{x} &#x3D; 0<br>$$</p><p>得到线性无关的特征向量。</p><p>✅ 步骤3：构造矩阵 $P$ 和 $D$</p><ul><li>$P$ 的列向量就是所有线性无关的特征向量</li><li>$D$ 是对角矩阵，其对角元素是对应的特征值（顺序和 $P$ 一致）</li></ul><p>📌 例题：对角化一个矩阵</p><p>设：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>4 &amp; 1 \\<br>0 &amp; 2<br>\end{bmatrix}<br>$$</p><p><strong>Step 1: 求特征值</strong></p><p>$$<br>\det(A - \lambda I) &#x3D; (4 - \lambda)(2 - \lambda)<br>$$</p><p>得特征值：$\lambda_1 &#x3D; 4,\ \lambda_2 &#x3D; 2$</p><p><strong>Step 2: 求特征向量</strong></p><p>对 $\lambda &#x3D; 4$：</p><p>$$<br>(A - 4I)\vec{x} &#x3D; \begin{bmatrix} 0 &amp; 1 \\ 0 &amp; -2 \end{bmatrix} \vec{x} &#x3D; 0<br>$$</p><p>得特征向量 $\vec{v}_1 &#x3D; \begin{bmatrix} 1 \ 0 \end{bmatrix}$</p><p>对 $\lambda &#x3D; 2$：</p><p>$$<br>(A - 2I)\vec{x} &#x3D; \begin{bmatrix} 2 &amp; 1 \\ 0 &amp; 0 \end{bmatrix} \vec{x} &#x3D; 0<br>$$</p><p>得特征向量 $\vec{v}_2 &#x3D; \begin{bmatrix} -1 \ 2 \end{bmatrix}$</p><p>Step 3: 构造 $P$ 和 $D$</p><p>$$<br>P &#x3D; \begin{bmatrix}<br>1 &amp; -1 \\<br>0 &amp; 2<br>\end{bmatrix},\quad<br>D &#x3D; \begin{bmatrix}<br>4 &amp; 0 \\<br>0 &amp; 2<br>\end{bmatrix}<br>$$</p><p>验证：</p><p>$$<br>P^{-1}AP &#x3D; D<br>$$</p><h3 id="📌-一些补充说明"><a href="#📌-一些补充说明" class="headerlink" title="📌 一些补充说明"></a>📌 一些补充说明</h3><p><strong>❗ 不可对角化的情况：</strong></p><p>有些矩阵没有 $n$ 个线性无关特征向量，例如：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>1 &amp; 1 \\<br>0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>它只有一个特征值 $\lambda &#x3D; 1$，但只有一个特征向量 —— 无法对角化（只能<strong>上三角化</strong>或用<strong>Jordan标准形</strong>）。</p><p><strong>✅ 可对角化充要条件回顾：</strong></p><ul><li>有 $n$ 个线性无关的特征向量</li><li>特征值<strong>代数重数 &#x3D; 几何重数</strong>（每个特征值的重数 &#x3D; 特征空间维数）</li></ul><h2 id="17-Jordan标准型（Jordan-Canonical-Form）"><a href="#17-Jordan标准型（Jordan-Canonical-Form）" class="headerlink" title="17. Jordan标准型（Jordan Canonical Form）"></a>17. Jordan标准型（Jordan Canonical Form）</h2><p>一个 $n \times n$ 的复矩阵 $A$ 总可以相似于一个分块上三角矩阵，该矩阵叫做 <strong>Jordan标准型</strong>，记作 $J$：</p><p>$$<br>A \sim J &#x3D; P^{-1}AP<br>$$</p><p>其中 $P$ 是可逆矩阵，$J$ 的形式如下：</p><p>$$<br>J &#x3D; \begin{bmatrix}<br>J_1 &amp; &amp; \\<br>&amp; \ddots &amp; \\<br>&amp; &amp; J_k<br>\end{bmatrix}<br>$$</p><p>每个 $J_i$ 是一个<strong>Jordan块（Jordan block）</strong>，它的形式如下：</p><p>$$<br>J_i(\lambda) &#x3D; \begin{bmatrix}<br>\lambda &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\<br>0 &amp; \lambda &amp; 1 &amp; \cdots &amp; 0 \\<br>\vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots \\<br>0 &amp; \cdots &amp; 0 &amp; \lambda &amp; 1 \\<br>0 &amp; \cdots &amp; \cdots &amp; 0 &amp; \lambda<br>\end{bmatrix}<br>$$</p><p>其中对角线上全是 $\lambda$，超对角线是 $1$，其他是 $0$。</p><p>每一个 <strong>Jordan块</strong> 对应一个 <strong>特征值  $\lambda$<strong>，如果矩阵不能对角化，说明该特征值的</strong>代数重数 &gt; 几何重数</strong>。</p><ul><li><strong>代数重数（algebraic multiplicity）</strong>：特征值 $\lambda$ 在特征多项式中的重数</li><li><strong>几何重数（geometric multiplicity）</strong>：特征空间的维度，也就是 $\dim(\ker(A - \lambda I))$<br>当代数重数 $&gt;$ 几何重数时，$A$ 不可对角化，但可表示成Jordan标准型。</li></ul><p><strong>✅ 构造Jordan标准型的步骤</strong></p><ol><li><strong>求特征值</strong> $\lambda_1, \lambda_2, \dots$</li><li><strong>对每个 $\lambda$ 求代数重数、几何重数</strong></li><li><strong>构造广义特征向量（generalized eigenvectors）</strong></li><li><strong>形成Jordan块</strong></li><li><strong>排列组合，形成Jordan矩阵</strong></li></ol><h3 id="17-1-例子1️⃣"><a href="#17-1-例子1️⃣" class="headerlink" title="17.1 例子1️⃣"></a>17.1 例子1️⃣</h3><p>设</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>5 &amp; 4 &amp; 2 \\<br>0 &amp; 5 &amp; 1 \\<br>0 &amp; 0 &amp; 5<br>\end{bmatrix}<br>$$</p><ul><li>特征值$\lambda &#x3D; 5$</li><li>特征多项式 $(5 - \lambda)^3$，代数重数是 3</li><li>$\ker(A - 5I)$ 只有一个自由变量，所以几何重数是 1</li></ul><p>→ 无法对角化，但可以写成：</p><p>$$<br>J &#x3D; \begin{bmatrix}<br>5 &amp; 1 &amp; 0 \\<br>0 &amp; 5 &amp; 1 \\<br>0 &amp; 0 &amp; 5<br>\end{bmatrix}<br>$$</p><h3 id="17-2-例子2️⃣"><a href="#17-2-例子2️⃣" class="headerlink" title="17.2 例子2️⃣"></a>17.2 例子2️⃣</h3><p>设：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>5 &amp; 4 &amp; 2 &amp; 0 &amp; 0 \\<br>0 &amp; 5 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 5 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 3 &amp; 1 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 3<br>\end{bmatrix}<br>$$</p><p><strong>✅ Step 1. 求特征值（eigenvalues）</strong></p><p>这是一个<strong>上三角矩阵</strong>，特征值为主对角线上的数：</p><p>$$<br>\lambda_1 &#x3D; 5 \quad（重数 3），\quad<br>\lambda_2 &#x3D; 3 \quad（重数 2）<br>$$</p><p><strong>✅ Step 2. 对每个特征值求几何重数（特征空间维数）</strong></p><p>我们对 $\lambda &#x3D; 5$ 和 $\lambda &#x3D; 3$ 分别求 $\ker(A - \lambda I)$。</p><p>对 $\lambda &#x3D; 5$：</p><p>$$<br>A - 5I &#x3D; \begin{bmatrix}<br>0 &amp; 4 &amp; 2 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; -2 &amp; 1 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; -2<br>\end{bmatrix}<br>$$</p><p>只看 $A_1 &#x3D; A[0:3,0:3]$ 的子块（即对应 $\lambda&#x3D;5$ 的前3行3列）：</p><p>$$<br>A_1 - 5I &#x3D; \begin{bmatrix}<br>0 &amp; 4 &amp; 2 \\<br>0 &amp; 0 &amp; 1 \\<br>0 &amp; 0 &amp; 0<br>\end{bmatrix}<br>$$</p><p>求解 $\ker(A_1 - 5I)$：</p><p>该矩阵的秩为 $2$（两个主元），所以零空间维数是 $3 - 2 &#x3D; 1$</p><p>→ 几何重数为 1，代数重数为 3 → 说明 $\lambda &#x3D; 5$ 对应 <strong>一个大小为3的Jordan块</strong></p><p>对 $\lambda &#x3D; 3$：</p><p>取右下角 $2 \times 2$ 块：</p><p>$$<br>A_2 &#x3D; \begin{bmatrix}<br>3 &amp; 1 \\<br>0 &amp; 3<br>\end{bmatrix}<br>\Rightarrow A_2 - 3I &#x3D; \begin{bmatrix}<br>0 &amp; 1 \\<br>0 &amp; 0<br>\end{bmatrix}<br>$$</p><p>这是阶数为 1 的矩阵，秩为 1，零空间维数是 $2 - 1 &#x3D; 1$</p><p>→ 代数重数为 2，几何重数为 1 → 所以 $\lambda &#x3D; 3$ 对应 <strong>一个大小为2的Jordan块</strong></p><p><strong>✅ Step 3. 确定 Jordan 标准型结构</strong></p><p>我们现在知道：</p><ul><li>特征值 $5$ 有一个大小为 $3$ 的Jordan块</li><li>特征值 $3$ 有一个大小为 $2$ 的Jordan块</li></ul><p><strong>✅ Step 4. 写出Jordan标准型</strong></p><p>Jordan标准型是对角块状矩阵：</p><p>$$<br>J &#x3D; \begin{bmatrix}<br>J_1(5) &amp; &amp; \\<br>&amp; J_2(3) &amp;<br>\end{bmatrix}<br>$$</p><p>其中：</p><ul><li>$J_1(5)$ 是大小为 $3$ 的 Jordan 块：</li></ul><p>$$<br>\begin{bmatrix}<br>5 &amp; 1 &amp; 0 \\<br>0 &amp; 5 &amp; 1 \\<br>0 &amp; 0 &amp; 5<br>\end{bmatrix}<br>$$</p><ul><li>$J_2(3)$ 是大小为 $2$ 的 Jordan 块：</li></ul><p>$$<br>\begin{bmatrix}<br>3 &amp; 1 \\<br>0 &amp; 3<br>\end{bmatrix}<br>$$</p><p>最终的 Jordan 标准型为：</p><p>$$<br>J &#x3D; \begin{bmatrix}<br>5 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; 5 &amp; 1 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 5 &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 3 &amp; 1 \\<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; 3<br>\end{bmatrix}<br>$$</p><h2 id="18-实对称矩阵（Real-Symmetric-Matrix）"><a href="#18-实对称矩阵（Real-Symmetric-Matrix）" class="headerlink" title="18. 实对称矩阵（Real Symmetric Matrix）"></a>18. 实对称矩阵（Real Symmetric Matrix）</h2><p>一个实矩阵 $A \in \mathbb{R}^{n \times n}$ 称为<strong>实对称矩阵</strong>，如果它等于它的转置：</p><p>$$<br>A^\top &#x3D; A<br>$$</p><p>也就是说，$A$ 满足：</p><p>$$<br>a_{ij} &#x3D; a_{ji},\quad \forall i, j<br>$$</p><p>实对称矩阵最重要的定理是：</p><blockquote><p><strong>实对称矩阵总可以正交对角化。</strong></p></blockquote><p><strong>更形式化地说</strong>：</p><p>若 $A$ 是 $n \times n$ 的实对称矩阵，则存在一个 <strong>正交矩阵</strong> $Q$（即 $Q^\top Q &#x3D; I$），使得：</p><p>$$<br>Q^\top A Q &#x3D; \Lambda<br>$$</p><p>其中 $\Lambda$ 是一个对角矩阵，其对角线上的元素为 $A$ 的实特征值。</p><p>这称为 <strong>谱定理（Spectral Theorem）</strong>。</p><p>设：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>2 &amp; -1 \\<br>-1 &amp; 2<br>\end{bmatrix}<br>$$</p><p>这是一个<strong>实对称矩阵</strong>。我们来对角化它：</p><p>解 $\det(A - \lambda I) &#x3D; 0$：</p><p>$$<br>\begin{vmatrix}<br>2 - \lambda &amp; -1 \\<br>-1 &amp; 2 - \lambda<br>\end{vmatrix}<br>&#x3D; (2 - \lambda)^2 - 1 &#x3D; \lambda^2 - 4\lambda + 3 &#x3D; 0<br>$$</p><p>解得：</p><p>$$<br>\lambda_1 &#x3D; 1,\quad \lambda_2 &#x3D; 3<br>$$</p><ul><li>对 $\lambda &#x3D; 1$：</li></ul><p>$$<br>A - I &#x3D; \begin{bmatrix}<br>1 &amp; -1 \\<br>-1 &amp; 1<br>\end{bmatrix} \Rightarrow x_1 &#x3D; x_2<br>$$</p><p>特征向量：$\boldsymbol{v}_1 &#x3D; \begin{bmatrix} 1 \ 1 \end{bmatrix}$</p><p>单位化得：$\boldsymbol{u}_1 &#x3D; \dfrac{1}{\sqrt{2}} \begin{bmatrix} 1 \ 1 \end{bmatrix}$</p><ul><li>对 $\lambda &#x3D; 3$：</li></ul><p>$$<br>A - 3I &#x3D; \begin{bmatrix}<br>-1 &amp; -1 \\<br>-1 &amp; -1<br>\end{bmatrix} \Rightarrow x_1 &#x3D; -x_2<br>$$</p><p>特征向量：$\boldsymbol{v}_2 &#x3D; \begin{bmatrix} 1 \ -1 \end{bmatrix}$</p><p>单位化得：$\boldsymbol{u}_2 &#x3D; \dfrac{1}{\sqrt{2}} \begin{bmatrix} 1 \ -1 \end{bmatrix}$</p><p>$$<br>Q &#x3D; \begin{bmatrix}<br>\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \<br>\frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}}<br>\end{bmatrix},\quad<br>\Lambda &#x3D; \begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 3<br>\end{bmatrix}<br>$$</p><p>验证：</p><p>$$<br>Q^\top A Q &#x3D; \Lambda<br>$$</p><h2 id="19-正定矩阵（Positive-Definite-Matrix）"><a href="#19-正定矩阵（Positive-Definite-Matrix）" class="headerlink" title="19. 正定矩阵（Positive Definite Matrix）"></a>19. 正定矩阵（Positive Definite Matrix）</h2><p>一个 $n \times n$ 的<strong>实对称矩阵</strong> $A$ 称为<strong>正定矩阵</strong>（positive definite），如果对任意非零列向量 $\boldsymbol{x} \in \mathbb{R}^n$，都有：</p><p>$$<br>\boldsymbol{x}^\top A \boldsymbol{x} &gt; 0<br>$$</p><p>设：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>2 &amp; 0 \\<br>0 &amp; 3<br>\end{bmatrix}<br>$$</p><p>则对任意非零向量 $\boldsymbol{x} &#x3D; \begin{bmatrix} x_1 \ x_2 \end{bmatrix}$，有：</p><p>$$<br>\boldsymbol{x}^\top A \boldsymbol{x} &#x3D; 2x_1^2 + 3x_2^2 &gt; 0<br>$$</p><p>→ 所以 $A$ 是正定矩阵。</p><p><strong>判断下列矩阵是否正定：</strong></p><p>$$<br>A &#x3D; \begin{bmatrix}<br>2 &amp; -1 \\<br>-1 &amp; 2<br>\end{bmatrix}<br>$$</p><p><strong>方法一：特征值法</strong></p><p>求特征值：</p><p>$$<br>\det\begin{bmatrix}<br>2 - \lambda &amp; -1 \\<br>-1 &amp; 2 - \lambda<br>\end{bmatrix}<br>&#x3D; \lambda^2 - 4\lambda + 3 &#x3D; 0 \Rightarrow \lambda &#x3D; 1, 3<br>$$</p><p>两个特征值都 &gt; 0 → 正定 ✅</p><p><strong>方法二：主子式法</strong></p><ul><li>一级主子式：$2 &gt; 0$</li><li>二级主子式：$\det(A) &#x3D; 2 \cdot 2 - (-1)^2 &#x3D; 3 &gt; 0$</li></ul><p>→ 所有主子式 &gt; 0 → 正定 ✅</p><h2 id="20-Rayleigh-商（Rayleigh-quotient）"><a href="#20-Rayleigh-商（Rayleigh-quotient）" class="headerlink" title="20. Rayleigh 商（Rayleigh quotient）"></a>20. Rayleigh 商（Rayleigh quotient）</h2><p>设 $A$ 是一个 <strong>实对称矩阵</strong>（或者复 Hermitian 矩阵），$x \in \mathbb{R}^n \setminus {0}$，则：</p><p>$$<br>R_A(x) &#x3D; \frac{x^\top A x}{x^\top x}<br>$$</p><p>这个值称为向量 $x$ 关于矩阵 $A$ 的 <strong>Rayleigh 商</strong>（Rayleigh quotient）。</p><ol><li><p>如果 $x$ 是 $A$ 的单位特征向量，则 $R_A(x)$ 就等于对应的特征值：</p><p>$$<br>A x &#x3D; \lambda x \Rightarrow R_A(x) &#x3D; \lambda<br>$$</p></li><li><p>Rayleigh 商是一个关于 $x$ 的函数，其值在某种意义上“逼近”矩阵 $A$ 的特征值。</p></li></ol><hr><h3 id="20-1-🔷-Rayleigh-商与特征值的不等式（极值性质）"><a href="#20-1-🔷-Rayleigh-商与特征值的不等式（极值性质）" class="headerlink" title="20.1 🔷 Rayleigh 商与特征值的不等式（极值性质）"></a>20.1 🔷 Rayleigh 商与特征值的不等式（极值性质）</h3><p>设 $A$ 是 $n \times n$ 的实对称矩阵，其特征值满足：</p><p>$$<br>\lambda_1 \leq \lambda_2 \leq \cdots \leq \lambda_n<br>$$</p><p>则对任意非零向量 $x$，Rayleigh 商满足如下不等式：</p><p>$$<br>\lambda_1 \leq R_A(x) \leq \lambda_n<br>$$</p><p>也就是说，Rayleigh 商的取值总在 $A$ 的最小与最大特征值之间。</p><h3 id="20-2-🌟-Rayleigh-商的极小极大值定理（Courant-Fischer-定理）"><a href="#20-2-🌟-Rayleigh-商的极小极大值定理（Courant-Fischer-定理）" class="headerlink" title="20.2 🌟 Rayleigh 商的极小极大值定理（Courant-Fischer 定理）"></a>20.2 🌟 Rayleigh 商的极小极大值定理（Courant-Fischer 定理）</h3><p>设 $A$ 是实对称矩阵，其特征值记为 $\lambda_1 \leq \lambda_2 \leq \cdots \leq \lambda_n$，则：</p><p>$$<br>\lambda_k &#x3D; \min_{\dim(V)&#x3D;k} \max_{x \in V,, x \neq 0} R_A(x)<br>$$</p><p>也就是说，$A$ 的第 $k$ 小特征值是所有 $k$ 维子空间中 Rayleigh 商最大值的最小值。</p><p><strong>✅ 举个简单例子</strong></p><p>设：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>2 &amp; 1 \\<br>1 &amp; 3<br>\end{bmatrix},\quad x &#x3D; \begin{bmatrix} 1 \\ 1 \end{bmatrix}<br>$$</p><p>$$<br>R_A(x) &#x3D; \frac{7}{2} &#x3D; 3.5<br>$$</p><p>而 $A$ 的特征值是 $\lambda_1 &#x3D; \frac{5 - \sqrt{5}}{2} \approx 1.38$，$\lambda_2 &#x3D; \frac{5 + \sqrt{5}}{2} \approx 3.62$，所以 Rayleigh 商确实落在特征值之间。</p><h2 id="21-SVD-分解（Singular-Value-Decomposition）"><a href="#21-SVD-分解（Singular-Value-Decomposition）" class="headerlink" title="21. SVD 分解（Singular Value Decomposition）"></a>21. SVD 分解（Singular Value Decomposition）</h2><p>对任意一个实矩阵 $A\in\mathbb{R}^{m\times n}$，存在三矩阵分解：</p><p>$$<br>A &#x3D; U ,\Sigma, V^\top<br>$$</p><ul><li><p>$U\in\mathbb{R}^{m\times m}$ 为正交矩阵，列向量称为 <strong>左奇异向量</strong>。</p></li><li><p>$V\in\mathbb{R}^{n\times n}$ 为正交矩阵，列向量称为 <strong>右奇异向量</strong>。</p></li><li><p>$\Sigma\in\mathbb{R}^{m\times n}$ 为“对角”矩阵：</p><p>$$<br>\Sigma &#x3D; \begin{bmatrix}<br>\sigma_1 &amp; &amp; &amp; &amp; \\<br> &amp; \sigma_2 &amp; &amp; &amp; \\<br> &amp; &amp; \ddots &amp; &amp; \\<br> &amp; &amp; &amp; \sigma_r &amp; \\<br> &amp; &amp; &amp; &amp; \mathbf{0}<br>\end{bmatrix},\quad \sigma_1 \ge \sigma_2 \ge \dots \ge \sigma_r &gt; 0<br>$$</p><p>其中 $r&#x3D;\operatorname{rank}(A)$，${\sigma_i}$ 称为 <strong>奇异值</strong>。</p></li></ul><h3 id="21-1-SVD-存在性"><a href="#21-1-SVD-存在性" class="headerlink" title="21.1 SVD 存在性"></a>21.1 SVD 存在性</h3><ul><li><p>对任意矩阵 $A$，总存在 SVD。</p></li><li><p>基于对称正定矩阵 $A^\top A$（或 $AA^\top$）的谱分解：</p><p>$$<br>A^\top A &#x3D; V,\Lambda,V^\top,\quad \Lambda &#x3D; \operatorname{diag}(\sigma_1^2,\dots,\sigma_n^2)<br>$$</p><p>取 $\sigma_i&#x3D;\sqrt{\lambda_i}$，再定义 $U$ 的列向量为</p><p>$$<br>u_i &#x3D; \frac{1}{\sigma_i} A,v_i,\quad i&#x3D;1,\dots,r<br>$$</p><p>剩余列向量可任意补全正交基。</p></li></ul><hr><h3 id="🧪-21-2-简单例题"><a href="#🧪-21-2-简单例题" class="headerlink" title="🧪 21.2 简单例题"></a>🧪 21.2 简单例题</h3><p>令</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>3 &amp; 1 \\<br>0 &amp; 2 \\<br>0 &amp; 0<br>\end{bmatrix}_{3\times2}<br>$$</p><ol><li>计算 $A^\top A &#x3D; \begin{bmatrix}9&amp;3\\3&amp;5\end{bmatrix}$，求特征值 $\lambda_1&#x3D;10,\ \lambda_2&#x3D;4$。</li><li>奇异值 $\sigma_1&#x3D;\sqrt{10},\ \sigma_2&#x3D;2$。</li><li>对应单位特征向量 $v_1,v_2$ 构造 $V$，</li><li>计算 $u_i&#x3D;\tfrac1{\sigma_i}Av_i$ 构造 $U$。</li><li>最终得</li></ol><p>$$<br>A &#x3D; U\begin{bmatrix}\sqrt{10}&amp;0\\0&amp;2\\0&amp;0\end{bmatrix}V^\top.<br>$$</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">SVD: A &#x3D; U Σ Vᵀ├── U: m×m 正交，左奇异向量├── Σ: m×n，奇异值对角├── V: n×n 正交，右奇异向量├── 存在性: 基于 AᵀA 特征分解├── 性质│   ├── σ_i ≥ 0│   ├── ‖A‖₂ &#x3D; σ₁│   ├── ‖A‖_F² &#x3D; Σσ_i²│   └── 最优低秩逼近└── 应用: PCA, 压缩, 伪逆, 推荐系统…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="22-维数定理（Rank–Nullity-Theorem）"><a href="#22-维数定理（Rank–Nullity-Theorem）" class="headerlink" title="22. 维数定理（Rank–Nullity Theorem）"></a>22. 维数定理（Rank–Nullity Theorem）</h2><p>设 $T: V \to W$ 是从有限维向量空间 $V$ 到 $W$ 的一个线性变换，或者说是一个 $m \times n$ 的矩阵 $A$ 表示 $T$，则有：</p><p>$$<br>\dim(\ker T) + \dim(\operatorname{Im} T) &#x3D; \dim V<br>$$</p><p>也可写作矩阵形式：</p><p>$$<br>\text{nullity}(A) + \text{rank}(A) &#x3D; n<br>$$</p><p>其中：</p><ul><li>$\ker T$ 是 $T$ 的核（null space）；</li><li>$\operatorname{Im} T$ 是 $T$ 的像空间（column space）；</li><li>$n$ 是 $A$ 的列数。</li></ul><h3 id="22-1-子空间维数公式（Grassmann’s-Formula）"><a href="#22-1-子空间维数公式（Grassmann’s-Formula）" class="headerlink" title="22.1 子空间维数公式（Grassmann’s Formula）"></a>22.1 子空间维数公式（Grassmann’s Formula）</h3><p>设 $U, W$ 是同一向量空间 $V$ 的两个子空间，则：</p><p>$$<br>\dim(U + W) &#x3D; \dim U + \dim W - \dim(U \cap W)<br>$$</p><p>这被称为<strong>Grassmann 定理</strong>，揭示了两个子空间的<strong>并与交之间的维数关系</strong>。</p><p><strong>✅ 推导简要：</strong></p><p>我们从 $U$ 中选出一个 $\dim(U \cap W)$ 的基，然后补出$U$ 的基，记为 $u_1, …, u_k$；<br>从 $W$ 中也补出剩下的基 $w_1, …, w_l$。</p><p>那么 $U + W$ 的一组生成元为：</p><p>$$<br>{u_1, …, u_k, u_{k+1}, …, u_m, w_{k+1}, …, w_n}<br>$$</p><p>他们是线性无关的，其个数为：</p><p>$$<br>\dim U + \dim W - \dim(U \cap W)<br>$$</p><p><strong>🧩 与矩阵运算结合的理解</strong></p><p>若 $A$ 是 $m \times n$ 的矩阵，$Ax &#x3D; b$ 可解 $\Leftrightarrow b \in \operatorname{Im}(A)$。</p><p>从维数定理得：</p><p>$$<br>\text{解空间的自由变量个数} &#x3D; n - \text{rank}(A)<br>$$</p><h2 id="23-Hermite矩阵（Hermitian-Matrix）"><a href="#23-Hermite矩阵（Hermitian-Matrix）" class="headerlink" title="23. Hermite矩阵（Hermitian Matrix）"></a>23. Hermite矩阵（Hermitian Matrix）</h2><p><strong>Hermite矩阵</strong>（也称为厄米矩阵）是指<strong>等于其自身共轭转置</strong>的方阵。</p><p>数学表达为：</p><p>$$<br>A &#x3D; A^*<br>$$</p><p>其中：</p><ul><li>$A$ 是一个复矩阵；</li><li>$A^*$ 表示 $A$ 的共轭转置（先取复共轭，再转置）。</li></ul><p>也就是说，对于所有 $i, j$，都有：</p><p>$$<br>a_{ij} &#x3D; \overline{a_{ji}}<br>$$</p><p>一个 $2 \times 2$ 的 Hermite 矩阵：</p><p>$$<br>A &#x3D; \begin{bmatrix}<br>2 &amp; 3+i \\<br>3-i &amp; 5<br>\end{bmatrix}<br>$$</p><p>验证是否是 Hermite 矩阵：</p><p>先取转置：</p><p>$$<br>A^T &#x3D; \begin{bmatrix}<br>2 &amp; 3-i \\<br>3+i &amp; 5<br>\end{bmatrix}<br>$$</p><p>然后取共轭（即共轭转置）：</p><p>$$<br>A^* &#x3D; \begin{bmatrix}<br>2 &amp; 3+i \\<br>3-i &amp; 5<br>\end{bmatrix} &#x3D; A<br>$$</p><p>所以它是 Hermite 矩阵。</p><hr><h3 id="23-1-Hermite矩阵的重要性质："><a href="#23-1-Hermite矩阵的重要性质：" class="headerlink" title="23.1 Hermite矩阵的重要性质："></a>23.1 Hermite矩阵的重要性质：</h3><ol><li><p><strong>所有特征值都是实数</strong><br>即使矩阵中含有复数，只要它是 Hermite 矩阵，其特征值一定是实数。</p></li><li><p><strong>不同特征值对应的特征向量正交</strong><br>如果 $\lambda_1 \neq \lambda_2$，则对应的特征向量 $\mathbf{v}_1$ 和 $\mathbf{v}_2$ 满足：</p><p>$$<br>\mathbf{v}_1^* \mathbf{v}_2 &#x3D; 0<br>$$</p></li><li><p><strong>可以酉对角化（unitarily diagonalizable）</strong><br>存在酉矩阵 $U$，使得：</p><p>$$<br>A &#x3D; U \Lambda U^*<br>$$</p><p>其中 $\Lambda$ 是实对角矩阵（包含所有实特征值）。</p></li><li><p><strong>主对角线上元素一定是实数</strong><br>因为对于 $i&#x3D;j$，有 $a_{ii} &#x3D; \overline{a_{ii}}$，说明 $a_{ii}$ 为实数。</p></li><li><p><strong>Hermite矩阵的所有特征向量可以构成一个标准正交基底（单位酉矩阵）</strong></p></li></ol><hr><p>实对称矩阵是 Hermite 矩阵的一种特殊情况，即：</p><p>$$<br>A &#x3D; A^T &#x3D; A^* \quad (\text{当 } A \text{ 是实矩阵时})<br>$$</p><p>所以<strong>实对称矩阵是 Hermite 矩阵的子集</strong>。</p><p>好的，我们来讲解线性代数中非常重要的一类矩阵：<strong>酉矩阵（Unitary Matrix）</strong>。</p><h2 id="24-酉矩阵（Unitary-Matrix）"><a href="#24-酉矩阵（Unitary-Matrix）" class="headerlink" title="24. 酉矩阵（Unitary Matrix）"></a>24. 酉矩阵（Unitary Matrix）</h2><p>在复数域 $\mathbb{C}$ 中，如果一个复方阵 $U$ 满足</p><p>$$<br>U^\dagger U &#x3D; UU^\dagger &#x3D; I<br>$$</p><p>则称 $U$ 是一个<strong>酉矩阵</strong>，其中 $U^\dagger$ 表示 $U$ 的<strong>共轭转置矩阵</strong>（又叫埃尔米特共轭，Hermitian conjugate）：</p><p>$$<br>U^\dagger &#x3D; \overline{U}^T<br>$$</p><p>酉矩阵是复数域中对应于实数域中<strong>正交矩阵</strong>的推广。</p><ul><li>$\overline{U}$ 是 $U$ 的<strong>元素共轭矩阵</strong>，即对每个元素取复共轭。</li><li>$U^T$ 是 $U$ 的转置。</li><li>所以 $U^\dagger$ 是先取共轭再转置。</li></ul><hr><h3 id="🧠-24-1-几个例子"><a href="#🧠-24-1-几个例子" class="headerlink" title="🧠 24.1 几个例子"></a>🧠 24.1 几个例子</h3><h3 id="1-单位矩阵一定是酉矩阵："><a href="#1-单位矩阵一定是酉矩阵：" class="headerlink" title="1. 单位矩阵一定是酉矩阵："></a>1. 单位矩阵一定是酉矩阵：</h3><p>$$<br>U &#x3D; I_n \Rightarrow U^\dagger &#x3D; I_n, \quad U^\dagger U &#x3D; I_n<br>$$</p><hr><h3 id="2-复旋转矩阵："><a href="#2-复旋转矩阵：" class="headerlink" title="2. 复旋转矩阵："></a>2. 复旋转矩阵：</h3><p>考虑二维复旋转矩阵：</p><p>$$<br>U &#x3D; \begin{bmatrix}<br>\cos\theta &amp; \sin\theta \\<br>-\sin\theta &amp; \cos\theta<br>\end{bmatrix}<br>$$</p><p>当 $\theta$ 为实数，这个是正交矩阵；若 $\cos\theta$ 和 $\sin\theta$ 是复数单位模数，这将成为酉矩阵。</p><hr><h3 id="3-酉矩阵的性质"><a href="#3-酉矩阵的性质" class="headerlink" title="3. 酉矩阵的性质"></a>3. 酉矩阵的性质</h3><ol><li><p><strong>保持内积</strong>：</p><p>$$<br>\langle Ux, Uy \rangle &#x3D; \langle x, y \rangle<br>$$</p><p>酉变换不改变向量之间的夹角和长度（模）。</p></li><li><p><strong>酉矩阵的逆是其共轭转置</strong>：</p><p>$$<br>U^{-1} &#x3D; U^\dagger<br>$$</p></li><li><p><strong>特征值模长为 1</strong>：<br>若 $\lambda$ 是 $U$ 的特征值，则 $|\lambda| &#x3D; 1$</p></li><li><p><strong>酉矩阵构成一个群</strong>：<br>酉矩阵在乘法下构成群（封闭性、单位元、逆元存在、结合性）。</p></li><li><p><strong>酉矩阵是“正交矩阵”的复数推广</strong>：<br>所有正交矩阵（实系数、$Q^T Q &#x3D; I$）都是酉矩阵的一种特殊情况。</p></li></ol><h2 id="25-二维旋转矩阵的定义"><a href="#25-二维旋转矩阵的定义" class="headerlink" title="25. 二维旋转矩阵的定义"></a>25. 二维旋转矩阵的定义</h2><p>设有一个二维平面上的向量 $\begin{bmatrix} x \ y \end{bmatrix}$，我们希望将它绕原点旋转一个角度 $\theta$（逆时针方向为正方向），旋转后的新向量 $\begin{bmatrix} x’ \ y’ \end{bmatrix}$ </p><p>这个 $2 \times 2$ 的矩阵就叫做 <strong>二维旋转矩阵</strong>，记作 $R(\theta)$：</p><p>$$<br>R(\theta) &#x3D;<br>\begin{bmatrix}<br>\cos \theta &amp; -\sin \theta \\<br>\sin \theta &amp; \cos \theta<br>\end{bmatrix}<br>$$</p><ol><li><p><strong>正交性（orthogonality）</strong></p><p>$$<br>R(\theta)^T R(\theta) &#x3D; I<br>$$</p><p>说明旋转矩阵是一个正交矩阵。</p></li><li><p><strong>行列式为1</strong></p><p>$$<br>\det(R(\theta)) &#x3D; \cos^2\theta + \sin^2\theta &#x3D; 1<br>$$</p></li><li><p><strong>可逆性</strong></p><p>$$<br>R(\theta)^{-1} &#x3D; R(-\theta)<br>$$</p></li><li><p><strong>保持向量长度</strong></p><p>$$<br>| R(\theta) \mathbf{v} | &#x3D; | \mathbf{v} |<br>$$</p><p>因此旋转变换不改变向量的模长。</p></li><li><p><strong>复数形式（便于与酉矩阵联系）</strong><br>旋转矩阵可以视为复数乘法中的一个例子：</p><p>$$<br>z &#x3D; x + iy \quad\Rightarrow\quad e^{i\theta} z &#x3D; \cos\theta z + i\sin\theta z<br>$$</p></li></ol><p>将点 $(1, 0)$ 逆时针旋转 $90^\circ$（即 $\theta &#x3D; \frac{\pi}{2}$）后变成了 $(0,1)$。</p><h2 id="26-常见的矩阵求导公式"><a href="#26-常见的矩阵求导公式" class="headerlink" title="26. 常见的矩阵求导公式"></a>26. 常见的矩阵求导公式</h2><ul><li>$x \in \mathbb{R}^{n \times 1}$：列向量</li><li>$A \in \mathbb{R}^{n \times n}$：矩阵</li><li>所有求导默认为对列向量 $x$ 求导，结果为列向量或矩阵</li><li>$\frac{\partial f}{\partial x}$ 表示 $f$ 对 $x$ 的导数</li></ul><p><strong>1.向量对向量的导数</strong></p><ul><li><p>$\frac{\partial (a^T x)}{\partial x} &#x3D; a$</p><blockquote><p>标量，$a$ 是常向量</p></blockquote></li><li><p>$\frac{\partial (x^T a)}{\partial x} &#x3D; a$</p><blockquote><p>同上，注意 $x^T a &#x3D; a^T x$</p></blockquote></li></ul><p><strong>2.二次型（最常用）</strong></p><ul><li><p>$\frac{\partial (x^T A x)}{\partial x} &#x3D; (A + A^T) x$</p><blockquote><p>若 $A$ 对称，则简化为 $2A x$</p></blockquote></li><li><p>$\frac{\partial (x^T x)}{\partial x} &#x3D; 2x$</p><blockquote><p>即 $A &#x3D; I$ 的特例</p></blockquote></li></ul><p><strong>3.向量-矩阵乘积</strong></p><ul><li><p>$\frac{\partial (A x)}{\partial x} &#x3D; A$</p><blockquote><p>$Ax$ 是一个向量，对 $x$ 求导为矩阵 $A$</p></blockquote></li><li><p>$\frac{\partial (x^T A)}{\partial x} &#x3D; A^T$</p><blockquote><p>$x^T A$ 是行向量，对 $x$ 的导数是 $A^T$</p></blockquote></li></ul><p><strong>4.Frobenius 范数相关</strong></p><ul><li><p>$\frac{\partial |A|_F^2}{\partial A} &#x3D; 2A$</p></li><li><p>$\frac{\partial |Ax - b|_2^2}{\partial x} &#x3D; 2A^T (Ax - b)$</p><blockquote><p>最常用于线性回归</p></blockquote></li></ul><p><strong>5.矩阵迹相关</strong></p><ul><li><p>$\frac{\partial \text{Tr}(A^T x)}{\partial x} &#x3D; A$</p></li><li><p>$\frac{\partial \text{Tr}(x^T A x)}{\partial x} &#x3D; (A + A^T) x$</p><blockquote><p>等价于 $x^T A x$ 的求导（注意 $x$ 是列向量）</p></blockquote></li></ul><p><strong>6.常见复合函数</strong></p><ul><li><p>$f(x) &#x3D; \log(\sigma(x))$, $\sigma(x) &#x3D; \frac{1}{1+e^{-x}}$</p><blockquote><p>$\frac{df}{dx} &#x3D; \sigma(x)(1 - \sigma(x))$</p></blockquote></li><li><p>$f(x) &#x3D; |Ax - b|_2^2 + \lambda |x|_2^2$</p><blockquote><p>$\frac{df}{dx} &#x3D; 2A^T (Ax - b) + 2\lambda x$</p></blockquote></li></ul><p>✳️ 延伸：矩阵对矩阵求导（高级）</p><ul><li>$\frac{\partial \text{Tr}(AB)}{\partial A} &#x3D; B^T$</li><li>$\frac{\partial \text{Tr}(A^T A)}{\partial A} &#x3D; 2A$</li><li>$\frac{\partial \text{Tr}(A X B)}{\partial X} &#x3D; A^T B^T$</li></ul><h2 id="偷偷说"><a href="#偷偷说" class="headerlink" title="偷偷说"></a>偷偷说</h2><p>线性代数的修考侧重点主要还是各种性质的推导，因此在熟悉每一个概念的时候，对于原理的理解是非常重要的:).<br>PS: 调整这些公式的格式真的太考验我耐心了…</p>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Linear Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Top Interview 150</title>
    <link href="/2025/02/06/Leetcode-Hot-150/"/>
    <url>/2025/02/06/Leetcode-Hot-150/</url>
    
    <content type="html"><![CDATA[<p>Source: <a href="https://leetcode.com/studyplan/top-interview-150/">Top Interview 150</a></p><h2 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88. Merge Sorted Array"></a><a href="https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">88. Merge Sorted Array</a></h2><p>画蛇添足的做法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> que<span class="token punctuation">;</span>    <span class="token comment">// 使用一个最小堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums1<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 清空nums1中的元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 逐个弹出最小堆中的元素</span>            nums1<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>暴力直接但能A过的做法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">+</span> n <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最希望看到的做法：#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 指向：排序后放入的位置</span>        <span class="token keyword">int</span> idx1 <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 指向：待排序的nums1的元素</span>        <span class="token keyword">int</span> idx2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 指向：待排序的nums2的元素</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>idx1 <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> idx2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 存在比较的情况</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span> <span class="token operator">></span> nums1<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span><span class="token punctuation">;</span>                idx2<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                                    nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">;</span>                idx1<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 剩下没放完nums2的情况</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>idx2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums1<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span><span class="token punctuation">;</span>            idx2<span class="token operator">--</span><span class="token punctuation">;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化过更好的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// nums1中还有元素能“挪动”的情况</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> nums1<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// nums1中没有元素能“挪动”的情况，因此不断放入nums2的元素</span>            <span class="token keyword">else</span> nums1<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150">27. Remove Element</a></h2><p>方法：#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 指向：不被移除的元素</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* i用来遍历一遍数组 */</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">26. Remove Duplicates from Sorted Array</a></h2><p>方法：#Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 指向需要放入的元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">++</span>k<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80. Remove Duplicates from Sorted Array II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150">80. Remove Duplicates from Sorted Array II</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 指向放入的位置</span>        <span class="token keyword">int</span> duplicates_count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 记录重复元素个数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 元素相同的情况</span>                duplicates_count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>duplicates_count <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 重复个数超过2，跳过</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 不超过2，则放入指定位置</span>                    nums<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 不相同的情况，放入指定位置，重制重复元素个数</span>                duplicates_count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span><span class="token operator">++</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更简洁的代码:</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// 指向应该放入的位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 直接与前面第二个元素进行比较</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a><a href="https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150">169. Majority Element</a></h2><p>Solution: #Math</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Map</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>second <span class="token operator">></span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> it<span class="token punctuation">.</span>first<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Boyer-Moore 多数投票算法</p><ol><li>初始化：</li></ol><ul><li><code>candidate</code>：候选元素，初始为 0。</li><li><code>count</code>：计数器，初始为 0。</li></ul><ol start="2"><li>遍历数组：</li></ol><ul><li>如果 <code>count == 0</code>，则将当前元素设为候选元素 <code>candidate</code>。</li><li>如果当前元素等于 <code>candidate</code>，则 <code>count</code> 增加 1。</li><li>如果当前元素不等于 <code>candidate</code>，则 count 减少 1。</li></ul><ol start="3"><li>返回结果：</li></ol><ul><li>遍历结束后，<code>candidate</code> 就是多数元素。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> candidate <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> candidate <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> candidate<span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> candidate<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a><a href="https://leetcode.com/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150">189. Rotate Array</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>  <span class="token comment">// 用来拷贝原数组 </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Math</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        k <span class="token operator">%=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> k<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><code>reverse</code>是<code>algorithm</code> 头文件中的一个标准函数,调用方式为:<code>reverse(起始迭代器, 结束迭代器);</code></p><h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150">121. Best Time to Buy and Sell Stock</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> gap <span class="token operator">=</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur_profit <span class="token operator">+</span> gap <span class="token operator">&lt;</span> gap<span class="token punctuation">)</span> cur_profit <span class="token operator">=</span> gap<span class="token punctuation">;</span>            <span class="token keyword">else</span> cur_profit <span class="token operator">+=</span> gap<span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> cur_profit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 0, -6, 4, -2, 3, -2</span><span class="token comment">// 0, -1, -2, -1, -2 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150">122. Best Time to Buy and Sell Stock II</a></h2><p>Solution: #DP<br>这里的DP数组含义<code>截止到i天，不持有/持有 股票时拥有的最大利润</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 第i天有股票的情况：i-1天无股票在i天买 or i-1天有股票在i天继续持有</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 第i天无股票的情况：i-1天无股票在i天不买 or i-1天有股票在i天卖</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 在n-1天没有股票是最好情况</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更加优化的方法：#Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 第i天贪心选择：卖 or 不卖 利润最大的情况</span>            profit <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>profit<span class="token punctuation">,</span> profit <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> profit<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a><a href="https://leetcode.com/problems/jump-game/?envType=study-plan-v2&envId=top-interview-150">55. Jump Game</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> edge <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 最大边界</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>edge <span class="token operator">&lt;</span> i<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 够不着下一个Index的情况</span>            <span class="token comment">/** 贪心维护最大边界 **/</span>            edge <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: 将上面的过程进行反推</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canJump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> goal <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/** 不断放缩可以达到边界的起点 **/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> goal<span class="token punctuation">)</span> goal <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> goal <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 判断最后放缩到的起点是否index = 0；</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a><a href="https://leetcode.com/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150">45. Jump Game II</a></h2><p>这道题真的蛮有意思的，之前手撕出来了，时隔一段时间又来做又A不出来了…还是贪心的思路，贪心的选择最大边界，不过要维护一个当前边界和跳跃次数</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 计数</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 当前边界</span>        <span class="token keyword">int</span> farthest <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 下一步可以达到的最远位置</span>        <span class="token keyword">int</span> goal <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 目标位置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            farthest <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>farthest<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 计算当前能跳到的最大位置</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 到达当前边界，必须增加跳跃次数</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>                end <span class="token operator">=</span> farthest<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>end <span class="token operator">>=</span> goal<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">jump</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur_end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 当前边界</span>        <span class="token keyword">int</span> next_end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 接下来的边界</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            next_end <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>next_end<span class="token punctuation">,</span> i <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 贪心选择接下来的边界</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> cur_end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 循环到当前边界，需要更新接下来的边界</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>                cur_end <span class="token operator">=</span> next_end<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274. H-Index"></a><a href="https://leetcode.com/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150">274. H-Index</a></h2><p>Solution: #Brute Force</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">hIndex</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> citations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> citations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> nominate <span class="token operator">=</span> citations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当前参照的元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nominate <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 跳过引用次数为0的元素</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 记录大于等于参照元素引用的个数</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> citations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>citations<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> nominate<span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cnt <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nominate<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 取最小值</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 取最大值</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">hIndex</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> citations<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 从小到大排列</span>        <span class="token function">sort</span><span class="token punctuation">(</span>citations<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> citations<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> citations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 遍历找h-index</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>citations<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="380-Insert-Delete-GetRandom-O-1"><a href="#380-Insert-Delete-GetRandom-O-1" class="headerlink" title="380. Insert Delete GetRandom O(1)"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150">380. Insert Delete GetRandom O(1)</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RandomizedSet</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>  <span class="token comment">// 元素 : 放入位置</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>       <span class="token comment">// 存放元素</span>    <span class="token function">RandomizedSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vec<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 已放入的情况</span>        vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 放入的index</span>        mp<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>   <span class="token comment">// 记录位置</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 没放入的情况</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> mp<span class="token punctuation">[</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 获取放入的位置</span>        <span class="token keyword">int</span> last_element <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取最后一个元素</span>        vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> last_element<span class="token punctuation">;</span>  <span class="token comment">// 覆盖要删除的元素</span>        vec<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mp<span class="token punctuation">[</span>last_element<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>  <span class="token comment">// 记录调整的元素位置</span>        mp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 消除记录的位置</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 随机获取下标</span>        <span class="token keyword">return</span> vec<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj->insert(val); * bool param_2 = obj->remove(val); * int param_3 = obj->getRandom(); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238. Product of Array Except Self"></a><a href="https://leetcode.com/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150">238. Product of Array Except Self</a></h2><p> Solution: #前缀数组和后缀数组<br> <figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pre_product</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 前缀积</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            start <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            pre_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">nxt_product</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 后缀积</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            end <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nxt_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> end<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ans</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pre_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nxt_product<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><br>优化后的代码如下:</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">productExceptSelf</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ans</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur <span class="token operator">*=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*=</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a><a href="https://leetcode.com/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150">134. Gas Station</a></h2><p>纯暴力爆超时的做法(33&#x2F;39)：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> gas<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> gas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">buff</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            buff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> candidates<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>buff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> candidates<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> candidates<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> idx<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> buff<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                sum <span class="token operator">+=</span> buff<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> idx<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Greedy</p><ul><li>遍历每个加油站：<ul><li>对于每个加油站，计算出从当前加油站到下一个加油站所需的油量：<code>curGas += (gas[i] - cost[i])</code>。</li><li>如果 <code>curGas</code> 变成了负值，意味着从当前加油站开始无法继续前进，因此将当前的起点更新为 <code>i + 1</code>，并且重置 <code>curGas</code> 为 0，尝试从下一个加油站作为起点重新开始。</li></ul></li></ul><p>这段代码的精妙之处在于：如果某一段的油量不足，前面的加油站不可能成为起点（因为从前一个加油站开始也不可能成功），所以可以跳过一段，直接从下一个加油站开始尝试。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> gas<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> cost<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> gasSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> costSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            gasSum <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            costSum <span class="token operator">+=</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>gasSum <span class="token operator">&lt;</span> costSum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curGas <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> gas<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            curGas <span class="token operator">+=</span> <span class="token punctuation">(</span>gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*如果累加起来的gas总量小于0，那么这一段都不能作为起点*/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curGas <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                  curGas <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 重新从当前点出发</span>                start <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 这里非常有数学意味</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> start<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode.com/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150">135. Candy</a></h2><p>Solution: #Greedy，从左到右遍历局部最优，从右到左局部最优</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">candy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ratings<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ratings<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">allo</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 每个元素的糖果分配情况</span>        allo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 从左到右分配</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> allo<span class="token punctuation">[</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 从右到左分配</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ratings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ratings<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> allo<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> allo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> allo<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> allo<span class="token punctuation">)</span> sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a><a href="https://leetcode.com/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-interview-150">42. Trapping Rain Water</a></h2><p>Solution: #Monotonic Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>   <span class="token comment">// 递增单调递减,存放index</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> mid<span class="token punctuation">;</span>                    <span class="token keyword">int</span> w <span class="token operator">=</span> i <span class="token operator">-</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                    sum <span class="token operator">+=</span> h <span class="token operator">*</span> w<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左右指针初始化</span>        <span class="token keyword">int</span> left_max <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> right_max <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化左右最大高度</span>        <span class="token keyword">int</span> water <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用来累积水量</span>                <span class="token comment">// 双指针遍历，直到左右指针相遇</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 更新左右最大值</span>            left_max <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>left_max<span class="token punctuation">,</span> height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            right_max <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>right_max<span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 根据左右最大值的大小来决定移动哪一边的指针</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left_max <span class="token operator">&lt;</span> right_max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前位置的水量 = 左侧最大值 - 当前柱子高度</span>                water <span class="token operator">+=</span> left_max <span class="token operator">-</span> height<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 当前位置的水量 = 右侧最大值 - 当前柱子高度</span>                water <span class="token operator">+=</span> right_max <span class="token operator">-</span> height<span class="token punctuation">[</span>r<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> water<span class="token punctuation">;</span> <span class="token comment">// 返回总的水量</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a><a href="https://leetcode.com/problems/roman-to-integer/description/?envType=study-plan-v2&envId=top-interview-150">13. Roman to Integer</a></h2><p>Solution: 暴力的做法，直接打表</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token char">'I'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'V'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'X'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'L'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'D'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'M'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dmp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token string">"IV"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"IX"</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"XL"</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"XC"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"CD"</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token string">"CM"</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> c1 <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">char</span> c2 <span class="token operator">=</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            string tmp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dmp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> dmp<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">;</span>                i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                sum <span class="token operator">+=</span> mp<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化一下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>m<span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'I'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'V'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'X'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'L'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'C'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'D'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">;</span>      m<span class="token punctuation">[</span><span class="token char">'M'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              ans<span class="token operator">-=</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">else</span><span class="token punctuation">&#123;</span>              ans<span class="token operator">+=</span>m<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a><a href="https://leetcode.com/problems/integer-to-roman/description/?envType=study-plan-v2&envId=top-interview-150">12. Integer to Roman</a></h2><p>Solution: #Hash Map, #Math</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">intToRoman</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        string s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"M"</span><span class="token punctuation">,</span> <span class="token string">"CM"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"CD"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"XC"</span><span class="token punctuation">,</span> <span class="token string">"L"</span><span class="token punctuation">,</span> <span class="token string">"XL"</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"IX"</span><span class="token punctuation">,</span> <span class="token string">"V"</span><span class="token punctuation">,</span> <span class="token string">"IV"</span><span class="token punctuation">,</span> <span class="token string">"I"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">>=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                num <span class="token operator">-=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                ans <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a><a href="https://leetcode.com/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150">58. Length of Last Word</a></h2><p>Solution: #STL</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        istringstream <span class="token function">iss</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        string words<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> vec<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iss <span class="token operator">>></span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> vec<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: 移动尾指针</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/*定位到最后一个单词末尾*/</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/*计算最后一个单词长度*/</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            p<span class="token operator">--</span><span class="token punctuation">;</span>            cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Flag</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> counting <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 开始计数的标志</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                counting <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                length<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>counting<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 停止计数</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a><a href="https://leetcode.com/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150">14. Longest Common Prefix</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> end <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 比对结束的标志</span>        <span class="token comment">/*暴力枚举第一个字符串的所有前缀*/</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*对每个字符串进行暴力比对*/</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    end <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> ans <span class="token operator">+=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Sort, #Double Pointers</p><ul><li>如果这些两个字符串有共同前缀，那么整个数组中的所有字符串也会有相同的前缀。因此，只需要比较数组中最小和最大字符串的前缀即可。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strs<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string firstStr <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        string lastStr <span class="token operator">=</span> strs<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">min</span><span class="token punctuation">(</span>firstStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lastStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>firstStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> lastStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> firstStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150">151. Reverse Words in a String</a></h2><p>Solution: #STL</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string word<span class="token punctuation">;</span>        istringstream <span class="token function">iss</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> vec<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iss <span class="token operator">>></span> word<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 遍历完单词的情况</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ans<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> tmp <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> ans<span class="token punctuation">;</span> <span class="token comment">// 不是第一个单词的情况</span>                    <span class="token keyword">else</span> ans <span class="token operator">=</span> tmp<span class="token punctuation">;</span>   <span class="token comment">// 是第一个单词的情况</span>                    tmp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> tmp <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tmp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 还剩下最后一个单词</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ans<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> tmp <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> ans<span class="token punctuation">;</span>  <span class="token comment">// 不是第一个单词的情况</span>            <span class="token keyword">else</span> ans <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token comment">// 第一个单词的情况</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一步：整体反转字符串</span>        <span class="token keyword">bool</span> wordStart <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 标记是否正在处理一个单词</span>        <span class="token comment">// 使用 fast 指针遍历字符串</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>fast <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> fast <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fast<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 找到一个单词的开始</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>wordStart <span class="token operator">&amp;&amp;</span> slow <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span>  <span class="token comment">// 如果已经找到一个单词，且不是字符串开头，加空格分隔单词</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> start <span class="token operator">=</span> fast<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    s<span class="token punctuation">[</span>slow<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>fast<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 把当前单词复制到新的位置</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 反转单词：把已复制的单词部分反转回来</span>                <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> slow <span class="token operator">-</span> <span class="token punctuation">(</span>fast <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span>                wordStart <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 标记已经找到了一个单词</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 调整字符串的大小，去掉多余的部分</span>        s<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="6-Zigzag-Conversion"><a href="#6-Zigzag-Conversion" class="headerlink" title="6. Zigzag Conversion"></a><a href="https://leetcode.com/problems/zigzag-conversion/description/?envType=study-plan-v2&envId=top-interview-150">6. Zigzag Conversion</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>numRows <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> mp<span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> flop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 控制反转。初始化为false</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*到达边界的时候，则需要反转*/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> r <span class="token operator">==</span> numRows <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> flop <span class="token operator">=</span> <span class="token operator">!</span>flop<span class="token punctuation">;</span>            mp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flop<span class="token punctuation">)</span> r<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        string ans <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">convert</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ans<span class="token punctuation">;</span>          vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">temp</span><span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*模拟从上到下的遍历过程*/</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numRows <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/*模拟从下到上的过程*/</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> numRows <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="28-Find-the-Index-of-the-First-Occurrence-in-a-String"><a href="#28-Find-the-Index-of-the-First-Occurrence-in-a-String" class="headerlink" title="28. Find the Index of the First Occurrence in a String"></a><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150">28. Find the Index of the First Occurrence in a String</a></h2><p>Solution: <code>string</code>类成员函数</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> haystack<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>正规的做法：#Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">&lt;</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token keyword">else</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：枚举子串进行比较</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> needle<span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68. Text Justification"></a><a href="https://leetcode.com/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150">68. Text Justification</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">fullJustify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">,</span> <span class="token keyword">int</span> maxWidth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> result<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> currentLine<span class="token punctuation">;</span>  <span class="token comment">// 用来存储当前行的单词，直到该行的长度超过 maxWidth。</span>        <span class="token keyword">int</span> currentLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前行中所有单词的总长度（不包括空格）</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> word <span class="token operator">:</span> words<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/* 判断当前行加上当前单词是否会超出 maxWidth */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>currentLength <span class="token operator">+</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> maxWidth<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">/* 计算当前行需要的空格*/</span>                <span class="token keyword">int</span> spaces <span class="token operator">=</span> maxWidth <span class="token operator">-</span> currentLength<span class="token punctuation">;</span>                <span class="token comment">/* 如果当前行只有一个单词，直接左对齐，空格填充右侧 */</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>currentLine<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>spaces<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token comment">/* 均匀分配空格 */</span>                    <span class="token keyword">int</span> evenSpace <span class="token operator">=</span> spaces <span class="token operator">/</span> <span class="token punctuation">(</span>currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 每个空格应该有的基本数量</span>                    <span class="token keyword">int</span> extraSpace <span class="token operator">=</span> spaces <span class="token operator">%</span> <span class="token punctuation">(</span>currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 剩余空格数量</span>                    string line <span class="token operator">=</span> currentLine<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">/* 分配空格 */</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> extraSpace<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            line <span class="token operator">+=</span> <span class="token function">string</span><span class="token punctuation">(</span>evenSpace <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">+</span> currentLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                            line <span class="token operator">+=</span> <span class="token function">string</span><span class="token punctuation">(</span>evenSpace<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">+</span> currentLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">/* 清空当前行的单词和长度，准备下一行 */</span>                currentLine<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                currentLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 将当前单词加入到当前行 */</span>            currentLine<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            currentLength <span class="token operator">+=</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 处理最后一行，左对齐 */</span>        string lastLine <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            lastLine <span class="token operator">+=</span> currentLine<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> currentLine<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                lastLine <span class="token operator">+=</span> <span class="token string">" "</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        lastLine <span class="token operator">+=</span> <span class="token function">string</span><span class="token punctuation">(</span>maxWidth <span class="token operator">-</span> lastLine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lastLine<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a><a href="https://leetcode.com/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150">125. Valid Palindrome</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">converString</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 清楚标点和大小写转换</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token char">'A'</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token char">'A'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> gap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token char">'a'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'z'</span> <span class="token operator">||</span> <span class="token char">'0'</span> <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string ss <span class="token operator">=</span> <span class="token function">converString</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> ss<span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ss<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> tmp <span class="token operator">==</span> ss<span class="token punctuation">;</span>  <span class="token comment">// 反转后的字符串和反转前字符串比较</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：#Tow Pointers, 使用双指针和类成员函数优化后的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isalnum</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isalnum</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>l<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">tolower</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392. Is Subsequence"></a><a href="https://leetcode.com/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150">392. Is Subsequence</a></h2><p>Solution: #Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的双指针写法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>sptr <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tptr <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>sptr<span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>tptr<span class="token punctuation">]</span><span class="token punctuation">)</span> sptr<span class="token operator">++</span><span class="token punctuation">;</span>            tptr<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sptr <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：#DP，也可以强行用动态规划来做</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* dp数组：当前两个字符串的子串所匹配的最大长度 */</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> n<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/?envType=study-plan-v2&envId=top-interview-150">167. Two Sum II - Input Array Is Sorted</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/* 由小到大的index顺序 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>target <span class="token operator">-</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mp<span class="token punctuation">[</span>target <span class="token operator">-</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>target <span class="token operator">-</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 没找到匹配才建立映射，顺序不能在if执行之前*/</span>            mp<span class="token punctuation">[</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更精简的写法：#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a><a href="https://leetcode.com/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-interview-150">11. Container With Most Water</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> r <span class="token operator">-</span> l<span class="token punctuation">;</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> w <span class="token operator">*</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 优先移动高最小的边界 */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> height<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><a href="https://leetcode.com/problems/3sum/description/?envType=study-plan-v2&envId=top-interview-150">15. 3Sum</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/*对目标元素进行去重*/</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/*对左右指针去重*/</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>                    l<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>r <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>                    r<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150">209. Minimum Size Subarray Sum</a></h2><p>Solution: #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">/* 当前和大于target则移动窗口左边界 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>sum <span class="token operator">>=</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> subLength <span class="token operator">=</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> subLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150">3. Longest Substring Without Repeating Characters</a></h2><p>Solution: #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">/* 果字符已存在于集合中，移动左边界 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                start<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            length <span class="token operator">=</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30. Substring with Concatenation of All Words"></a><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&envId=top-interview-150">30. Substring with Concatenation of All Words</a></h2><p>Solution: #Brute Force, #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">checkSubstring</span><span class="token punctuation">(</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> wordCount<span class="token punctuation">,</span> string s<span class="token punctuation">,</span> <span class="token keyword">int</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> wordLen <span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 确保不会越界</span>            string w <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>wordCount<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">!=</span> wordCount<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>wordCount<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>                unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> wordCount<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> words<span class="token punctuation">)</span> wordCount<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> wordLen <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> subLen <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> wordLen<span class="token punctuation">;</span>                <span class="token comment">// 如果子串长度超过原字符串长度，直接返回空结果</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>subLen <span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> subLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">checkSubstring</span><span class="token punctuation">(</span>wordCount<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> subLen<span class="token punctuation">)</span><span class="token punctuation">,</span> wordLen<span class="token punctuation">)</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：#Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> words<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token keyword">int</span> wordLength <span class="token operator">=</span> words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> wordCount <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> totalLength <span class="token operator">=</span> wordLength <span class="token operator">*</span> wordCount<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>totalLength <span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token comment">// 统计words中每个单词出现的次数</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> wordFreq<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> word <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            wordFreq<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 对每个可能的起始位置进行处理（由于单词长度可能大于1，需要考虑不同的偏移）</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">&lt;</span> wordLength<span class="token punctuation">;</span> offset<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 对于每个偏移量，使用滑动窗口</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> offset<span class="token punctuation">;</span>            unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> currentFreq<span class="token punctuation">;</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 窗口内有效单词数量</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> right <span class="token operator">=</span> offset<span class="token punctuation">;</span> right <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> wordLength<span class="token punctuation">;</span> right <span class="token operator">+=</span> wordLength<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                string currentWord <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> wordLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">// 如果当前单词不在words中，重置窗口</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>wordFreq<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>currentWord<span class="token punctuation">)</span> <span class="token operator">==</span> wordFreq<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    currentFreq<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    left <span class="token operator">=</span> right <span class="token operator">+</span> wordLength<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                                <span class="token comment">// 增加当前单词的计数</span>                currentFreq<span class="token punctuation">[</span>currentWord<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                                <span class="token comment">// 如果当前单词出现次数过多，缩小窗口直到匹配</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>currentFreq<span class="token punctuation">[</span>currentWord<span class="token punctuation">]</span> <span class="token operator">></span> wordFreq<span class="token punctuation">[</span>currentWord<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    string leftWord <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> wordLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                    currentFreq<span class="token punctuation">[</span>leftWord<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    left <span class="token operator">+=</span> wordLength<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                                <span class="token comment">// 如果窗口大小正好等于所有单词的总数，找到一个匹配</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> wordCount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                                        <span class="token comment">// 移动窗口左边界，继续寻找下一个匹配</span>                    string leftWord <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> wordLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                    currentFreq<span class="token punctuation">[</span>leftWord<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    left <span class="token operator">+=</span> wordLength<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a><a href="https://leetcode.com/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-interview-150">76. Minimum Window Substring</a></h2><p>Solution: #Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">minWindow</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> charCount<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> t<span class="token punctuation">)</span> charCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 记录t中字符出现的次数</span>        <span class="token keyword">int</span> required <span class="token operator">=</span> charCount<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需要匹配的字符种类</span>        <span class="token keyword">int</span> formed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 已匹配成功的字符种类</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minLen <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// Start index of minimum window</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> windowCount<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>charCount<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> charCount<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> charCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                formed<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 成功匹配完一类字符</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 尝试缩小滑动窗口 */</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> formed <span class="token operator">==</span> required<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                c <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> minLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    minLen <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    start <span class="token operator">=</span> left<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>charCount<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> charCount<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> windowCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> charCount<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    formed<span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token comment">// 匹配次数减少，导致匹配字符类型数-1</span>                <span class="token punctuation">&#125;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> minLen <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token string">""</span> <span class="token operator">:</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> minLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a><a href="https://leetcode.com/problems/valid-sudoku/description/?envType=study-plan-v2&envId=top-interview-150">36. Valid Sudoku</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">/* 判断当前字符是否是1～9 */</span>    <span class="token keyword">bool</span> <span class="token function">isValidChar</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token char">'1'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 检查 3x3 的格子是否有重复数字 */</span>    <span class="token keyword">bool</span> <span class="token function">checkBox</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> y<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> y <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> c <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValidChar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> row<span class="token punctuation">;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> col<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 检查行</span>            row<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> c <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValidChar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>row<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> row<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    row<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 检查列</span>            col<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> c <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isValidChar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>col<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> col<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    col<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 检查3x3的小格子</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">checkBox</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table, 更加优化的方法，只用遍历一次数组，采用打表记录的方式</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValidSudoku</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 使用3个9x9的布尔数组，分别记录行、列和方格中数字的出现情况</span>        <span class="token keyword">bool</span> row<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// row[i][j]表示第i行是否出现数字j+1</span>        <span class="token keyword">bool</span> col<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// col[i][j]表示第i列是否出现数字j+1</span>        <span class="token keyword">bool</span> box<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// box[i][j]表示第i个方格是否出现数字j+1</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'.'</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                                <span class="token keyword">int</span> num <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'1'</span><span class="token punctuation">;</span>  <span class="token comment">// 将字符转为0-8的索引</span>                <span class="token keyword">int</span> box_index <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> j <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// 计算当前位置属于哪个3x3方格</span>                                <span class="token comment">// 检查当前数字在行、列、方格中是否已经出现过</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">||</span> col<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">||</span> box<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                                <span class="token comment">// 标记数字已出现</span>                row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                col<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                box<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a><a href="https://leetcode.com/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150">54. Spiral Matrix</a></h2><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 设置边界</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>             <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 从右到左（需要检查top &lt;= bottom）</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span> j <span class="token operator">>=</span> left<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                bottom<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 从下到上（需要检查left &lt;= right）</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">>=</span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// line</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// column</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bottom <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> top <span class="token operator">&lt;=</span> bottom<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> left<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> bottom<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">&lt;</span> bottom <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> right <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">></span> left<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>bottom<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> bottom<span class="token punctuation">;</span> i <span class="token operator">></span> top<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            bottom<span class="token operator">--</span><span class="token punctuation">;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a><a href="https://leetcode.com/problems/rotate-image/description/?envType=study-plan-v2&envId=top-interview-150">48. Rotate Image</a></h2><p>Solution: #Queue，开一个队列把所有数装进来…</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方案，不用开辟新的空间。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 先转置</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 再反转</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">reverse</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a><a href="https://leetcode.com/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-interview-150">73. Set Matrix Zeroes</a></h2><p>Solution: #Brute Force</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setZeroes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> row<span class="token punctuation">;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> col<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    row<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                    col<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> row<span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> j <span class="token operator">:</span> col<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">setZeroes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> firstRowZero <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span> firstColZero <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">// 记录第一列是否有0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> firstColZero <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 记录第一行是否有0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> firstRowZero <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 遍历整个矩阵，用第一行和第一列记录 0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>firstRowZero<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>firstColZero<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="289-Game-of-Life"><a href="#289-Game-of-Life" class="headerlink" title="289. Game of Life"></a><a href="https://leetcode.com/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150">289. Game of Life</a></h2><p>Solution: #Brute Force，对每一个点逐一检查</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">Alive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> bottom <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> bottom <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> x <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> curAlive <span class="token operator">=</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>curAlive <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>curAlive <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>curAlive <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>curAlive <span class="token operator">&amp;&amp;</span> cnt <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> tmp <span class="token operator">=</span> board<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Alive</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        board <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：</p><ul><li><code>-1</code> 表示 活细胞变死（即原本是 <code>1</code>，但根据规则变成<code>0</code>）</li><li><code>2</code> 表示 死细胞变活（即原本是 <code>0</code>，但根据规则变成<code>1</code>）。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">gameOfLife</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> directions <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 方向数组，表示相邻八个方向的移动</span>        <span class="token comment">// 遍历计算每个细胞的状态</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> liveNeighbors <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dx <span class="token operator">:</span> directions<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> dy <span class="token operator">:</span> directions<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>dx <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 跳过自身</span>                        <span class="token keyword">int</span> ni <span class="token operator">=</span> i <span class="token operator">+</span> dx<span class="token punctuation">,</span> nj <span class="token operator">=</span> j <span class="token operator">+</span> dy<span class="token punctuation">;</span>                        <span class="token comment">// 原地修改，注意找活细胞要用绝对值</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>ni <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ni <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> nj <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nj <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> <span class="token function">abs</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>ni<span class="token punctuation">]</span><span class="token punctuation">[</span>nj<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            liveNeighbors<span class="token operator">++</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>liveNeighbors <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> liveNeighbors <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 1 -> 0</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> liveNeighbors <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 0 -> 1</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.com/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150">383. Ransom Note</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span>string ransomNote<span class="token punctuation">,</span> string magazine<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>  <span class="token comment">// 统计magazine中字符出现次数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> magazine<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> ransomNote<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 字符不存在</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 字符不够用</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205. Isomorphic Strings"></a><a href="https://leetcode.com/problems/isomorphic-strings/description/?envType=study-plan-v2&envId=top-interview-150">205. Isomorphic Strings</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isIsomorphic</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">!=</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>              <span class="token comment">// 记录已经被map的字符</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 如果有记录</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      <span class="token comment">// 没有记录的情况</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    mp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化过的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isIsomorphic</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> sc <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">char</span> tc <span class="token operator">=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>sc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">// 映射不正确</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">!=</span> tc<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> pair <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 检查是否映射冲突</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>pair<span class="token punctuation">.</span>second <span class="token operator">==</span> tc<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                mp<span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">=</span> tc<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="290. Word Pattern"></a><a href="https://leetcode.com/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150">290. Word Pattern</a></h2><p>Solution:# Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">wordPattern</span><span class="token punctuation">(</span>string pattern<span class="token punctuation">,</span> string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> string<span class="token operator">></span> mp<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> words<span class="token punctuation">;</span>        string tmp<span class="token punctuation">;</span>        istringstream <span class="token function">iss</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>iss <span class="token operator">>></span> tmp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            words<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pattern<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>   <span class="token comment">// 比对数量不对等</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> pc <span class="token operator">=</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>pc<span class="token punctuation">]</span> <span class="token operator">!=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>pair str <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 检查是否有冲突映射</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>second <span class="token operator">==</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                mp<span class="token punctuation">[</span>pc<span class="token punctuation">]</span> <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.com/problems/valid-anagram/description/?envType=study-plan-v2&envId=top-interview-150">242. Valid Anagram</a></h2><p>Solution: #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s <span class="token operator">==</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">int</span> kinds <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 记录字符种类</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                kinds<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> kinds<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 匹配完一种字符</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> kinds <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table，优化后的映射</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> string t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            count<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            count<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> num <span class="token operator">:</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a><a href="https://leetcode.com/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-interview-150">49. Group Anagrams</a></h2><p>Solution: #Hash Table, #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ump<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string tmp <span class="token operator">=</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// sort调整顺序</span>            ump<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> ump<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vector<span class="token operator">&lt;</span>string<span class="token operator">></span> vec<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> idx <span class="token operator">:</span> it<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> s <span class="token operator">:</span> strs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string t <span class="token operator">=</span> s<span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mp<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>手搓哈希映射的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> s <span class="token operator">:</span> strs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token operator">></span> count <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                count<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            string key<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                key <span class="token operator">+=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"#"</span><span class="token punctuation">;</span>  <span class="token comment">// 避免哈希冲突</span>            <span class="token punctuation">&#125;</span>            ans<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> result<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> entry <span class="token operator">:</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/description/?envType=study-plan-v2&envId=top-interview-150">1. Two Sum</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>   <span class="token comment">// value : index</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>mp<span class="token punctuation">[</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> v<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 记录初始位置</span>        <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 双指针初始化</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">+</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">,</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">+</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">></span> target<span class="token punctuation">)</span> j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.com/problems/happy-number/description/?envType=study-plan-v2&envId=top-interview-150">202. Happy Number</a></h2><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 计算每个digit的平方和</span>        string tmp <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tmp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>   <span class="token comment">// 检查是否有loop出现</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                n <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法，使用快慢指针。#Tow Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 更优质的计算</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> slow <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> fast <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">do</span><span class="token punctuation">&#123;</span>                    <span class="token comment">// 快慢指针</span>            slow <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">;</span>            fast <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token function">calc</span><span class="token punctuation">(</span>fast<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>slow <span class="token operator">!=</span> fast<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="219-Contains-Duplicate-II"><a href="#219-Contains-Duplicate-II" class="headerlink" title="219. Contains Duplicate II"></a><a href="https://leetcode.com/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150">219. Contains Duplicate II</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">containsNearbyDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>   <span class="token comment">// value : 最近一次出现的index</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化的解法#Sliding Window</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">containsNearbyDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> window<span class="token punctuation">;</span>   <span class="token comment">// 维护滑动窗口内的元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            window<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> window<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 维护窗口大小</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-interview-150">128. Longest Consecutive Sequence</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 去重</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token operator">*</span>st<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 取第一个元素</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> right <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 向左寻找连续序列</span>                st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                left<span class="token operator">--</span><span class="token punctuation">;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 向右寻找连续序列</span>                st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            result <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">st</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用 HashSet 存储去重后的元素</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">:</span> st<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 没有向左连续的情况，那么直接向右找连续元素</span>                <span class="token keyword">int</span> currNum <span class="token operator">=</span> x<span class="token punctuation">;</span>                <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>currNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    currNum<span class="token operator">++</span><span class="token punctuation">;</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                result <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228. Summary Ranges"></a><a href="https://leetcode.com/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150">228. Summary Ranges</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">summaryRanges</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> ans<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 找出连续区间的结束位置</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"->"</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a href="https://leetcode.com/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-interview-150">56. Merge Intervals</a></h2><p>Solution: #Greedy, #Sort</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 不合并区间</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 合并区间的情况</span>                ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以稍微优化一下</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 使用lambda表达式简化排序</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 只需按起始点排序即可</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>                result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 检查是否可以合并</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 合并区间</span>                result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 添加新区间</span>                result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a><a href="https://leetcode.com/problems/insert-interval/description/?envType=study-plan-v2&envId=top-interview-150">57. Insert Interval</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">insert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> newInterval<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        intervals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> end <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：#Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">insert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> newInterval<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/?envType=study-plan-v2&envId=top-interview-150">452. Minimum Number of Arrows to Burst Balloons</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findMinArrowShots</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>points<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> points<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> end <span class="token operator">=</span> points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                end <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                end <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>end<span class="token punctuation">,</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-interview-150">20. Valid Parentheses</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'['</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'&#123;'</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'&#125;'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'&#123;'</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">']'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'['</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span> mp <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token char">'('</span><span class="token punctuation">,</span> <span class="token char">')'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token char">'&#123;'</span><span class="token punctuation">,</span> <span class="token char">'&#125;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token char">'['</span><span class="token punctuation">,</span> <span class="token char">']'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> mp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mp<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="71-Simplify-Path"><a href="#71-Simplify-Path" class="headerlink" title="71. Simplify Path"></a><a href="https://leetcode.com/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150">71. Simplify Path</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">simplifyPath</span><span class="token punctuation">(</span>string path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span>string<span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            string word<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                word <span class="token operator">+=</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        string ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans <span class="token operator">=</span> <span class="token string">"/"</span> <span class="token operator">+</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> ans<span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">simplifyPath</span><span class="token punctuation">(</span>string path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 跳过 '/'</span>            string word<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span> word <span class="token operator">+=</span> path<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">"."</span> <span class="token operator">||</span> word<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token string">".."</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        string ans <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> st<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token string">"/"</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a><a href="https://leetcode.com/problems/min-stack/description/?envType=study-plan-v2&envId=top-interview-150">155. Min Stack</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>    <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vec<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vec<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> vec<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minn <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> vec<span class="token punctuation">)</span> minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minn<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> minn<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> st<span class="token punctuation">;</span>  <span class="token comment">// 放入元素 ： 当前栈的最小元素</span>    <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>val<span class="token punctuation">,</span> val<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>val<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 维护栈顶的最小值</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/?envType=study-plan-v2&envId=top-interview-150">150. Evaluate Reverse Polish Notation</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> stNum<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> s <span class="token operator">:</span> tokens<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'-'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stNum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    b <span class="token operator">=</span> stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stNum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    a <span class="token operator">=</span> stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stNum<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> stNum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a <span class="token operator">/</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> stNum<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>string c <span class="token operator">:</span> tokens<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"+"</span><span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">"-"</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">"*"</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> nums2 <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> nums1 <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"+"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">+</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"-"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">-</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">*</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">"/"</span><span class="token punctuation">)</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1 <span class="token operator">/</span> nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">stoi</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="224-Basic-Calculator"><a href="#224-Basic-Calculator" class="headerlink" title="224. Basic Calculator"></a><a href="https://leetcode.com/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150">224. Basic Calculator</a></h2><p>Solution: #Stack, #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// 结果变量，存储当前计算的总和</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token comment">// 记录当前解析的数字</span>        <span class="token keyword">int</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 记录当前的符号，初始为正（1 代表正，-1 代表负）</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>     <span class="token comment">// 栈用于存储括号内的符号作用</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化栈，默认作用域符号为 1（正号）</span>        <span class="token comment">// 遍历字符串中的每个字符</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 如果是数字，构造当前数字（支持多位数）</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 遇到左括号 '('，表示进入新的作用域，将当前作用域的 sign 存入栈</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 遇到右括号 ')'，表示离开当前作用域，弹出栈顶的 sign</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 遇到加号 '+' 或减号 '-'，进行计算</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>  <span class="token comment">// 先计算前面解析的数字并累加到 ans</span>                sign <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新当前符号，受括号作用域影响</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 归零，准备解析下一个数字</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 处理最后一个数字</span>        <span class="token keyword">return</span> ans <span class="token operator">+</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用两个栈的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> numStack<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> opStack<span class="token punctuation">;</span> <span class="token comment">// 1 代表 '+', -1 代表 '-'</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isdigit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span> <span class="token comment">// 计算当前数字</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                sign <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'+'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                numStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                opStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sign<span class="token punctuation">)</span><span class="token punctuation">;</span>                ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">')'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span> <span class="token comment">// 计算括号内的最后一个数</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                ans <span class="token operator">*=</span> opStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> opStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理括号前的符号</span>                ans <span class="token operator">+=</span> numStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> numStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 叠加之前的计算结果</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans <span class="token operator">+</span> sign <span class="token operator">*</span> num<span class="token punctuation">;</span> <span class="token comment">// 计算最后一个数</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-interview-150">141. Linked List Cycle</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">==</span> slow<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token operator">!=</span> st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a><a href="https://leetcode.com/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150">2. Add Two Numbers</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 递归获取链表长度</span>    <span class="token keyword">int</span> <span class="token function">listLength</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">listLength</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> size1 <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size2 <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>size1 <span class="token operator">&lt;</span> size2<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 保证l1是最长的链表;</span>        ListNode<span class="token operator">*</span> cur1 <span class="token operator">=</span> l1<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cursum<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> last <span class="token operator">=</span> l1<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cursum <span class="token operator">=</span> cur1<span class="token operator">-></span>val <span class="token operator">+</span> cur2<span class="token operator">-></span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>            cur1<span class="token operator">-></span>val <span class="token operator">=</span> cursum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            carry <span class="token operator">=</span> cursum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> cur1<span class="token punctuation">;</span>            cur1 <span class="token operator">=</span> cur1<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur2 <span class="token operator">=</span> cur2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cursum <span class="token operator">=</span> cur1<span class="token operator">-></span>val <span class="token operator">+</span> carry<span class="token punctuation">;</span>            cur1<span class="token operator">-></span>val <span class="token operator">=</span> cursum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            carry <span class="token operator">=</span> cursum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> cur1<span class="token punctuation">;</span>            cur1 <span class="token operator">=</span> cur1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>carry <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> last<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> l1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：使用虚拟头节点</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> p1 <span class="token operator">=</span> l1<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> p2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> p2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">?</span> p1<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>p2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">?</span> p2<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> x <span class="token operator">+</span> y <span class="token operator">+</span> carry<span class="token punctuation">;</span>            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> p1 <span class="token operator">=</span> p1<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> p2 <span class="token operator">=</span> p2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150">21. Merge Two Sorted Lists</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> list1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> list2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> list2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> list2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">-></span>val <span class="token operator">&lt;</span> list2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    cur<span class="token operator">-></span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>                    list1 <span class="token operator">=</span> list1<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    cur<span class="token operator">-></span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>                    list2 <span class="token operator">=</span> list2<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>list1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    cur<span class="token operator">-></span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>                    list1 <span class="token operator">=</span> list1<span class="token operator">-></span>next<span class="token punctuation">;</span>                    cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>list2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    cur<span class="token operator">-></span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>                    list2 <span class="token operator">=</span> list2<span class="token operator">-></span>next<span class="token punctuation">;</span>                    cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> list1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> list2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>list1 <span class="token operator">&amp;&amp;</span> list2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">-></span>val <span class="token operator">&lt;</span> list2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                cur<span class="token operator">-></span>next <span class="token operator">=</span>list1<span class="token punctuation">;</span>                list1 <span class="token operator">=</span> list1<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                cur<span class="token operator">-></span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>                list2 <span class="token operator">=</span> list2<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span> cur<span class="token operator">-></span>next <span class="token operator">=</span> list1<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span> cur<span class="token operator">-></span>next <span class="token operator">=</span> list2<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-interview-150">138. Copy List with Random Pointer</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*// Definition for a Node.class Node &#123;public:    int val;    Node* next;    Node* random;        Node(int _val) &#123;        val = _val;        next = NULL;        random = NULL;    &#125;&#125;;*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> Node<span class="token operator">*</span><span class="token operator">></span> mp<span class="token punctuation">;</span> <span class="token comment">// 旧节点->新节点</span>        Node<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">// 第一遍：创建所有新节点，并建立映射关系</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mp<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 第二遍：复制 next 和 random 指针</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mp<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">-></span>next <span class="token operator">=</span> mp<span class="token punctuation">[</span>cur<span class="token operator">-></span>next<span class="token punctuation">]</span><span class="token punctuation">;</span>            mp<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">-></span>random <span class="token operator">=</span> mp<span class="token punctuation">[</span>cur<span class="token operator">-></span>random<span class="token punctuation">]</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mp<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li>浅拷贝 (Shallow Copy)：仅复制对象的指针，而不是内容。例如，如果 <code>mp[cur] = cur</code>; 这样做，新的链表仍然会指向原来的 random 节点。</li><li>深拷贝 (Deep Copy)：复制数据本身，确保新旧对象互不影响。本代码中的 <code>new Node(cur-&gt;val)</code>就是深拷贝的关键。</li></ul><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">copyRandomList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token comment">// Step 1: 复制节点并插入到原链表</span>        Node<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            Node<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            cur <span class="token operator">=</span> tmp<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Step 2: 复制 random 指针</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>random<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                cur<span class="token operator">-></span>next<span class="token operator">-></span>random <span class="token operator">=</span> cur<span class="token operator">-></span>random<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// Step 3: 拆分新旧链表</span>        Node<span class="token operator">*</span> newHead <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        Node<span class="token operator">*</span> copyCur <span class="token operator">=</span> newHead<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>copyCur<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                copyCur<span class="token operator">-></span>next <span class="token operator">=</span> copyCur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            copyCur <span class="token operator">=</span> copyCur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&envId=top-interview-150">92. Reverse Linked List II</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            pre<span class="token operator">-></span>next <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        pre<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法，Solution：#Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> left<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> pre <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment">/*反转区间的节点*/</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right <span class="token operator">-</span> left<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> tmp<span class="token operator">-></span>next<span class="token punctuation">;</span>            tmp<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>            pre<span class="token operator">-></span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-interview-150">25. Reverse Nodes in k-Group</a></h2><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">getLength</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">getLength</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">+=</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>                head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                cur<span class="token operator">-></span>next <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Recursion, #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cur<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>  <span class="token comment">// 剩余节点不足 k 个，直接返回</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> nxt <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> nxt<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 反转后，head 变成 k 组的最后一个节点</span>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>与栈的方法类似，还可以使用双端队列<code>deque</code></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        deque<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> dq<span class="token punctuation">;</span>        ListNode <span class="token function">dummy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token operator">&amp;</span>dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dq<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>            head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>dq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    cur<span class="token operator">-></span>next <span class="token operator">=</span> dq<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    dq<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>dq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> dq<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dq<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-interview-150">19. Remove Nth Node From End of List</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">getLength</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">getLength</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            prev <span class="token operator">=</span> prev<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        prev<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> cur<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：使用快慢指针 #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> toDelete <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        slow<span class="token operator">-></span>next <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> toDelete<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> newHead <span class="token operator">=</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/?envType=study-plan-v2&envId=top-interview-150">82. Remove Duplicates from Sorted List II</a></h2><p>Solution: #Deque</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        deque<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                que<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val <span class="token operator">==</span> que<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-></span>val <span class="token operator">==</span> que<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>val<span class="token punctuation">)</span> cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>                    que<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    que<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment">// 重塑指针，不然无法AC</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>更优化的方法：#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">deleteDuplicates</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">bool</span> isDuplicate <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>next <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-></span>val <span class="token operator">==</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                isDuplicate <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>isDuplicate<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                prev<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a><a href="https://leetcode.com/problems/rotate-list/description/?envType=study-plan-v2&envId=top-interview-150">61. Rotate List</a></h2><p>Solution: #Deque</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">getLength</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>         <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">getLength</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> n<span class="token punctuation">;</span>        deque<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            que<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化的方法：计算长度 + 直接拼接</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token operator">-></span>next <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tail<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            tail <span class="token operator">=</span> tail<span class="token operator">-></span>next<span class="token punctuation">;</span>            n<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        k <span class="token operator">=</span> k <span class="token operator">%</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        tail<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token comment">// 让链表变成一个环</span>        ListNode<span class="token operator">*</span> newTail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            newTail <span class="token operator">=</span> newTail<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">// 找到链表新的断点</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> newHead <span class="token operator">=</span> newTail<span class="token operator">-></span>next<span class="token punctuation">;</span>        newTail<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用快慢指针，#Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token operator">-></span>next <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tail<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            tail <span class="token operator">=</span> tail<span class="token operator">-></span>next<span class="token punctuation">;</span>            n<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        k <span class="token operator">%=</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 让fast先走k步</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// slow和fast一起走</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> newHead <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        slow<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        fast<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> newHead<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a><a href="https://leetcode.com/problems/partition-list/description/?envType=study-plan-v2&envId=top-interview-150">86. Partition List</a></h2><p>Solution: #Queue</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">partition</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> sml<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> big<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> sml<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> big<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>sml<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> sml<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            sml<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>big<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cur<span class="token operator">-></span>next <span class="token operator">=</span> big<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>            big<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">partition</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> dummy2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> ptr1 <span class="token operator">=</span> dummy1<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> ptr2 <span class="token operator">=</span> dummy2<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val <span class="token operator">&lt;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ptr1<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>                ptr1 <span class="token operator">=</span> ptr1<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                ptr2<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>                ptr2 <span class="token operator">=</span> ptr2<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ptr2<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ptr1<span class="token operator">-></span>next <span class="token operator">=</span> dummy2<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy1<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a><a href="https://leetcode.com/problems/lru-cache/description/?envType=study-plan-v2&envId=top-interview-150">146. LRU Cache</a></h2><p>Solution: #list</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> cap<span class="token punctuation">;</span> <span class="token comment">// 缓存容量</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lruList<span class="token punctuation">;</span> <span class="token comment">// 维护访问顺序，最近访问的在前</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator<span class="token operator">>></span> cache<span class="token punctuation">;</span> <span class="token comment">// key -> &#123;value, 在lruList中的位置&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cap <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> cache<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// key 不存在</span>        <span class="token comment">// key 存在，移动到链表头部（表示最近使用）</span>        lruList<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 先删除原来的位置</span>        lruList<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 移动到前面</span>        cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">=</span> lruList<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新迭代器</span>        <span class="token keyword">return</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>             <span class="token comment">// 返回值</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> cache<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// key 已存在，更新值，并移动到前面</span>            lruList<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>            lruList<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>value<span class="token punctuation">,</span> lruList<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// key 不存在，检查是否超出容量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> oldKey <span class="token operator">=</span> lruList<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 找到最久未使用的 key</span>                lruList<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 移除链表最后一个元素</span>                cache<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>oldKey<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 从哈希表中删除</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 插入新 key</span>            lruList<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>value<span class="token punctuation">,</span> lruList<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">104. Maximum Depth of Binary Tree</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration </p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            height<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> height<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a href="https://leetcode.com/problems/same-tree/description/?envType=study-plan-v2&envId=top-interview-150">100. Same Tree</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> q <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">-></span> val <span class="token operator">!=</span> q <span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token operator">-></span>left<span class="token punctuation">,</span> q<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token operator">-></span>right<span class="token punctuation">,</span> q<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que1<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que2<span class="token punctuation">;</span>        que1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        que2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>que2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span> node1 <span class="token operator">=</span> que1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">auto</span> node2 <span class="token operator">=</span> que2<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node1 <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> node2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node1 <span class="token operator">!=</span> node2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node1<span class="token operator">-></span>val <span class="token operator">!=</span> node2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            que1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node1<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            que1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node1<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            que2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node2<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            que2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node2<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode.com/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">226. Invert Binary Tree</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-interview-150">101. Symmetric Tree</a></h2><p>Solution: Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">solve</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> l<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>l <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>l <span class="token operator">||</span> <span class="token operator">!</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">-></span>val <span class="token operator">!=</span> r<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">solve</span><span class="token punctuation">(</span>l<span class="token operator">-></span>left<span class="token punctuation">,</span> r<span class="token operator">-></span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">solve</span><span class="token punctuation">(</span>l<span class="token operator">-></span>right<span class="token punctuation">,</span> r<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">solve</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> node1 <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> node2 <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node1 <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node2<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 都为空</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node1 <span class="token operator">||</span> <span class="token operator">!</span>node2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 只有一个为空</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node1<span class="token operator">-></span>val <span class="token operator">!=</span> node2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 值不相等</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node1<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node2<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node1<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node2<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>   <span class="token comment">// 递归边界条件</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>  <span class="token comment">// 边界条件</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inleft<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inright<span class="token punctuation">;</span>        <span class="token keyword">bool</span> over <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                over <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>over<span class="token punctuation">)</span> inleft<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> inright<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> preleft<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> preright<span class="token punctuation">;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> inleft<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                preleft<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> preright<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preleft<span class="token punctuation">,</span> inleft<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preright<span class="token punctuation">,</span> inright<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用哈希表优化的递归解法</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> inMap<span class="token punctuation">;</span>        <span class="token comment">// 将中序遍历的值与下标存储在哈希表中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            inMap<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        TreeNode<span class="token operator">*</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> preStart<span class="token punctuation">,</span> <span class="token keyword">int</span> preEnd<span class="token punctuation">,</span>                            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> <span class="token keyword">int</span> inEnd<span class="token punctuation">,</span>                            unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inMap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preStart <span class="token operator">></span> preEnd <span class="token operator">||</span> inStart <span class="token operator">></span> inEnd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 前序遍历的第一个节点是根节点</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 在中序遍历中找到根节点的位置</span>        <span class="token keyword">int</span> inRoot <span class="token operator">=</span> inMap<span class="token punctuation">[</span>root<span class="token operator">-></span>val<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 计算左子树的节点数量</span>        <span class="token keyword">int</span> numsLeft <span class="token operator">=</span> inRoot <span class="token operator">-</span> inStart<span class="token punctuation">;</span>                <span class="token comment">// 递归构建左子树和右子树</span>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preStart <span class="token operator">+</span> numsLeft<span class="token punctuation">,</span>                                      inorder<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> inRoot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inMap<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> numsLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span>                                       inorder<span class="token punctuation">,</span> inRoot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">,</span> inMap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>迭代解法（使用栈）</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>                TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> inorderIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> curr <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">-></span>val <span class="token operator">!=</span> inorder<span class="token punctuation">[</span>inorderIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果当前栈顶节点不等于中序遍历的当前节点</span>                <span class="token comment">// 说明当前前序遍历的节点是栈顶节点的左子节点</span>                curr<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果当前栈顶节点等于中序遍历的当前节点</span>                <span class="token comment">// 说明需要回溯到合适的父节点，然后添加右子节点</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>val <span class="token operator">==</span> inorder<span class="token punctuation">[</span>inorderIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    curr <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    inorderIndex<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                curr<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>使用索引而不是子数组的递归解法</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        TreeNode<span class="token operator">*</span> <span class="token function">build</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> preStart<span class="token punctuation">,</span> <span class="token keyword">int</span> preEnd<span class="token punctuation">,</span>                  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> <span class="token keyword">int</span> inEnd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>preStart <span class="token operator">></span> preEnd<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>                <span class="token comment">// 前序遍历的第一个节点是根节点</span>        <span class="token keyword">int</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preStart<span class="token punctuation">]</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 在中序遍历中找到根节点的位置</span>        <span class="token keyword">int</span> rootIndex <span class="token operator">=</span> inStart<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>rootIndex<span class="token punctuation">]</span> <span class="token operator">!=</span> rootVal<span class="token punctuation">)</span> rootIndex<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">// 左子树的节点数量</span>        <span class="token keyword">int</span> leftSize <span class="token operator">=</span> rootIndex <span class="token operator">-</span> inStart<span class="token punctuation">;</span>                <span class="token comment">// 构建左子树和右子树</span>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preStart <span class="token operator">+</span> leftSize<span class="token punctuation">,</span>                         inorder<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> rootIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preStart <span class="token operator">+</span> leftSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preEnd<span class="token punctuation">,</span>                          inorder<span class="token punctuation">,</span> rootIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/?envType=study-plan-v2&envId=top-interview-150">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>inorder<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inleft<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inright<span class="token punctuation">;</span>        <span class="token keyword">bool</span> findRoot <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ust<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>findRoot <span class="token operator">&amp;&amp;</span> inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                inleft<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ust<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>findRoot<span class="token punctuation">)</span> findRoot <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> inright<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> posleft<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> posright<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ust<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> ust<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> posleft<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> posright<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>inleft<span class="token punctuation">,</span> posleft<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>inright<span class="token punctuation">,</span> posright<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>简化的代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">rec</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postorder<span class="token punctuation">,</span> <span class="token keyword">int</span> inStart<span class="token punctuation">,</span> <span class="token keyword">int</span> inEnd<span class="token punctuation">,</span> <span class="token keyword">int</span> postStart<span class="token punctuation">,</span> <span class="token keyword">int</span> postEnd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>inStart <span class="token operator">></span> inEnd<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postEnd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> inStart<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> index<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// 找到中序遍历左右子树划分位置</span>        <span class="token keyword">int</span> leftLen <span class="token operator">=</span> index <span class="token operator">-</span> inStart<span class="token punctuation">;</span>       <span class="token comment">// 左子树长度</span>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">rec</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> inStart<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> postStart<span class="token punctuation">,</span> postStart <span class="token operator">+</span> leftLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">rec</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inEnd<span class="token punctuation">,</span> postStart <span class="token operator">+</span> leftLen<span class="token punctuation">,</span> postEnd <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">rec</span><span class="token punctuation">(</span>inorder<span class="token punctuation">,</span> postorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> postorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><ul><li>入栈节点：表示当前树的右子树还没构建完。</li><li>出栈节点：表示右子树构建完成，需要转向左子树。<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inorder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postorder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token comment">// 哈希表存储 inorder 中每个值的索引，O(1) 查询</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> inMap<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            inMap<span class="token punctuation">[</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> postIndex <span class="token operator">=</span> postorder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 先创建根节点</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>postIndex<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> postIndex<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>postorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token comment">// 判断是否需要出栈（找到正确的父节点）</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> inMap<span class="token punctuation">[</span>st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>val<span class="token punctuation">]</span> <span class="token operator">></span> inMap<span class="token punctuation">[</span>node<span class="token operator">-></span>val<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 根据 parent 是否存在决定插入左还是右子树</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token operator">-></span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul><h2 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&envId=top-interview-150">117. Populating Next Right Pointers in Each Node II</a></h2><p>Solution: #Queue</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*// Definition for a Node.class Node &#123;public:    int val;    Node* left;    Node* right;    Node* next;    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val, Node* _left, Node* _right, Node* _next)        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">connect</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                Node<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                Node<span class="token operator">*</span> cur <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                cur<span class="token operator">-></span>next <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cnt<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：#Recursion #DFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*// Definition for a Node.class Node &#123;public:    int val;    Node* left;    Node* right;    Node* next;    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val, Node* _left, Node* _right, Node* _next)        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> collect<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>collect<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> level<span class="token punctuation">)</span> collect<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            collect<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">-></span>next <span class="token operator">=</span> root<span class="token punctuation">;</span>            collect<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> collect<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> collect<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Node<span class="token operator">*</span> <span class="token function">connect</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> collect<span class="token punctuation">;</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> collect<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Pre Pointer</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*// Definition for a Node.class Node &#123;public:    int val;    Node* left;    Node* right;    Node* next;    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;    Node(int _val, Node* _left, Node* _right, Node* _next)        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">connect</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Node<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment">// 每一层的遍历设置一个pre指针</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                Node<span class="token operator">*</span> cur <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    prev<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-interview-150">114. Flatten Binary Tree to Linked List</a></h2><p>Solution: #Recursion #preOrder</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> vec<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">flatten</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> vec<span class="token punctuation">;</span>        <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> vec<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> vec<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            x<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            cur<span class="token operator">-></span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：#Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">flatten</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">flatten</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">flatten</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> tmp <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">flatten</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> rightmost <span class="token operator">=</span> cur<span class="token operator">-></span>left<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>rightmost<span class="token operator">-></span>right<span class="token punctuation">)</span> rightmost <span class="token operator">=</span> rightmost<span class="token operator">-></span>right<span class="token punctuation">;</span>                rightmost<span class="token operator">-></span>right <span class="token operator">=</span> cur<span class="token operator">-></span>right<span class="token punctuation">;</span>                cur<span class="token operator">-></span>right <span class="token operator">=</span> cur<span class="token operator">-></span>left<span class="token punctuation">;</span>                cur<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/description/?envType=study-plan-v2&envId=top-interview-150">112. Path Sum</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-></span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-></span>right <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>val <span class="token operator">==</span> targetSum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> targetSum <span class="token operator">-</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> targetSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>root<span class="token punctuation">,</span> root<span class="token operator">-></span>val<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>            <span class="token keyword">int</span> currSum <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token operator">-></span>right <span class="token operator">&amp;&amp;</span> currSum <span class="token operator">==</span> targetSum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> currSum <span class="token operator">+</span> node<span class="token operator">-></span>left<span class="token operator">-></span>val<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> currSum <span class="token operator">+</span> node<span class="token operator">-></span>right<span class="token operator">-></span>val<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&envId=top-interview-150">129. Sum Root to Leaf Numbers</a></h2><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">sumNumbers</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>root<span class="token punctuation">,</span> root<span class="token operator">-></span>val<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>            <span class="token keyword">int</span> curSum <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> ans <span class="token operator">+=</span> curSum<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> node<span class="token operator">-></span>left<span class="token operator">-></span>val <span class="token operator">+</span> curSum <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> node<span class="token operator">-></span>right<span class="token operator">-></span>val <span class="token operator">+</span> curSum <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> sum <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-></span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span> nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 叶子节点</span>        <span class="token function">solve</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">solve</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">sumNumbers</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token function">solve</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> ans <span class="token operator">+=</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150">124. Binary Tree Maximum Path Sum</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> maxSum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">solve</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> maxSum<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">solve</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> maxSum<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pathSum <span class="token operator">=</span> left <span class="token operator">+</span> right <span class="token operator">+</span> node<span class="token operator">-></span>val<span class="token punctuation">;</span>        maxSum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> pathSum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token operator">-></span>val <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token function">solve</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> maxSum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span> <span class="token comment">// 记忆化存储最大路径和</span>    <span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> maxSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记忆化</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">solve</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> maxSum<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">solve</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> maxSum<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pathSum <span class="token operator">=</span> left <span class="token operator">+</span> right <span class="token operator">+</span> node<span class="token operator">-></span>val<span class="token punctuation">;</span>        maxSum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> pathSum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-></span>val <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token function">solve</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> maxSum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173. Binary Search Tree Iterator"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/?envType=study-plan-v2&envId=top-interview-150">173. Binary Search Tree Iterator</a></h2><p>Solution: #中序遍历</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BSTIterator</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">BSTIterator</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> index <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Stack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BSTIterator</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>    <span class="token function">BSTIterator</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">pushLeft</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pushLeft</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token operator">-></span>val<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">pushLeft</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.com/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&envId=top-interview-150">222. Count Complete Tree Nodes</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">countNodes</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">236. Lowest Common Ancestor of a Binary Tree</a></h2><ul><li>递归遍历二叉树，分别在 左子树 和 右子树 查找 p 和 q。</li><li>如果 p 和 q 分别出现在左右子树，则 root 是最近公共祖先。</li><li>如果 p 和 q 都出现在某一侧，就往那一侧递归。</li><li>如果当前 root &#x3D;&#x3D; p 或 root &#x3D;&#x3D; q，直接返回 root。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span><span class="token operator">></span> parent<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> stk<span class="token punctuation">;</span>        parent<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 遍历整棵树，记录每个节点的父节点</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> parent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>node<span class="token operator">-></span>left<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>                stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>node<span class="token operator">-></span>right<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>                stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 记录 p 的所有祖先</span>        unordered_set<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> ancestors<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ancestors<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> parent<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 找到 q 的第一个公共祖先</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ancestors<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            q <span class="token operator">=</span> parent<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> q<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a href="https://leetcode.com/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-interview-150">199. Binary Tree Right Side View</a></h2><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>depth <span class="token operator">==</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 保证右子树先被访问</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150">637. Average of Levels in Binary Tree</a></h2><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                sum <span class="token operator">+=</span> node<span class="token operator">-></span>val<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sum <span class="token operator">/</span> <span class="token punctuation">(</span>num <span class="token operator">*</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> sum<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">// sum 和 count 记录每一层的信息，初始为空。</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> level<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        sum<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">+=</span> node<span class="token operator">-></span>val<span class="token punctuation">;</span>        count<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">averageOfLevels</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> sum<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> count<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sum<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sum<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-interview-150">102. Binary Tree Level Order Traversal</a></h2><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>level <span class="token operator">>=</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/?envType=study-plan-v2&envId=top-interview-150">103. Binary Tree Zigzag Level Order Traversal</a></h2><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            level<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>level <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">reverse</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>level <span class="token operator">>=</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>level <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> ans<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> ans<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从右到左</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">zigzagLevelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/?envType=study-plan-v2&envId=top-interview-150">530. Minimum Absolute Difference in BST</a></h2><p>Solution: 笨办法#Brute Force</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> gap <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>gap<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> gap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: BST的中序遍历可以得到一个递增序列。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getMinimumDifference</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            gap <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>gap<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> gap<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-interview-150">230. Kth Smallest Element in a BST</a></h2><p>Solution: #Inorder</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：不需要完整遍历</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans <span class="token operator">=</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">kthSmallest</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150">98. Validate Binary Search Tree</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pre <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pre<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            pre <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：不用完全遍历且不用额外空间</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 左子树不满足BST</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>prev <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;=</span> prev<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        prev <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-interview-150">200. Number of Islands</a></h2><p>Solution: #BFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> ox<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> oy<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">;</span>  <span class="token comment">// 合法的'1'</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isValid</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'0'</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> dx <span class="token operator">=</span> x <span class="token operator">+</span> ox<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> dy <span class="token operator">=</span> y <span class="token operator">+</span> oy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">bfs</span><span class="token punctuation">(</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">bfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #UnionSet</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> parent<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 路径压缩</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">unionSets</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> parent<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> rank<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rootX <span class="token operator">!=</span> rootY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span> parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span> <span class="token comment">// 合并小树到大树</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span> parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>                rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">parent</span><span class="token punctuation">(</span>m <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 并查集父节点数组</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rank</span><span class="token punctuation">(</span>m <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录树的高度</span>        <span class="token keyword">int</span> directions<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">*</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 初始化每个位置的父节点</span>        <span class="token keyword">int</span> numIslands <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> cur <span class="token operator">=</span> i <span class="token operator">*</span> n <span class="token operator">+</span> j<span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> dir <span class="token operator">:</span> directions<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">int</span> ni <span class="token operator">=</span> i <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> nj <span class="token operator">=</span> j <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>ni <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ni <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> nj <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nj <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> grid<span class="token punctuation">[</span>ni<span class="token punctuation">]</span><span class="token punctuation">[</span>nj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            <span class="token keyword">int</span> next <span class="token operator">=</span> ni <span class="token operator">*</span> n <span class="token operator">+</span> nj<span class="token punctuation">;</span>                            <span class="token function">unionSets</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> next<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> rank<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 统计岛屿的数量，判断每个节点的根节点是否唯一</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> islandRoots<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">*</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i <span class="token operator">/</span> n<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">%</span> n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span> islandRoots<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> islandRoots<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130. Surrounded Regions"></a><a href="https://leetcode.com/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150">130. Surrounded Regions</a></h2><ul><li>从边界上的 <code>O</code> 开始，用 BFS 标记所有能连到边界的 <code>O</code>（换成 <code>#</code>）。</li><li>遍历整个网格，把所有未标记的 <code>O</code>（被包围的）变成 <code>X</code>。</li><li>恢复标记的 <code>#</code> 变回 <code>O</code>（这些是原本连接到边界的 <code>O</code>）。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// line</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// col</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">>=</span> m <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// 超出界限</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>            queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> que<span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>x<span class="token punctuation">,</span> y<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>                    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>                    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>                    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>                    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">bfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">bfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'X'</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'#'</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'O'</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #DFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">>=</span> m <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">>=</span> n <span class="token operator">||</span> board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'O'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>                board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>  <span class="token comment">// 先标记</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 上</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 下</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 处理边界</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 第一列</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 最后一列</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 第一行</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 最后一行</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 遍历整个矩阵，修改值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'X'</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'#'</span><span class="token punctuation">)</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'O'</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Union-Find</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rank<span class="token punctuation">;</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        rank<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span>             parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 路径压缩</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">unite</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootX <span class="token operator">!=</span> rootY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>                rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dummy <span class="token operator">=</span> m <span class="token operator">*</span> n<span class="token punctuation">;</span>  <span class="token comment">// 虚拟节点</span>        UnionFind <span class="token function">uf</span><span class="token punctuation">(</span>dummy <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历整个矩阵，处理边界上的 'O'</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> index <span class="token operator">=</span> i <span class="token operator">*</span> n <span class="token operator">+</span> j<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 边界上的 'O' 连接到 dummy</span>                        uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> dummy<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// 合并相邻的 'O'</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> i <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> i <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 遍历整个矩阵，修改值</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> index <span class="token operator">=</span> i <span class="token operator">*</span> n <span class="token operator">+</span> j<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>uf<span class="token punctuation">.</span><span class="token function">connected</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> dummy<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'X'</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="133-Clone-Graph"><a href="#133-Clone-Graph" class="headerlink" title="133. Clone Graph"></a><a href="https://leetcode.com/problems/clone-graph/description/?envType=study-plan-v2&envId=top-interview-150">133. Clone Graph</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*// Definition for a Node.class Node &#123;public:    int val;    vector&lt;Node*> neighbors;    Node() &#123;        val = 0;        neighbors = vector&lt;Node*>();    &#125;    Node(int _val) &#123;        val = _val;        neighbors = vector&lt;Node*>();    &#125;    Node(int _val, vector&lt;Node*> _neighbors) &#123;        val = _val;        neighbors = _neighbors;    &#125;&#125;;*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> Node<span class="token operator">*</span><span class="token operator">></span> copies<span class="token punctuation">;</span>    Node<span class="token operator">*</span> <span class="token function">cloneGraph</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        copies<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> copy<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            Node<span class="token operator">*</span> cur <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> neighbor <span class="token operator">:</span> cur<span class="token operator">-></span>neighbors<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>copies<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span> <span class="token operator">==</span> copies<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    copies<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>neighbor<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                copies<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token operator">-></span>neighbors<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>copies<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> copy<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="399-Evaluate-Division"><a href="#399-Evaluate-Division" class="headerlink" title="399. Evaluate Division"></a><a href="https://leetcode.com/problems/evaluate-division/description/?envType=study-plan-v2&envId=top-interview-150">399. Evaluate Division</a></h2><p>Solution: #Union-Find</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> parent<span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> weight<span class="token punctuation">;</span>    string <span class="token function">find</span><span class="token punctuation">(</span>string x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>            weight<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string origin <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 路径压缩</span>            weight<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">*=</span> weight<span class="token punctuation">[</span>origin<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 更新路径中的比值</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">unionSets</span><span class="token punctuation">(</span>string x<span class="token punctuation">,</span> string y<span class="token punctuation">,</span> <span class="token keyword">double</span> value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        string rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        string rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rootX <span class="token operator">!=</span> rootY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>            weight<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> value <span class="token operator">*</span> weight<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">/</span> weight<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">calcEquation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token operator">&amp;</span> equations<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> values<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token operator">&amp;</span> queries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> equations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string a <span class="token operator">=</span> equations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> equations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> value <span class="token operator">=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">unionSets</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> result<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> query <span class="token operator">:</span> queries<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            string a <span class="token operator">=</span> query<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> query<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> parent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>weight<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">/</span> weight<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution：构图 + BFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">>></span><span class="token operator">></span> graph<span class="token punctuation">;</span>    <span class="token keyword">double</span> <span class="token function">bfs</span><span class="token punctuation">(</span>string start<span class="token punctuation">,</span> string end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">==</span> graph<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> graph<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">==</span> graph<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">>></span> q<span class="token punctuation">;</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> visited<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>start<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span> <span class="token punctuation">[</span>curr<span class="token punctuation">,</span> val<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curr <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> val<span class="token punctuation">;</span>  <span class="token comment">// 找到目标</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> neighbor <span class="token operator">:</span> graph<span class="token punctuation">[</span>curr<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                string nextNode <span class="token operator">=</span> neighbor<span class="token punctuation">.</span>first<span class="token punctuation">;</span>                <span class="token keyword">double</span> weight <span class="token operator">=</span> neighbor<span class="token punctuation">.</span>second<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>visited<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 避免重复访问</span>                visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nextNode<span class="token punctuation">,</span> val <span class="token operator">*</span> weight<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 更新累计权重</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">calcEquation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token operator">&amp;</span> equations<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> values<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token operator">&amp;</span> queries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 构造图</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> equations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            string a <span class="token operator">=</span> equations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> equations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> value <span class="token operator">=</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            graph<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>b<span class="token punctuation">,</span> value<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            graph<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">/</span> value<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 2. 处理查询</span>        vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> result<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> query <span class="token operator">:</span> queries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">bfs</span><span class="token punctuation">(</span>query<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> query<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a><a href="https://leetcode.com/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150">207. Course Schedule</a></h2><p>Solution: #BFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">canFinish</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">graph</span><span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 邻接表</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">indegree</span><span class="token punctuation">(</span>numCourses<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 入度表</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            graph<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// b -> a</span>            indegree<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 入度为0的可以先学</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> finished <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> course <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            finished<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> neighbor <span class="token operator">:</span> graph<span class="token punctuation">[</span>course<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                indegree<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> finished <span class="token operator">==</span> numCourses<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210. Course Schedule II"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/?envType=study-plan-v2&envId=top-interview-150">210. Course Schedule II</a></h2><p>Solution: #BFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> numCourses<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">graph</span><span class="token punctuation">(</span>numCourses<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 邻接表</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">indegree</span><span class="token punctuation">(</span>numCourses<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 入度表</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> p <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            graph<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// b -> a</span>            indegree<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> course <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> neighbor <span class="token operator">:</span> graph<span class="token punctuation">[</span>course<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                indegree<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> numCourses<span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="909-Snakes-and-Ladders"><a href="#909-Snakes-and-Ladders" class="headerlink" title="909. Snakes and Ladders"></a><a href="https://leetcode.com/problems/snakes-and-ladders/description/?envType=study-plan-v2&envId=top-interview-150">909. Snakes and Ladders</a></h2><p>Solution: #BFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">snakesAndLadders</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">flat</span><span class="token punctuation">(</span>n <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1-based indexing</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> leftToRight <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>leftToRight<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> flat<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> flat<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            leftToRight <span class="token operator">=</span> <span class="token operator">!</span>leftToRight<span class="token punctuation">;</span> <span class="token comment">// 换遍历方向</span>        <span class="token punctuation">&#125;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n <span class="token operator">*</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> steps <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>sz<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> cur <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> n <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> steps<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> move <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> move <span class="token operator">&lt;=</span> <span class="token number">6</span> <span class="token operator">&amp;&amp;</span> cur <span class="token operator">+</span> move <span class="token operator">&lt;=</span> n <span class="token operator">*</span> n<span class="token punctuation">;</span> move<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> next <span class="token operator">=</span> cur <span class="token operator">+</span> move<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>flat<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> next <span class="token operator">=</span> flat<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        visited<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            steps<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="433-Minimum-Genetic-Mutation"><a href="#433-Minimum-Genetic-Mutation" class="headerlink" title="433. Minimum Genetic Mutation"></a><a href="https://leetcode.com/problems/minimum-genetic-mutation/description/?envType=study-plan-v2&envId=top-interview-150">433. Minimum Genetic Mutation</a></h2><p>Solution:#BFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minMutation</span><span class="token punctuation">(</span>string startGene<span class="token punctuation">,</span> string endGene<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> bank<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">ust</span><span class="token punctuation">(</span>bank<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bank<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ust<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>endGene<span class="token punctuation">)</span> <span class="token operator">==</span> ust<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 目标基因不在bank中</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> visited<span class="token punctuation">;</span>  <span class="token comment">// 用来记录已访问的基因</span>        queue<span class="token operator">&lt;</span>string<span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>startGene<span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>startGene<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mutations <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 记录变异次数</span>        string genes <span class="token operator">=</span> <span class="token string">"ACGT"</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                string curr <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>curr <span class="token operator">==</span> endGene<span class="token punctuation">)</span> <span class="token keyword">return</span> mutations<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> genes<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            string newGene <span class="token operator">=</span> curr<span class="token punctuation">;</span>                            newGene<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                            <span class="token keyword">if</span><span class="token punctuation">(</span>ust<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>newGene<span class="token punctuation">)</span> <span class="token operator">!=</span> ust<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> visited<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>newGene<span class="token punctuation">)</span> <span class="token operator">==</span> visited<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                                visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>newGene<span class="token punctuation">)</span><span class="token punctuation">;</span>                                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newGene<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            mutations<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a><a href="https://leetcode.com/problems/word-ladder/description/?envType=study-plan-v2&envId=top-interview-150">127. Word Ladder</a></h2><p>Solution: #BFS，暴力枚举可能出现的字段</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>string beginWord<span class="token punctuation">,</span> string endWord<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> wordList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">wordSet</span><span class="token punctuation">(</span>wordList<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wordList<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>wordSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>endWord<span class="token punctuation">)</span> <span class="token operator">==</span> wordSet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 终点不在wordList中</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> visited<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>string<span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> steps <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                string cur <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> endWord<span class="token punctuation">)</span> <span class="token keyword">return</span> steps<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cur<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">char</span> original <span class="token operator">=</span> cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> <span class="token char">'z'</span><span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> original<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                        cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>wordSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token operator">!=</span> wordSet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> visited<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token operator">==</span> visited<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        visited<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                     cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> original<span class="token punctuation">;</span>  <span class="token comment">// 还原</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            steps<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-interview-150">208. Implement Trie (Prefix Tree)</a></h2><p>Solution: 暴力映射找前缀</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> ust<span class="token punctuation">;</span>    <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ust<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ust<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">search</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>ust<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> ust<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>string prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prefix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> str <span class="token operator">:</span> ust<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> prefix<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #BFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> TrieNode<span class="token operator">*</span><span class="token operator">></span> children<span class="token punctuation">;</span>  <span class="token comment">// 存储子节点</span>    <span class="token keyword">bool</span> is_end_of_word<span class="token punctuation">;</span>  <span class="token comment">// 标记是否为单词的结尾</span>        <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">is_end_of_word</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TrieNode<span class="token operator">*</span> root<span class="token punctuation">;</span>  <span class="token comment">// 根节点</span>        <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化根节点</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 插入单词</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TrieNode<span class="token operator">*</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                node<span class="token operator">-></span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        node<span class="token operator">-></span>is_end_of_word <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 标记该节点为单词的结尾</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 搜索单词</span>    <span class="token keyword">bool</span> <span class="token function">search</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TrieNode<span class="token operator">*</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 如果某个字符不存在，返回 false</span>            <span class="token punctuation">&#125;</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> node<span class="token operator">-></span>is_end_of_word<span class="token punctuation">;</span>  <span class="token comment">// 如果到达的节点是单词的结尾，则返回 true</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 判断是否有单词以 prefix 开头</span>    <span class="token keyword">bool</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>string prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TrieNode<span class="token operator">*</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// 如果某个字符不存在，返回 false</span>            <span class="token punctuation">&#125;</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 如果遍历完 prefix 的所有字符，返回 true</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>🖼️ 图示（插入 “apple” 和 “app” 之后）</p><figure><div class="code-wrapper"><pre class="line-numbers language-arduino" data-language="arduino"><code class="language-arduino"><span class="token punctuation">(</span>root<span class="token punctuation">)</span>  <span class="token operator">|</span>  a  <span class="token operator">|</span>  p  <span class="token operator">|</span>  p<span class="token operator">*</span>   ← app 的结尾（is_end_of_word <span class="token operator">=</span> <span class="token boolean">true</span>）  <span class="token operator">|</span>  l  <span class="token operator">|</span>  e<span class="token operator">*</span>   ← apple 的结尾（is_end_of_word <span class="token operator">=</span> <span class="token boolean">true</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="211-Design-Add-and-Search-Words-Data-Structure"><a href="#211-Design-Add-and-Search-Words-Data-Structure" class="headerlink" title="211. Design Add and Search Words Data Structure"></a><a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/description/?envType=study-plan-v2&envId=top-interview-150">211. Design Add and Search Words Data Structure</a></h2><p>Solution: #Trie</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WordDictionary</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">&#123;</span>        TrieNode<span class="token operator">*</span> children<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token keyword">nullptr</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> isEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    TrieNode<span class="token operator">*</span> root<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">WordDictionary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addWord</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TrieNode<span class="token operator">*</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span>                node<span class="token operator">-></span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            node <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        node<span class="token operator">-></span>isEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">search</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">searchHelper</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">searchHelper</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> word<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> TrieNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> node<span class="token operator">-></span>isEnd<span class="token punctuation">;</span>        <span class="token keyword">char</span> c <span class="token operator">=</span> word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'.'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Try all possible children</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">searchHelper</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">searchHelper</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>字典树🌲插入方式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">(</span>root<span class="token punctuation">)</span>  ├── b  │   └── a  │       └── d*  ├── d  │   └── a  │       └── d*  └── m      └── a          └── d*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="212-Word-Search-II"><a href="#212-Word-Search-II" class="headerlink" title="212. Word Search II"></a><a href="https://leetcode.com/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150">212. Word Search II</a></h2><p>Solution: #Trie #BFS #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token punctuation">(</span>root<span class="token punctuation">)</span> ├── o │   └── a │       └── t │           └── h [<span class="token property">word</span><span class="token punctuation">:</span> <span class="token string">"oath"</span>] ├── p │   └── e │       └── a [<span class="token property">word</span><span class="token punctuation">:</span> <span class="token string">"pea"</span>] ├── e │   └── a │       └── t [<span class="token property">word</span><span class="token punctuation">:</span> <span class="token string">"eat"</span>] └── r     └── a         └── i             └── n [<span class="token property">word</span><span class="token punctuation">:</span> <span class="token string">"rain"</span>]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> TrieNode<span class="token operator">*</span><span class="token operator">></span> children<span class="token punctuation">;</span>        string word <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        TrieNode<span class="token operator">*</span> <span class="token function">buildTrie</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TrieNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> word <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            TrieNode<span class="token operator">*</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    node<span class="token operator">-></span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                node <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            node<span class="token operator">-></span>word <span class="token operator">=</span> word<span class="token punctuation">;</span>  <span class="token comment">// Store word at the end node</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> TrieNode<span class="token operator">*</span> node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> c <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token char">'#'</span> <span class="token operator">||</span> <span class="token operator">!</span>node<span class="token operator">-></span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        node <span class="token operator">=</span> node<span class="token operator">-></span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-></span>word<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token operator">-></span>word <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">// avoid duplicate</span>        <span class="token punctuation">&#125;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span> <span class="token comment">// mark visited</span>        <span class="token keyword">int</span> dirs<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> d <span class="token operator">:</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> i <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> j <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> node<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// backtrack</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">findWords</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> result<span class="token punctuation">;</span>        TrieNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token function">buildTrie</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&envId=top-interview-150">17. Letter Combinations of a Phone Number</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> string<span class="token operator">></span> mp <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#123;</span><span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token string">"def"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'4'</span><span class="token punctuation">,</span> <span class="token string">"ghi"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'5'</span><span class="token punctuation">,</span> <span class="token string">"jkl"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'6'</span><span class="token punctuation">,</span> <span class="token string">"mno"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'7'</span><span class="token punctuation">,</span> <span class="token string">"pqrs"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'8'</span><span class="token punctuation">,</span> <span class="token string">"tuv"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span><span class="token char">'9'</span><span class="token punctuation">,</span> <span class="token string">"wxyz"</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">rec</span><span class="token punctuation">(</span>string digits<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> ans<span class="token punctuation">,</span> string tmp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>idx <span class="token operator">>=</span> digits<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        string word <span class="token operator">=</span> mp<span class="token punctuation">[</span>digits<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">rec</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">,</span> tmp <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>string digits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> ans<span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token function">rec</span><span class="token punctuation">(</span>digits<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ans<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">实例图Level 0<span class="token punctuation">:</span>└── <span class="token string">""</span>                     // 开始递归，空字符串Level 1<span class="token punctuation">:</span> 处理 digits[0] = <span class="token string">'2'</span> → <span class="token string">"abc"</span>├── <span class="token string">"a"</span>├── <span class="token string">"b"</span>└── <span class="token string">"c"</span>Level 2<span class="token punctuation">:</span> 处理 digits[1] = <span class="token string">'3'</span> → <span class="token string">"def"</span>├── <span class="token string">"a"</span>│   ├── <span class="token string">"ad"</span>│   ├── <span class="token string">"ae"</span>│   └── <span class="token string">"af"</span>├── <span class="token string">"b"</span>│   ├── <span class="token string">"bd"</span>│   ├── <span class="token string">"be"</span>│   └── <span class="token string">"bf"</span>└── <span class="token string">"c"</span>    ├── <span class="token string">"cd"</span>    ├── <span class="token string">"ce"</span>    └── <span class="token string">"cf"</span>最终结果：[<span class="token string">"ad"</span><span class="token punctuation">,</span> <span class="token string">"ae"</span><span class="token punctuation">,</span> <span class="token string">"af"</span><span class="token punctuation">,</span> <span class="token string">"bd"</span><span class="token punctuation">,</span> <span class="token string">"be"</span><span class="token punctuation">,</span> <span class="token string">"bf"</span><span class="token punctuation">,</span> <span class="token string">"cd"</span><span class="token punctuation">,</span> <span class="token string">"ce"</span><span class="token punctuation">,</span> <span class="token string">"cf"</span>]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a><a href="https://leetcode.com/problems/combinations/description/?envType=study-plan-v2&envId=top-interview-150">77. Combinations</a></h2><p>Solution: #Backtracking</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rec</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rec</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            nums<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// backtracking</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">combine</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>        <span class="token function">rec</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a><a href="https://leetcode.com/problems/permutations/description/?envType=study-plan-v2&envId=top-interview-150">46. Permutations</a></h2><p>Solution: #Backtracking</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rec</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> used<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> tmp<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">rec</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            tmp<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// backtracking</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">// backtracking</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">permute</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">used</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">rec</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> used<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/description/?envType=study-plan-v2&envId=top-interview-150">39. Combination Sum</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">rec</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> path<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candidates<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> ans<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> candidates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">rec</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> target <span class="token operator">-</span> candidates<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> candidates<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">combinationSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> candidates<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> ans<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span>        <span class="token function">rec</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> path<span class="token punctuation">,</span> candidates<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a><a href="https://leetcode.com/problems/n-queens-ii/description/?envType=study-plan-v2&envId=top-interview-150">52. N-Queens II</a></h2><p>Solution: #Backtrack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> cols<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> diag1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> diag2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> result<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            result<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cols<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">||</span> diag1<span class="token punctuation">[</span>row <span class="token operator">-</span> col <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> diag2<span class="token punctuation">[</span>row <span class="token operator">+</span> col<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            cols<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> diag1<span class="token punctuation">[</span>row <span class="token operator">-</span> col <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> diag2<span class="token punctuation">[</span>row <span class="token operator">+</span> col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> diag1<span class="token punctuation">,</span> diag2<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>            cols<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> diag1<span class="token punctuation">[</span>row <span class="token operator">-</span> col <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> diag2<span class="token punctuation">[</span>row <span class="token operator">+</span> col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">totalNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">cols</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">diag1</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 主对角线</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">diag2</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 副对角线</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> diag1<span class="token punctuation">,</span> diag2<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a><a href="https://leetcode.com/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-interview-150">22. Generate Parentheses</a></h2><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">                 <span class="token string">""</span>              /      \           <span class="token string">"("</span>        [×]         /     \     <span class="token string">"(("</span>     <span class="token string">"()"</span>            /   \     /   \[×]  <span class="token string">"(()"</span>  [×]  <span class="token string">"()("</span>        \          \      <span class="token string">"(())"</span>      <span class="token string">"()()"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Backtrack</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> result<span class="token punctuation">,</span> string current<span class="token punctuation">,</span> <span class="token keyword">int</span> open<span class="token punctuation">,</span> <span class="token keyword">int</span> close<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> max <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>open <span class="token operator">&lt;</span> max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> current <span class="token operator">+</span> <span class="token string">"("</span><span class="token punctuation">,</span> open <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> close<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>close <span class="token operator">&lt;</span> open<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">backtrack</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> current <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">,</span> open<span class="token punctuation">,</span> close <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> result<span class="token punctuation">;</span>        string current<span class="token punctuation">;</span>        <span class="token function">backtrack</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> current<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a><a href="https://leetcode.com/problems/word-search/description/?envType=study-plan-v2&envId=top-interview-150">79. Word Search</a></h2><p>Solution: #Backtrack #DFS</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> word<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">>=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> temp <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> found <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span>                     <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span>                     <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span>                     <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span> found<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">exist</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> word<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cols <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150">108. Convert Sorted Array to Binary Search Tree</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">solve</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    TreeNode<span class="token operator">*</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">solve</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a><a href="https://leetcode.com/problems/sort-list/description/?envType=study-plan-v2&envId=top-interview-150">148. Sort List</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">merge</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">-></span>val <span class="token operator">&lt;</span> l2<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                tail<span class="token operator">-></span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                tail<span class="token operator">-></span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            tail <span class="token operator">=</span> tail<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tail<span class="token operator">-></span>next <span class="token operator">=</span> l1 <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">sortList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 链表一分为二</span>        ListNode<span class="token operator">*</span> mid <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>        slow<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">sortList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">sortList</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="427-Construct-Quad-Tree"><a href="#427-Construct-Quad-Tree" class="headerlink" title="427. Construct Quad Tree"></a><a href="https://leetcode.com/problems/construct-quad-tree/description/?envType=study-plan-v2&envId=top-interview-150">427. Construct Quad Tree</a></h2><p>Solution: #Recursion</p><figure><div class="code-wrapper"><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token punctuation">(</span>r1<span class="token punctuation">,</span>c1<span class="token punctuation">)</span>                <span class="token punctuation">(</span>r1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span>   <span class="token operator">+</span><span class="token comment">---------------------+</span>   <span class="token operator">|</span>         <span class="token operator">|</span>           <span class="token operator">|</span>   <span class="token operator">|</span>   TL    <span class="token operator">|</span>    TR     <span class="token operator">|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>           <span class="token operator">|</span><span class="token punctuation">(</span>midR<span class="token punctuation">,</span>c1<span class="token punctuation">)</span>   <span class="token punctuation">(</span>midR<span class="token punctuation">,</span> c2<span class="token punctuation">)</span>   <span class="token operator">|</span><span class="token comment">---------+-----------|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>           <span class="token operator">|</span>   <span class="token operator">|</span>   BL    <span class="token operator">|</span>    BR     <span class="token operator">|</span>   <span class="token operator">|</span>         <span class="token operator">|</span>           <span class="token operator">|</span><span class="token punctuation">(</span>r2<span class="token punctuation">,</span>c1<span class="token punctuation">)</span>                <span class="token punctuation">(</span>r2<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*// Definition for a QuadTree node.class Node &#123;public:    bool val;    bool isLeaf;    Node* topLeft;    Node* topRight;    Node* bottomLeft;    Node* bottomRight;        Node() &#123;        val = false;        isLeaf = false;        topLeft = NULL;        topRight = NULL;        bottomLeft = NULL;        bottomRight = NULL;    &#125;        Node(bool _val, bool _isLeaf) &#123;        val = _val;        isLeaf = _isLeaf;        topLeft = NULL;        topRight = NULL;        bottomLeft = NULL;        bottomRight = NULL;    &#125;        Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) &#123;        val = _val;        isLeaf = _isLeaf;        topLeft = _topLeft;        topRight = _topRight;        bottomLeft = _bottomLeft;        bottomRight = _bottomRight;    &#125;&#125;;*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">,</span> <span class="token keyword">int</span> c1<span class="token punctuation">,</span> <span class="token keyword">int</span> c2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">bool</span> same <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> first <span class="token operator">=</span> grid<span class="token punctuation">[</span>r1<span class="token punctuation">]</span><span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r1<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r2 <span class="token operator">&amp;&amp;</span> same<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> c1<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> first<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    same <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>same<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> midR <span class="token operator">=</span> <span class="token punctuation">(</span>r1 <span class="token operator">+</span> r2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> midC <span class="token operator">=</span> <span class="token punctuation">(</span>c1 <span class="token operator">+</span> c2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> topLeft <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> midR<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> midC<span class="token punctuation">)</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> topRight <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> midR<span class="token punctuation">,</span> midC<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> bottomLeft <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> midR<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> midC<span class="token punctuation">)</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> bottomRight <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> midR<span class="token punctuation">,</span> r2<span class="token punctuation">,</span> midC<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> topLeft<span class="token punctuation">,</span> topRight<span class="token punctuation">,</span> bottomLeft<span class="token punctuation">,</span> bottomRight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">construct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150">23. Merge k Sorted Lists</a></h2><p>Solution: #Min Heap</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">struct</span> <span class="token class-name">compare</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> a<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> a<span class="token operator">-></span>val <span class="token operator">></span> b<span class="token operator">-></span>val<span class="token punctuation">;</span>  <span class="token comment">// 小顶堆</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> lists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        priority_queue<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> compare<span class="token operator">></span> pq<span class="token punctuation">;</span>        <span class="token comment">// 初始将每个链表的第一个节点入堆</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> node <span class="token operator">:</span> lists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ListNode <span class="token function">dummy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token operator">&amp;</span>dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ListNode<span class="token operator">*</span> minNode <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            tail<span class="token operator">-></span>next <span class="token operator">=</span> minNode<span class="token punctuation">;</span>            tail <span class="token operator">=</span> tail<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>minNode<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>minNode<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Divide &amp; Conquer</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 合并两个有序链表</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ListNode <span class="token function">dummy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token operator">&amp;</span>dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token operator">-></span>val <span class="token operator">&lt;</span> l2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                tail<span class="token operator">-></span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                tail<span class="token operator">-></span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            tail <span class="token operator">=</span> tail<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tail<span class="token operator">-></span>next <span class="token operator">=</span> l1 <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 分治合并链表</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> lists<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">mergeRange</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 递归合并 lists[left...right]</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeRange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span><span class="token operator">&amp;</span> lists<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> lists<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> l1 <span class="token operator">=</span> <span class="token function">mergeRange</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> l2 <span class="token operator">=</span> <span class="token function">mergeRange</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a><a href="https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150">53. Maximum Subarray</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pre <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            pre <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> pre <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="918-Maximum-Sum-Circular-Subarray"><a href="#918-Maximum-Sum-Circular-Subarray" class="headerlink" title="918. Maximum Sum Circular Subarray"></a><a href="">918. Maximum Sum Circular Subarray</a></h2><p>Solution: #Greedy</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubarraySumCircular</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> curMax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minSum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> curMin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            curMax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> curMax <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            maxSum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> curMax<span class="token punctuation">)</span><span class="token punctuation">;</span>            curMin <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> curMin <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            minSum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minSum<span class="token punctuation">,</span> curMin<span class="token punctuation">)</span><span class="token punctuation">;</span>            total <span class="token operator">+=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>maxSum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>maxSum<span class="token punctuation">,</span> total<span class="token operator">-</span>minSum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a><a href="https://leetcode.com/problems/search-insert-position/description/?envType=study-plan-v2&envId=top-interview-150">35. Search Insert Position</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a><a href="https://leetcode.com/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-interview-150">74. Search a 2D Matrix</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：把矩阵视作为一维数组</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> m <span class="token operator">*</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> value <span class="token operator">=</span> matrix<span class="token punctuation">[</span>mid <span class="token operator">/</span> n<span class="token punctuation">]</span><span class="token punctuation">[</span>mid <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 映射回二维下标</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a><a href="https://leetcode.com/problems/find-peak-element/description/?envType=study-plan-v2&envId=top-interview-150">162. Find Peak Element</a></h2><p>Solution: #Binary Search</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findPeakElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> right <span class="token operator">=</span> mid<span class="token punctuation">;</span>  <span class="token comment">// 峰值在左侧（含mid）</span>            <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 峰值在右侧</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">33. Search in Rotated Sorted Array</a></h2><p>Solution: #Hash Table</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> mp<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> mp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target <span class="token operator">&amp;&amp;</span> target <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">34. Find First and Last Position of Element in Sorted Array</a></h2><p>Solution: #Two Pointers</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">searchRange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> l <span class="token operator">=</span> mid<span class="token punctuation">,</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> l<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> r<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>l<span class="token punctuation">,</span> r<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化的方法：两次二分查找（分别找左边界和右边界）</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findBound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">bool</span> isLeft<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bound <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                bound <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>isLeft<span class="token punctuation">)</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 继续往左找</span>                <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 继续往右找</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> bound<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">searchRange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">findBound</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// target 不存在</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">findBound</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>left<span class="token punctuation">,</span> right<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150">153. Find Minimum in Rotated Sorted Array</a></h2><p>Solution: #Binary Search</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 当 left == right 时，即为最小值。</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-interview-150">4. Median of Two Sorted Arrays</a></h2><p>Solution: 每次我们尝试在两个数组中都“跳过” k&#x2F;2 个元素。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getKthElement</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> <span class="token keyword">const</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> idx2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>idx1 <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> nums2<span class="token punctuation">[</span>idx2 <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>idx2 <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>idx1 <span class="token operator">+</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> half <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> newIdx1 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>idx1 <span class="token operator">+</span> half<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> newIdx2 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>idx2 <span class="token operator">+</span> half<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> pivot1 <span class="token operator">=</span> nums1<span class="token punctuation">[</span>newIdx1<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> pivot2 <span class="token operator">=</span> nums2<span class="token punctuation">[</span>newIdx2<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pivot1 <span class="token operator">&lt;=</span> pivot2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                k <span class="token operator">-=</span> <span class="token punctuation">(</span>newIdx1 <span class="token operator">-</span> idx1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                idx1 <span class="token operator">=</span> newIdx1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                k <span class="token operator">-=</span> <span class="token punctuation">(</span>newIdx2 <span class="token operator">-</span> idx2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                idx2 <span class="token operator">=</span> newIdx2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">findMedianSortedArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> totalLength <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>totalLength <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">getKthElement</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> totalLength <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getKthElement</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> totalLength <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getKthElement</span><span class="token punctuation">(</span>nums1<span class="token punctuation">,</span> nums2<span class="token punctuation">,</span> totalLength <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-interview-150">215. Kth Largest Element in an Array</a></h2><p>Solution: #Priority Queue</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> minHeap<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 只保留K个最大的</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>另类做法：疯狂开辟空间</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token number">20004</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> index<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">20003</span><span class="token punctuation">;</span> i<span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                k <span class="token operator">-=</span> index<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token operator">-</span><span class="token number">10000</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="502-IPO"><a href="#502-IPO" class="headerlink" title="502. IPO"></a><a href="https://leetcode.com/problems/ipo/description/?envType=study-plan-v2&envId=top-interview-150">502. IPO</a></h2><p>Solution: #Heap</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findMaximizedCapital</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> profits<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> capital<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> profits<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> projects<span class="token punctuation">;</span>  <span class="token comment">// 把所有项目封装成 (capital, profit) 对</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> projects<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>capital<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> profits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>projects<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> projects<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 按所需资本升序排序</span>        <span class="token comment">// 大顶堆：存储当前可做项目的利润（用负数实现最大堆）</span>        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> maxProfitHeap<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 将所有当前资本 w 能做的项目加入大顶堆</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> projects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">&lt;=</span> w<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                maxProfitHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>projects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>maxProfitHeap<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            w <span class="token operator">+=</span> maxProfitHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            maxProfitHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> w<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&envId=top-interview-150">373. Find K Pairs with Smallest Sums</a></h2><p>Solution: #Min-Heap</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">kSmallestPairs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> nums2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token comment">// 最小堆：pair的比较基于 nums1[i] + nums2[j]</span>        <span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>a<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>a<span class="token punctuation">.</span>second<span class="token punctuation">]</span> <span class="token operator">></span> nums1<span class="token punctuation">[</span>b<span class="token punctuation">.</span>first<span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>b<span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">minHeap</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 初始时，把 nums1 的前 k 个和 nums2[0] 组成的 pair 放入堆中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            minHeap<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minHeap<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minHeap<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 推进 nums2 的索引</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-interview-150">295. Find Median from Data Stream</a></h2><p>Solution: #Heap</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MedianFinder</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> maxHeap<span class="token punctuation">;</span> <span class="token comment">// 最大堆：存较小的一半</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> minHeap<span class="token punctuation">;</span> <span class="token comment">// 最小堆：存较大的一半</span>    <span class="token function">MedianFinder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">void</span> <span class="token function">addNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        maxHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        minHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        maxHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            maxHeap<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            minHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">double</span> <span class="token function">findMedian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> maxHeap<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a><a href="https://leetcode.com/problems/add-binary/description/?envType=study-plan-v2&envId=top-interview-150">67. Add Binary</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">addBinary</span><span class="token punctuation">(</span>string a<span class="token punctuation">,</span> string b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">||</span> carry<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> carry<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> sum <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> sum <span class="token operator">+=</span> b<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token keyword">char</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token operator">+</span> res<span class="token punctuation">;</span>            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a><a href="https://leetcode.com/problems/reverse-bits/description/?envType=study-plan-v2&envId=top-interview-150">190. Reverse Bits</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">uint32_t</span> <span class="token function">reverseBits</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">uint32_t</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// 1. 结果左移一位，为下一位腾出空间</span>        ans <span class="token operator">|=</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 2. 把 n 的最低位加到结果末尾</span>        n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// 3. n 右移，准备处理下一位</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a><a href="https://leetcode.com/problems/number-of-1-bits/description/?envType=study-plan-v2&envId=top-interview-150">191. Number of 1 Bits</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">hammingWeight</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">32</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            n <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a><a href="https://leetcode.com/problems/single-number/description/?envType=study-plan-v2&envId=top-interview-150">136. Single Number</a></h2><p>Solution: XOR</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span> result <span class="token operator">^=</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="137-Single-Number-II"><a href="#137-Single-Number-II" class="headerlink" title="137. Single Number II"></a><a href="https://leetcode.com/problems/single-number-ii/description/?envType=study-plan-v2&envId=top-interview-150">137. Single Number II</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ones <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> twos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 模拟三进制计数器</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            ones <span class="token operator">=</span> <span class="token punctuation">(</span>ones <span class="token operator">^</span> num<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>twos<span class="token punctuation">;</span>            twos <span class="token operator">=</span> <span class="token punctuation">(</span>twos <span class="token operator">^</span> num<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>ones<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ones<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="201-Bitwise-AND-of-Numbers-Range"><a href="#201-Bitwise-AND-of-Numbers-Range" class="headerlink" title="201. Bitwise AND of Numbers Range"></a><a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/description/?envType=study-plan-v2&envId=top-interview-150">201. Bitwise AND of Numbers Range</a></h2><p>Solution: #Bit Manipulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rangeBitwiseAnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> shift <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            left <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>            right <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>            shift<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> left <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a><a href="https://leetcode.com/problems/palindrome-number/description/?envType=study-plan-v2&envId=top-interview-150">9. Palindrome Number</a></h2><p>Solution: #String</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        string tmp <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> tmp <span class="token operator">==</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: 只反转整数的一半数字，然后与剩余一半做比较。每次取出 x 的最后一位，加到 check 的末尾。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> check <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">></span> check<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            check <span class="token operator">=</span> check <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> check <span class="token operator">||</span> x <span class="token operator">==</span> check <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a><a href="https://leetcode.com/problems/plus-one/description/?envType=study-plan-v2&envId=top-interview-150">66. Plus One</a></h2><p>Solution: #Simulation</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">plusOne</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> digits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> digits<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> digits<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 所有数字都是 9，比如 [9,9,9]</span>        digits<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> digits<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="172-Factorial-Trailing-Zeroes"><a href="#172-Factorial-Trailing-Zeroes" class="headerlink" title="172. Factorial Trailing Zeroes"></a><a href="https://leetcode.com/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&envId=top-interview-150">172. Factorial Trailing Zeroes</a></h2><p>Solution: #Math</p><p>直接计算 <code>n!</code> 然后数有几个 0 —— 对小数字可以，但 n! 增长极快，很容易溢出。</p><p>每一个末尾的 0 来自于乘以 <code>10</code>，而 <code>10 = 2 × 5</code>。</p><p>所以我们只需要统计在 n! 的所有乘数中，一共有多少个 成对的 <code>2 × 5</code>。</p><p>但显然，2 的个数永远比 5 多，所以只需要 统计多少个 5 就可以了！</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">trailingZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            n <span class="token operator">/=</span> <span class="token number">5</span><span class="token punctuation">;</span>            cnt <span class="token operator">+=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cnt<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a><a href="https://leetcode.com/problems/sqrtx/description/?envType=study-plan-v2&envId=top-interview-150">69. Sqrt(x)</a></h2><p>Solution: #Binary Search</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mid <span class="token operator">&lt;=</span> x <span class="token operator">/</span> mid <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> x <span class="token operator">/</span> <span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">/</span> mid <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode.com/problems/powx-n/description/?envType=study-plan-v2&envId=top-interview-150">50. Pow(x, n)</a></h2><p>Solution: #快速幂</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> N <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 避免 n == INT_MIN 溢出</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            x <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">;</span>            N <span class="token operator">=</span> <span class="token operator">-</span>N<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">fastPow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">double</span> <span class="token function">fastPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> half <span class="token operator">=</span> <span class="token function">fastPow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> half <span class="token operator">*</span> half<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> half <span class="token operator">*</span> half <span class="token operator">*</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">INT_MIN <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span><span class="token operator">-</span>INT_MIN <span class="token operator">=</span> <span class="token number">2147483648</span> ❌溢出了 <span class="token keyword">int</span> 范围<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>使用迭代的方法：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">double</span> <span class="token function">myPow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> N <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            x <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">;</span>            N <span class="token operator">=</span> <span class="token operator">-</span>N<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>N <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> res <span class="token operator">*=</span> x<span class="token punctuation">;</span>            x <span class="token operator">*=</span> x<span class="token punctuation">;</span>            N <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="149-Max-Points-on-a-Line"><a href="#149-Max-Points-on-a-Line" class="headerlink" title="149. Max Points on a Line"></a><a href="https://leetcode.com/problems/max-points-on-a-line/description/?envType=study-plan-v2&envId=top-interview-150">149. Max Points on a Line</a></h2><p>Solution: #Math</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">gcd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">:</span> <span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxPoints</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> points<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">int</span> maxResult <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            map<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> slopeCount<span class="token punctuation">;</span>            <span class="token keyword">int</span> overlap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> curMax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> x1 <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y1 <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> x2 <span class="token operator">=</span> points<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y2 <span class="token operator">=</span> points<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> dx <span class="token operator">=</span> x2 <span class="token operator">-</span> x1<span class="token punctuation">;</span>                <span class="token keyword">int</span> dy <span class="token operator">=</span> y2 <span class="token operator">-</span> y1<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dx <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    overlap<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">int</span> g <span class="token operator">=</span> <span class="token function">gcd</span><span class="token punctuation">(</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">)</span><span class="token punctuation">;</span>                dx <span class="token operator">/=</span> g<span class="token punctuation">;</span>                dy <span class="token operator">/=</span> g<span class="token punctuation">;</span>                <span class="token comment">// 统一斜率方向</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dx <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dx <span class="token operator">=</span> <span class="token operator">-</span>dx<span class="token punctuation">;</span>                    dy <span class="token operator">=</span> <span class="token operator">-</span>dy<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                slopeCount<span class="token punctuation">[</span><span class="token punctuation">&#123;</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                curMax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>curMax<span class="token punctuation">,</span> slopeCount<span class="token punctuation">[</span><span class="token punctuation">&#123;</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            maxResult <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxResult<span class="token punctuation">,</span> curMax <span class="token operator">+</span> overlap <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> maxResult<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><a href="https://leetcode.com/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-interview-150">70. Climbing Stairs</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">solve</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> mp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">solve</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Iteration</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> prev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            tmp <span class="token operator">=</span> curr<span class="token punctuation">;</span>            curr <span class="token operator">=</span> prev <span class="token operator">+</span> curr<span class="token punctuation">;</span>            prev <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> curr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode.com/problems/house-robber/description/?envType=study-plan-v2&envId=top-interview-150">198. House Robber</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a><a href="https://leetcode.com/problems/word-break/description/?envType=study-plan-v2&envId=top-interview-150">139. Word Break</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">wordSet</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wordDict<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                string word <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i <span class="token operator">-</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>wordSet<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">!=</span> wordSet<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化：#Memoization</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> wordSet<span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> memo<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>wordSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        wordSet <span class="token operator">=</span> <span class="token generic-function"><span class="token function">unordered_set</span><span class="token generic class-name"><span class="token operator">&lt;</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span>wordDict<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wordDict<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode.com/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150">322. Coin Change</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coins<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> INT_MAX<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-interview-150">300. Longest Increasing Subsequence</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">)</span> result <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a><a href="https://leetcode.com/problems/triangle/description/?envType=study-plan-v2&envId=top-interview-150">120. Triangle</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minimumTotal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> triangle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> triangle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp <span class="token operator">=</span> triangle<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化为最后一层</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="64-Minimum-Path-Sum"><a href="#64-Minimum-Path-Sum" class="headerlink" title="64. Minimum Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150">64. Minimum Path Sum</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化第一列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 初始化第一行</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的方法：#1D DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a><a href="https://leetcode.com/problems/unique-paths-ii/description/?envType=study-plan-v2&envId=top-interview-150">63. Unique Paths II</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> obstacleGrid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> obstacleGrid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #Memoization</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">numberOfPaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> obs<span class="token punctuation">,</span> <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> m <span class="token operator">||</span> j <span class="token operator">==</span> n <span class="token operator">||</span> obs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> down <span class="token operator">=</span> <span class="token function">numberOfPaths</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> obs<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">numberOfPaths</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> obs<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> down <span class="token operator">+</span> right<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> obstacleGrid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        m <span class="token operator">=</span> obstacleGrid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> obstacleGrid<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">numberOfPaths</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> obstacleGrid<span class="token punctuation">,</span> dp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-interview-150">5. Longest Palindromic Substring</a></h2><p>Solution: #Brute Force</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">></span> max_len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            max_len <span class="token operator">=</span> j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                            start_index <span class="token operator">=</span> i<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span> max_len<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 单个字符是回文</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">></span> maxLen<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                            maxLen <span class="token operator">=</span> len<span class="token punctuation">;</span>                            start <span class="token operator">=</span> i<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> maxLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="97-Interleaving-String"><a href="#97-Interleaving-String" class="headerlink" title="97. Interleaving String"></a><a href="https://leetcode.com/problems/interleaving-string/description/?envType=study-plan-v2&envId=top-interview-150">97. Interleaving String</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isInterleave</span><span class="token punctuation">(</span>string s1<span class="token punctuation">,</span> string s2<span class="token punctuation">,</span> string s3<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m <span class="token operator">+</span> n <span class="token operator">!=</span> s3<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s3<span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s3<span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a><a href="https://leetcode.com/problems/edit-distance/description/?envType=study-plan-v2&envId=top-interview-150">72. Edit Distance</a></h2><p>Solution: #DP</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>string word1<span class="token punctuation">,</span> string word2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>word1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> word2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&envId=top-interview-150">123. Best Time to Buy and Sell Stock III</a></h2><p>Solution: #DP</p><table><thead><tr><th>状态编号</th><th>状态描述</th></tr></thead><tbody><tr><td>0</td><td>什么都没做（初始状态）</td></tr><tr><td>1</td><td>第一次买入</td></tr><tr><td>2</td><td>第一次卖出</td></tr><tr><td>3</td><td>第二次买入</td></tr><tr><td>4</td><td>第二次卖出（最终状态）</td></tr></tbody></table><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/?envType=study-plan-v2&envId=top-interview-150">188. Best Time to Buy and Sell Stock IV</a></h2><p>Solution: #DP</p><p>设<code>dp[i][j]</code>表示：</p><blockquote><p>第<code>i</code>天结束时，执行到第<code>j</code>个状态（买入&#x2F;卖出操作）的最大收益。</p></blockquote><p>把交易过程拆成 2*k 个状态：</p><ul><li>奇数状态（1, 3, …, 2k-1）是<code>买入操作后</code>的状态</li><li>偶数状态（2, 4, …, 2k）是<code>卖出操作后</code>的状态</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a><a href="https://leetcode.com/problems/maximal-square/description/?envType=study-plan-v2&envId=top-interview-150">221. Maximal Square</a></h2><p>Solution: #DP</p><p>定义一个二维数组<code>dp[i][j]</code>表示：</p><blockquote><p>以<code>matrix[i][j]</code>作为正方形右下角时，最大的正方形边长是多少。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maximalSquare</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    maxLen <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxLen<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> maxLen <span class="token operator">*</span> maxLen<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="完结撒花🎉"><a href="#完结撒花🎉" class="headerlink" title="完结撒花🎉"></a>完结撒花🎉</h2><p>总的来讲，涉及到回溯，动态规划还有比特位运算的一些问题，我还是比较苦手的ToT；不过好在完成了一项壮举，还是坚持下来了哈哈。短时间，我都不想碰这些算法题目了，接下来还是做一点Project的设计和优化吧。 — 2025&#x2F;5&#x2F;21</p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Formal Language and Automata</title>
    <link href="/2025/01/08/automata/"/>
    <url>/2025/01/08/automata/</url>
    
    <content type="html"><![CDATA[<h1 id="Formal-Language-and-Automata"><a href="#Formal-Language-and-Automata" class="headerlink" title="Formal Language and Automata"></a>Formal Language and Automata</h1><p>关于形式语言与自动机技术这门课我认为内容非常的少，考生只需要掌握正则语言，上下文无关语言以及其对应的自动机模型就可以了。自动机里面的状态转移图和数字电路中的时序电路设计有异曲同工之妙。我觉得这门课是一门很需要脑筋急转弯的课程…To learn this course, you have to preview <code>Data Structure &amp; Algorithm</code></p><p><strong>Reference：</strong></p><ol><li>哈工大Mooc by 王春雨</li><li>MIT Sisper</li></ol><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>形式语言与自动机技术这门课的内容包括：</p><ul><li>形式语言：定义计算语言的方式（正则语言、上下文无关语言等）。</li><li>自动机：描述语言识别的数学模型（有限自动机、下推自动机等）。</li><li>计算理论：讨论问题是否可以通过算法解决（可计算性）以及解决问题的资源消耗（复杂性）。</li></ul><p>首先在学习这门课，我们需要认识一些自动机所需要的一些表示方法。这些表示方法在我们的有穷自动机和下推自动机同样适用。</p><h3 id="1-1-字母表（Alphabet）"><a href="#1-1-字母表（Alphabet）" class="headerlink" title="1.1 字母表（Alphabet）"></a>1.1 字母表（Alphabet）</h3><p>在形式语言与自动机中，<strong>字母表（Alphabet）</strong> 是一个基本的概念，它是用于构造语言的最小组成单位。字母表（通常记为 $\Sigma$）是一个<strong>有限的符号集合</strong>，其中的每个符号称为一个<strong>字母</strong>。</p><p>例如：</p><ul><li>$\Sigma &#x3D; \{a, b\}$ 表示一个字母表，包含两个字母 $a$ 和 $b$。</li><li>$\Sigma &#x3D; \{0, 1\}$ 表示一个二进制字母表。</li><li>$\Sigma &#x3D; \{x, y, z\}$ 表示一个包含三个符号的字母表。</li></ul><p>字母表是<strong>字符串</strong>和<strong>语言</strong>的基础：</p><ol><li><p><strong>字符串</strong>：是由字母表中的符号按一定顺序排列而成的有限序列。</p><ul><li>例如：对 $\Sigma &#x3D; \{a, b\}$，字符串可以是 $a$, $b$, $ab$, $bba$ 等。</li><li>空字符串用 $\epsilon$ 表示，表示长度为 0 的字符串。</li></ul></li><li><p><strong>语言</strong>：是字母表上所有字符串的某个子集。</p><ul><li>例如：对于 $\Sigma &#x3D; \{a, b\}$，语言可以是所有以 $a$ 开头的字符串 $\{a, ab, abb, \dots\}$。</li></ul></li></ol><p><strong>注意事项</strong></p><ul><li>字母表是有限的，但基于字母表生成的字符串集合可能是<strong>无限的</strong>。</li><li>字母表的大小和定义取决于具体问题的需求。</li></ul><h3 id="1-2-字符串（String）"><a href="#1-2-字符串（String）" class="headerlink" title="1.2 字符串（String）"></a>1.2 字符串（String）</h3><p>在形式语言与自动机中，<strong>字符串（String）</strong> 是一个由字母表中符号按一定顺序排列而成的<strong>有限序列</strong>。字符串的定义如下</p><ol><li><p>给定字母表 $\Sigma$（一个有限符号集合），字符串是由 $\Sigma$ 中的符号组成的一个<strong>有限长度序列</strong>。</p><ul><li>例如：若 $\Sigma &#x3D; \{a, b\}$，字符串可以是 $a$, $b$, $ab$, $bba$ 等。</li></ul></li><li><p>字符串的<strong>长度</strong>是序列中符号的个数，记为 $|w|$，其中 $w$ 是字符串。</p><ul><li>例如：若 $w &#x3D; abba$，则 $|w| &#x3D; 4$。</li></ul></li><li><p>特殊情况：<strong>空字符串</strong>表示长度为 $0$ 的字符串，用符号 $\epsilon$ 表示。</p><ul><li>$\epsilon$ 是唯一的长度为 $0$ 的字符串，即 $|\epsilon| &#x3D; 0$。</li><li>注意，$\epsilon \notin \Sigma$ ，下面简单辨析一下<ul><li>字母表 $\Sigma$ 是一个有限符号的集合，表示语言构造的基本单位。它仅包含单个符号，不包括空字符串。</li><li>空字符串 $\epsilon$ 是字符串的概念，它表示一个长度为 $0$ 的特殊字符串，而不是字母表中的符号。</li></ul></li></ul></li></ol><p><strong>常见的字符串的操作:</strong></p><ol><li><p><strong>连接</strong>：将两个字符串首尾相接形成新字符串。</p><ul><li>若 $w_1 &#x3D; ab$ 且 $w_2 &#x3D; ba$，则 $w_1w_2 &#x3D; abba$。</li></ul></li><li><p><strong>幂运算</strong>：将字符串自身重复多次，记为 $w^n$（$n \geq 0$）。</p><ul><li>例如：若 $w &#x3D; ab$，则 $w^0 &#x3D; \epsilon$，$w^1 &#x3D; ab$，$w^2 &#x3D; abab$。</li></ul></li><li><p><strong>反转</strong>：将字符串的符号顺序倒置。</p><ul><li>例如：若 $w &#x3D; abba$，则 $w^R &#x3D; abba$。</li></ul></li></ol><p>下文会对常见的字符串操作进行详细推导。</p><p><strong>字符串与语言的区别</strong></p><ul><li>字符串是语言的基本组成单位。</li><li><strong>语言（Language）</strong> 是字母表上所有可能字符串的某个子集。</li></ul><p>示例</p><ul><li>若 $\Sigma &#x3D; \{0, 1\}$，可能的字符串包括：$0$, $1$, $01$, $10$, $001$, 等。</li><li>空字符串 $\epsilon$ 始终是 $\Sigma^*$  的成员（ $\Sigma^*$  是所有字符串的集合）。</li></ul><hr><h4 id="1-2-1-字符串长度的定义"><a href="#1-2-1-字符串长度的定义" class="headerlink" title="1.2.1 字符串长度的定义"></a>1.2.1 字符串长度的定义</h4><p>在形式语言与自动机理论中，字符串长度是指字符串中所包含的字符个数。设 $\Sigma$ 是一个字母表（字符的有限集合），一个字符串 $w$ 是由字母表中字符的有限序列。字符串的长度用 $|w|$ 表示，其含义是 $w$ 中字符的个数：</p><ul><li><strong>空字符串</strong> $\varepsilon$：长度为 $0$，即 $|\varepsilon| &#x3D; 0$。</li><li><strong>非空字符串</strong>：长度为字符串中所有字符的个数。</li></ul><p>例如：</p><ul><li>$w &#x3D; \text{abc}$，则 $|w| &#x3D; 3$；</li><li>$w &#x3D; \varepsilon$，则 $|w| &#x3D; 0$。</li></ul><p>字符串长度 $|w|$ 可以通过<strong>递归方式</strong>定义如下：</p><ol><li><p><strong>基例</strong>（Base case）：<br>如果 $w &#x3D; \varepsilon$（空字符串），那么 $|w| &#x3D; 0$。</p></li><li><p><strong>递归关系</strong>（Recursive case）：<br>如果 $w &#x3D; xa$，其中 $x \in \Sigma^*$（是字母表 $\Sigma$ 的某个字符串）且 $a \in \Sigma$（是字母表中的一个字符），那么：<br>$$<br>|w| &#x3D; |x| + 1<br>$$</p></li></ol><hr><p><strong>推导过程示例</strong>：以字符串 $w &#x3D; \text{abc}$ 为例，设字母表 $\Sigma &#x3D; \{a, b, c\}$：</p><ol><li><p>$w &#x3D; \text{abc}$，将其视为 $x &#x3D; \text{ab}$ 和 $a &#x3D; \text{c}$，则：<br>$$<br>|w| &#x3D; |\text{ab}| + 1<br>$$</p></li><li><p>对 $|\text{ab}|$ 递归分解：<br>$$<br>|\text{ab}| &#x3D; |\text{a}| + 1<br>$$</p></li><li><p>对 $|\text{a}|$ 再递归分解：<br>$$<br>|\text{a}| &#x3D; |\varepsilon| + 1 &#x3D; 0 + 1 &#x3D; 1<br>$$</p></li><li><p>反向合并计算：<br>$$<br>|\text{ab}| &#x3D; 1 + 1 &#x3D; 2<br>$$<br>$$<br>|\text{abc}| &#x3D; 2 + 1 &#x3D; 3<br>$$</p></li></ol><p>字符串长度的递归定义可以表示为：</p><p>$$<br>|w| &#x3D;<br>\begin{cases}<br>0 &amp; \text{if } w &#x3D; \varepsilon \\<br>|x| + 1 &amp; \text{if } w &#x3D; xa, x \in \Sigma^*,  a \in \Sigma<br>\end{cases}<br>$$</p><hr><h4 id="1-2-2-字符串连接的定义"><a href="#1-2-2-字符串连接的定义" class="headerlink" title="1.2.2 字符串连接的定义"></a>1.2.2 字符串连接的定义</h4><p>在形式语言与自动机理论中，<strong>字符串连接</strong>（String Concatenation）是指将两个字符串按顺序组合在一起，形成一个新的字符串。连接操作是形式语言中一个非常重要的基本操作，通常用符号 “$\cdot$” 或直接用空格来表示。</p><p>给定两个字符串 $w_1$ 和 $w_2$，它们分别属于字母表 $\Sigma$ 上的语言 $\Sigma^*$，则它们的连接 $w_1 \cdot w_2$（或写作 $w_1 w_2$）是一个新的字符串，表示将 $w_1$ 和 $w_2$ 顺序连接在一起，形成一个新字符串。</p><p>形式上，假设：</p><ul><li>$w_1 &#x3D; x_1 x_2 \dots x_m$，其中 $x_1, x_2, \dots, x_m \in \Sigma$，是一个长度为 $m$ 的字符串；</li><li>$w_2 &#x3D; y_1 y_2 \dots y_n$，其中 $y_1, y_2, \dots, y_n \in \Sigma$，是一个长度为 $n$ 的字符串。</li></ul><p>那么，$w_1 \cdot w_2 &#x3D; x_1 x_2 \dots x_m y_1 y_2 \dots y_n$，是一个长度为 $m+n$ 的新字符串。</p><p><strong>字符串连接操作的基本性质：</strong></p><ol><li><p><strong>结合律</strong>（Associativity）：  字符串连接满足结合律，即对于任意三个字符串 $w_1, w_2, w_3 \in \Sigma^*$，都有：<br>$$<br>(w_1 \cdot w_2) \cdot w_3 &#x3D; w_1 \cdot (w_2 \cdot w_3)<br>$$</p></li><li><p><strong>单位元</strong>（Identity element）：  空字符串 $\varepsilon$ 是连接操作的单位元，即对于任何字符串 $w \in \Sigma^*$，都有：<br>$$<br>w \cdot \varepsilon &#x3D; \varepsilon \cdot w &#x3D; w<br>$$</p></li></ol><p>字符串连接示例：假设字母表 $\Sigma &#x3D; {a, b}$，考虑以下字符串：</p><ul><li>$w_1 &#x3D; \text{ab}$，</li><li>$w_2 &#x3D; \text{ba}$。</li></ul><p>它们的连接 $w_1 \cdot w_2$ 为：<br>$$<br>w_1 \cdot w_2 &#x3D; \text{ab} \cdot \text{ba} &#x3D; \text{abba}<br>$$</p><hr><p>字符串连接的递归表达式可以通过分段函数的方式来定义。假设 $w_1$ 和 $w_2$ 是两个字符串，递归地定义它们的连接操作 $w_1 \cdot w_2$ 如下：</p><p>$$<br>w_1 \cdot w_2 &#x3D;<br>\begin{cases}<br>w_2, &amp; \text{if } w_1 &#x3D; \varepsilon \\<br>x_1 \cdot (x_2 \cdot \dots \cdot (x_m \cdot w_2)), &amp; \text{if } w_1 &#x3D; x_1 x_2 \dots x_m \text{ and } m &gt; 0<br>\end{cases}<br>$$</p><ol><li><p><strong>基例</strong>（Base case）：  如果 $w_1 &#x3D; \varepsilon$（空字符串），则有：<br>$$<br>\varepsilon \cdot w_2 &#x3D; w_2<br>$$</p></li><li><p><strong>递归关系</strong>（Recursive case）：  如果 $w_1 &#x3D; x_1 x_2 \dots x_m$，其中 $x_1, x_2, \dots, x_m \in \Sigma$，则递归地将 $w_1$ 分解成 $x_1$ 和剩下的部分 $x_2 \dots x_m$，然后将 $x_1$ 与递归结果 $x_2 \dots x_m \cdot w_2$ 连接：<br>$$<br>w_1 \cdot w_2 &#x3D; x_1 \cdot (x_2 \cdot \dots \cdot (x_m \cdot w_2))<br>$$</p></li></ol><p>假设我们有两个字符串 $w_1 &#x3D; \text{abc}$ 和 $w_2 &#x3D; \text{def}$，我们来逐步推导它们的连接过程。</p><ol><li><p>首先，$w_1 &#x3D; \text{abc}$，将其分解为 $w_1 &#x3D; x_1 x_2 x_3$，其中 $x_1 &#x3D; \text{a}$，$x_2 &#x3D; \text{b}$，$x_3 &#x3D; \text{c}$。</p></li><li><p>根据递归关系：<br>$$<br>w_1 \cdot w_2 &#x3D; \text{a} \cdot (\text{b} \cdot (\text{c} \cdot \text{def}))<br>$$</p><p>继续递归下去：<br>$$<br>\text{b} \cdot (\text{c} \cdot \text{def}) &#x3D; \text{b} \cdot \text{cdef}<br>$$</p><p>最终得到：<br>$$<br>\text{a} \cdot (\text{b} \cdot (\text{c} \cdot \text{def})) &#x3D; \text{abcdef}<br>$$</p><p>  因此，$w_1 \cdot w_2 &#x3D; \text{abcdef}$。</p></li></ol><hr><h4 id="1-2-3-字符串幂运算的定义"><a href="#1-2-3-字符串幂运算的定义" class="headerlink" title="1.2.3 字符串幂运算的定义"></a>1.2.3 字符串幂运算的定义</h4><p>在形式语言与自动机理论中，<strong>字符串的幂运算</strong>（String Power）是指将一个字符串自我连接若干次的操作。具体地，对于一个字符串 $w$ 和一个非负整数 $n$，$w^n$ 表示将字符串 $w$ 自我连接 $n$ 次。</p><p><strong>定义：</strong> 设 $w$ 是一个字符串，$n$ 是一个非负整数。字符串 $w$ 的幂 $w^n$ 的定义如下：</p><ul><li><p><strong>基例</strong>：当 $n &#x3D; 0$ 时，$w^0$ 被定义为空字符串 $\varepsilon$：<br>$$<br>w^0 &#x3D; \varepsilon<br>$$</p></li><li><p><strong>递归关系</strong>：当 $n &gt; 0$ 时，$w^n$ 被定义为将字符串 $w$ 连接 $n$ 次，即：<br>$$<br>w^n &#x3D; w \cdot w^{n-1} \quad \text{for } n &gt; 0<br>$$</p><p>这里，$\cdot$ 表示字符串连接操作。</p></li></ul><p><strong>字符串幂运算的性质：</strong></p><ol><li><p><strong>空字符串的幂</strong>：对于任意字符串 $w$，空字符串 $\varepsilon$ 的幂总是为空字符串：<br>$$<br>\varepsilon^n &#x3D;<br>\begin{cases}<br>\varepsilon, &amp; \text{if } n &#x3D; 0 \\<br>\text{undefined}, &amp; \text{if } n &gt; 0<br>\end{cases}<br>$$</p></li><li><p><strong>单位元素</strong>：对于任意字符串 $w$，有：<br>$$<br>w^0 &#x3D; \varepsilon \quad \text{(空字符串)}<br>$$<br>且对于任意正整数 $n$：<br>$$<br>w^1 &#x3D; w<br>$$</p></li><li><p><strong>结合律</strong>：字符串幂运算具有结合律。例如，对于任意字符串 $w$ 和非负整数 $n$、$m$，有：<br>$$<br>w^{n+m} &#x3D; w^n \cdot w^m<br>$$</p></li><li><p><strong>易错点辨析</strong>：对于任意字符串 $w_1$ 和 $w_2$，以及非负整数 $n$，字符串连接的幂运算并不满足分配律。具体地，<strong>字符串连接的幂</strong>遵循以下规律：<br>$$<br>(w_1 \cdot w_2)^n &#x3D; (w_1 w_2) \cdot (w_1 w_2) \cdot \dots \cdot (w_1 w_2) \quad \text{(总共 $n$ 次连接)}<br>$$</p><p>而不是将幂分配到每个字符串上：<br>$$<br>(w_1 \cdot w_2)^n \neq w_1^n \cdot w_2^n<br>$$</p><p><em>这是一个常见的误解。字符串连接的幂是按整体连接的，而不是按每个字符串的幂分别计算。</em></p></li></ol><hr><p><strong>示例：</strong> 假设字母表 $\Sigma &#x3D; {a, b}$，并且考虑字符串 $w &#x3D; \text{ab}$。</p><ol><li><p><strong>当 $n &#x3D; 0$</strong> 时：<br>$$<br>w^0 &#x3D; \varepsilon<br>$$</p></li><li><p><strong>当 $n &#x3D; 1$</strong> 时：<br>$$<br>w^1 &#x3D; \text{ab}<br>$$</p></li><li><p><strong>当 $n &#x3D; 2$</strong> 时：<br>$$<br>w^2 &#x3D; \text{ab} \cdot \text{ab} &#x3D; \text{abab}<br>$$</p></li><li><p><strong>当 $n &#x3D; 3$</strong> 时：<br>$$<br>w^3 &#x3D; \text{ab} \cdot \text{abab} &#x3D; \text{ababab}<br>$$</p></li></ol><p>通过这些示例，可以看出字符串的幂运算是将字符串 $w$ 自我连接多次，产生新的更长的字符串。</p><hr><p><strong>递推关系推导</strong>：假设字符串 $w &#x3D; x_1 x_2 \dots x_m$，其中 $x_1, x_2, \dots, x_m$ 是 $w$ 的各个字符。若 $w^n$ 表示字符串 $w$ 自我连接 $n$ 次，则递归定义如下：</p><ol><li><p><strong>基例</strong>：  当 $n &#x3D; 0$ 时，$w^0 &#x3D; \varepsilon$。</p></li><li><p><strong>递归关系</strong>：  当 $n &gt; 0$ 时：<br>$$<br>w^n &#x3D; w \cdot w^{n-1}<br>$$</p></li><li><p>因此我们可以写出递推表达式：</p></li></ol><p>$$<br>w&#x3D;<br>\begin{cases}<br>\epsilon,\quad n &#x3D; 0 \\<br>w \cdot w^{n-1}, \quad x&gt;0<br>\end{cases}<br>$$</p><hr><h4 id="1-2-4-字符串集合的定义"><a href="#1-2-4-字符串集合的定义" class="headerlink" title="1.2.4 字符串集合的定义"></a>1.2.4 字符串集合的定义</h4><p> 一个字符串是字母表中字符的有限序列，字符串的集合是字母表中所有可能字符串的集合。例如，字母表 $\Sigma &#x3D; \{a, b\}$ 中的所有可能的长度为 2 的字符串集合是：</p><p>$$<br>\{aa, ab, ba, bb\}<br>$$</p><p>在形式语言中，我们可以对字符串集合执行运算，常见的操作包括：</p><ol><li><p><strong>串联（Concatenation）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的串联 $L_1 \cdot L_2$ 是所有可能的通过将 $L_1$ 中的元素与 $L_2$ 中的元素连接而成的字符串集合。例如：</p><ul><li>若 $L_1 &#x3D; \{a, b\}$ 和 $L_2 &#x3D; \{c, d\}$，则：<br>$$<br>L_1 \cdot L_2 &#x3D; \{ac, ad, bc, bd\}<br>$$</li></ul></li><li><p><strong>闭包（Kleene Star）</strong>：给定一个语言 $L$，它的 <strong>Kleene 闭包</strong> $L^*$ 是所有 $L$ 中零个或多个字符串的串联集合，即：<br>$$<br>L^* &#x3D; \{\varepsilon\} \cup L \cup L^2 \cup L^3 \cup \dots<br>$$<br>其中，$\varepsilon$ 表示空字符串，$L^n$ 表示所有长度为 $n$ 的字符串的集合，$n \geq 0$。  </p><p>例如，假设 $L &#x3D; \{a, b\}$，则：<br>$$<br>L^* &#x3D; \{\varepsilon, a, b, aa, ab, ba, bb, aaa, aab, \dots \}<br>$$</p><ul><li><strong>正闭包（Positive Closure）</strong>：正闭包 $L^+$ 是由 $L$ 中一个或多个字符串的串联组成的集合。即：<br>$$<br>L^+ &#x3D; L \cup L^2 \cup L^3 \cup \dots<br>$$<br>正闭包可以看作是 Kleene 闭包去除空字符串部分。例如，如果 $L &#x3D; {a, b}$，则：<br>$$<br>L^+ &#x3D; \{a, b, aa, ab, ba, bb, aaa, aab, \dots\}<br>$$</li></ul></li><li><p><strong>并集（Union）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的并集 $L_1 \cup L_2$ 是包含 $L_1$ 和 $L_2$ 中所有字符串的语言集合。例如：</p><ul><li>若 $L_1 &#x3D; \{a, b\}$ 和 $L_2 &#x3D; \{c, d\}$，则：<br>$$<br>L_1 \cup L_2 &#x3D; \{a, b, c, d\}<br>$$</li></ul></li><li><p><strong>差集（Difference）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的差集 $L_1 \setminus L_2$ 是包含所有属于 $L_1$ 但不属于 $L_2$ 的字符串的语言集合。例如：</p><ul><li>若 $L_1 &#x3D; \{a, b, c\}$ 和 $L_2 &#x3D; \{b, c, d\}$，则：<br>$$<br>L_1 \setminus L_2 &#x3D; \{a\}<br>$$</li></ul></li><li><p><strong>集合的 n 次幂运算（n-th Power of a Set）</strong>：给定一个语言 $L$ 和一个非负整数 $n$，语言 $L$ 的 <strong>n 次幂</strong> $L^n$ 是由 $L$ 中所有长度为 $n$ 的字符串组成的集合。具体定义如下：</p><ul><li>当 $n &#x3D; 0$ 时，$L^0 &#x3D; \{\varepsilon\}$，即仅包含空字符串。</li><li>当 $n &gt; 0$ 时，$L^n$ 包含所有由 $L$ 中的字符串串联组成的长度为 $n$ 的字符串。例如：<ul><li>若 $L &#x3D; \{a, b\}$，则：<ul><li>$L^1 &#x3D; \{a, b\}$</li><li>$L^2 &#x3D; \{aa, ab, ba, bb\}$</li><li>$L^3 &#x3D; \{aaa, aab, aba, abb, baa, bab, bba, bbb\}$</li></ul></li></ul></li></ul><p>通过定义 $L^n$，我们可以理解语言中不同长度的字符串是如何通过多个字符串的串联来生成的。</p></li></ol><h3 id="1-3-语言（Language）"><a href="#1-3-语言（Language）" class="headerlink" title="1.3 语言（Language）"></a>1.3 语言（Language）</h3><p>语言（Language）是一个由字母表上的字符串组成的集合，字符串是字母表上符号的有限序列。形式语言通常是根据某种特定的规则或语法定义的字符串集合。形式语言广泛应用于计算机科学中的编程语言设计、编译原理、人工智能、自然语言处理等领域。</p><p>给定一个字母表 $\Sigma$，语言 $L$ 是 $\Sigma$ 上所有合法字符串的集合。我们可以使用集合表示语言，记作：<br>$$<br>L \subseteq \Sigma^*<br>$$<br>其中，$\Sigma^*$ 是字母表 $\Sigma$ 上所有可能的字符串的集合，包括空字符串 $\varepsilon$。</p><p><strong>字母表（Alphabet）</strong> 是构成语言中所有字符串的基本单位，是一个有限的符号集合，通常用 $\Sigma$ 表示。字母表的元素可以是任何字符、符号或数字。例如：</p><ul><li>二进制字母表：$\Sigma &#x3D; \{0, 1\}$</li><li>字母表：$\Sigma &#x3D; \{a, b, c, \dots\}$</li><li>十进制字母表：$\Sigma &#x3D; \{0, 1, 2, \dots, 9\}$</li></ul><p><strong>字符串</strong>是由字母表 $\Sigma$ 中的符号按照一定顺序排列组成的有限序列。字符串的长度是有限的，通常用 $w$ 表示一个字符串。常见的符号包括：</p><ul><li>空字符串 $\varepsilon$，表示一个不含任何符号的字符串。</li><li>字符串 $w$ 是字母表 $\Sigma$ 中的符号按顺序排列形成的一个有序序列。例如：<ul><li>如果 $\Sigma &#x3D; \{a, b\}$，则字符串 $w &#x3D; \text{ab}$ 是字母表 $\Sigma$ 中字符的一个序列。</li></ul></li></ul><p>字符串的长度是字符串中符号的数量，记作 $|w|$。例如：</p><ul><li>$|\varepsilon| &#x3D; 0$（空字符串的长度为零）</li><li>$|w| &#x3D; 3$，如果 $w &#x3D; \text{abc}$</li></ul><p>根据其生成规则或接受条件，语言可以分为以下几类：</p><ol><li><p><strong>正规语言（Regular Language）</strong>：正规语言是最简单的一类语言，可以由有限自动机（DFA&#x2F;NFA）接受或通过正规表达式表示。正规语言可以通过正规文法生成，并且有许多应用，如文本搜索、词法分析等。</p><ul><li>A language is called a regular language if some infinite automaton recognizes it</li></ul></li><li><p><strong>上下文无关语言（Context-Free Language）</strong>：上下文无关语言是由上下文无关文法（CFG）生成的语言。它们通常可以由推理自动机（如下推自动机）接受，广泛用于编程语言的语法分析。</p></li><li><p><strong>上下文相关语言（Context-Sensitive Language）</strong>：上下文相关语言是由上下文相关文法（CSG）生成的语言，通常由线性有界自动机接受。它们比上下文无关语言更强，但也更复杂。</p></li><li><p><strong>递归可枚举语言（Recursively Enumerable Language）</strong>：递归可枚举语言是可以通过图灵机接受的语言。它们可以包含一些不能有效计算的语言，是计算理论中的最广泛类。</p></li></ol><p><strong>特殊语言类型：</strong></p><ol><li><p><strong>空语言（Empty Language）</strong>：空语言是一个不包含任何字符串的集合，记作 $\emptyset$。例如，对于字母表 $\Sigma &#x3D; \{a, b\}$，如果定义的规则不允许任何字符串出现，那么该语言就是空语言：</p><p>$$<br>L &#x3D; \emptyset<br>$$</p><p>这里需要辨析下面的一个结论： $\emptyset$ 不包含任何元素，即：$|\emptyset| &#x3D; 0$（集合的大小为 0），而 $\{\varepsilon\}$ 包含一个具体的元素（空字符串）。</p><p>$$<br>\emptyset \neq \{\varepsilon\}<br>$$</p></li><li><p><strong>全集语言（Universal Language）</strong>：全集语言是包含字母表 $\Sigma$ 上所有可能字符串的语言，通常记作 $\Sigma^*$。它包含所有长度为任意数目的字符串，包括空字符串。例如：<br>$$<br>L &#x3D; \Sigma^* &#x3D; \{\varepsilon, a, b, ab, aa, ba, \dots \}<br>$$</p></li><li><p><strong>单一元素语言（Singleton Language）</strong>：单一元素语言是只包含一个字符串的语言。例如，若字母表为 $\Sigma &#x3D; \{a, b\}$，语言 $L &#x3D; \{ab\}$ 只有一个字符串元素：<br>$$<br>L &#x3D; \{ab\}<br>$$</p></li></ol><p><strong>语言的运算包括：</strong></p><ol><li><p><strong>串联（Concatenation）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的串联 $L_1 \cdot L_2$ 是所有可能通过将 $L_1$ 中的字符串与 $L_2$ 中的字符串连接起来得到的字符串的集合。</p></li><li><p><strong>并集（Union）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的并集 $L_1 \cup L_2$ 是包含所有属于 $L_1$ 或 $L_2$ 的字符串的集合。</p></li><li><p><strong>差集（Difference）</strong>：给定两个语言 $L_1$ 和 $L_2$，它们的差集 $L_1 \setminus L_2$ 是包含所有属于 $L_1$ 但不属于 $L_2$ 的字符串的集合。</p></li><li><p><strong>闭包（Closure）</strong>：</p><ul><li><strong>Kleene 闭包（Kleene Star）</strong>：语言 $L$ 的 Kleene 闭包 $L^*$ 是包含所有 $L$ 中零个或多个字符串串联的语言。</li><li><strong>正闭包（Positive Closure）</strong>：语言 $L$ 的正闭包 $L^+$ 是包含所有 $L$ 中一个或多个字符串串联的语言。</li></ul></li></ol><h2 id="2-Finite-Automata"><a href="#2-Finite-Automata" class="headerlink" title="2. Finite Automata"></a>2. Finite Automata</h2><p>有限自动机 (Finite Automaton, FA) 是一种理论模型，用来描述和识别形式语言中的某些类型的语言。它是自动机理论中的基础之一，广泛应用于计算机科学、编译原理、正则表达式等领域。本章内容我们需要熟悉并且掌握确定性有限自动机（DFA）和非确定性有限自动机 （NFA）</p><h3 id="2-1-DFA"><a href="#2-1-DFA" class="headerlink" title="2.1 DFA"></a>2.1 DFA</h3><p><strong>确定性有限自动机（DFA，Deterministic Finite Automaton）</strong> 是一种计算模型，用于识别正则语言。它由一个有限的状态集合组成，每次在一个特定的输入符号下，从某一状态转换到唯一的另一个状态，因此被称为“确定性”。</p><p>DFA 可以通过<strong>五元组</strong>来定义：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li><p><strong>Q</strong>：状态集，表示所有可能的状态。$ Q &#x3D; \{q_0, q_1, q_2, \dots, q_n\} $ 是有限的。</p></li><li><p><strong>Σ</strong>：输入字母表，是一个有限的符号集合，表示自动机可以接受的输入字符。通常 $ \Sigma &#x3D; \{a, b, \dots\} $。</p></li><li><p><strong>δ</strong>：转移函数，定义了每个状态在给定输入符号时的转移情况。对于任何状态 $ q_i \in Q $ 和输入符号 $ a \in \Sigma $，转移函数 δ 给出了唯一的下一状态 $ q_j \in Q $。即：<br>$$<br>\delta : Q \times \Sigma \to Q<br>$$</p></li><li><p><strong>q₀</strong>：初始状态，表示自动机开始时所处的状态。它是状态集 $ Q $ 中的一个元素，即 $ q_0 \in Q $。</p></li><li><p><strong>F</strong>：接受状态集，表示自动机在接受输入并成功识别一个字符串时所处的状态集合。$ F \subseteq Q $，是状态集 $ Q $ 的一个子集。</p></li></ul><p>DFA 是通过一个<strong>确定的过程</strong>来处理输入字符串的。它从初始状态 $ q_0 $ 开始，逐个读取输入字符串中的符号，并根据当前状态和输入符号，按照转移函数 $ \delta $ 进行状态转移。每次读取一个符号后，自动机都会进入一个新的状态。最终，输入串处理完毕后，如果自动机处于一个接受状态，则该输入字符串被接受；否则，它被拒绝。</p><p>DFA有如下性质：</p><ul><li><strong>确定性</strong>：在每个状态下，对于每一个输入符号，DFA都有一个唯一的转移状态。即不存在多个可能的状态转移。</li><li><strong>有限性</strong>：DFA有一个有限的状态集合，因此它只能识别有限的状态。</li></ul><hr><p>假设我们设计一个DFA来识别所有包含 <strong>偶数个0</strong> 的二进制字符串。这个语言的正则表达式是 $ (1^\ast 0 1^\ast 0)^\ast $。</p><ul><li><p>状态集 $ Q &#x3D; \{q_0, q_1\} $，其中：</p><ul><li>$ q_0 $ 表示当前读取的 0 的个数是偶数个（接受状态）。</li><li>$ q_1 $ 表示当前读取的 0 的个数是奇数个。</li></ul></li><li><p>输入字母表 $ \Sigma &#x3D; \{0, 1\} $。</p></li><li><p>转移函数 $ \delta $ 可以这样定义：</p><ul><li>$ \delta(q_0, 0) &#x3D; q_1 $（如果当前状态是 $ q_0 $，读取到 0 后转到 $ q_1 $）。</li><li>$ \delta(q_0, 1) &#x3D; q_0 $（如果当前状态是 $ q_0 $，读取到 1 后保持在 $ q_0 $）。</li><li>$ \delta(q_1, 0) &#x3D; q_0 $（如果当前状态是 $ q_1 $，读取到 0 后转到 $ q_0 $）。</li><li>$ \delta(q_1, 1) &#x3D; q_1 $（如果当前状态是 $ q_1 $，读取到 1 后保持在 $ q_1 $）。</li></ul></li><li><p>初始状态 $ q_0 $，因为一开始是偶数个 0。</p></li><li><p>接受状态集 $ F &#x3D; \{q_0\} $，即只有在状态 $ q_0 $ 时，DFA 才接受输入。</p></li></ul><p>DFA的状态转换示意图如下：</p><center><img src="/img/FL/dfa1.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><p>我们可以画一个状态转移表：</p><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$\text{*}q_0$</td><td>$q_1$</td><td>$q_0$</td></tr><tr><td>$q_1$</td><td>$q_0$</td><td>$q_1$</td></tr></tbody></table><ul><li><strong>初始状态</strong>：$q_0$</li><li><strong>接受状态</strong>：$q_0$（用 <code>*</code> 表示）</li></ul><p>假设输入字符串是 <code>1010</code>，我们来分析 DFA 的运行过程：</p><ul><li>初始状态 $q_0$。</li><li>读取第一个字符 ‘1’，根据转移函数 $ \delta(q_0, 1) &#x3D; q_0 $，仍然处于状态 $q_0$。</li><li>读取第二个字符 ‘0’，根据转移函数 $ \delta(q_0, 0) &#x3D; q_1 $，转到状态 $q_1$。</li><li>读取第三个字符 ‘1’，根据转移函数 $ \delta(q_1, 1) &#x3D; q_1 $，仍然处于状态 $q_1$。</li><li>读取第四个字符 ‘0’，根据转移函数 $ \delta(q_1, 0) &#x3D; q_0 $，转回状态 $q_0$。</li></ul><p>最终，自动机处于接受状态 $q_0$，因此输入字符串 “1010” 被接受。</p><hr><h4 id="2-1-1-DFA的扩展转移函数"><a href="#2-1-1-DFA的扩展转移函数" class="headerlink" title="2.1.1 DFA的扩展转移函数"></a>2.1.1 DFA的扩展转移函数</h4><p>在形式语言与自动机理论中，DFA的<strong>扩展转移函数</strong>（Extended Transition Function）是指在原始转移函数的基础上，对DFA的状态转移进行扩展，使其能够处理整个输入字符串，而不仅仅是单个符号。这个扩展函数通常表示为 $ \delta^* $，它允许我们对一个输入字符串进行逐个字符的状态转移。</p><p> <strong>扩展转移函数的定义</strong>：设定</p><ul><li><p>$\delta$ 是原始的转移函数，它是一个从状态和输入符号到下一个状态的映射：<br>$$<br>\delta : Q \times \Sigma \to Q<br>$$<br>其中，$Q$ 是状态集，$\Sigma$ 是输入字母表。</p></li><li><p><strong>扩展转移函数</strong>  $\delta^* : Q \times \Sigma^* \to Q$ ，它扩展了原始转移函数，使其能够接受任意长度的输入串，并返回最终的状态。</p></li></ul><p>形式化地，扩展转移函数定义为：</p><p>$$<br>\delta^*(q, \epsilon) &#x3D; q<br>$$</p><p>这里，$\epsilon$ 表示空串，表示在没有任何输入时，自动机保持在原状态 $q$。</p><p>对于一个非空的输入串 $w &#x3D; a_1 a_2 \dots a_n \in \Sigma^*$，扩展转移函数满足以下递归关系：</p><p>$$<br>\delta^*(q, a_1 a_2 \dots a_n) &#x3D; \delta(\delta^*(q, a_1 a_2 \dots a_{n-1}), a_n)<br>$$</p><p>即，扩展转移函数首先对前 $n-1$ 个符号计算转移，并最终得到最后一个符号的转移。</p><p>扩展转移函数允许我们一次性地处理整个输入串，而不是每次只处理一个符号。通过使用这个扩展函数，我们可以计算在输入串的每一个字符都被处理后的最终状态。这在计算是否接受某个字符串时非常有用，因为我们只需要检查自动机最终是否处于接受状态。</p><p>还是用上面的状态转移图举个例子</p><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$\text{*}q_0$</td><td>$q_1$</td><td>$q_0$</td></tr><tr><td>$q_1$</td><td>$q_0$</td><td>$q_1$</td></tr></tbody></table><p>初始状态是 $q_0$，接受状态是 $q_0$。</p><p>我们可以使用扩展转移函数来处理整个输入串。假设输入字符串是 $w &#x3D; 1010$。</p><ol><li>计算 $\delta^*(q_0, \epsilon) &#x3D; q_0$，即没有输入时，自动机仍然处于初始状态 $q_0$。</li><li>计算 $\delta^*(q_0, 1) &#x3D; \delta(q_0, 1) &#x3D; q_0$，读取第一个字符 ‘1’ 后，仍然处于状态 $q_0$。</li><li>计算 $\delta^*(q_0, 10) &#x3D; \delta(\delta^*(q_0, 1), 0) &#x3D; \delta(q_0, 0) &#x3D; q_1$，读取字符 ‘0’ 后，自动机转到状态 $q_1$。</li><li>计算 $\delta^*(q_1, 101) &#x3D; \delta(\delta^*(q_1, 10), 1) &#x3D; \delta(q_1, 1) &#x3D; q_1$，读取字符 ‘1’ 后，仍然处于状态 $q_1$。</li><li>计算 $\delta^*(q_1, 1010) &#x3D; \delta(\delta^*(q_1, 101), 0) &#x3D; \delta(q_1, 0) &#x3D; q_0$，读取最后一个字符 ‘0’ 后，自动机转回状态 $q_0$。</li></ol><p>最终，$\delta^*(q_0, 1010) &#x3D; q_0$，因为最终状态 $q_0$ 是接受状态，因此输入字符串 <code>1010</code>被接受。</p><p>最终总结一下，我们可以得出，DFA的扩展转移函数为：</p><p>$$<br>\delta^*(q, w) &#x3D;<br>\begin{cases}<br>q, &amp; \text{if } w &#x3D; \epsilon \\<br>\delta(\delta^*(q, w_1 w_2 \dots w_{n-1}), w_n), &amp; \text{if } w &#x3D; w_1 w_2 \dots w_n \text{ and } n &gt; 0<br>\end{cases}<br>$$</p><hr><h3 id="2-2-NFA"><a href="#2-2-NFA" class="headerlink" title="2.2 NFA"></a>2.2 NFA</h3><p><strong>非确定性有限自动机（NFA，Nondeterministic Finite Automaton）</strong> 是另一种计算模型，与DFA类似，NFA也用于识别正则语言。与DFA不同的是，NFA在每个状态下，给定某个输入符号时，可能存在多个不同的转移路径，或者在某些情况下甚至可以不进行任何状态转移。这就是它的“非确定性”特性。</p><p>NFA同样可以通过<strong>五元组</strong>来定义：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li><p><strong>Q</strong>：状态集，表示所有可能的状态。$ Q &#x3D; \{q_0, q_1, q_2, \dots, q_n\} $ 是有限的。</p></li><li><p><strong>Σ</strong>：输入字母表，是一个有限的符号集合，表示自动机可以接受的输入字符。通常 $\Sigma &#x3D; \{a, b, \dots\}$。</p></li><li><p><strong>δ</strong>：转移函数，定义了每个状态在给定输入符号时的转移情况。与DFA不同，NFA的转移函数允许多个可能的下一状态，或者在某些状态下，输入符号可能不产生任何转移（即允许空转移）。因此，转移函数 $\delta$ 是从状态集到状态集的映射：<br>$$<br>\delta : Q \times \Sigma \to 2^Q<br>$$<br>其中 $2^Q$ 表示状态集的幂集，表示可能的多个目标状态。</p></li><li><p><strong>q₀</strong>：初始状态，表示自动机开始时所处的状态。它是状态集 $Q$ 中的一个元素，即 $q_0 \in Q$。</p></li><li><p><strong>F</strong>：接受状态集，表示自动机在接受输入并成功识别一个字符串时所处的状态集合。$F \subseteq Q$，是状态集 $Q$ 的一个子集。</p></li></ul><p>NFA处理输入字符串的方式与DFA相似，但是在每个步骤中，NFA可以选择不同的状态转移，或者在某些输入符号下可能没有任何状态转移。NFA并不是沿着一个确定的路径处理输入，而是沿着所有可能的路径并行地进行状态转移。最终，NFA接受输入字符串当且仅当存在至少一条路径能够让它停留在接受状态。</p><p>NFA与DFA的<strong>主要区别：</strong></p><ul><li><strong>非确定性</strong>：在每个状态下，对于每一个输入符号，NFA可以有多个可能的转移状态，或者根本没有转移（空转移）。</li><li><strong>空转移（ε-转移）</strong>：NFA可以有空转移，即在没有任何输入符号的情况下，从一个状态转移到另一个状态。下文会讲解ε-NFA和NFA等价。</li></ul><hr><p>假设我们设计一个NFA来识别所有包含 <strong>至少一个1</strong> 的二进制字符串。这个语言的正则表达式是 $(0|1)^* 1(0|1)^*$。</p><ul><li><p>状态集 $Q &#x3D; \{q_0, q_1\}$，其中：</p><ul><li>$q_0$ 是我们尚未看到任何1的状态</li><li>$q_1$ 是我们已经至少看到一个1的状态</li></ul></li><li><p>输入字母表 $\Sigma &#x3D; \{0, 1\}$</p></li><li><p>转移函数 $\delta$ 定义如下：</p><ul><li>$\delta(q_0, 0) &#x3D; \{q_0\}$（在初始状态读到0，继续等待1的出现）</li><li>$\delta(q_0, 1) &#x3D; \{q_1\}$（在初始状态读到1，转移到接受状态）</li><li>$\delta(q_1, 0) &#x3D; \{q_1\}$（已经看到1后，读到0保持在接受状态）</li><li>$\delta(q_1, 1) &#x3D; \{q_1\}$（已经看到1后，读到1保持在接受状态）</li></ul></li><li><p>初始状态 $q_0$（自然从未读取到1的状态开始）</p></li><li><p>接受状态集 $F &#x3D; \{q_1\}$（只要曾经读取到1，就应该接受）</p></li></ul><p>我们可以用状态转移表来更清晰地展示：</p><center><img src="/img/FL/nfa1.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$q_0$</td><td>${q_0}$</td><td>${q_1}$</td></tr><tr><td>$\text{*}q_1$</td><td>${q_1}$</td><td>${q_1}$</td></tr></tbody></table><ul><li><strong>初始状态</strong>：$q_0$</li><li><strong>接受状态</strong>：$q_1$（用 <code>*</code> 表示）</li></ul><p>让我们分析当输入字符串为 “0110” 时NFA的运行过程：</p><ol><li>从初始状态 $q_0$ 开始</li><li>读取第一个字符 ‘0’：$\delta(q_0, 0) &#x3D; \{q_0\}$，保持在状态 $q_0$</li><li>读取第二个字符 ‘1’：$\delta(q_0, 1) &#x3D; \{q_1\}$，转移到状态 $q_1$</li><li>读取第三个字符 ‘1’：$\delta(q_1, 1) &#x3D; \{q_1\}$，保持在状态 $q_1$</li><li>读取第四个字符 ‘0’：$\delta(q_1, 0) &#x3D; \{q_1\}$，保持在状态 $q_1$</li></ol><p>由于最终停在接受状态 $q_1$，因此字符串 <code>0110</code> 被接受。这符合我们的预期，因为它确实包含至少一个1（实际上包含两个1）。</p><hr><p>再来看一个例子。设计接受全部<strong>以<code>01</code>结尾的串</strong>的NFA。</p><p>首先，自动机需要能够识别所有以 <code>01</code> 结尾的字符串，而不关注字符串前面的部分。我们需要理解这个语言接受什么样的字符串：</p><ul><li>“01” 应该被接受</li><li>“101” 应该被接受</li><li>“1101” 应该被接受</li><li>“11101” 应该被接受</li><li>但 “011” 不应该被接受（因为中间有0）</li><li>“10” 不应该被接受（没有以01结尾）</li></ul><p>接下来是我们的解题步骤</p><ol><li><p><strong>定义状态集 Q</strong>：</p><ul><li>我们需要设计的 NFA 至少有三个状态：<ul><li>$q_0$：初始状态，表示当前没有识别到“01”结尾。</li><li>$q_1$：表示已经读取了一个 <code>0</code>，即我们已经识别到了 <code>0</code>，等待接收 <code>1</code> 作为结束符。</li><li>$q_2$：接受状态，表示已经识别到 <code>01</code> 结尾，自动机接受字符串。</li></ul></li></ul></li><li><p><strong>定义输入字母表 Σ</strong>：</p><ul><li>由于字符串只由字符 <code>0</code> 和 <code>1</code> 构成，字母表为：$ \Sigma &#x3D; \{0, 1\} $。</li></ul></li><li><p><strong>定义转移函数 δ</strong>：</p><ul><li>$ \delta(q_0, 1) &#x3D; \{q_0\} $：如果当前状态是 $q_0$，输入 <code>1</code> 后仍然处于 $q_0$，表示读取 <code>1</code> 不影响结尾是否为 <code>01</code>。</li><li>$ \delta(q_0, 0) &#x3D; \{q_1\} $：如果当前状态是 $q_0$，输入 <code>0</code> 后转移到 $q_1$，表示遇到了一个 <code>0</code>，准备接受接下来的 <code>1</code>；还有一种情况是当前输入的<code>0</code>并不是倒数第二个字符，因此停留在$q_0$</li><li>$ \delta(q_1, 1) &#x3D; \{q_2\} $：如果当前状态是 $q_1$，输入 <code>1</code> 后转移到 $q_2$，表示成功识别到了以 <code>01</code> 结尾；</li><li>$ \delta(q_1, 0) &#x3D; \{q_1\} $：如果当前状态是 $q_1$，输入 <code>0</code> 后走到了未定义的状态，因此走到$\emptyset$</li><li>$ \delta(q_2, 1) &#x3D; \{q_2\} $：没出现我们定义的状态，走到 $\emptyset$</li><li>$ \delta(q_2, 0) &#x3D; \{q_1\} $：没出现我们定义的状态，走到 $\emptyset$</li></ul></li><li><p><strong>定义初始状态$q_0$ :</strong> </p><ul><li>初始状态是 $q_0$，表示开始时尚未识别到 <code>01</code> 结尾。</li></ul></li><li><p><strong>定义接受状态集 F :</strong></p><ul><li>接受状态是 $q_2$，表示已经识别到以 <code>01</code> 结尾的字符串。</li></ul></li></ol><table><thead><tr><th>当前状态</th><th>输入符号 &#x3D; 0</th><th>输入符号 &#x3D; 1</th></tr></thead><tbody><tr><td>$q_0$</td><td>$\{q_0,q_1\}$</td><td>$\{q_0\}$</td></tr><tr><td>$q_1$</td><td>$\emptyset$</td><td>$\{q_2\}$</td></tr><tr><td>$\text{*}q_2$</td><td>$\emptyset$</td><td>$\emptyset$</td></tr></tbody></table><ul><li><strong>初始状态</strong>：$q_0$</li><li><strong>接受状态</strong>：$q_2$（用 <code>*</code> 表示）</li></ul><center><img src="/img/FL/nfa2.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><p>假设输入字符串是 <code>1101</code>，我们来分析 NFA 的运行过程：</p><ol><li>初始状态 $q_0$。</li><li>读取第一个字符 ‘1’，根据转移函数 $ \delta(q_0, 1) &#x3D; \{q_0\} $，保持在状态 $q_0$。</li><li>读取第二个字符 ‘1’，根据转移函数 $ \delta(q_0, 1) &#x3D; \{q_0\} $，保持在状态 $q_0$。</li><li>读取第三个字符 ‘0’，根据转移函数 $ \delta(q_0, 0) &#x3D; \{q_1\} $，转移到状态 $\{q_0,q_1\}$。</li><li>读取第四个字符 ‘1’，对于$q_0$，根据转移函数  $ \delta(q_0, 0) &#x3D; \{q_0,q_1\} $ 。对于$q_1$，$ \delta(q_1, 1) &#x3D; \{q_2\} $ 。这时候可能出现三种状态，存在一种状态$q_2$能被NFA接受</li></ol><p>最终，NFA停在接受状态 $q_2$，因此输入字符串 <code>1101</code> 被接受。</p><hr><h4 id="2-2-1-NFA的扩展转移函数"><a href="#2-2-1-NFA的扩展转移函数" class="headerlink" title="2.2.1 NFA的扩展转移函数"></a>2.2.1 NFA的扩展转移函数</h4><p>在非确定性有限自动机（NFA）中，<strong>扩展转移函数</strong>是对传统转移函数的扩展。它允许我们从一个状态开始，处理整个输入字符串，而不仅仅是处理单个字符。扩展转移函数定义了 NFA 如何从一个状态开始，读取整个输入字符串后，到达的状态集。</p><p>假设我们有一个NFA，定义为 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta$ 是转移函数。</li><li>$q_0$ 是初始状态。</li><li>$F$ 是接受状态集。</li></ul><p>扩展转移函数 $ \delta^* $ 是从状态到<strong>状态集</strong>的映射，定义如下：</p><p>$$<br>\delta^*(q, w) &#x3D; \delta^*(q, w_1 w_2 \dots w_n)<br>$$</p><p>其中，$w &#x3D; w_1 w_2 \dots w_n$ 是输入字符串，$w_1, w_2, \dots, w_n$ 是字符串 $w$ 中的各个字符。扩展转移函数遵循以下递归定义：</p><p><strong>Step1:</strong> 空串的处理</p><p>对于空串（即 $w &#x3D; \epsilon$），扩展转移函数返回包含当前状态的状态集，即：</p><p>$$<br>\delta^*(q, \epsilon) &#x3D; {q}<br>$$</p><p>这意味着，当输入为空时，NFA 仍然停留在当前状态。</p><p><strong>Step2:</strong> 递归处理非空字符串</p><p>如果输入字符串 $w &#x3D; w_1 w_2 \dots w_n$ 非空，扩展转移函数 $\delta^*$ 会递归地调用自身来处理子串 $w_1 w_2 \dots w_{n-1}$，然后再根据当前状态和最后一个字符 $w_n$ 进行状态转移。具体的递归形式如下：</p><p>$$<br>\delta^*(q, w) &#x3D; \bigcup_{r \in \delta(q, w_1)} \delta^*(r, w_2 \dots w_n)<br>$$</p><p>这意味着，对于每个可能的目标状态 $r$（从当前状态 $q$ 通过字符 $w_1$ 转移得到的状态），我们递归地求出从状态 $r$ 开始，处理剩余字符串 $w_2 \dots w_n$ 后的状态集，并将这些状态集进行并集运算。</p><p>总结一下，我们可以得出NFA的状态转移函数如下：</p><p>$$<br>\delta^*(q, w) &#x3D;<br>\begin{cases}<br>{q}, &amp; \text{if } w &#x3D; \epsilon \\<br>\bigcup_{r \in \delta(q, w_1)} \delta^*(r, w_2 \dots w_n), &amp; \text{if } w &#x3D; w_1 w_2 \dots w_n \text{ and } n &gt; 0<br>\end{cases}<br>$$</p><hr><p>举个例子: 假设我们有一个简单的 NFA，其中状态集 $Q &#x3D; \{q_0, q_1\}$，输入字母表 $\Sigma &#x3D; \{0, 1\}$，转移函数 $\delta$ 如下：</p><ul><li>$ \delta(q_0, 0) &#x3D; \{q_0, q_1\} $</li><li>$ \delta(q_0, 1) &#x3D; \{q_0\} $</li><li>$ \delta(q_1, 1) &#x3D; \{q_0\} $</li></ul><p>假设我们要计算 $\delta^*(q_0, 01)$，也就是从状态 $q_0$ 开始，处理字符串 <code>01</code> 后最终到达的状态集。</p><ol><li>首先，考虑空串情况：</li></ol><p>$$<br>\delta^*(q_0, \epsilon) &#x3D; \{q_0\}<br>$$</p><ol start="2"><li>然后，处理第一个字符 <code>0</code>：</li></ol><p>$$<br>\delta(q_0, 0) &#x3D; \{q_0, q_1\}<br>$$</p><ol start="3"><li><p>接着，处理剩余的字符串 <code>1</code>。我们需要从上一步得到的所有状态（即 $q_0$ 和 $q_1$）继续进行状态转移：</p><ul><li>对于状态 $q_0$，$ \delta(q_0, 1) &#x3D; \{q_0\} $。</li><li>对于状态 $q_1$，$ \delta(q_1, 1) &#x3D; \{q_0\} $。</li></ul></li><li><p>将这两次转移的结果合并：</p></li></ol><p>$$<br>\delta^*(q_0, 01) &#x3D; \{q_0\} \cup \{q_0\} &#x3D; \{q_0\}<br>$$</p><p>因此，从状态 $q_0$ 开始处理字符串 <code>01</code> 后，最终到达的状态是 $q_0$。</p><p>总结一下NFA的扩展函数有如下特点：</p><ul><li><strong>空串</strong>的扩展转移函数 $\delta^*(q, \epsilon)$ 使得当前状态保持不变。</li><li><strong>递归计算</strong>扩展转移函数是通过逐步处理输入字符串，并根据每个字符的转移结果来更新状态集。</li><li>扩展转移函数允许我们处理整个字符串的转移，而不仅仅是一个字符，这对 NFA 的运行至关重要，因为 NFA 可以在多个状态间“并行”进行状态转移。</li></ul><hr><h4 id="2-2-2-epsilon-NFA"><a href="#2-2-2-epsilon-NFA" class="headerlink" title="2.2.2 $\epsilon$-NFA"></a>2.2.2 $\epsilon$-NFA</h4><p><strong>$\epsilon$-NFA（Epsilon-Non-deterministic Finite Automaton）</strong> 是一种特殊的非确定性有限自动机（NFA）。与普通的 NFA 相比，$\epsilon$-NFA 允许使用 $\epsilon$ 转移（即<strong>空转移</strong>）。$\epsilon$ 转移意味着在没有读取任何输入字符的情况下，自动机可以从一个状态跳转到另一个状态。</p><p>一个 $\epsilon$-NFA 通常用以下五元组表示：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li>$Q$：状态集（有限集合）。</li><li>$\Sigma$：输入字母表（有限集合）。</li><li>$\delta$：状态转移函数，$\delta: Q \times (\Sigma \cup {\epsilon}) \to 2^Q$。注意，这里 $\delta$ 可以包含 $\epsilon$ 转移。</li><li>$q_0$：初始状态，$q_0 \in Q$。</li><li>$F$：接受状态集，$F \subseteq Q$。</li></ul><p>$\epsilon$-NFA 具有<em>以下特性：</em></p><ol><li><p><strong>$\epsilon$ 转移</strong>：</p><ul><li>自动机可以通过 $\epsilon$ 转移从一个状态跳转到另一个状态，而无需消耗任何输入字符。</li><li>例如，如果 $\delta(q_1, \epsilon) &#x3D; \{q_2, q_3\}$，自动机可以从状态 $q_1$ 转移到 $q_2$ 或 $q_3$，而不需要读取输入字符。</li></ul></li><li><p><strong>非确定性</strong>：</p><ul><li>和普通 NFA 一样，$\epsilon$-NFA 也具有非确定性：对于相同的输入字符，自动机可能有多个可能的转移路径。</li></ul></li><li><p><strong>接受条件</strong>：</p><ul><li>一个字符串 $w$ 被 $\epsilon$-NFA 接受，当且仅当：<ul><li>从初始状态 $q_0$ 开始，沿着可能的路径（包括 $\epsilon$ 转移），读取完字符串 $w$ 后，最终能到达某个接受状态 $f \in F$。</li></ul></li></ul></li></ol><p><strong>$\epsilon$ 闭包</strong>是 $\epsilon$-NFA 的一个关键概念。它描述了从某个状态 $q$ 开始，通过任意多次 $\epsilon$ 转移可以到达的状态集合。</p><p>记 $\epsilon$ 闭包为 $\text{E-closure}(q)$，定义如下：</p><p>$$<br>\text{E-closure}(q) &#x3D; \{ p \in Q \mid p \text{ 是从 } q \text{ 经 $\epsilon$ 转移可到达的状态} \}<br>$$</p><p>如果从状态 $q$ 开始经过若干次 $\epsilon$ 转移可以到达状态 $p$，则 $p \in \text{E-closure}(q)$。</p><hr><p>考虑一个简单的 $\epsilon$-NFA，定义如下：</p><ul><li>状态集：$Q &#x3D; \{q_0, q_1, q_2\}$。</li><li>输入字母表：$\Sigma &#x3D; \{a, b\}$。</li><li>初始状态：$q_0$。</li><li>接受状态集：$F &#x3D; \{q_2\}$。</li><li>转移函数 $\delta$：<ul><li>$\delta(q_0, \epsilon) &#x3D; \{q_1\}$。</li><li>$\delta(q_1, a) &#x3D; \{q_1, q_2\}$。</li><li>$\delta(q_2, b) &#x3D; \{q_2\}$。</li></ul></li></ul><p>我们可以用状态转移图表示这个 $\epsilon$-NFA：</p><center><img src="/img/FL/nfa3.svg" alt="例题演示" style="max-width: 100%; height: auto;" /></center><p><strong>$\epsilon$ 闭包计算</strong></p><ul><li>$\text{E-closure}(q_0) &#x3D; \{q_0, q_1\}$ （$q_1$ 是通过 $\epsilon$ 转移从 $q_0$ 可达）。</li><li>$\text{E-closure}(q_1) &#x3D; \{q_1\}$。</li><li>$\text{E-closure}(q_2) &#x3D; \{q_2\}$。</li></ul><p>假设输入字符串是 “a”，分析其是否被接受：</p><ol><li>初始状态 $q_0$，根据 $\epsilon$ 闭包，$\text{E-closure}(q_0) &#x3D; \{q_0, q_1\}$。</li><li>读取第一个字符 “a”：<ul><li>从 $q_1$ 读取 “a” 后，可以到达状态 $q_1$ 和 $q_2$。</li><li>从 $q_0$ 无法直接读取 “a”。</li></ul></li><li>计算 $\epsilon$ 闭包：<ul><li>$\text{E-closure}(\{q_1, q_2\}) &#x3D; \{q_1, q_2\}$。</li></ul></li><li>最终状态集包含 $q_2$，它是一个接受状态。</li></ol><p>因此，字符串 “a” 被该 $\epsilon$-NFA 接受。</p><p>上面的$\epsilon$-NFA接受的语言是以一个或多个 ‘a’ 结束，并且可以在后面跟上零个或多个 ‘b’。即正则表达式为 $a^+ b^*$。</p><hr><h4 id="2-2-3-epsilon-NFA的扩展转移函数"><a href="#2-2-3-epsilon-NFA的扩展转移函数" class="headerlink" title="2.2.3 $\epsilon$-NFA的扩展转移函数"></a>2.2.3 $\epsilon$-NFA的扩展转移函数</h4><p>一个非确定性有限自动机（NFA）由五元组 $(Q, \Sigma, \delta, q_0, F)$ 组成，其中：</p><ul><li>$Q$ 是状态集，</li><li>$\Sigma$ 是输入字母表，</li><li>$\delta: Q \times \Sigma \to \mathcal{P}(Q)$ 是转移函数（映射一个状态和输入符号到可能的状态集合），</li><li>$q_0 \in Q$ 是初始状态，</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>在 $\epsilon$-NFA 中，除了常规的转移外，还允许存在 $\epsilon$（空字符串）转移，意味着自动机可以在没有任何输入的情况下从一个状态转移到另一个状态。</p><p>$\epsilon$-NFA的扩展转移函数 $\delta^*(q, w)$ 用于计算从状态 $q$ 开始，处理输入字符串 $w$ 后可能到达的所有状态。这个函数需要分别考虑两种情况：当输入字符串为空（$w &#x3D; \epsilon$）时，以及输入字符串非空（$w \neq \epsilon$）时。可以定义为如下的分段函数：</p><p>$$<br>\delta^*(q, w) &#x3D;<br>\begin{cases}<br>E\text{-closure}(q), &amp; \text{if } w &#x3D; \epsilon \\<br>\bigcup_{q’ \in \delta(q, a)} \delta^*(q’, w’), &amp; \text{if } w &#x3D; a w’ \text{ and } a \in \Sigma<br>\end{cases}<br>$$</p><p>其中：</p><ul><li>如果 $w &#x3D; \epsilon$，表示输入字符串为空，那么扩展转移函数的值是从状态 $q$ 开始，所有通过 $\epsilon$ 转移能够到达的状态集合，即 $E$-closure($q$)。</li><li>如果 $w &#x3D; a w’$，表示输入字符串非空，且可以分解为第一个符号 $a$ 和剩余部分 $w’$，那么扩展转移函数的值是所有从状态 $q$ 通过符号 $a$ 转移后，再继续处理 $w’$ 后可能到达的状态的集合。这些状态是通过递归计算 $\delta^*(q’, w’)$ 来得到的，其中 $q’$ 是状态 $q$ 经过符号 $a$ 转移后到达的状态。</li></ul><p>假设有一个简单的 $\epsilon$-NFA，其状态集为 $Q &#x3D; \{q_0, q_1, q_2\}$，字母表为 $\Sigma &#x3D; \{a, b\}$，初始状态为 $q_0$，接受状态为 $F &#x3D; \{q_1\}$，且转移函数如下：</p><ul><li>$\delta(q_0, a) &#x3D; \{q_1\}$</li><li>$\delta(q_1, b) &#x3D; \{q_2\}$</li><li>$\delta(q_0, \epsilon) &#x3D; \{q_2\}$</li></ul><p>则其空转移闭包为：</p><p>$$<br>E\text{-closure}(q_0) &#x3D; \{q_0, q_2\}<br>$$</p><p>扩展转移函数计算为：</p><ul><li>对于输入字符串 $a$，从状态 $q_0$ 开始，$E$-closure 包含 $q_0$ 和 $q_2$，因此扩展转移将考虑状态 $q_0$ 和 $q_2$ 的转移。<ul><li>从 $q_0$，转移到 $q_1$。</li><li>从 $q_2$，没有输入符号 $a$ 的转移。</li></ul></li></ul><p>所以，扩展转移函数为：</p><p>$$<br>\delta^*(q_0, a) &#x3D; \{q_1, q_2\}<br>$$</p><ul><li>对于输入字符串 $ab$，我们首先从状态 $q_0$ 处理 $a$，然后再从 $q_1$ 处理 $b$。<ul><li>从 $q_0$ 处理 $a$ 后，到达状态 $q_1$。</li><li>从 $q_1$ 处理 $b$ 后，到达状态 $q_2$。</li></ul></li></ul><p>所以，扩展转移函数为：</p><p>$$<br>\delta^*(q_0, ab) &#x3D; \{q_2\}<br>$$</p><hr><h4 id="2-2-4-epsilon-NFA与NFA等价性证明"><a href="#2-2-4-epsilon-NFA与NFA等价性证明" class="headerlink" title="2.2.4 $\epsilon$-NFA与NFA等价性证明"></a>2.2.4 $\epsilon$-NFA与NFA等价性证明</h4><p>为了证明 <strong>$\epsilon$-NFA</strong> 和 <strong>NFA</strong> 之间的等价性，即任何一个 <strong>$\epsilon$-NFA</strong> 都可以转换为一个等价的 <strong>NFA</strong>，我们将使用数学归纳法来推导和证明。</p><p><strong>定义：</strong></p><ul><li><strong>$\epsilon$-NFA</strong>（Epsilon-Non-deterministic Finite Automaton）：与普通的 NFA 不同，$\epsilon$-NFA 允许在没有消耗任何输入字符的情况下，通过 $\epsilon$ 转移从一个状态跳转到另一个状态。</li><li><strong>NFA</strong>（Non-deterministic Finite Automaton）：普通的非确定性有限自动机，在每个状态下对每个输入符号至多有一个转移。</li></ul><p><strong>证明目标：</strong> 对于每个 <strong>$\epsilon$-NFA</strong>，存在一个等价的 <strong>NFA</strong>，可以接受相同的语言。</p><p><strong>证明思路：</strong> 我们将采用归纳法来证明，即：任何 <strong>$\epsilon$-NFA</strong> 都可以通过一个构造转换为一个等价的 <strong>NFA</strong>。</p><p><strong>Step 1：基础情况</strong></p><p>假设我们有一个最简单的 <strong>$\epsilon$-NFA</strong>，它没有任何 $\epsilon$ 转移。即这个 <strong>$\epsilon$-NFA</strong> 实际上是一个普通的 <strong>NFA</strong>，因此显然是等价的。</p><ul><li><strong>$\epsilon$-NFA</strong> 就是一个普通的 <strong>NFA</strong>。</li><li>因此，这种情况我们已经证明了等价性。</li></ul><p><strong>Step 2：归纳假设</strong></p><p>假设对于所有状态数目小于 $n$ 的 <strong>$\epsilon$-NFA</strong>，我们已经证明它们与相应的 <strong>NFA</strong> 等价。即：对所有状态数目小于 $n$ 的 <strong>$\epsilon$-NFA</strong>，我们都能构造一个等价的 <strong>NFA</strong>。</p><p><strong>Step 3：归纳步骤</strong></p><p>现在考虑一个有 $n$ 个状态的 <strong>$\epsilon$-NFA</strong>。我们需要通过构造一个 <strong>NFA</strong> 来证明它与 <strong>NFA</strong> 等价。</p><p>假设我们的 <strong>$\epsilon$-NFA</strong> 定义为：</p><p>$$<br>M &#x3D; (Q, \Sigma, \delta, q_0, F)<br>$$</p><p>其中：</p><ul><li>$Q &#x3D; \{q_0, q_1, q_2, \dots, q_{n-1}\}$ 是状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta$ 是转移函数，$\delta: Q \times (\Sigma \cup {\epsilon}) \to 2^Q$，表示从状态到状态的转移。</li><li>$q_0$ 是初始状态。</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>我们的任务是构造一个等价的 <strong>NFA</strong>，用来接受相同的语言。</p><hr><p><strong>构造过程:</strong></p><ol><li><p><strong>扩展状态集</strong>：</p><ul><li>对于给定的 <strong>$\epsilon$-NFA</strong>，我们构造一个新的 <strong>NFA</strong>，将其状态集 $Q$ 扩展为 $\tilde{Q}$，其中 $\tilde{Q}$ 表示每个状态的 <strong>$\epsilon$ 闭包</strong>。也就是说，$\tilde{Q}$ 中的每个元素是 <strong>$\epsilon$ 闭包</strong> 集合，表示从原状态集的每个状态出发，经过若干个 $\epsilon$ 转移后可能到达的所有状态。</li></ul></li><li><p><strong>定义新的转移函数</strong>：</p><ul><li>对于每一个 $\tilde{q} \in \tilde{Q}$ 和输入符号 $a \in \Sigma$，新的转移函数 $\tilde{\delta}$ 将定义为：<br>$$<br>\tilde{\delta}(\tilde{q}, a) &#x3D; \bigcup_{q \in \tilde{q}} \delta(q, a)<br>$$<br>其中 $\tilde{q}$ 是一个 <strong>$\epsilon$ 闭包</strong> 集合，而 $\delta(q, a)$ 是普通的 NFA 转移。</li><li>注意，$\tilde{q}$ 代表的是从状态集合中通过 $\epsilon$ 转移到达的所有状态，因此 $\tilde{\delta}(\tilde{q}, a)$ 是所有从该集合内的状态通过输入字符 $a$ 能到达的状态的并集。</li></ul></li><li><p><strong>定义初始状态和接受状态</strong>：</p><ul><li>新的初始状态是 $\tilde{q_0} &#x3D; \text{E-closure}(q_0)$，即初始状态 $q_0$ 经过 $\epsilon$ 闭包后到达的状态集合。</li><li>接受状态集 $F’ &#x3D; \{\tilde{q} \mid \tilde{q} \cap F \neq \emptyset\}$，即任何包含原接受状态 $F$ 中某个状态的状态集合都作为新的接受状态。</li></ul></li></ol><hr><p><strong>证明等价性</strong></p><p>我们要证明，通过上述构造的 <strong>NFA</strong> 能够接受与原 <strong>$\epsilon$-NFA</strong> 相同的语言。我们使用归纳法步骤中的假设和构造的转换来证明这一点。</p><ol><li><p><strong>$\epsilon$ 闭包和转移函数</strong>：</p><ul><li>在 <strong>$\epsilon$-NFA</strong> 中，任何通过 $\epsilon$ 转移到达的状态都能被纳入 <strong>NFA</strong> 的转移函数中。由于 $\epsilon$ 转移没有消耗输入字符，因此 <strong>NFA</strong> 的转移函数扩展了对 $\epsilon$ 转移的处理。</li><li>每个 <strong>$\epsilon$-NFA</strong> 的 $\epsilon$ 闭包都被映射为 <strong>NFA</strong> 的状态集合，而输入字符会在这个集合内传播。</li></ul></li><li><p><strong>接受条件</strong>：</p><ul><li><strong>NFA</strong> 通过判断是否可以到达一个包含原接受状态的集合来确定是否接受字符串。这与 <strong>$\epsilon$-NFA</strong> 的接受条件一致，即只要从初始状态出发经过输入串到达某个接受状态，就被接受。</li></ul></li><li><p><strong>语言相等性</strong>：</p><ul><li>由于 <strong>$\epsilon$-NFA</strong> 的每一步转移都在 <strong>NFA</strong> 中得到了精确的映射，并且接受状态的条件也被正确保留，因此构造的 <strong>NFA</strong> 接受的语言与原 <strong>$\epsilon$-NFA</strong> 接受的语言是相同的。</li></ul></li></ol><p>通过以上构造和证明，我们可以得出结论：<strong>任何一个 $\epsilon$-NFA 都可以转换为一个等价的 NFA</strong>，即 $\epsilon$-NFA$ \equiv$ NFA。</p><div class="note note-success">            <p>此后不再明确区分$\epsilon$-NFA和NFA，因为它们都是NFA</p>          </div><hr><h3 id="2-3-DFA和NFA等价性证明"><a href="#2-3-DFA和NFA等价性证明" class="headerlink" title="2.3 DFA和NFA等价性证明"></a>2.3 DFA和NFA等价性证明</h3><p>在形式语言与自动机理论中，<strong>确定性有限自动机</strong>（DFA）和<strong>非确定性有限自动机</strong>（NFA）是两种常见的自动机模型。它们用于识别正则语言，并且<strong>DFA</strong> 和 <strong>NFA</strong> 是<strong>等价的</strong>，即它们识别的语言是完全一样的。具体来说，任何一个 NFA 都可以转换成一个等价的 DFA，反之亦然。以下是 DFA 和 NFA 等价性的证明过程。</p><p>DFA 是一个五元组 $(Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是有限状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta: Q \times \Sigma \to Q$ 是状态转移函数，给定当前状态和输入符号，确定唯一的下一个状态。</li><li>$q_0 \in Q$ 是初始状态。</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>NFA 是一个五元组 $(Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是有限状态集。</li><li>$\Sigma$ 是输入字母表。</li><li>$\delta: Q \times \Sigma \to \mathcal{P}(Q)$ 是状态转移函数，给定当前状态和输入符号，可以转移到多个状态（即可以是空的或多个状态的集合）。</li><li>$q_0 \in Q$ 是初始状态。</li><li>$F \subseteq Q$ 是接受状态集。</li></ul><p>我们要证明的是，<strong>每个 NFA 都可以转化为一个等价的 DFA</strong>。为此，我们将通过构造来展示如何从 NFA 构造 DFA，使得它们识别的语言是一样的。</p><p>分析：从 NFA 转换到 DFA</p><p>假设有一个 NFA $N &#x3D; (Q, \Sigma, \delta, q_0, F)$，我们想构造一个等价的 DFA $D &#x3D; (Q’, \Sigma, \delta’, q_0’, F’)$。</p><ol><li><p><strong>状态集</strong>：DFA 的状态集 $Q’$ 由 NFA 的状态集的子集组成。更具体地，DFA 的状态对应于 NFA 的状态集合的一个子集。即 $Q’ \subseteq 2^Q$（所有 NFA 状态的集合的幂集）。</p></li><li><p><strong>初始状态</strong>：DFA 的初始状态 $q_0’$ 是 NFA 初始状态的 $\epsilon$-闭包。记 $E\text{-closure}(q_0)$ 为 NFA 状态 $q_0$ 的空转移闭包。于是，DFA 的初始状态是 $q_0’ &#x3D; E\text{-closure}(q_0)$。</p></li><li><p><strong>转移函数</strong>：对于 DFA 中的每个状态（它是 NFA 状态的一个子集），DFA 的转移函数 $\delta’(S, a)$ 被定义为所有 NFA 状态在读取符号 $a$ 后所能到达的状态的 $\epsilon$-闭包：</p><p>$$ \delta’(S, a) &#x3D; E\text{-closure} \left( \bigcup_{q \in S} \delta(q, a) \right) $$</p><p>也就是说，DFA 的转移函数是 NFA 中所有可能的状态集合的组合。</p></li><li><p><strong>接受状态集</strong>：DFA 的接受状态集 $F’$ 由 NFA 中的所有包含接受状态的状态集合组成。即：</p><p>$$ F’ &#x3D; \{ S \subseteq Q \mid S \cap F \neq \emptyset \} $$</p><p>也就是说，DFA 中只要某个状态子集包含 NFA 的某个接受状态，它就被认为是接受状态。</p></li></ol><p><strong>证明：</strong></p><p>为了证明从 NFA 到 DFA 的转换是有效的，即两者识别的语言是一样的，我们可以分为以下几步：</p><ol><li><p><strong>从 NFA 接受的语言到 DFA</strong>：</p><ul><li>NFA 对输入字符串 $w$ 执行多个路径，并在路径中存在至少一条接受状态时就接受字符串。</li><li>对于 DFA，它基于一个状态子集来模拟所有这些路径。由于每个状态子集都包括了 NFA 的多个状态，DFA 必定能够找到 NFA 中的一个路径来接受字符串。</li></ul><p>因此，如果一个字符串被 NFA 接受，它也会被通过构造的 DFA 接受。</p></li><li><p><strong>从 DFA 接受的语言到 NFA</strong>：</p><ul><li>DFA 在每一步都有唯一的转移，因此它只能遵循一个路径。这个路径可以直接对应于 NFA 的多个可能路径。</li><li>因此，如果 DFA 接受一个字符串，那么这个字符串也会被 NFA 接受（尽管 NFA 可能有多个路径，但至少有一条与 DFA 的唯一路径相同）。</li></ul></li></ol><p>由于这两个方向的转换都成立，因此 <strong>DFA 和 NFA 是等价的</strong>。</p><p>假设我们有一个简单的 NFA，其状态集为 $Q &#x3D; \{q_0, q_1\}$，字母表为 $\Sigma &#x3D; \{a, b\}$，初始状态为 $q_0$，接受状态为 $F &#x3D; \{q_1\}$，转移函数如下：</p><ul><li>$\delta(q_0, a) &#x3D; \{q_0, q_1\}$</li><li>$\delta(q_0, b) &#x3D; \{q_0\}$</li><li>$\delta(q_1, a) &#x3D; \{q_1\}$</li><li>$\delta(q_1, b) &#x3D; \{q_1\}$</li></ul><p>可以看到，NFA 在状态 $q_0$ 时，对于输入 $a$ 可以转移到 $q_0$ 或 $q_1$。我们可以按照上述方法将此 NFA 转换为一个等价的 DFA。</p><p>这里我们简单总结一下：</p><ul><li><strong>DFA 和 NFA 是等价的</strong>，它们可以识别相同的正则语言。</li><li><strong>NFA 到 DFA 的转换</strong>是通过将 NFA 状态的所有子集映射到 DFA 状态的过程来实现的。</li><li><strong>从 NFA 到 DFA 的转换</strong>能够保留语言不变，并且可以通过递归地计算状态的 $\epsilon$-闭包和转移来实现。</li></ul><p>这个等价性证明展示了尽管 DFA 和 NFA 在结构上有所不同，但它们的能力是等同的，都能够识别正则语言(Regular Language)。</p><hr><h3 id="2-4-State-Elimination-Method"><a href="#2-4-State-Elimination-Method" class="headerlink" title="2.4 State Elimination Method"></a>2.4 State Elimination Method</h3><p><strong>状态消除法（State Elimination Method）</strong> 是一种常用于将有限状态机（Finite State Machine, FSM）或确定性有限自动机（Deterministic Finite Automaton, DFA）转换为正则表达式的技术。在形式语言与自动机的学习中，这一方法是将有限状态机的转移图简化为一个相应的正则表达式的有效工具。</p><p><strong>基本步骤</strong></p><ol><li><p><strong>构造状态转移图：</strong><br>开始时，首先需要有一个确定的有限状态机（DFA）或者非确定的有限状态机（NFA），其状态转移图应包括：</p><ul><li>各状态</li><li>状态之间的转移（可能是输入字符）</li><li>初态与终态的标定</li></ul></li><li><p><strong>从图中删除状态：</strong><br>在每一步中，选择一个非终态进行删除。删除一个状态时，需考虑：</p><ul><li>状态间的所有可能的转移路径。</li><li>通过删除该状态，可能会导致一些新路径的产生。</li></ul></li><li><p><strong>更新转移关系：</strong><br>删除某一状态后，所有从该状态出发的转移关系必须通过其它状态来代替。具体地：</p><ul><li>如果有从状态 <code>A</code> 到状态 <code>B</code> 的路径 <code>a</code> 和从状态 <code>B</code> 到状态 <code>C</code> 的路径 <code>b</code>，那么删除状态 <code>B</code> 后，可以通过路径 <code>a</code> 和 <code>b</code> 连接成新的路径 <code>ab</code>。</li><li>对于状态 <code>B</code> 本身的自环路径（比如 <code>B</code> 到 <code>B</code> 的路径），要通过循环自环的组合形成新的路径。</li></ul></li><li><p><strong>重复删除直到只剩下起始状态和终止状态：</strong><br>继续删除其他非终态，逐步简化自动机的结构，直到只剩下一个起始状态和一个或多个终止状态。这时可以从起始状态到终止状态的路径表示为一个正则表达式。</p></li><li><p><strong>得到正则表达式：</strong><br>一旦删除所有状态，只剩下两个状态（起始状态和终止状态），从起始状态到终止状态的所有路径就是自动机的正则表达式。</p></li></ol><img src="/img/FL/state_elimation.svg" alt="状态消除法" style="max-width: 100%; height: auto;" /><h2 id="3-Regular-Language"><a href="#3-Regular-Language" class="headerlink" title="3. Regular Language"></a>3. Regular Language</h2><p><strong>正则语言 (Regular Language)</strong> 是形式语言理论中的一个重要概念，通常与有限自动机（Finite Automata, FA）和正则表达式（Regular Expressions, RE）相关联。正则语言是可以被有限自动机识别或由正则表达式描述的语言。它们的特点是相对简单，能够用有限的计算资源进行识别或生成。</p><p>形式化地，正则语言是一个语言集合，满足以下条件之一：</p><ul><li>它可以被一个<strong>有限自动机</strong>识别。</li><li>它可以通过<strong>正则表达式</strong>来描述。</li><li>它可以通过正则文法生成。</li></ul><p>这些语言可以被归类为<strong>正规语言</strong>，它们的生成和识别过程是有限的，不需要无限的计算资源。</p><p>正则语言可以通过 DFA 或 NFA 来识别。尽管 DFA 和 NFA 之间在形式上有所不同，实际上它们是等价的，因为每一个 NFA 都可以被转换成一个等效的 DFA。</p><blockquote><p>有限自动机与正则表达式的等价性证明留到后面</p></blockquote><div class="note note-primary">            <p><strong>有限自动机 (Finite Automaton)</strong> 是一种计算模型，它由一组状态、一个输入字母表、一个转换函数、一个初始状态和一些接受状态组成。有限自动机有两种类型：</p><ul><li><strong>确定性有限自动机 (DFA)</strong> ：对于每个状态和输入符号，都有唯一的转移。</li><li><strong>非确定性有限自动机 (NFA)</strong> ：对于某些状态和输入符号，可能有多个转移或者没有转移。</li></ul>          </div><p>正则语言具有一些有用的性质，包括：</p><ul><li><p><strong>闭包性质</strong>：正则语言在以下操作下保持闭合，即操作结果仍然是正则语言。</p><ul><li><strong>并运算</strong>：如果 $L_1$ 和 $L_2$ 是正则语言，则 $L_1 \cup L_2$ 也是正则语言。</li><li><strong>连接运算</strong>：如果 $L_1$ 和 $L_2$ 是正则语言，则 $L_1 \cdot L_2$ 也是正则语言。</li><li><strong>星号闭包（Kleene闭包）</strong>：如果 $L$ 是正则语言，则 $L^*$ 也是正则语言。</li><li><strong>补运算</strong>：正则语言对于补集操作是封闭的，假设 $L$ 是正则语言，则 $\overline{L}$ 也是正则语言。</li></ul></li><li><p><strong>可表示性</strong>：正则语言可以用正则表达式来描述。每个正则表达式都定义了一个正则语言。</p></li></ul><blockquote><p>后面内容对这里的正确性进行证明</p></blockquote><p>尽管正则语言非常有用，它们也有一些限制：</p><ul><li>正则语言无法描述<strong>上下文相关语言</strong>或<strong>上下文无关语言</strong>中一些更复杂的结构。例如，正则语言不能识别平衡的括号或相互嵌套的结构。</li><li>正则语言只能识别相对简单的模式（如重复模式、选择模式），对于更复杂的结构，它们的<strong>表达能力有限。</strong></li></ul><p>正则语言和正则表达式在计算机科学中有广泛应用，尤其是在文本处理领域，如：</p><ul><li><strong>文本搜索</strong>：正则表达式广泛用于字符串匹配和文本搜索。</li><li><strong>编译器设计</strong>：在编译器中，正则语言用于词法分析阶段，识别输入的词法单位（如关键字、标识符、操作符等）。</li><li><strong>数据验证</strong>：在输入数据验证中，正则表达式被用于检查输入是否符合特定模式（如电子邮件地址、电话号码等）。</li></ul><hr><ol><li><p><strong>正则语言的简单示例</strong>：</p><ul><li>语言 $L &#x3D; {a, b}$，即由字符 ‘a’ 或 ‘b’ 组成的语言，可以由正则表达式 $a|b$ 来表示。</li></ul></li><li><p><strong>使用 Kleene 星号操作</strong>：</p><ul><li>语言 $L &#x3D; {a^n \mid n \geq 0}$，即包含任意数量的字符 ‘a’ 的语言，可以用正则表达式 $a^*$ 来表示。</li></ul></li><li><p><strong>连接操作</strong>：</p><ul><li>语言 $L &#x3D; {ab, abc}$，即包含字符串 ‘ab’ 和 ‘abc’ 的语言，可以通过正则表达式 $ab|abc$ 来表示。</li></ul></li></ol><hr><h3 id="3-1-Regular-Expression"><a href="#3-1-Regular-Expression" class="headerlink" title="3.1 Regular Expression"></a>3.1 Regular Expression</h3><p><strong>正则表达式 (Regular Expression, RE)</strong> 是一种用于描述字符串模式的形式化语言，广泛应用于文本搜索、数据匹配、编译器的词法分析等领域。在形式语言与自动机的理论中，正则表达式用于定义<strong>正则语言</strong>，它们能够描述可以被<strong>有限自动机</strong>识别的语言。</p><p>正则表达式是一种通过特定规则组合字母、符号和运算符来表示字符串集合的工具。它由字母表（通常为有限的字符集）中的符号以及以下几种运算符组合而成：</p><ul><li><strong>字面量字符</strong>：如字符 <code>a</code>、<code>b</code>、<code>1</code> 等，它们直接表示一个特定的字符。</li><li><strong>连接 (Concatenation)</strong> ：将两个正则表达式拼接在一起，表示这两个模式依次出现。例如，<code>ab</code> 表示第一个字符是 <code>a</code>，第二个字符是 <code>b</code>。(也可以用<code>·</code>来表示)</li><li><strong>并运算 (Union)</strong> ：表示选择操作，表示两个模式的并集。用竖线 <code>|</code> 表示，如 <code>a|b</code> 表示匹配 <code>a</code> 或 <code>b</code>。（也可以用<code>+</code>来表示并运算）</li><li><strong>Kleene 星号 (Kleene Star)</strong> ：表示零次或多次重复某个模式。用星号 <code>*</code> 表示，如 <code>a*</code> 表示匹配零次或多次字符 <code>a</code>。</li><li><strong>括号 (Parentheses)</strong> ：用于分组操作，将多个元素或子表达式组合成一个单位。例如，<code>(ab)*</code> 表示零次或多次重复 <code>ab</code>。</li><li><strong>字符集 (Character Class)</strong> ：用于匹配一组字符中的任意一个。用方括号 <code>[]</code> 表示，如 <code>[a-z]</code> 表示匹配小写字母中的任何一个。</li><li><strong>取反 (Negation)</strong> ：表示匹配不在指定字符集中的字符。用 <code>^</code> 在字符集的开头表示，如 <code>[^0-9]</code> 表示匹配任意非数字字符。</li></ul><hr><p>下面列举一些简单的例子：</p><ol><li><p><strong>匹配一个单一字符：</strong></p><ul><li><code>a</code>：匹配字符 <code>a</code>。</li></ul></li><li><p><strong>匹配字符的选择：</strong></p><ul><li><code>a|b</code>：匹配字符 <code>a</code> 或字符 <code>b</code>。</li></ul></li><li><p><strong>匹配多个字符：</strong></p><ul><li><code>abc</code>：匹配字符串 <code>abc</code>。</li></ul></li><li><p><strong>匹配字符重复：</strong></p><ul><li><code>a*</code>：匹配零次或多次字符 <code>a</code>，即可以匹配空字符串、<code>a</code>、<code>aa</code>、<code>aaa</code> 等。</li><li><code>(ab)*</code>：匹配零次或多次 <code>ab</code>，即可以匹配空字符串、<code>ab</code>、<code>abab</code> 等。</li></ul></li><li><p><strong>匹配字符集合：</strong></p><ul><li><code>[0-9]</code>：匹配任意一个数字字符。</li><li><code>[a-zA-Z]</code>：匹配任意一个英文字母（不区分大小写）。</li></ul></li><li><p><strong>匹配任意字符：</strong></p><ul><li><code>.</code>：表示匹配任意单个字符（除了换行符）。</li></ul></li></ol><hr><p>正则表达式广泛应用于多个领域，主要包括：</p><ul><li><strong>文本搜索与替换</strong>：可以在文本中查找匹配特定模式的字符串，或对匹配的部分进行替换。</li><li><strong>数据验证</strong>：验证用户输入是否符合特定模式，如电子邮件、电话号码等。</li><li><strong>编译器与解释器</strong>：在编译器的词法分析阶段，正则表达式用于识别源代码中的词法单元（tokens），如关键字、标识符、常数等。</li><li><strong>日志分析与处理</strong>：从大量的日志文件中提取出符合特定模式的数据，进行后续分析。</li></ul><p>尽管正则表达式非常强大，但它也有一些限制，主要体现在以下方面：</p><ul><li>正则表达式无法处理<strong>上下文依赖</strong>的结构，比如匹配平衡的括号或递归模式。</li><li>对于复杂的语言结构，正则表达式的表达能力是有限的。对于需要更复杂模式匹配的任务，可能需要更高级的解析技术，如上下文无关文法或上下文相关文法。</li></ul><blockquote><p>这里就引入了后面章节的下推自动机和上下文无关文法</p></blockquote><hr><p>正则表达式中的运算符有一定的优先级，决定了它们在表达式中组合的顺序。理解这些优先级对于正确解析和构建正则表达式至关重要。</p><p><strong>运算优先级总结：</strong></p><ol><li><strong><code>()</code></strong> ：分组，最高优先级。</li><li><strong>量词 <code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;n,m&#125;</code></strong> ：应用于前面的字符或表达式。</li><li><strong><code>[]</code></strong> 和 <strong><code>[^]</code></strong> ：字符集和取反。</li><li><strong><code>|</code></strong> ：选择，最低优先级。</li></ol><p><strong>示例：</strong></p><ul><li><strong><code>a(b|c)*d</code></strong> ：匹配 <code>a</code> 后跟 <code>b</code> 或 <code>c</code> 任意次（包括零次）再跟 <code>d</code>。这里，<code>(b|c)</code> 优先于 <code>*</code>。</li><li><strong><code>a|b*</code></strong> ：先匹配 <code>b*</code>，然后匹配 <code>a</code>，因为 <code>*</code> 的优先级高于 <code>|</code>。</li></ul><div class="note note-success">            <p>修考题目中会有许多正则表达式的考点，我就放在修考真题里来讲解吧…</p>          </div><hr><h3 id="3-2-有限自动机与正则表达式的等价性证明"><a href="#3-2-有限自动机与正则表达式的等价性证明" class="headerlink" title="3.2 有限自动机与正则表达式的等价性证明"></a>3.2 有限自动机与正则表达式的等价性证明</h3><p><em>第一部分：基本定义</em></p><p>一个确定性有限自动机(DFA) $M$ 是一个五元组 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是有限的状态集</li><li>$\Sigma$ 是有限的输入字母表</li><li>$\delta: Q \times \Sigma \rightarrow Q$ 是转移函数</li><li>$q_0 \in Q$ 是初始状态</li><li>$F \subseteq Q$ 是接受状态集合</li></ul><p>一个非确定性有限自动机(NFA) $M$ 是一个五元组 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$\delta: Q \times (\Sigma \cup {\varepsilon}) \rightarrow \mathcal{P}(Q)$ 是转移函数，$\mathcal{P}(Q)$表示$Q$的幂集</li><li>其他组件与DFA定义相同</li></ul><p>正则表达式归纳定义如下：</p><ol><li>$\emptyset$ 是正则表达式</li><li>$\varepsilon$ 是正则表达式</li><li>对于任何 $a \in \Sigma$，$a$ 是正则表达式</li><li>如果 $r$ 和 $s$ 是正则表达式，则：<ul><li>$(r \cdot s)$ 是正则表达式（连接）</li><li>$(r|s)$ 是正则表达式（选择）</li><li>$(r*)$ 是正则表达式（Kleene闭包）</li></ul></li></ol><p>正则表达式表示的语言: $L(r)$ 表示正则表达式 $r$ 表示的语言，归纳定义如下：</p><ol><li>$L(\emptyset) &#x3D; \emptyset$</li><li>$L(\varepsilon) &#x3D; \{\varepsilon\}$</li><li>$L(a) &#x3D; \{a\}$, $a \in \Sigma$</li><li>$L(r \cdot s) &#x3D; L(r) \cdot L(s)$</li><li>$L(r|s) &#x3D; L(r) \cup L(s)$</li><li>$L(r^*) &#x3D; L(r)* &#x3D; \bigcup_{i \geq 0} L(r)^i$</li></ol><p><em>第二部分：正则表达式到有限自动机的转换</em></p><p><strong>定理:Thompson构造</strong>:</p><ul><li>对于任意正则表达式 $r$，存在一个接受 $L(r)$ 的$\varepsilon$-NFA。</li></ul><p>我们用结构归纳法证明。</p><p>基础情况：</p><ol><li><p>$r &#x3D; \emptyset$：<br>构造 $M &#x3D; (\{q_0\}, \Sigma, \delta, q_0, \emptyset)$，其中$\delta$为空函数</p></li><li><p>$r &#x3D; \varepsilon$：<br>构造 $M &#x3D; (\{q_0\}, \Sigma, \delta, q_0, \{q_0\})$，其中$\delta$为空函数</p></li><li><p>$r &#x3D; a$，$a \in \Sigma$：<br>构造 $M &#x3D; (\{q_0, q_1\}, \Sigma, \delta, q_0, \{q_1\})$，其中<br>$\delta(q_0, a) &#x3D; \{q_1\}$</p></li></ol><p>归纳步骤：<br>假设对于正则表达式 $r_1$ 和 $r_2$，已经构造出接受 $L(r_1)$ 和 $L(r_2)$ 的NFA $M_1 &#x3D; (Q_1, \Sigma, \delta_1, s_1, F_1)$ 和 $M_2 &#x3D; (Q_2, \Sigma, \delta_2, s_2, F_2)$。</p><ol><li><p>连接 $r &#x3D; r_1 \cdot r_2$：<br>构造 $M &#x3D; (Q_1 \cup Q_2, \Sigma, \delta, s_1, F_2)$，其中</p><ul><li>$\delta(q, a) &#x3D; \delta_1(q, a)$ 对于 $q \in Q_1, a \in \Sigma$</li><li>$\delta(q, a) &#x3D; \delta_2(q, a)$ 对于 $q \in Q_2, a \in \Sigma$</li><li>$\delta(f, \varepsilon) &#x3D; {s_2}$ 对于所有 $f \in F_1$</li></ul></li><li><p>选择 $r &#x3D; r_1|r_2$：<br>构造 $M &#x3D; (Q_1 \cup Q_2 \cup \{q_0\}, \Sigma, \delta, q_0, F_1 \cup F_2)$，其中</p><ul><li>$\delta(q_0, \varepsilon) &#x3D; {s_1, s_2}$</li><li>其他转移同上</li></ul></li><li><p>Kleene闭包 $r &#x3D; r_1*$：<br>构造 $M &#x3D; (Q_1 \cup \{q_0\}, \Sigma, \delta, q_0, \{q_0\} \cup F_1)$，其中</p><ul><li>$\delta(q_0, \varepsilon) &#x3D; \{s_1\}$</li><li>$\delta(f, \varepsilon) &#x3D; \{s_1, q_0\}$ 对于所有 $f \in F_1$</li></ul></li></ol><p><em>第三部分：有限自动机到正则表达式的转换</em></p><p><em>广义化的Kleene定理:</em> 对于任意NFA $M$，存在一个正则表达式 $r$，使得 $L(M) &#x3D; L(r)$。</p><p><strong>证明：</strong></p><p>给定NFA $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，令 $Q &#x3D; \{1, 2, …, n\}$。</p><ol><li><p>定义生成式 $R_{ij}^k$，表示从状态$i$到状态$j$的路径，其中中间状态编号不超过$k$。</p></li><li><p>基础情况 $(k &#x3D; 0)$：$R_{ij}^0 &#x3D; \{a | j \in \delta(i, a)\} \cup \{\varepsilon | i &#x3D; j\}$</p></li><li><p>归纳步骤：$R_{ij}^k &#x3D; R_{ij}^{k-1} \cup R_{ik}^{k-1}(R_{kk}^{k-1})^*R_{kj}^{k-1}$</p></li><li><p>最终表达式：$r &#x3D; \bigcup\{R_{0j}^n | j \in F\}$</p></li></ol><p><em>第四部分：等价性证明的完成</em></p><p>Kleene定理: 一个语言是正则的，当且仅当它能被某个有限自动机识别。</p><blockquote><p>The language is regular if and only if it can be recognized by some finite automaton.</p></blockquote><p><strong>证明：</strong></p><ol><li>$(\Rightarrow)$ 由定理2.1，每个正则表达式都可以转换为等价的NFA</li><li>$(\Leftarrow)$ 由定理3.1，每个NFA都可以转换为等价的正则表达式</li></ol><p>补充定理：对于任意正则表达式 $r$，如果 $M$ 是通过Thompson构造得到的NFA，那么：<br>$L(M) &#x3D; L(r)$</p><p><strong>证明：</strong> 用归纳法证明，对应每个构造步骤，证明：<br>$w \in L(r) \Leftrightarrow w \in L(M)$</p><blockquote><p>这里的等价性证明非常繁琐…我们只需要知道有限自动机和正则表达式在表示语言的能力上等价即可。直接记结论。</p></blockquote><hr><h3 id="3-3-正则表达式的代数定律"><a href="#3-3-正则表达式的代数定律" class="headerlink" title="3.3 正则表达式的代数定律"></a>3.3 正则表达式的代数定律</h3><p>正则表达式的代数定律是形式语言与自动机理论中的重要内容，它描述了正则表达式在运算过程中具有的一些代数性质。这些定律可以帮助简化和推导正则表达式，进而用于分析和构造自动机。以下是常见的正则表达式代数定律：</p><p><strong>1.交换律 (Commutative Law)</strong></p><ul><li>对于两种运算，正则表达式的并运算是满足交换律的，但是<em>连接运算是不满足的。</em></li><li><strong>并运算：</strong><br>$$<br>A + B &#x3D; B + A<br>$$<br>意思是，两个正则表达式的并运算可以交换顺序。</li><li><strong>连接运算：</strong><br>$$<br>A \cdot B \neq B \cdot A<br>$$</li></ul><p><strong>2.结合律 (Associative Law)</strong></p><ul><li><strong>并运算：</strong><br>$$<br>(A + B) + C &#x3D; A + (B + C)<br>$$</li><li><strong>连接运算：</strong><br>$$<br>(A \cdot B) \cdot C &#x3D; A \cdot (B \cdot C)<br>$$</li></ul><p><strong>3.分配律 (Distributive Law)</strong></p><ul><li><strong>连接对并的分配律：</strong><br>$$<br>A \cdot (B + C) &#x3D; (A \cdot B) + (A \cdot C)<br>$$</li><li><strong>并对连接的分配律：</strong><br>$$<br>(A + B) \cdot C &#x3D; (A \cdot C) + (B \cdot C)<br>$$</li></ul><p><strong>4.单位元律 (Identity Law)</strong></p><ul><li>正则表达式中有“单位元”概念，通常用空集和空字符串表示。<ul><li>空集 $∅$ 与并运算：<br>$$<br>A + \emptyset &#x3D; A<br>$$</li><li>空字符串 $ε$ 与连接运算：<br>$$<br>A \cdot \varepsilon &#x3D; A<br>$$</li></ul></li></ul><p><strong>5.幂集运算 (Kleene Star)</strong></p><ul><li>Kleene星（表示零次或多次重复）有一些特殊的性质：<ul><li><strong>结合律：</strong><br>$$<br>(A^*)^* &#x3D; A^*<br>$$</li><li><strong>吸收律：</strong><br>$$<br>A \cdot A^* &#x3D; A^*<br>$$<br>$$<br>A^* \cdot A &#x3D; A^*<br>$$</li><li><strong>与空集结合：</strong><br>$$<br>\emptyset^* &#x3D; \varepsilon<br>$$</li><li><strong>空字符串的 Kleene 星：</strong><br>$$<br>\varepsilon^* &#x3D; \varepsilon<br>$$</li></ul></li></ul><hr><h3 id="3-4-Pumping-Lemma"><a href="#3-4-Pumping-Lemma" class="headerlink" title="3.4 Pumping Lemma"></a>3.4 Pumping Lemma</h3><p>正则语言的泵引理（<strong>Pumping Lemma</strong>）是形式语言与自动机理论中的一个重要工具，用于证明某个语言不是正则语言。泵引理提供了一种“泵”的性质，即正则语言中的某些字符串可以在一定条件下重复（或“泵”）而不改变该字符串是否属于语言。</p><p>泵引理主要适用于正则语言，它指出：如果一个语言是正则的，那么存在一个常数 $p$（泵长度），对于任何长度大于或等于 $p$ 的字符串 $s \in L$（该字符串属于语言 $L$），都可以将 $s$ 分解成以下三部分：</p><ul><li>$s &#x3D; xyz$，其中：<ul><li>$x$ 是 $s$ 的前缀（可能为空）。</li><li>$y$ 是可以被“泵”的部分，且 $|y| &gt; 0$。</li><li>$z$ 是 $s$ 的后缀（可能为空）。</li></ul></li></ul><p>并且，对于任意 $i \geq 0$，字符串 $xy^i z$ 都应该属于语言 $L$，也就是说，$y$ 可以重复任意次数而不影响 $s$ 是否在语言 $L$ 中。</p><hr><h4 id="3-4-1-正则语言的泵引理证明"><a href="#3-4-1-正则语言的泵引理证明" class="headerlink" title="3.4.1 正则语言的泵引理证明"></a>3.4.1 正则语言的泵引理证明</h4><p>泵引理是正则语言的一个重要性质，它指出：如果一个语言是正则的，那么存在一个常数 $p$（泵长度），对于任何长度大于或等于 $p$ 的字符串 $s \in L$（该字符串属于语言 $L$），都可以将 $s$ 分解成以下三部分：</p><ul><li>$s &#x3D; xyz$，其中：<ul><li>$x$ 是 $s$ 的前缀（可能为空）。</li><li>$y$ 是可以被“泵”的部分，且 $|y| &gt; 0$。</li><li>$z$ 是 $s$ 的后缀（可能为空）。</li></ul></li></ul><p>并且，对于任意 $i \geq 0$，字符串 $xy^i z$ 都应该属于语言 $L$，也就是说，$y$ 可以重复任意次数而不影响 $s$ 是否在语言 $L$ 中。</p><p><strong>证明思路:</strong></p><ol><li><p><strong>假设语言是正则的</strong>：假设语言 $L$ 是正则的，那么存在一个有限状态自动机（DFA）能够接受语言 $L$。我们称该自动机为 $M$，其状态数为 $q$（即 $M$ 的状态集大小）。设 $p &#x3D; q$，这是泵引理中的泵长度。</p></li><li><p><strong>选择适当的字符串$s$</strong> ：选择一个字符串 $s \in L$，且 $|s| \geq p$。由于 $s$ 的长度大于或等于 $p$，它会经过 DFA $M$ 的多个状态，并且会在某些状态之间重复。</p></li><li><p><strong>应用鸽巢原理(Pigeonhole principle)</strong> ：根据鸽巢原理，若一个物体放入有限多个箱子中，且物体数量超过箱子数量，那么至少有一个箱子中必须放入超过一个物体。</p><p>在这里，DFA $M$ 有 $p$ 个状态（箱子），而字符串 $s$ 长度至少为 $p$，因此在 $s$ 从起始状态到终止状态的过程中，至少有两个不同的位置会经过相同的状态。具体地，假设 $s &#x3D; a_1 a_2 \dots a_n$，其中 $n \geq p$，我们可以表示 $s$ 的执行过程中的状态序列为：<br>$$<br>q_0, q_1, q_2, \dots, q_n<br>$$<br>其中 $q_0$ 是初始状态，$q_1, q_2, \dots, q_n$ 是字符串 $s$ 中每个字符对应的状态转换。</p><p>由于状态总共有 $p$ 个，因此，根据鸽巢原理，在这 $n$ 步转换中，必然存在一个状态 $q_i$（在 $1 \leq i \leq n$）至少重复一次。假设 $q_i &#x3D; q_j$ 且 $i &lt; j$，那么在 $s$ 中，$a_i, a_{i+1}, \dots, a_j$ 这部分的输入字符会使自动机回到同一个状态。这就为我们提供了分解字符串 $s$ 的依据。</p></li><li><p><strong>分解字符串$s$</strong> ：假设字符串 $s$ 被分解为：<br>$$<br>s &#x3D; x , y , z<br>$$<br>其中：</p><ul><li>$x &#x3D; a_1 a_2 \dots a_{i-1}$（从起始位置到重复状态之前的部分），</li><li>$y &#x3D; a_i a_{i+1} \dots a_{j-1}$（从第一个重复状态到第二个重复状态之间的部分），</li><li>$z &#x3D; a_j a_{j+1} \dots a_n$（从第二个重复状态之后的部分）。</li></ul><p>注意到 $y$ 至少包含一个字符，因为 $i &lt; j$，所以 $|y| &gt; 0$。</p></li><li><p><strong>验证泵操作</strong> ：现在我们需要验证，对于任意 $i \geq 0$，字符串 $xy^i z$ 仍然属于语言 $L$。</p><ul><li>由于 $y$ 的重复仅仅是使自动机在状态空间中来回循环，但没有改变接受状态，因此可以通过重复 $y$ 来构造新的字符串 $xy^i z$，使得新的字符串也能被自动机接受。即：<br>$$<br>xy^i z \in L \quad \text{对于任意} \quad i \geq 0<br>$$<br>这就完成了对泵引理的证明。</li></ul></li></ol><img src="/img/FL/pumping_lemma.svg" alt="泵引理证明" style="max-width: 100%; height: auto;" /><p>通过鸽巢原理，我们证明了正则语言的泵引理。我们假设语言是正则的，构造一个长度大于等于泵长度 $p$ 的字符串，并应用鸽巢原理来确定字符串中的某些部分是重复的。然后，通过分解字符串并使用状态重复性（即“泵”）来证明任意重复的部分都不会改变字符串是否属于语言，从而完成了泵引理的证明。</p><hr><h4 id="3-4-2-泵引理的形式化描述"><a href="#3-4-2-泵引理的形式化描述" class="headerlink" title="3.4.2 泵引理的形式化描述"></a>3.4.2 泵引理的形式化描述</h4><p>假设 $L$ 是一个正则语言，那么存在一个常数 $p$，满足：</p><ol><li><p>对于任意的字符串 $s \in L$，如果 $|s| \geq p$，那么 $s$ 可以被分解为 $s &#x3D; xyz$，且满足：</p><ul><li>$|xy| \leq p$，</li><li>$|y| &gt; 0$。</li></ul></li><li><p>对于任意 $i \geq 0$，字符串 $xy^i z \in L$。</p></li></ol><p>泵引理的作用是帮助我们<strong>证明某个语言不是正则的</strong>。具体来说，如果我们能够找到一个语言中的某个字符串，并且我们无法将它分解成符合上述条件的三部分（即无法“泵”），那么就可以证明该语言不是正则的。</p><p><em>如何使用泵引理证明语言不是正则的?</em></p><ol><li><p><strong>假设语言是正则的</strong>：首先假设语言 $L$ 是正则的，那么根据泵引理，必定存在一个泵长度 $p$。</p></li><li><p><strong>选择一个适当的字符串</strong>：从语言 $L$ 中选择一个特定的字符串 $s$，使得 $|s| \geq p$。</p></li><li><p><strong>尝试分解字符串</strong>：尝试将该字符串 $s$ 分解为 $s &#x3D; xyz$，并确保满足上述条件。特别注意，$y$ 部分必须满足 $|y| &gt; 0$。</p></li><li><p><strong>尝试泵操作</strong>：通过不同的 $i$ 值（即对 $y$ 进行不同次数的重复），构造新的字符串 $xy^i z$。</p></li><li><p><strong>找出矛盾</strong>：如果在某些情况下，$xy^i z$ 不再属于语言 $L$，那么就说明假设语言 $L$ 是正则的错误，从而得出结论，$L$ 不是正则语言。</p></li></ol><hr><p><strong>例子 1：</strong> 语言 $L &#x3D; \{ a^n b^n \mid n \geq 0 \}$</p><p>我们来尝试使用泵引理证明这个语言不是正则的。</p><ol><li><p>假设 $L$ 是正则的，那么根据泵引理，存在一个常数 $p$，对于任意 $s \in L$ 且 $|s| \geq p$，都可以分解为 $s &#x3D; xyz$，并且满足：</p><ul><li>$|xy| \leq p$，</li><li>$|y| &gt; 0$。</li></ul></li><li><p>选择 $s &#x3D; a^p b^p$ 作为字符串。显然，$|s| &#x3D; 2p \geq p$，所以 $s$ 必须符合泵引理。</p></li><li><p>根据泵引理，$s &#x3D; xyz$ 且 $|xy| \leq p$，这意味着 $x$ 和 $y$ 只能包含字符 $a$，而 $z$ 中包含的字符则包含 $b$。</p></li><li><p>由于 $y$ 至少包含一个 $a$（因为 $|y| &gt; 0$），我们可以通过泵操作，选择 $i &#x3D; 2$ 生成字符串 $xy^2z$，即将 $y$ 中的 $a$ 重复一次。结果是一个包含 $p+1$ 个 $a$ 和 $p$ 个 $b$ 的字符串，显然它不属于语言 $L$，因为 $L$ 中的字符串必须有相同数量的 $a$ 和 $b$。</p></li><li><p>由于构造的字符串不属于 $L$，这与我们假设 $L$ 是正则语言相矛盾。因此，语言 $L &#x3D; { a^n b^n \mid n \geq 0 }$ 不是正则的。</p></li></ol><p><strong>例子 2：</strong> 语言 $L &#x3D; \{ ww \mid w \in {a, b}^* \}$</p><ol><li><p>假设 $L$ 是正则的，那么根据泵引理，存在一个泵长度 $p$。</p></li><li><p>选择 $s &#x3D; a^p b^p a^p b^p$ 作为字符串，显然，$|s| &#x3D; 4p \geq p$，所以 $s$ 必须符合泵引理。</p></li><li><p>根据泵引理，$s &#x3D; xyz$ 且 $|xy| \leq p$，这意味着 $x$ 和 $y$ 只能包含字符 $a$，而 $z$ 中包含的字符包含 $b$ 和后面的部分。</p></li><li><p>通过泵操作，选择 $i &#x3D; 2$ 生成字符串 $xy^2z$。由于 $y$ 部分仅包含 $a$，所以将 $y$ 重复后，得到的字符串是 $a^{p+k} b^p a^p b^p$（其中 $k &gt; 0$）。显然，这个字符串不能保持原始形式 $ww$，因为它不再符合形式 $ww$（即左右两部分必须完全相同）。</p></li><li><p>因此，语言 $L$ 不是正则的。</p></li></ol><p>泵引理是用来<strong>证明某个语言不是正则语言</strong>的重要工具。通过假设某个语言是正则的，并利用泵引理来分析该语言的字符串，若能找到无法满足泵引理条件的字符串，就能证明该语言不是正则语言。它为我们提供了一个有效的手段来排除正则性，尤其在证明一些较为复杂的语言不是正则语言时非常有用。</p><hr><h3 id="3-5-正则语言的封闭性"><a href="#3-5-正则语言的封闭性" class="headerlink" title="3.5 正则语言的封闭性"></a>3.5 正则语言的封闭性</h3><p>正则语言的封闭性（Closure Property）是指正则语言在某些操作下的结果仍然是正则语言。也就是说，如果我们对正则语言进行某些运算操作，那么得到的语言仍然是正则的。我们要证明正则语言在以下几种情况下是封闭的：</p><ul><li>并（Union）</li><li>交（Intersection）</li><li>连接（Concatenation）</li><li>闭包（Kleene Closure）</li><li>补（Complement）</li><li>差（Difference）</li><li>反转（Reversal）</li><li>同态（Homomorphism）</li><li>逆同态（Inverse Homomorphism）</li></ul><div class="note note-success">            <p>修考题经常考前面6个封闭性性质的证明,重点掌握</p>          </div><hr><h4 id="3-5-1-并运算的封闭性"><a href="#3-5-1-并运算的封闭性" class="headerlink" title="3.5.1 并运算的封闭性"></a>3.5.1 并运算的封闭性</h4><p><strong>并运算</strong>（Union）指的是将两个语言中的所有字符串合并在一起，构成一个新的语言。具体来说，给定两个语言 $L_1$ 和 $L_2$，它们的并集定义为：</p><p>$$<br>L_1 \cup L_2 &#x3D; \{ w \mid w \in L_1 \text{ 或者 } w \in L_2 \}<br>$$</p><p>这意味着，任何一个属于 $L_1$ 或者 $L_2$ 的字符串都将属于 $L_1 \cup L_2$。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 是正则语言，那么 $L_1 \cup L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于并运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的并集 $L_1 \cup L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对并运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若我们有两个 DFA 分别接受 $L_1$ 和 $L_2$，我们将构造一个新的自动机来接受它们的并集。</p><p><strong>Step 1：</strong>  <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设我们有两个正则语言 $L_1$ 和 $L_2$，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们的目标是构造一个新的 DFA $M$，使得它接受 $L_1 \cup L_2$。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M$ 来接受 $L_1 \cup L_2$</em></p><p>我们将使用一个新的起始状态，并通过非确定性选择进入 $M_1$ 或 $M_2$ 来模拟两个原始的 DFA。这种方法是基于非确定性有限自动机（NFA）的构造，最后我们将转换为一个 DFA。</p><ol><li><p><strong>状态集</strong>：新的自动机 $M$ 的状态集是 $Q_1 \cup Q_2$。也就是说，$M$ 的状态集合包括 $M_1$ 和 $M_2$ 的所有状态。</p></li><li><p><strong>起始状态</strong>：$M$ 的起始状态 $q_0$ 是一个新的状态，表示新的起始状态。我们通过 $\epsilon$-转换从 $q_0$ 转移到 $q_1^0$（$M_1$ 的起始状态）或者 $q_2^0$（$M_2$ 的起始状态）。这表示新的自动机可以选择进入 $M_1$ 或 $M_2$ 来继续执行。</p></li><li><p><strong>接受状态</strong>：$M$ 的接受状态是 $M_1$ 和 $M_2$ 的接受状态集合的并集，即 $F &#x3D; F_1 \cup F_2$。这意味着，只要 $M$ 到达 $M_1$ 或 $M_2$ 中的任何接受状态，就接受该字符串。</p></li><li><p><strong>转移函数</strong>：新的转移函数 $\delta$ 是如下定义的：</p><ul><li>如果在状态 $q_1$ 上，按照 $M_1$ 的转移函数进行转移；</li><li>如果在状态 $q_2$ 上，按照 $M_2$ 的转移函数进行转移；</li><li>从新的起始状态 $q_0$ 可以通过 $\epsilon$-转换分别转移到 $M_1$ 和 $M_2$ 的起始状态。</li></ul></li></ol><p>这样，我们通过构造一个新的 NFA 来接受 $L_1 \cup L_2$。由于 NFA 和 DFA 等价，最终我们可以将 NFA 转换为一个等价的 DFA，因此我们得出结论，$L_1 \cup L_2$ 是正则语言。</p><p>通过构造一个新的 NFA，我们证明了正则语言对于并运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 是正则语言，则它们的并集 $L_1 \cup L_2$ 也是正则语言。因为 NFA 和 DFA 等价，最终我们可以将 NFA 转换为 DFA，从而证明 $L_1 \cup L_2$ 是正则语言。</p><hr><p><strong>举个例子：</strong> 假设我们有两个正则语言：</p><ol><li>$L_1 &#x3D; \{ a^n \mid n \geq 1 \}$，由 DFA $M_1$ 接受。</li><li>$L_2 &#x3D; \{ b^n \mid n \geq 1 \}$，由 DFA $M_2$ 接受。</li></ol><p>我们希望构造一个 DFA 来接受 $L_1 \cup L_2$，即接受所有形式为 $a^n$ 或 $b^n$ 的字符串。通过上面的方法，构造出的 DFA 会有以下状态：</p><ul><li>起始状态 $q_0$，可以通过 $\epsilon$-转换进入 $M_1$ 或 $M_2$ 的起始状态。</li><li>接受状态为 $M_1$ 和 $M_2$ 的所有接受状态的并集。</li><li>转移规则根据 $M_1$ 和 $M_2$ 的转移规则构造。</li></ul><p>该 DFA 将正确接受 $a^n$ 或 $b^n$ 形式的字符串，因此它能够接受 $L_1 \cup L_2$。</p><p>通过构造一个新的 NFA 来接受并集 $L_1 \cup L_2$，并利用 NFA 和 DFA 等价的性质，我们证明了正则语言对于并运算是封闭的。即：如果 $L_1$ 和 $L_2$ 都是正则语言，那么它们的并集 $L_1 \cup L_2$ 也是正则语言。</p><hr><h4 id="3-5-2-交运算的封闭性"><a href="#3-5-2-交运算的封闭性" class="headerlink" title="3.5.2 交运算的封闭性"></a>3.5.2 交运算的封闭性</h4><p><strong>交运算</strong>（Intersection）用于表示两个语言中的共同部分。给定两个语言 $L_1$ 和 $L_2$，它们的交运算定义为：</p><p>$$<br>L_1 \cap L_2 &#x3D; \{ w \mid w \in L_1 \text{ and } w \in L_2 \}<br>$$</p><p>这意味着 $L_1 \cap L_2$ 包含所有同时属于 $L_1$ 和 $L_2$ 的字符串。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 都是正则语言，那么 $L_1 \cap L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于交运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的交运算 $L_1 \cap L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对交运算封闭，我们将利用有限状态自动机（DFA）来表示正则语言。具体来说，若 $L_1$ 和 $L_2$ 分别由 DFA $M_1$ 和 DFA $M_2$ 接受，我们将通过构造一个新的自动机来接受 $L_1 \cap L_2$。</p><p><strong>Step 1：</strong> <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设 $L_1$ 和 $L_2$ 都是正则语言，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们的目标是构造一个新的 DFA $M$ 来接受 $L_1 \cap L_2$，即所有同时属于 $L_1$ 和 $L_2$ 的字符串。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M$ 来接受 $L_1 \cap L_2$</em></p><p>为了构造接受交集 $L_1 \cap L_2$ 的 DFA，我们可以使用两个 DFA 的 <strong>直积自动机</strong>（product automaton）。直积自动机的状态集是由两个原始自动机的状态对组成，并且状态转移是由两个 DFA 的转移规则共同决定的。</p><ol><li><p><strong>状态集</strong>：$M$ 的状态集是 $Q_1 \times Q_2$，即每个状态由 $M_1$ 和 $M_2$ 的一个状态对组成。</p></li><li><p><strong>起始状态</strong>：$M$ 的起始状态是 $(q_1^0, q_2^0)$，即 $M_1$ 和 $M_2$ 的起始状态的组合。</p></li><li><p><strong>接受状态</strong>：$M$ 的接受状态集是 $F_1 \times F_2$，即 $M_1$ 和 $M_2$ 的接受状态的组合。这意味着只有当 $M_1$ 和 $M_2$ 都到达各自的接受状态时，$M$ 才会接受该字符串。</p></li><li><p><strong>转移函数</strong>：$M$ 的转移函数是通过 $M_1$ 和 $M_2$ 的转移函数组合得到的。具体来说，如果 $M_1$ 在状态 $q_1$ 接收输入符号 $a$ 并转移到状态 $q_1’$，同时 $M_2$ 在状态 $q_2$ 接收输入符号 $a$ 并转移到状态 $q_2’$，那么 $M$ 在状态 $(q_1, q_2)$ 接收输入符号 $a$ 后将转移到状态 $(q_1’, q_2’)$。</p></li></ol><p>通过这种构造，$M$ 就可以接受所有同时属于 $L_1$ 和 $L_2$ 的字符串，即接受交集 $L_1 \cap L_2$。</p><p>通过构造一个新的 DFA 来接受交集 $L_1 \cap L_2$，我们证明了正则语言对于交运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 都是正则语言，则它们的交运算 $L_1 \cap L_2$ 也是正则语言。</p><hr><p>假设我们有两个正则语言：</p><ol><li>$L_1 &#x3D; { a^n b^m \mid n \geq 1 \text{ and } m \geq 1 }$，即由一个或多个 ‘a’ 后跟一个或多个 ‘b’ 构成的字符串。</li><li>$L_2 &#x3D; { a^n b^n \mid n \geq 1 }$，即由相同数量的 ‘a’ 和 ‘b’ 构成的字符串。</li></ol><p>为了构造一个 DFA 来接受交集 $L_1 \cap L_2$，我们需要利用两个 DFA：</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA。</li><li>$M_2$ 是接受 $L_2$ 的 DFA。</li></ul><p>我们将通过<strong>直积构造法</strong>（product construction）来构造一个新的 DFA，它接受 $L_1 \cap L_2$。</p><p><strong>步骤 1：构造直积自动机</strong></p><ol><li><p><strong>状态集</strong>：</p><ul><li>$M_1$ 的状态集为 $Q_1$，$M_2$ 的状态集为 $Q_2$，因此交集自动机 $M$ 的状态集是 $Q_1 \times Q_2$，即每个状态是由 $M_1$ 和 $M_2$ 的状态对组成。</li></ul></li><li><p><strong>起始状态</strong>：</p><ul><li>$M_1$ 的起始状态是 $q_1^0$，$M_2$ 的起始状态是 $q_2^0$，因此交集自动机的起始状态是 $(q_1^0, q_2^0)$。</li></ul></li><li><p><strong>接受状态</strong>：</p><ul><li>$M_1$ 的接受状态集为 $F_1$，$M_2$ 的接受状态集为 $F_2$。因此，交集自动机的接受状态集为 $F_1 \times F_2$，即所有 $M_1$ 和 $M_2$ 都接受的状态对。</li></ul></li><li><p><strong>转移函数</strong>：</p><ul><li>假设 $M_1$ 在状态 $q_1$ 接收符号 $a$ 后转移到状态 $q_1’$，同时 $M_2$ 在状态 $q_2$ 接收符号 $a$ 后转移到状态 $q_2’$，那么交集自动机 $M$ 在状态 $(q_1, q_2)$ 接收符号 $a$ 后将转移到状态 $(q_1’, q_2’)$。</li></ul></li></ol><p>交集 DFA 的转移函数是通过两个原始 DFA 的转移函数组合而成的。</p><p><strong>步骤 2：构造过程的分析</strong></p><p>我们需要考虑交集 DFA 的工作过程：</p><ul><li><p><strong>对于输入字符串的处理</strong>：</p><ol><li>交集自动机将逐步处理输入字符串，状态转移遵循 $M_1$ 和 $M_2$ 的转移规则。</li><li>当读取到字符 ‘a’ 时，$M_1$ 继续在它的状态上移动，而 $M_2$ 也继续在它的状态上移动。</li><li>当读取到字符 ‘b’ 时，$M_1$ 和 $M_2$ 分别继续处理接下来的字符，保持状态的变化。</li></ol></li><li><p><strong>接受条件</strong>：</p><ul><li>字符串必须同时满足两个条件：它属于 $L_1$（即形如 $a^n b^m$），并且它属于 $L_2$（即形如 $a^n b^n$）。因此，交集自动机接受的字符串必须是形如 $a^n b^n$，且 $n \geq 1$。</li></ul></li></ul><p>通过这个构造，交集自动机能够接受所有形如 $a^n b^n$ 的字符串，其中 $n \geq 1$，即 $L_1 \cap L_2 &#x3D; \{ a^n b^n \mid n \geq 1 \}$。</p><p>通过直积构造法，最终我们得到一个新的 DFA，它接受所有形如 $a^n b^n$ 的字符串。</p><p>通过构造一个新的 DFA 来接受交集运算 $L_1 \cap L_2$，我们证明了正则语言对于交运算是封闭的。即：如果 $L_1$ 和 $L_2$ 都是正则语言，那么它们的交运算 $L_1 \cap L_2$ 也是正则语言。</p><hr><h4 id="3-5-3-连接运算的封闭性"><a href="#3-5-3-连接运算的封闭性" class="headerlink" title="3.5.3 连接运算的封闭性"></a>3.5.3 连接运算的封闭性</h4><p><strong>连接运算</strong>（Concatenation）是另一种常见的运算。连接运算指的是将两个语言中的所有字符串拼接在一起，构成一个新的语言。具体来说，给定两个语言 $L_1$ 和 $L_2$，它们的连接运算定义为：</p><p>$$<br>L_1 \cdot L_2 &#x3D; \{ w_1w_2 \mid w_1 \in L_1, w_2 \in L_2 \}<br>$$</p><p>这意味着，任何一个由 $L_1$ 中的字符串 $w_1$ 和 $L_2$ 中的字符串 $w_2$ 拼接而成的字符串都属于 $L_1 \cdot L_2$。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 是正则语言，那么 $L_1 \cdot L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于连接运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的连接运算 $L_1 \cdot L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对连接运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若我们有两个 DFA 分别接受 $L_1$ 和 $L_2$，我们将构造一个新的自动机来接受它们的连接。</p><p><strong>Step 1：</strong> <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设我们有两个正则语言 $L_1$ 和 $L_2$，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们的目标是构造一个新的 DFA $M$，使得它接受 $L_1 \cdot L_2$。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M$ 来接受 $L_1 \cdot L_2$</em></p><p>我们可以通过在 $M_1$ 的接受状态添加 $\epsilon$-转换，来将 $M_1$ 和 $M_2$ 连接起来，从而构造一个新的 DFA 来接受 $L_1 \cdot L_2$。</p><ol><li><p><strong>状态集</strong>：新的自动机 $M$ 的状态集是 $Q_1 \cup Q_2$，即包含 $M_1$ 和 $M_2$ 的所有状态。</p></li><li><p><strong>起始状态</strong>：$M$ 的起始状态是 $q_1^0$（即 $M_1$ 的起始状态）。从 $q_1^0$ 开始执行。</p></li><li><p><strong>接受状态</strong>：$M$ 的接受状态是 $F_2$，即 $M_2$ 的接受状态集。表示当 $M_2$ 达到接受状态时，接受该字符串。</p></li><li><p><strong>转移函数</strong>：</p><ul><li>如果在 $M_1$ 的状态中，按照 $M_1$ 的转移函数 $\delta_1$ 进行转移；</li><li>如果在 $M_2$ 的状态中，按照 $M_2$ 的转移函数 $\delta_2$ 进行转移；</li><li>当 $M_1$ 进入接受状态时，增加从 $M_1$ 的接受状态到 $M_2$ 的起始状态 $q_2^0$ 的 $\epsilon$-转换。</li></ul></li></ol><p>通过这种方式，新的自动机可以先接受 $L_1$ 中的字符串，然后接着接受 $L_2$ 中的字符串，最终接受整个字符串。</p><p>通过构造一个新的 DFA 来接受连接 $L_1 \cdot L_2$，我们证明了正则语言对于连接运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 是正则语言，则它们的连接 $L_1 \cdot L_2$ 也是正则语言。</p><hr><p>举个例子：假设我们有两个正则语言：</p><ol><li>$L_1 &#x3D; \{ a^n \mid n \geq 1 \}$，由 DFA $M_1$ 接受。</li><li>$L_2 &#x3D; \{ b^m \mid m \geq 1 \}$，由 DFA $M_2$ 接受。</li></ol><p>我们希望构造一个 DFA 来接受 $L_1 \cdot L_2$，即接受所有形式为 $a^n b^m$（$n, m \geq 1$）的字符串。通过上面的构造方法，得到的 DFA 将有以下状态：</p><ul><li>起始状态 $q_1^0$，接受 $L_1$ 中的 $a^n$ 字符串。</li><li>一旦 $M_1$ 接受完 $a^n$，它会通过 $\epsilon$-转换跳转到 $M_2$，然后接受 $b^m$ 字符串。</li><li>接受状态为 $M_2$ 的接受状态集。</li></ul><p>该 DFA 将正确接受所有形如 $a^n b^m$ 的字符串，因此它能够接受 $L_1 \cdot L_2$。</p><p>通过构造一个新的 DFA 来接受连接运算 $L_1 \cdot L_2$，我们证明了正则语言对于连接运算是封闭的。即：如果 $L_1$ 和 $L_2$ 都是正则语言，那么它们的连接 $L_1 \cdot L_2$ 也是正则语言。</p><hr><h4 id="3-5-4-闭包运算的封闭性"><a href="#3-5-4-闭包运算的封闭性" class="headerlink" title="3.5.4 闭包运算的封闭性"></a>3.5.4 闭包运算的封闭性</h4><p><strong>闭包运算</strong>（Kleene closure）用于表示一个语言中所有可能的字符串的任意次重复（包括空字符串）。给定一个语言 $L$，其 Kleene 闭包表示为：</p><p>$$<br>L^* &#x3D; \{ w_1 w_2 \cdots w_k \mid k \geq 0, w_i \in L \text{ for all } i \}<br>$$</p><p>这意味着 $L^*$ 包含所有由 $L$ 中的字符串组成的串，且可以重复零次或多次。换句话说，$L^*$ 包括空字符串 $\epsilon$ 以及 $L$ 中字符串的任意数量的串联。</p><p><strong>问题：</strong> 如果 $L$ 是正则语言，那么 $L^*$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于 Kleene 闭包运算是封闭的</strong>。也就是说，若 $L$ 是正则语言，那么它的 Kleene 闭包 $L^*$ 也是正则语言。</p><hr><p>为了证明正则语言对闭包运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若 $L$ 是由某个 DFA $M$ 接受的正则语言，那么我们将构造一个新的自动机来接受 $L^*$。</p><p><strong>Step 1：</strong> <em>假设 $L$ 是正则语言</em></p><p>假设 $L$ 是一个正则语言，并且由 DFA $M$ 接受。$M$ 的状态集为 $Q$，起始状态为 $q_0$，接受状态集为 $F$，以及转移函数为 $\delta$。</p><p>我们的目标是构造一个新的 DFA $M^*$ 来接受 $L^*$，即接受所有在 $L$ 中的字符串的任意次重复（包括空字符串）。</p><p><strong>Step 2：</strong>  构造一个新的自动机 $M^*$ 来接受 $L^*$</p><p>我们通过对原始 DFA $M$ 进行修改来构造一个新的 DFA $M^*$，使其能够接受 $L^*$。</p><ol><li><p><strong>状态集</strong>：$M^*$ 的状态集仍然是 $Q$，即与 $M$ 相同。</p></li><li><p><strong>起始状态</strong>：$M^*$ 的起始状态是原来的起始状态 $q_0$，并且我们将 $q_0$ 设置为一个额外的接受状态，因为空字符串 $\epsilon$ 也属于 $L^*$。</p></li><li><p><strong>接受状态</strong>：$M^*$ 的接受状态集是 $F \cup \{q_0\}$，即包括 $M$ 的接受状态以及起始状态 $q_0$（空字符串的情况）。</p></li><li><p><strong>转移函数</strong>：对于 $M^*$ 的转移函数：</p><ul><li>如果 $M$ 在某个状态 $q$ 上接收到输入符号 $a$，并转移到状态 $q’$，那么 $M^*$ 在状态 $q$ 上接收到 $a$ 后也转移到状态 $q’$。</li><li>另外，在 $M^*$ 中，当它到达某个接受状态时，它可以通过一个 $\epsilon$-转换回到原来的起始状态 $q_0$，以实现对重复的字符串的处理。</li></ul></li></ol><p>通过这种方式，$M^*$ 可以接受 $L$ 中所有字符串的任意次重复，并且包括空字符串。</p><p>通过对原始 DFA $M$ 进行修改，我们证明了正则语言对于闭包运算是封闭的。具体地说，若 $L$ 是正则语言，则它的 Kleene 闭包 $L^*$ 也是正则语言。</p><hr><p><strong>举个例子：</strong> 假设我们有一个正则语言：</p><ol><li>$L &#x3D; \{ a^n \mid n \geq 1 \}$，由 DFA $M$ 接受。</li></ol><p>我们希望构造一个 DFA 来接受 $L^*$，即接受所有形式为 $a^n$（$n \geq 1$）的字符串的任意次重复。这将包括像 $\epsilon$（空字符串）、$a$, $aa$, $aaa$ 等等的所有可能组合。</p><p>通过上面的构造方法，得到的 DFA 将有以下状态：</p><ul><li>起始状态 $q_0$，既是接受状态也是新的起始状态，因为我们需要接受空字符串。</li><li>从 $q_0$ 出发，如果接收到 $a$，则转移到 $q_1$（即接受 $a$）。</li><li>一旦到达 $q_1$，它可以继续接收更多的 $a$ 字符串。</li><li>在每次接收完一个字符串后，我们都可以通过 $\epsilon$-转换返回到起始状态 $q_0$，从而实现对多个 $a$ 字符串的重复。</li></ul><p>该 DFA 将正确接受 $a^n$ 的任意次重复形式，因此它能够接受 $L^*$。</p><p>通过构造一个新的 DFA 来接受 Kleene 闭包 $L^*$，我们证明了正则语言对于闭包运算是封闭的。即：如果 $L$ 是正则语言，那么它的 Kleene 闭包 $L^*$ 也是正则语言。</p><hr><h4 id="3-5-5-补运算的封闭性"><a href="#3-5-5-补运算的封闭性" class="headerlink" title="3.5.5 补运算的封闭性"></a>3.5.5 补运算的封闭性</h4><p><strong>补运算</strong>（Complement）用于表示一个语言中不包含的所有字符串。给定一个语言 $L$，它的补语言 $\overline{L}$ 定义为：</p><p>$$<br>\overline{L} &#x3D; \Sigma^* \setminus L<br>$$</p><p>其中，$\Sigma^*$ 表示所有可能的字符串的集合，$L$ 是一个语言，$\overline{L}$ 就是包含所有不属于 $L$ 的字符串的语言。</p><p><strong>问题：</strong> 如果 $L$ 是正则语言，那么 $\overline{L}$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于补运算是封闭的</strong>。也就是说，若 $L$ 是正则语言，那么它的补语言 $\overline{L}$ 也是正则语言。</p><hr><p>为了证明正则语言对补运算封闭，我们将使用有限状态自动机（DFA）来表示正则语言。具体来说，若 $L$ 是由某个 DFA $M$ 接受的正则语言，那么我们将通过改变 $M$ 来构造一个新的 DFA 来接受 $\overline{L}$。</p><p><strong>Step 1：</strong> <em>假设 $L$ 是正则语言</em></p><p>假设 $L$ 是一个正则语言，并且由 DFA $M$ 接受。$M$ 的状态集为 $Q$，起始状态为 $q_0$，接受状态集为 $F$，以及转移函数为 $\delta$。</p><p>我们的目标是构造一个新的 DFA $M’$ 来接受 $\overline{L}$，即接受所有不属于 $L$ 的字符串。</p><p><strong>Step 2：</strong> <em>构造一个新的自动机 $M’$ 来接受 $\overline{L}$</em></p><p>我们可以通过改变 $M$ 中接受状态的定义来构造一个新的 DFA 来接受 $\overline{L}$。</p><ol><li><p><strong>状态集</strong>：$M’$ 的状态集与 $M$ 相同，即 $Q$。</p></li><li><p><strong>起始状态</strong>：$M’$ 的起始状态与 $M$ 相同，即 $q_0$。</p></li><li><p><strong>接受状态</strong>：$M’$ 的接受状态集是 $M$ 中所有非接受状态的集合。也就是说，如果 $M$ 中的接受状态集是 $F$，那么 $M’$ 中的接受状态集就是 $Q \setminus F$，即所有不属于 $F$ 的状态。</p></li><li><p><strong>转移函数</strong>：$M’$ 的转移函数与 $M$ 的转移函数完全相同。也就是说，$M’$ 仍然按照 $M$ 中的转移规则进行状态转换。</p></li></ol><p>通过这种方式，$M’$ 会接受所有不属于 $L$ 的字符串，即它接受的语言是 $\overline{L}$。</p><hr><h4 id="3-5-6-差运算的封闭性"><a href="#3-5-6-差运算的封闭性" class="headerlink" title="3.5.6 差运算的封闭性"></a>3.5.6 差运算的封闭性</h4><p><strong>差运算</strong>（Difference）用于表示一个语言中的所有字符串减去另一个语言中的字符串。给定两个语言 $L_1$ 和 $L_2$，它们的差运算定义为：</p><p>$$<br>L_1 - L_2 &#x3D; \{ w \mid w \in L_1 \text{ and } w \notin L_2 \}<br>$$</p><p>这意味着 $L_1 - L_2$ 包含所有属于 $L_1$ 但不属于 $L_2$ 的字符串。</p><p><strong>问题：</strong> 如果 $L_1$ 和 $L_2$ 都是正则语言，那么 $L_1 - L_2$ 是否也是正则语言？</p><p>答案是：<strong>是的，正则语言对于差运算是封闭的</strong>。也就是说，若 $L_1$ 和 $L_2$ 都是正则语言，那么它们的差运算 $L_1 - L_2$ 也是正则语言。</p><hr><p>为了证明正则语言对差运算封闭，我们将利用正则语言的补运算封闭性以及交运算封闭性来完成证明。具体来说，若 $L_1$ 和 $L_2$ 都是正则语言，那么 $L_1 - L_2$ 可以表示为 $L_1 \cap \overline{L_2}$，即 $L_1$ 与 $L_2$ 的补语言 $\overline{L_2}$ 的交集。</p><p><strong>Step 1：</strong> <em>假设 $L_1$ 和 $L_2$ 是正则语言</em></p><p>假设 $L_1$ 和 $L_2$ 都是正则语言，并且分别由 DFA $M_1$ 和 DFA $M_2$ 接受。</p><ul><li>$M_1$ 是接受 $L_1$ 的 DFA，其中有状态集 $Q_1$，起始状态 $q_1^0$，接受状态集 $F_1$，以及转移函数 $\delta_1$。</li><li>$M_2$ 是接受 $L_2$ 的 DFA，其中有状态集 $Q_2$，起始状态 $q_2^0$，接受状态集 $F_2$，以及转移函数 $\delta_2$。</li></ul><p>我们想要构造一个新的 DFA 来接受 $L_1 - L_2$，即所有属于 $L_1$ 但不属于 $L_2$ 的字符串。</p><p><strong>Step 2：</strong> <em>利用补运算和交运算构造新自动机</em></p><p>首先，利用正则语言对补运算的封闭性，我们知道，如果 $L_2$ 是正则语言，那么它的补语言 $\overline{L_2}$ 也是正则语言。然后，利用正则语言对交运算的封闭性，我们知道 $L_1 \cap \overline{L_2}$ 也是正则语言。</p><ol><li><p><strong>构造 $M_1$ 和 $M_2$ 的补自动机：</strong> 假设 $M_1$ 和 $M_2$ 是接受 $L_1$ 和 $L_2$ 的 DFA。我们可以通过对 $M_2$ 进行修改，构造一个新的 DFA 来接受 $L_2$ 的补语言 $\overline{L_2}$，方法与补运算的证明相同。</p></li><li><p><strong>构造 $L_1 \cap \overline{L_2}$ 的交集自动机：</strong> 利用正则语言对交运算的封闭性，我们可以构造一个新的 DFA 来接受 $L_1 \cap \overline{L_2}$。这可以通过构造两个 DFA 的直积自动机（product automaton）来实现：每个状态对包含 $M_1$ 和 $M_2$ 的状态对，转移规则通过两者的转移函数组合来确定。（状态是两个自动机状态的笛卡尔积）</p></li></ol><p>通过这样的构造，新的自动机可以接受所有属于 $L_1$ 但不属于 $L_2$ 的字符串，即接受差语言 $L_1 - L_2$。</p><p>通过利用正则语言对补运算和交运算的封闭性，我们证明了正则语言对于差运算是封闭的。具体地说，若 $L_1$ 和 $L_2$ 都是正则语言，则它们的差运算 $L_1 - L_2$ 也是正则语言。</p><hr><h4 id="3-5-7-反转运算的封闭性"><a href="#3-5-7-反转运算的封闭性" class="headerlink" title="3.5.7 反转运算的封闭性"></a>3.5.7 反转运算的封闭性</h4><p>我们来探讨正则语言在<strong>反转运算</strong>下的封闭性。即，如果一个语言是正则的，那么它的反转语言也是正则的。</p><p><strong>定义：</strong> 给定一个语言 $L$，我们定义其<strong>反转语言</strong> $L^R$ 为：</p><p>$$<br>L^R &#x3D; \{ w^R \mid w \in L \}<br>$$</p><p>其中，$w^R$ 是字符串 $w$ 的反转。例如，如果 $w &#x3D; \text{abc}$，则 $w^R &#x3D; \text{cba}$。</p><p>正则语言的封闭性意味着，如果 $L$ 是一个正则语言，那么 $L^R$ 也一定是正则语言。</p><p>我们通过以下步骤来证明正则语言对反转运算是封闭的：</p><ol><li><p><strong>假设 $L$ 是一个正则语言</strong>，那么存在一个确定性有限自动机（DFA） $M$ 来接受 $L$。我们的目标是构造一个 DFA 来接受 $L^R$。</p></li><li><p><strong>构造反转的非确定性有限自动机（NFA）</strong>：</p><ul><li>假设 $M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 是接受语言 $L$ 的 DFA，其中：<ul><li>$Q$ 是状态集，</li><li>$\Sigma$ 是输入字母表，</li><li>$\delta$ 是转移函数，</li><li>$q_0$ 是起始状态，</li><li>$F$ 是接受状态集。</li></ul></li></ul><p>我们需要构造一个 NFA $M^R &#x3D; (Q, \Sigma, \delta^R, q_0^R, F^R)$ 来接受语言 $L^R$。</p></li><li><p><strong>反转过程的步骤</strong>：</p><ul><li><strong>反转接受状态</strong>：NFA 的接受状态集 $F^R$ 应该是原 DFA $M$ 的起始状态 $q_0$。</li><li><strong>反转转移函数</strong>：在 $M$ 中，每个状态到另一个状态的转移是由 $\delta$ 定义的。在 $M^R$ 中，我们将这些转移反向，即如果在 $M$ 中有一个转移 $\delta(q, a) &#x3D; p$，那么在 $M^R$ 中，$p$ 到 $q$ 也应有一个转移，记作 $\delta^R(p, a) &#x3D; q$。</li><li><strong>起始状态</strong>：NFA $M^R$ 的起始状态是 $M$ 的接受状态集 $F$ 中的所有状态。这是因为我们希望通过反转路径从接受状态回到起始状态。</li></ul></li><li><p><strong>从 NFA 到 DFA</strong>：</p><ul><li>由于正则语言是通过 DFA 接受的，因此我们可以通过<strong>子集构造法</strong>将 NFA 转换为一个等价的 DFA。这个 DFA 将接受语言 $L^R$。</li></ul></li><li><p><strong>结论</strong>：</p><ul><li>通过构造 NFA 和将其转换为 DFA，我们证明了反转运算对于正则语言是封闭的。</li></ul></li></ol><p>正则语言对反转运算是封闭的，即如果一个语言是正则的，那么它的反转语言也是正则的。通过构造 NFA 来接受反转语言，并利用子集构造法将其转化为 DFA，我们证明了这一点。</p><hr><h4 id="3-5-8-同态运算的封闭性"><a href="#3-5-8-同态运算的封闭性" class="headerlink" title="3.5.8 同态运算的封闭性"></a>3.5.8 同态运算的封闭性</h4><p>在形式语言理论中，<strong>同态</strong>（Homomorphism）是指将一个语言中的字母按某种规则替换为另一个字母或字母串的操作。我们来探讨正则语言在<strong>同态运算</strong>下的封闭性。即，如果一个语言是正则的，那么它的同态映射后的语言也是正则的。</p><p><strong>定义：</strong></p><p>给定一个字母表 $\Sigma$ 和一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，其中 $\Gamma$ 是另一个字母表，$\varphi$ 是将字符串从 $\Sigma$ 字母表映射到 $\Gamma$ 字母表的映射。</p><p>假设我们有一个语言 $L \subseteq \Sigma^*$，则语言 $L^\varphi$ 是通过对语言 $L$ 中的每个字符串应用同态映射 $\varphi$ 得到的语言：</p><p>$$<br>L^\varphi &#x3D; { \varphi(w) \mid w \in L }<br>$$</p><p>其中，$\varphi(w)$ 是字符串 $w$ 在同态映射下的结果。我们的目标是证明正则语言在同态下是封闭的，即如果 $L$ 是正则语言，那么 $L^\varphi$ 也是正则语言。</p><p>我们通过以下步骤来证明正则语言对同态运算是封闭的：</p><ol><li><p><strong>假设 $L$ 是一个正则语言</strong>：</p><ul><li>如果 $L$ 是正则语言，那么存在一个 DFA（确定性有限自动机）$M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 来接受 $L$。</li></ul></li><li><p><strong>定义同态映射</strong>：</p><ul><li>给定一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，它将字母表 $\Sigma$ 上的每个符号映射到 $\Gamma$ 上的字符串。</li><li>例如，假设 $\varphi$ 将 $\Sigma &#x3D; {a, b}$ 映射到 $\Gamma &#x3D; {0, 1}$，其中 $\varphi(a) &#x3D; 0$，$\varphi(b) &#x3D; 11$。对于字符串 $w &#x3D; ab$, $\varphi(w) &#x3D; 011$。</li></ul></li><li><p><strong>构造接受 $L^\varphi$ 的 NFA</strong>：</p><ul><li>给定 DFA $M$ 接受语言 $L$，我们将构造一个新的 NFA 来接受语言 $L^\varphi$。</li><li>对于 $M$ 中的每个状态转移 $\delta(q, a) &#x3D; p$，我们将新的 NFA 中的转移改为 $\delta’(q, \varphi(a)) &#x3D; p$，即每次读取字母 $a$ 时，我们在新自动机中读取 $\varphi(a)$。</li></ul></li><li><p><strong>从 NFA 到 DFA</strong>：</p><ul><li>由于正则语言是通过 DFA 接受的，因此我们可以通过<strong>子集构造法</strong>（subset construction）将这个新的 NFA 转换为一个等价的 DFA。</li></ul></li><li><p><strong>结论</strong>：</p><ul><li>通过上述构造过程，我们证明了正则语言在同态下是封闭的，即如果 $L$ 是正则语言，那么 $L^\varphi$ 也是正则语言。</li></ul></li></ol><hr><p><strong>子集构造法</strong>是将一个 NFA 转换为等价的 DFA 的经典方法。具体过程如下：</p><ol><li><p><strong>NFA 的状态集</strong>：</p><ul><li>假设我们已经构造了一个 NFA $M^\varphi &#x3D; (Q, \Gamma, \delta’, q_0, F)$ 来接受语言 $L^\varphi$，其中：<ul><li>$Q$ 是 NFA 的状态集，</li><li>$\Gamma$ 是新的字母表（经过同态映射后），</li><li>$\delta’$ 是新的转移函数，</li><li>$q_0$ 是起始状态，</li><li>$F$ 是接受状态集。</li></ul></li><li>在这个 NFA 中，状态的转移是非确定性的，因此多个状态可能会同时被激活。</li></ul></li><li><p><strong>DFA 的状态集</strong>：</p><ul><li>对应的 DFA 状态集是 NFA 状态集的<strong>子集</strong>。具体来说，DFA 中的每个状态都表示 NFA 中某些状态的集合。这些集合是 NFA 在某个状态和输入符号下可能到达的状态的集合。</li></ul></li><li><p><strong>DFA 状态转移</strong>：</p><ul><li>假设 DFA 的当前状态是 $S \subseteq Q$（即 NFA 中某些状态的集合），而当前输入符号是 $a \in \Gamma$。DFA 的下一状态是由 NFA 对每个状态集合的转移决定的：<br>$$<br>\delta_{\text{DFA}}(S, a) &#x3D; \bigcup_{q \in S} \delta’(q, a)<br>$$<br>也就是说，DFA 状态转移函数根据当前的输入符号 $a$，将所有处于集合 $S$ 中的 NFA 状态的转移结果联合起来，得到新的状态集合。</li></ul></li><li><p><strong>DFA 的起始状态</strong>：</p><ul><li>DFA 的起始状态对应于 NFA 起始状态的集合。假设 NFA 的起始状态是 $q_0$，那么 DFA 的起始状态是包含 $q_0$ 的集合：${q_0}$。</li></ul></li><li><p><strong>DFA 的接受状态</strong>：</p><ul><li>DFA 中的接受状态集合是 NFA 中任何包含接受状态的集合。具体来说，DFA 的状态 $S$ 是接受状态，如果 $S$ 包含 NFA 的某个接受状态。</li></ul></li><li><p><strong>结束</strong>：</p><ul><li>通过这些步骤，我们就能够构造一个 DFA，它的状态集由 NFA 的状态集的子集组成，转移函数由 NFA 的转移函数导出，起始状态和接受状态也对应了 NFA 中的起始状态和接受状态。</li></ul></li></ol><p><strong>例子</strong>：假设我们有一个简单的 NFA 和同态映射：</p><ul><li><p><strong>NFA</strong> $M^\varphi$ 接受语言 $L^\varphi$，其中 $\Sigma &#x3D; {a, b}$ 和 $\Gamma &#x3D; {0, 1}$，并且同态映射 $\varphi$ 如下：</p><ul><li>$\varphi(a) &#x3D; 0$</li><li>$\varphi(b) &#x3D; 11$</li></ul></li><li><p>假设 $L &#x3D; {ab, aa, abba}$，我们想要计算 $L^\varphi$，即应用同态映射后得到的语言：</p><ul><li>$\varphi(ab) &#x3D; 011$</li><li>$\varphi(aa) &#x3D; 00$</li><li>$\varphi(abba) &#x3D; 0111$</li></ul></li></ul><p>根据这些映射，我们可以构造一个 NFA 来接受 $L^\varphi &#x3D; {011, 00, 0111}$。接下来，我们使用子集构造法将 NFA 转换为一个 DFA。</p><hr><h4 id="3-5-9-逆同态运算的封闭性"><a href="#3-5-9-逆同态运算的封闭性" class="headerlink" title="3.5.9 逆同态运算的封闭性"></a>3.5.9 逆同态运算的封闭性</h4><p>在形式语言理论中，<strong>逆同态</strong>（Inverse Homomorphism）是指将一个语言中的字符串的各个字母按某种规则反向映射到字母表中的操作。我们来探讨正则语言在<strong>逆同态运算</strong>下的封闭性。即，如果一个语言是正则的，那么它的逆同态映射后的语言也是正则的。</p><p><strong>定义</strong>：给定一个字母表 $\Sigma$ 和一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，其中 $\Gamma$ 是另一个字母表，$\varphi$ 是将字符串从 $\Sigma$ 字母表映射到 $\Gamma$ 字母表的映射。</p><p>逆同态映射是一个将一个字符串从 $\Gamma^*$ 映射到 $\Sigma^*$ 的操作，记作 $\varphi^{-1}$. 对于任意的字符串 $w \in \Gamma^*$，$\varphi^{-1}(w)$ 表示所有可能的字符串，它们在同态映射 $\varphi$ 下可以映射到 $w$。</p><p>逆同态语言 $L^{\varphi^{-1}}$ 是对语言 $L$ 应用逆同态映射 $\varphi^{-1}$ 后得到的语言：</p><p>$$<br>L^{\varphi^{-1}} &#x3D; \{ w \in \Sigma^* \mid \varphi(w) \in L \}<br>$$</p><p>即，语言 $L^{\varphi^{-1}}$ 包含所有可以通过同态映射 $\varphi$ 映射到语言 $L$ 中的字符串。</p><p>我们要证明的是：<strong>如果 $L$ 是正则语言，那么 $L^{\varphi^{-1}}$ 也是正则语言</strong>。</p><p>我们通过以下步骤来证明正则语言在逆同态运算下是封闭的：</p><ol><li><p><strong>假设 $L$ 是正则语言</strong>：</p><ul><li>如果 $L$ 是正则语言，那么存在一个 DFA（确定性有限自动机）$M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 来接受 $L$。</li></ul></li><li><p><strong>定义逆同态映射</strong>：</p><ul><li>给定一个同态映射 $\varphi: \Sigma^* \to \Gamma^*$，我们定义其逆同态映射为 $\varphi^{-1}$，即对于每个字符串 $w \in \Gamma^*$，$\varphi^{-1}(w)$ 是所有可以被映射到 $w$ 的字符串。</li></ul></li><li><p><strong>构造逆同态的 NFA</strong>：</p><ul><li>假设我们已经有一个 DFA $M &#x3D; (Q, \Sigma, \delta, q_0, F)$ 来接受语言 $L$。我们要构造一个接受语言 $L^{\varphi^{-1}}$ 的 NFA。</li><li><strong>逆同态的状态转移</strong>：对于每个输入符号 $a \in \Gamma$，如果在 DFA 中有转移 $\delta(q, \varphi(a)) &#x3D; p$，则在逆同态的 NFA 中，我们可以反向将转移为从 $p$ 到 $q$ 的转移。</li><li>这个反向的过程类似于同态的构造，只不过是在反向应用同态映射的结果。</li></ul></li><li><p><strong>从 NFA 到 DFA</strong>：</p><ul><li>由于正则语言是通过 DFA 接受的，因此我们可以通过<strong>子集构造法</strong>（subset construction）将这个新的 NFA 转换为一个等价的 DFA。</li></ul></li><li><p><strong>结论</strong>：</p><ul><li>通过构造逆同态的 NFA，并通过子集构造法将其转化为 DFA，我们证明了正则语言在逆同态运算下是封闭的。</li></ul></li></ol><p>正则语言对逆同态运算是封闭的。也就是说，如果一个语言是正则的，那么它经过逆同态映射后的语言也是正则语言。我们通过将 DFA 中的转移规则反向应用于 NFA，进而通过子集构造法将其转化为 DFA，证明了这一点。</p><hr><h3 id="3-6-自动机最小化"><a href="#3-6-自动机最小化" class="headerlink" title="3.6 自动机最小化"></a>3.6 自动机最小化</h3><p>自动机最小化是形式语言与自动机理论中的一个重要主题，其目的是将一个确定有限自动机（DFA）转化为一个状态数量最少的等价自动机。最小化的目的是减少状态数量，进而减少计算复杂度和存储需求。</p><p>最小化的目标是通过合并一些等价的状态来简化自动机。两个状态被称为等价的，如果它们在自动机中的行为相同，即对于任何输入串，它们的转移和接受状态是一样的。</p><hr><h4 id="3-6-1-状态的等价性"><a href="#3-6-1-状态的等价性" class="headerlink" title="3.6.1 状态的等价性"></a>3.6.1 状态的等价性</h4><p>在自动机理论中，两个状态 $q_1$ 和 $q_2$ 被称为 <strong>等价状态</strong>，如果它们在给定的输入下，能够产生相同的行为。具体来说，两个状态 $q_1$ 和 $q_2$ 是等价的，意味着对于每一个输入串 $w$，从状态 $q_1$ 和 $q_2$ 出发，最终是否接受该串的结果是相同的。</p><p>形式化地讲，状态 $q_1$ 和 $q_2$ 等价，若满足以下条件：</p><ol><li>对于每个输入串 $w$，从 $q_1$ 和 $q_2$ 出发，最终的接受状态是否一致。即：<br>$$<br>\delta(q_1, w) \in F \iff \delta(q_2, w) \in F<br>$$<br>其中，$\delta(q, w)$ 表示从状态 $q$ 出发读取输入串 $w$ 后到达的状态，$F$ 是接受状态的集合。</li></ol><p>等价状态的数学证明：假设我们有一个确定有限自动机（DFA） $M &#x3D; (Q, \Sigma, \delta, q_0, F)$，其中：</p><ul><li>$Q$ 是状态集合；</li><li>$\Sigma$ 是输入字母表；</li><li>$\delta$ 是状态转移函数；</li><li>$q_0$ 是初始状态；</li><li>$F$ 是接受状态集合。</li></ul><p>我们要证明两个状态 $q_1$ 和 $q_2$ 等价，即：<br>$$<br>\delta(q_1, w) \in F \iff \delta(q_2, w) \in F \quad \text{对所有输入串 } w \text{ 成立}.<br>$$</p><p><strong>证明过程：</strong></p><ol><li><p><strong>定义等价关系：</strong><br>定义一个等价关系 $\sim$ 在状态集 $Q$ 上。对于任意两个状态 $q_1$ 和 $q_2$：</p><p>$$<br>q_1 \sim q_2 \iff \forall w \in \Sigma^*, \delta(q_1, w) \in F \iff \delta(q_2, w) \in F<br>$$<br>即 $q_1$ 和 $q_2$ 等价当且仅当，对于任意的输入串 $w$，从 $q_1$ 和 $q_2$ 出发，最终是否接受该串的结果是相同的。</p></li><li><p><strong>划分状态集：</strong><br>通过上述等价关系 $\sim$，将状态集 $Q$ 划分为若干个等价类，每个等价类中的状态对于所有输入串具有相同的接受行为。</p></li><li><p><strong>构造最小化自动机：</strong><br>在自动机最小化过程中，合并那些属于同一个等价类的状态。这些状态在任何输入下的行为完全一致，因此可以作为一个状态来表示，从而得到最小化的自动机。</p></li></ol><p><strong>反证法证明：</strong></p><p>假设 $q_1$ 和 $q_2$ 是两个状态，它们在行为上是等价的，即：<br>$$<br>\delta(q_1, w) \in F \iff \delta(q_2, w) \in F \quad \text{对于所有的输入串 } w.<br>$$</p><p>接下来我们证明：如果 $q_1 \sim q_2$，那么它们的转移关系完全一致。</p><ol><li><p>假设我们有一个输入字母 $a \in \Sigma$ 和状态 $q_1$, $q_2$，即考虑从 $q_1$ 和 $q_2$ 出发，分别读取输入字母 $a$ 后转移到新的状态。</p></li><li><p>由于 $q_1 \sim q_2$，对于任意的输入串 $w$，从 $q_1$ 和 $q_2$ 出发，最终的接受状态是相同的。因此，考虑输入串 $w &#x3D; a$ 时，从 $q_1$ 和 $q_2$ 出发，都会进入同一个接受状态或非接受状态。</p></li><li><p>从这个反推，我们可以得出：从状态 $q_1$ 和 $q_2$ 读取输入字母 $a$ 后，必须转移到相同的状态。因此，状态转移关系 $\delta(q_1, a) &#x3D; \delta(q_2, a)$ 必然成立。</p></li><li><p>由于 $q_1 \sim q_2$ 对于所有输入串 $w$ 都成立，因此可以逐步推断出它们的转移关系一致。</p></li></ol><p>通过上述过程，我们证明了两个状态 $q_1$ 和 $q_2$ 的等价性意味着它们的转移函数在所有输入下都一致，从而可以被合并为一个状态。在自动机最小化过程中，等价的状态可以被合并，从而简化自动机的结构，减少状态数量。</p><hr><h4 id="3-6-2-填表算法"><a href="#3-6-2-填表算法" class="headerlink" title="3.6.2 填表算法"></a>3.6.2 填表算法</h4><p>对于任意一个DFA，我们都可以找到一个等价的、状态数最少的DFA。两个状态如果对于任何输入串都产生相同的接受&#x2F;拒绝行为，我们就说它们是等价的。</p><p>让我们通过一个具体的例子来理解这个过程。考虑一个识别所有以”ab”结尾的二进制串的DFA：</p><p>形式化定义如下：</p><ul><li>状态集合 $Q &#x3D; \{q_0, q_1, q_2, q_3, q_4\}$</li><li>字母表 $\Sigma &#x3D; \{a, b\}$</li><li>初始状态 &#x3D; $q_0$</li><li>接受状态 $F &#x3D; \{q_4\}$</li></ul><p>转移函数 $\delta$ 可以表示为：</p><table><thead><tr><th>状态</th><th>$a$</th><th>$b$</th></tr></thead><tbody><tr><td>$q_0$</td><td>$q_1$</td><td>$q_3$</td></tr><tr><td>$q_1$</td><td>$q_1$</td><td>$q_2$</td></tr><tr><td>$q_2$</td><td>$q_1$</td><td>$q_4$</td></tr><tr><td>$q_3$</td><td>$q_1$</td><td>$q_3$</td></tr><tr><td>$q_4$</td><td>$q_1$</td><td>$q_3$</td></tr></tbody></table><p>填表算法步骤如下：</p><p><strong>Step 1</strong> :初始区分</p><p>首先，我们将所有状态分为两组：</p><ul><li>接受状态：$\{q_4\}$</li><li>非接受状态：$\{q_0, q_1, q_2, q_3\}$</li></ul><p><strong>Step 2</strong> :构建初始表格</p><p>我们创建一个对角表格，标记明显不等价的状态对（一个是接受状态，一个是非接受状态）：</p><table><thead><tr><th></th><th>$q_1$</th><th>$q_2$</th><th>$q_3$</th><th>$q_4$</th></tr></thead><tbody><tr><td>$q_0$</td><td>-</td><td>-</td><td>-</td><td>X</td></tr><tr><td>$q_1$</td><td></td><td>-</td><td>-</td><td>X</td></tr><tr><td>$q_2$</td><td></td><td></td><td>-</td><td>X</td></tr><tr><td>$q_3$</td><td></td><td></td><td></td><td>X</td></tr></tbody></table><p>其中 X 表示这对状态明显不等价。</p><p>补充一下什么是等价：</p><ul><li>如果 $q_i \in F$ 且 $q_j \notin F$，则 $(q_i, q_j)$ 不等价。</li><li>如果 $q_i \notin F$ 且 $q_j \in F$，则 $(q_i, q_j)$ 不等价。</li><li>否则，将 $(q_i, q_j)$ 标记为等价。</li></ul><p><strong>Step 3</strong> :迭代区分过程</p><p>对于每对状态 $p,q$，我们需要检查：</p><ul><li>在每个输入符号 $a \in \Sigma$ 下</li><li>如果 $\delta(p,a)$ 和 $\delta(q,a)$ 已被标记为不等价</li><li>则 $p$ 和 $q$ 也应被标记为不等价</li></ul><p>例如，检查 $(q_0,q_1)$：</p><ul><li>输入 $a$：$\delta(q_0,a)&#x3D;q_1$, $\delta(q_1,a)&#x3D;q_1$ （转向相同状态）</li><li>输入 $b$：$\delta(q_0,b)&#x3D;q_3$, $\delta(q_1,b)&#x3D;q_2$ </li><li>由于 $q_2$ 和 $q_3$ 在到达接受状态 $q_4$ 的能力上不同，所以 $q_0$ 和 $q_1$ 是不等价的</li></ul><p>最终的表格变为：</p><table><thead><tr><th></th><th>$q_1$</th><th>$q_2$</th><th>$q_3$</th><th>$q_4$</th></tr></thead><tbody><tr><td>$q_0$</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>$q_1$</td><td></td><td>X</td><td>X</td><td>X</td></tr><tr><td>$q_2$</td><td></td><td></td><td>X</td><td>X</td></tr><tr><td>$q_3$</td><td></td><td></td><td></td><td>X</td></tr></tbody></table><p><strong>Step 4</strong> : 合并等价状态</p><p>根据最终表格，我们可以看到所有状态对都被标记为不等价，因此这个自动机已经是最小的了。</p><p>如果有未被标记的状态对 $(p,q)$，则：</p><ul><li>创建一个新状态 $[p]$ 代表 $p$ 和 $q$ 的等价类</li><li>新状态的转移函数：$\delta([p],a) &#x3D; [\delta(p,a)]$</li><li>如果 $p$ 或 $q$ 是接受状态，则 $[p]$ 也是接受状态</li><li>如果 $p$ 或 $q$ 是初始状态，则 $[p]$ 也是初始状态</li></ul><p>填表算法基于以下重要概念：</p><ol><li><p>Myhill-Nerode 定理：两个状态等价当且仅当它们对于任何输入串都有相同的接受性</p></li><li><p>等价关系的传递性：如果状态 $p$ 等价于 $q$，且 $q$ 等价于 $r$，则 $p$ 等价于 $r$</p></li><li><p>不等价的传递性：如果输入 $w$ 能区分状态 $p$ 和 $q$，则 $w$ 也能区分所有等价于 $p$ 的状态和所有等价于 $q$ 的状态</p></li></ol><p>这个算法的时间复杂度为 $O(n^2)$，其中 $n$ 是状态数。它是求解DFA最小化问题的一个经典且高效的算法。</p><h2 id="4-Context-Free-Language"><a href="#4-Context-Free-Language" class="headerlink" title="4. Context-Free Language"></a>4. Context-Free Language</h2><p>上下文无关文法（Context-free grammar，CFG）是一种形式化的文法，用于生成语言。它由一个包含以下四个部分的四元组组成：</p><p>$$<br>G &#x3D; (V, \Sigma, R, S)<br>$$</p><ul><li>$V$：变量（非终结符）的集合。</li><li>$\Sigma$：终结符的集合，即语言中的字母表。</li><li>$R$：产生式规则的集合，每个规则的形态为 $A \rightarrow \alpha$，其中 $A \in V$ 是一个非终结符，$\alpha$ 是由终结符和非终结符组成的字符串（可以为空，表示空串）。</li><li>$S$：开始符号，是一个特殊的非终结符，表示语言的开始。</li></ul><p>上下文无关文法的关键在于其产生式规则的结构：每个产生式的左边是一个单一的非终结符（例如 $A$），右边是一个由终结符和非终结符组成的字符串（例如 $\alpha$）。这一点与<strong>上下文相关文法</strong>不同，后者的产生式规则的左边可以是多个符号的组合（非终结符或终结符）。</p><hr><h3 id="4-1-上下文无关语言的定义"><a href="#4-1-上下文无关语言的定义" class="headerlink" title="4.1 上下文无关语言的定义"></a>4.1 上下文无关语言的定义</h3><p>上下文无关语言（CFL）是由上下文无关文法（CFG）生成的语言。换句话说，如果一个语言可以通过某个上下文无关文法的规则从开始符号 $S$ 推导出一个字符串，那么这个字符串就属于上下文无关语言。</p><div class="note note-primary">            <p>上下文无关语言是一种形式语言，其生成规则由上下文无关文法（CFG）定义，不依赖于符号周围的上下文。</p>          </div><p>例如，考虑如下文法：$aSb \rightarrow aYb \mid \epsilon$</p><p>这个文法的符号串<code>Y</code>是根据<code>S</code>的派生式产生的，不依赖<code>S</code>的上下文<code>a</code>和<code>b</code>。</p><p><strong>上下文无关语言有如下特性：</strong></p><ul><li><strong>递归结构</strong>：上下文无关语言能够表示递归结构。它能够处理很多具有递归特征的语言，例如编程语言中的嵌套结构（如括号匹配、表达式求值等）。</li><li><strong>构造性强</strong>：上下文无关语言不仅可以描述自然语言中的一些结构，还能表达很多编程语言的语法。</li><li><strong>推导和归约</strong>：上下文无关语言的推导过程是基于替换规则的应用，直到生成一个由终结符组成的字符串。这个过程通常是“递归下降”的。</li></ul><p>上下文无关语言与 <strong>下推自动机（Pushdown Automaton，PDA）</strong> 密切相关。下推自动机是能够识别上下文无关语言的一种自动机模型。下推自动机与有限自动机的主要区别在于它有一个栈，可以用来存储额外的信息，从而实现对递归结构的处理。</p><p>例如，对于文法 $S \rightarrow aSb \mid \epsilon$</p><p>下推自动机可以使用栈来存储“a”并在遇到“b”时逐一弹出栈顶的“a”，从而保证字符串中的“a”和“b”的数量相等。</p><p>上下文无关语言的例子：</p><ul><li>$\{ a^n b^n \mid n \geq 0 \}$（例如 $aabbb$）</li><li>$\{ w \mid w \text{ 是一个合法的括号序列} \}$，比如 $(())$、(())、(()()() )等。</li><li>编程语言中的语法，如 C 语言中的函数定义、条件表达式等。</li></ul><p>尽管上下文无关语言在很多实际应用中都非常重要，但它们并不是万能的。上下文无关语言不能处理所有类型的语言，例如，语言</p><p>$$<br>\{ a^n b^n c^n \mid n \geq 0 \}<br>$$</p><p>就不是上下文无关的，因为它需要同时确保 $a$、$b$、$c$ 的数量相等，这超出了上下文无关文法的能力。</p><p>上下文无关语言（CFL）是一类可以由上下文无关文法生成的语言，具有非常广泛的应用，尤其在编程语言的语法分析中。它们能够表示许多递归结构，但并不具备表达所有形式语言的能力。上下文无关语言可以通过下推自动机进行识别，其计算能力介于有限自动机和图灵机之间。</p><p>接下来的内容我们就仔细探讨上下文无关语言的特点和识别它的PDA的特点</p><hr><h3 id="4-2-Derivation-Reduction"><a href="#4-2-Derivation-Reduction" class="headerlink" title="4.2 Derivation &amp; Reduction"></a>4.2 Derivation &amp; Reduction</h3><ul><li><strong>派生</strong>是从开始符号出发，一步步通过应用文法规则，直到得到一个终结符的串。</li><li><strong>规约</strong>是从终结符串开始，一步步逆向应用文法规则，将其简化为开始符号。</li></ul><p>派生和规约是语法分析的两个核心过程，在编译器的语法分析阶段起着至关重要的作用。</p><ul><li><strong>最左派生</strong>和<strong>最右派生</strong>是两种不同的推导方式，它们规定了在派生过程中每一步替换的顺序：最左派生总是替换最左边的非终结符，最右派生总是替换最右边的非终结符。</li><li><strong>规约</strong>是派生过程的逆过程，通过逆向应用产生式规则，将终结符串简化回开始符号。</li></ul><p>这两者在语法分析和推导中各有重要作用，理解它们对于学习上下文无关语言的解析非常关键。</p><hr><h4 id="4-2-1-派生（Derivation）"><a href="#4-2-1-派生（Derivation）" class="headerlink" title="4.2.1 派生（Derivation）"></a>4.2.1 派生（Derivation）</h4><p>派生是根据文法规则从开始符号 $S$ 开始，逐步替换非终结符，直到得到一个仅由终结符组成的字符串的过程。派生有两种常见的形式：<strong>最左派生</strong>和<strong>最右派生</strong>。</p><p><strong>最左派生（Left Derivation）</strong></p><p>最左派生指的是在派生过程中，每一步都选择最左边的非终结符进行替换。换句话说，在每一步推导中，总是选择最左边的非终结符来进行替换，直到最终只剩下终结符。</p><p><strong>最右派生（Right Derivation）</strong></p><p>最右派生指的是在派生过程中，每一步都选择最右边的非终结符进行替换。也就是说，在每一步推导中，总是选择最右边的非终结符来进行替换，直到最终只剩下终结符。</p><p>举个简单的例子辨别一下最左派生和最右派生：</p><p>$<br>E \rightarrow E + T \mid T \<br>$</p><p>$<br>T \rightarrow T * F \mid F <br>$</p><p>$<br>F \rightarrow (E) \mid id<br>$</p><p>让我们用这个文法来推导表达式 <code>id + id * id</code>。</p><p>在<strong>最左派生</strong>中,我们每次都选择最左边的非终结符来替换:</p><p>从起始符号开始：$E$</p><p>使用 $E \rightarrow E + T$ 替换最左边的 $E$：$E \Rightarrow E + T$</p><p>使用 $E \rightarrow T$ 替换最左边的 $E$：$E \Rightarrow T + T$</p><p>使用 $T \rightarrow F$ 替换最左边的 $T$：$E \Rightarrow F + T$</p><p>使用 $F \rightarrow id$ 替换 $F$：$E \Rightarrow id + T$</p><p>使用 $T \rightarrow T * F$ 替换 $T$：$E \Rightarrow id + T * F$</p><p>使用 $T \rightarrow F$ 替换 $T$：$E \Rightarrow id + F * F$</p><p>使用 $F \rightarrow id$ 替换第一个 $F$：$E \Rightarrow id + id * F$</p><p>使用 $F \rightarrow id$ 替换最后的 $F$：$E \Rightarrow id + id * id$</p><hr><p>在<strong>最右派生</strong>中,我们每次都选择最右边的非终结符来替换:</p><p>从起始符号开始：$E$</p><p>使用 $E \rightarrow E + T$ 替换 $E$：$E \Rightarrow E + T$</p><p>使用 $T \rightarrow T * F$ 替换最右边的 $T$：$E \Rightarrow E + T * F$</p><p>使用 $T \rightarrow F$ 替换 $T$：$E \Rightarrow E + F * F$</p><p>使用 $F \rightarrow id$ 替换最右边的 $F$：$E \Rightarrow E + F * id$</p><p>使用 $F \rightarrow id$ 替换剩下的 $F$：$E \Rightarrow E + id * id$</p><p>使用 $E \rightarrow T$ 替换 $E$：$E \Rightarrow T + id * id$</p><p>使用 $T \rightarrow F$ 替换 $T$：$E \Rightarrow F + id * id$</p><p>使用 $F \rightarrow id$ 替换 $F$：$E \Rightarrow id + id * id$</p><hr><h4 id="4-2-2-规约（Reduction）"><a href="#4-2-2-规约（Reduction）" class="headerlink" title="4.2.2 规约（Reduction）"></a>4.2.2 规约（Reduction）</h4><p>规约是派生的反过程，即从一个终结符字符串开始，逐步通过逆向应用文法规则，将字符串中的终结符和非终结符替换回更高层次的非终结符，直到恢复到开始符号 $S$ 为止。规约和派生是上下文无关文法中解析过程的两个主要组成部分。</p><p>在规约过程中，每一步都是根据文法的产生式规则来“逆向”推导。例如，如果有一个产生式 $A \rightarrow \alpha$，并且我们当前的字符串中包含 $\alpha$，则我们可以用 $A$ 来替代 $\alpha$。</p><p>假设我们已经得到了一个字符串（比如终结符的串），然后通过逆推规则一步一步将其还原为开始符号 $S$：</p><ol><li>如果字符串中包含某个产生式的右边部分（例如 $A \rightarrow \alpha$），我们可以用左边的非终结符 $A$ 替换掉右边的部分 $\alpha$。</li><li>继续这个过程，直到字符串被简化为开始符号 $S$。</li></ol><p>规约通常是在语法分析过程中进行的，尤其是<strong>自顶向下</strong>或<strong>自底向上</strong>的语法分析方法。</p><hr><p>假设我们有输入字符串 $id + id * id$，我们将展示如何将其规约回开始符号 $E$。规约过程实际上是最右派生的逆过程，我们需要从右向左观察并应用合适的产生式规则。<br>详细规约步骤</p><ul><li><p>第一步规约：观察最右端的 $id$，应用规则 $F \rightarrow id$<br>$$id + id * id \Rightarrow id + id * F$$</p></li><li><p>第二步规约：继续向左，遇到另一个 $id$，同样应用规则 $F \rightarrow id$<br>$$id + id * F \Rightarrow id + F * F$$</p></li><li><p>第三步规约：现在我们看到 $ F * F $ 的形式，这符合规则 $<br>T \rightarrow T*F$</p></li></ul><p>$$id + F * F \Rightarrow id + T$$</p><ul><li><p>第四步规约：处理最左边的 $id$，应用规则 $F \rightarrow id$<br>$$id + T \Rightarrow F + T$$</p></li><li><p>最后一步规约：应用规则 $E \rightarrow E + T$，将 $F + T$ 规约为 $E$<br>$$F + T \Rightarrow E$$</p></li></ul><hr><h3 id="4-3-文法等价性"><a href="#4-3-文法等价性" class="headerlink" title="4.3 文法等价性"></a>4.3 文法等价性</h3><p>在上下文无关文法（Context-Free Grammar, CFG）中，<strong>文法等价性</strong>指的是两个文法生成相同语言，即它们能够产生相同的所有字符串。换句话说，若两个文法 $G_1$ 和 $G_2$ 对于任意输入串 $w$ 都能通过各自的推导产生这个字符串 $w$，则我们称这两个文法是等价的。</p><p><strong>文法等价性的常见方式：</strong></p><ol><li><p><strong>语言等价</strong>：<br>如果两个文法生成相同的语言，即它们能够生成相同的所有字符串，那么我们说这两个文法是<strong>语言等价</strong>的。</p><p>对于文法 $G_1$ 和 $G_2$，如果 $\mathcal{L}(G_1) &#x3D; \mathcal{L}(G_2)$（其中 $\mathcal{L}(G)$ 表示文法 $G$ 生成的语言），那么它们是语言等价的。</p></li><li><p><strong>推导等价</strong>：<br>两个文法可能有不同的推导方式，但如果它们生成相同的语言，且能够通过等价的推导步骤将一个文法的推导转换为另一个文法的推导，我们也可以认为这两个文法在某种程度上是等价的。通常来说，如果文法 $G_1$ 和 $G_2$ 通过推导能够互相转换，它们也可以被视为等价的。</p></li></ol><p><strong>判断文法是否等价：</strong></p><ul><li><strong>直接比较语言</strong>：通过生成的语言是否相同来判断两个文法是否等价。</li><li><strong>转换法</strong>：通过将一个文法转换为另一个文法的等价形式（例如，转换为简化文法、正规文法等）来判断它们是否等价。</li></ul><p>让我举一个正确的语言等价的文法例子:</p><p>$G_1$:</p><p>$$<br>S \rightarrow aA<br>$$</p><p>$$<br>A \rightarrow aA \mid b<br>$$</p><p>$G_2$:</p><p>$$<br>S \rightarrow a a^* b<br>$$</p><p>这两个文法都生成语言 $L &#x3D; \{a^nb | n \geq 1\}$,即至少包含一个 $a$ 后面跟着一个 $b$ 的所有字符串。<br>我们可以验证:</p><p>$G_1$ 中,第一步必须生成一个 $a$,然后 $A$ 可以生成任意多个 $a$ 最后生成一个 $b$<br>$G_2$ 直接表达了这个语言的形式:一个 $a$ 后面跟着任意多个 $a$ (包括零个),最后是一个 $b$</p><p>这两个文法虽然写法不同,但生成的语言完全相同,所以它们是语言等价的。</p><p>文法等价性通常是通过比较两个文法生成的语言是否相同来判断的。如果两个文法生成的语言相同，则我们认为它们是等价的。</p><hr><h3 id="4-4-Parse-Tree"><a href="#4-4-Parse-Tree" class="headerlink" title="4.4 Parse Tree"></a>4.4 Parse Tree</h3><p>在形式语言与自动机的学习中，<strong>语法分析树（Parse Tree）</strong> 是一个非常重要的概念。它通常用于表示一个输入字符串在某个特定文法下的语法结构，反映了该字符串如何由文法规则生成。语法分析树可以帮助我们理解输入字符串是如何符合某种文法的，并且它是编译器中的一个核心组件，特别是在编译过程的语法分析阶段。</p><h4 id="4-4-1-语法分析树定义"><a href="#4-4-1-语法分析树定义" class="headerlink" title="4.4.1 语法分析树定义"></a>4.4.1 语法分析树定义</h4><p>语法分析树是一棵树形结构，其特点如下：</p><ul><li><strong>根节点</strong>：树的根通常代表语言的开始符号（Start Symbol），例如 $S$（常见于上下文无关文法）。</li><li><strong>内部节点</strong>：每个内部节点表示文法中的某个非终结符，或者在某些情况下可能是终结符的组合。</li><li><strong>叶节点</strong>：树的叶子节点表示文法中的终结符，也就是输入字符串的实际字符或符号。</li></ul><p>构建语法分析树的过程实际上是推导过程的可视化。对于一个给定的输入字符串，通过应用文法规则逐步替代非终结符，直到最终替换成终结符。具体的过程包括：</p><ol><li><strong>选择开始符号</strong>，例如 $S$。</li><li>使用文法规则（例如 $S \to aSb \mid \epsilon$）将开始符号逐步展开，生成新的非终结符。</li><li>每次展开都会在树中添加一个新的节点，并继续扩展，直到输入字符串完全匹配到叶节点为止。</li><li>最终生成的树形结构就是该输入字符串的语法分析树。</li></ol><p>假设我们有一个简单的上下文无关文法：</p><p>$$<br>S \to aSb \mid \epsilon<br>$$</p><p>我们想分析字符串 <code>&quot;aabb&quot;</code> 是否符合这个文法。</p><ul><li><strong>步骤 1</strong>：从根节点开始，$S$。</li><li><strong>步骤 2</strong>：使用 $S \to aSb$ 规则，得到 $S \to aSb$。</li><li><strong>步骤 3</strong>：继续展开 $S \to aSb$，得到 $S \to aaSbb$。</li><li><strong>步骤 4</strong>：再次应用 $S \to \epsilon$，得到 $S \to aa\epsilon bb$，结果是 <code>&quot;aabb&quot;</code>。</li></ul><p>对应的语法分析树如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\a S b   /|\  a S b     |     ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="4-4-2-语法分析树与派生"><a href="#4-4-2-语法分析树与派生" class="headerlink" title="4.4.2 语法分析树与派生"></a>4.4.2 语法分析树与派生</h4><p>语法分析树是派生过程的图形化表示。每一次应用文法规则都对应语法分析树中的一个分支或一个节点的展开。具体来说：</p><ul><li>根节点：表示开始符号。</li><li>内部节点：表示一个非终结符，并且这些非终结符是通过相应的文法规则展开的。</li><li>叶子节点：表示终结符，通常是输入字符串的实际字符。</li></ul><p><strong>从派生到语法分析树：</strong></p><ul><li>给定一个派生过程，我们可以通过每一步推导生成一个节点，并将其按顺序组织成一棵树。</li><li>每个非终结符的应用对应语法分析树中的一个内节点，每次替代操作都创建树的分支。</li></ul><p><strong>从语法分析树到派生：</strong></p><ul><li>通过语法分析树，我们可以逆向得到派生过程。从根节点开始，逐层向下，按照每个节点的子节点选择合适的文法规则，逆推出每一步派生。</li></ul><p>根据上面例子的语法分析树</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\a S b   /|\  a S b     |     ε<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到：</p><ul><li>每一步派生都对应树中的每一层节点展开，每一层都是一个文法规则的应用。</li><li>从语法分析树回推派生：从根到叶的路径，可以通过每个非终结符的替换规则反推出派生过程。</li></ul><h4 id="4-4-3-Grammar-Ambiguity"><a href="#4-4-3-Grammar-Ambiguity" class="headerlink" title="4.4.3 Grammar Ambiguity"></a>4.4.3 Grammar Ambiguity</h4><p><strong>文法的歧义性（ Grammar Ambiguity）</strong>指的是一种情况：对于某个文法，它可以通过多种不同的方式生成同一个字符串，导致该字符串存在多个不同的<strong>语法分析树（Parse Tree）</strong>或<strong>推导（Derivations）</strong>。这种属性使得文法具有歧义性。</p><p>如果一个文法 $G$ 存在某个字符串 $w$（属于该文法生成的语言 $L(G)$），使得 $w$ 有<strong>两种或更多不同的最左推导（Leftmost Derivations）</strong>、最右推导或语法分析树，则称该文法 $G$ 是<strong>歧义文法</strong>。</p><p>换句话说：</p><ul><li>该文法中的某些规则允许通过多种不同的方式从开始符号 $S$ 推导出字符串 $w$。</li><li>歧义产生的原因是文法的结构无法唯一确定字符串的生成方式。</li></ul><hr><p><strong>歧义文法的例子</strong>：考虑以下文法 $G$：</p><p>$$<br>S \to S + S \mid S \times S \mid a<br>$$</p><ul><li>终结符 $a$ 表示一个变量或操作数。</li><li>非终结符 $S$ 表示一个表达式。</li></ul><p>该文法可以生成字符串 $a + a \times a$，但这个字符串有<strong>两种不同的语法分析树</strong>：</p><ol><li>如果优先处理“+”操作：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\S  + S|    /|\a   S  x S    |    |    a    a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ol><li>如果优先处理“×”操作：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  S /|\S  x S|    |a   S    /|\   S  + S   |    |   a    a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这两棵语法分析树对应相同的字符串 $a + a \times a$，但它们表示的结构和含义不同（例如，不同的操作符优先级会导致计算结果不同）。</p><p><strong>文法歧义性的影响</strong></p><ul><li><strong>语义不明确</strong>：文法的歧义性使得字符串的含义变得不明确。例如，在编程语言中，歧义文法可能会导致相同的表达式得出不同的结果。</li><li><strong>解析困难</strong>：歧义文法更难解析，因为解析器可能无法唯一确定语法分析树。</li><li><strong>编译器设计问题</strong>：大多数编程语言都要求文法是无歧义的，以确保代码的解析和执行是确定性的。</li></ul><p>遗憾的是，对于一个任意上下文无关文法（CFG），<strong>无法通过算法判断文法是否是歧义的</strong>。这是形式语言理论中的一个已知的不可判定问题（Undecidable Problem）。<br>不过，对于简单的情况，可以通过手动检查某些字符串是否有多种推导方式来发现歧义。</p><hr><p><strong>如何消除歧义:</strong> 如果一个文法是歧义的，有时可以将其重写为一个等价的<strong>无歧义文法</strong>。例如，上述的算术表达式文法可以通过引入操作符优先级和结合性规则来消除歧义：</p><ul><li>定义<strong>优先级</strong>：乘法（$\times$）的优先级高于加法（$+$）。</li><li>定义<strong>结合性</strong>：加法和乘法均为左结合。</li></ul><p>重写后的文法如下：</p><p>$$<br>E \to E + T \mid T<br>$$<br>$$<br>T \to T \times F \mid F<br>$$<br>$$<br>F \to a<br>$$</p><p>在这个文法中，字符串 $a + a \times a$ 的语法分析树唯一，结构如下：</p><figure><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">  E /|\E  + T|    |F    T|    |a    F     |     a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这棵语法分析树清楚地表示了“$\times$”比“$+$”具有更高的优先级，从而消除了歧义。</p><p>文法的歧义性不仅存在于编程语言或形式语言中，也经常出现在<strong>自然语言</strong>中。例如：</p><p><code>I saw the man with a telescope</code></p><p>这句话有两种解释：</p><ol><li><strong>我用望远镜看到了这个人。</strong></li><li><strong>我看到了一个拿着望远镜的人。</strong></li></ol><p>这种歧义也可以用两棵不同的语法分析树表示，与形式语言中的歧义类似。</p><h3 id="4-5-文法化简与范式"><a href="#4-5-文法化简与范式" class="headerlink" title="4.5 文法化简与范式"></a>4.5 文法化简与范式</h3><p>文法化简是形式语言与自动机理论中的重要内容，用于简化上下文无关文法（CFG），使其更易于分析或实现。文法化简的目标是通过一系列步骤，移除冗余规则和符号，同时保持生成语言不变。主要包括以下三步：</p><p><strong>Step 1:</strong> 消除无用符号</p><p>无用符号是指在文法中不可能被用来生成任何字符串的非终结符，分为两种情况：</p><ul><li><strong>不可达符号</strong>：从起始符号出发，无法到达的非终结符。</li><li><strong>非生成符号</strong>：无法推导出终结符串的非终结符。</li></ul><p><strong>处理方法</strong>：</p><ol><li>找出能够推导出终结符串的非终结符（生成符号）。</li><li>找出从起始符号可以到达的符号（可达符号）。</li><li>移除所有既非生成又不可达的符号及相关产生式。</li></ol><p><strong>Step 2:</strong> 消除 $\epsilon$-产生式</p><p>$\epsilon$-产生式是指形如 $A \to \epsilon$ 的规则（$\epsilon$ 表示空串）。除非文法描述的语言中包含空串，应尽量消除这些规则。</p><p><strong>处理方法</strong>：</p><ol><li>找出所有可以直接或间接推导出空串的非终结符（称为 $\epsilon$-可导符号）。</li><li>对于每个包含 $\epsilon$-可导符号的产生式，生成所有可能的替代产生式（通过省略这些符号）。</li><li>如果起始符号可以推导出空串，需增加新的起始符号：<br>$$<br>S’ \to S \ | \ \epsilon<br>$$</li></ol><p><strong>Step 3:</strong> 消除单一产生式</p><p>单一产生式是指形如 $A \to B$ 的规则，其中 $A$ 和 $B$ 都是非终结符。它们会增加文法复杂性但不会增加语言的表达能力。</p><p><strong>处理方法</strong>：</p><ol><li>找出所有的单一产生式。</li><li>替换单一产生式 $A \to B$ 为 $A$ 直接生成 $B$ 的所有右部。</li></ol><p><strong>Step 4:</strong> 化简为规范形式（可选）</p><p>如果需要进一步化简，可将文法转化为以下特定的规范形式：</p><ul><li><strong>格雷巴赫范式（GNF）</strong>：每个产生式的右部以一个终结符开头，后跟若干非终结符。</li><li><strong>乔姆斯基范式（CNF）</strong>：每个产生式要么是两个非终结符，要么是一个终结符。</li></ul><p>$$<br>A \to BC<br>$$</p><p>$$<br>A \to a<br>$$</p><p>下面我们先了解一下文法化简的规范形式。</p><hr><h4 id="4-5-1-Chomsky-Normal-Form-CNF"><a href="#4-5-1-Chomsky-Normal-Form-CNF" class="headerlink" title="4.5.1 Chomsky Normal Form (CNF)"></a>4.5.1 Chomsky Normal Form (CNF)</h4><p>在形式语言与自动机理论中，<strong>Chomsky Normal Form（CNF）</strong> 是一种用于上下文无关文法（Context-Free Grammar，CFG）标准化的形式。通过将文法转换为 Chomsky 正常形式，很多算法（如 CYK 算法）可以变得更加高效。</p><p><strong>Chomsky Normal Form 的定义:</strong></p><p>一个上下文无关文法 $G &#x3D; (V, \Sigma, R, S)$，其中 $V$ 是非终结符的集合，$\Sigma$ 是终结符的集合，$R$ 是产生式规则的集合，$S$ 是起始符号。若该文法满足以下条件，则称其为 Chomsky Normal Form：</p><ol><li><p>每个产生式 $A \rightarrow \alpha$ 满足以下之一：</p><ul><li>$\alpha$ 是一个终结符，形式为 $A \rightarrow a$，其中 $a \in \Sigma$。</li><li>$\alpha$ 是两个非终结符的串，形式为 $A \rightarrow BC$，其中 $B, C \in V$，并且 $B$ 和 $C$ 不能是起始符号 $S$。</li></ul></li><li><p>如果文法包含空产生式（即 $S \rightarrow \epsilon$），则 $S$ 必须是唯一的起始符号，并且不能出现在右侧的产生式中。</p></li><li><p>如果文法包含单位产生式（即 $A \rightarrow B$），则可以用合适的规则进行替换，消除单位产生式。</p></li></ol><p>假设我们有一个上下文无关文法 $G$，想要将其转换为 Chomsky Normal Form，通常的步骤如下：</p><p><strong>Step 1:</strong> 移除空产生式<br>首先，移除所有的空产生式（即产生式 $A \rightarrow \epsilon$）。如果文法包含这样的产生式，需要适当调整其他产生式，将空产生式的影响消除。</p><p><strong>Step 2:</strong> 移除单位产生式<br>移除所有的单位产生式（即 $A \rightarrow B$ 形式的产生式）。这一步需要通过替换和合并产生式来完成。</p><p><strong>Step 3:</strong> 替换长右边的产生式<br>将所有右边有两个以上符号的产生式替换为符合 CNF 的形式。如果存在一个产生式 $A \rightarrow X_1 X_2 \dots X_n$，其中 $n &gt; 2$，则通过引入新的非终结符逐步将其拆分成二元产生式。</p><p><strong>Step 4:</strong> 替换终结符的混合产生式<br>如果在某个产生式中，右边含有终结符和非终结符混合的情况（例如 $A \rightarrow aB$，其中 $a \in \Sigma$ 且 $B \in V$），则通过引入新的非终结符来替换终结符。</p><p>假设我们有以下文法：</p><ul><li>$S \rightarrow AB \mid a$</li><li>$A \rightarrow SA \mid \epsilon$</li><li>$B \rightarrow b$</li></ul><p>我们将其转换为 Chomsky Normal Form：</p><ol><li><p><strong>移除空产生式</strong>：由于 $A \rightarrow \epsilon$，我们需要将文法中可能依赖 $A$ 的规则调整为不包含 $A$ 的形式。</p><ul><li>$S \rightarrow AB \mid a$ -&gt; $S \rightarrow AB \mid a \mid B$</li><li>$A \rightarrow SA$ -&gt; $A \rightarrow SA \mid S$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>移除单位产生式</strong>：从 $A \rightarrow S$ 和 $S \rightarrow B$ 可以看出我们有单位产生式。我们将 $A \rightarrow S$ 和 $S \rightarrow B$ 替换成等效的产生式。</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow AB \mid a$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>替换长右边的产生式</strong>：没有长右边的产生式，所有产生式都已经是符合 CNF 的。</p></li></ol><p>最终结果可能会是：</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow AB \mid a$</li><li>$B \rightarrow b$</li></ul><hr><h4 id="4-5-2-Greibach-Normal-Form-GNF"><a href="#4-5-2-Greibach-Normal-Form-GNF" class="headerlink" title="4.5.2 Greibach Normal Form (GNF)"></a>4.5.2 Greibach Normal Form (GNF)</h4><p><strong>Greibach Normal Form（GNF）</strong> 是另一种上下文无关文法（Context-Free Grammar，CFG）的标准形式。与 Chomsky Normal Form 不同，GNF 强调了产生式的结构形式。特别是，每个产生式的右侧必须以一个终结符开始，其后跟随零个或多个非终结符。</p><p><strong>Greibach Normal Form 的定义:</strong></p><p>一个上下文无关文法 $G &#x3D; (V, \Sigma, R, S)$，其中 $V$ 是非终结符的集合，$\Sigma$ 是终结符的集合，$R$ 是产生式规则的集合，$S$ 是起始符号。若该文法满足以下条件，则称其为 Greibach Normal Form：</p><ol><li><p>每个产生式 $A \rightarrow \alpha$ 都是以下形式之一：</p><ul><li>$\alpha$ 以一个终结符开始，形式为 $A \rightarrow a \gamma$，其中 $a \in \Sigma$，且 $\gamma$ 是非终结符的串（包括空串）。</li></ul></li><li><p>文法中的每个产生式右边必须以一个终结符开头，后面可以跟任意数量的非终结符。</p></li></ol><p>与 Chomsky Normal Form 不同，GNF 不要求右边的产生式是二元的，而是要求右边的第一个符号是终结符。</p><p>假设我们有一个上下文无关文法 $G$，想要将其转换为 Greibach Normal Form，通常的步骤如下：</p><p><strong>Step 1:</strong> 移除空产生式<br>首先，移除所有的空产生式（即产生式 $A \rightarrow \epsilon$）。如果文法包含这样的产生式，需要调整文法中的其他产生式，以消除空产生式的影响。</p><p><strong>Step 2:</strong> 移除单位产生式<br>移除所有的单位产生式（即 $A \rightarrow B$ 形式的产生式）。这一步需要通过替换单位产生式来完成。</p><p><strong>Step 3:</strong> 替换长右边的产生式<br>如果产生式的右边有多个符号，则需要通过引入新的非终结符逐步将其转换为以终结符开始的形式。</p><ul><li>例如，如果你有一个产生式 $A \rightarrow X_1 X_2 \dots X_n$，其中 $n &gt; 1$，你需要分解该产生式，使其右边以终结符开始，并且后面跟着非终结符。</li></ul><p><strong>Step 4:</strong> 替换终结符的混合产生式<br>如果产生式的右边包含终结符与非终结符的混合（例如 $A \rightarrow aB$），则需要将终结符与非终结符分离，确保右边的产生式以终结符开头，后面跟随零个或多个非终结符。</p><p>假设我们有以下文法：</p><ul><li>$S \rightarrow AB \mid a$</li><li>$A \rightarrow SA \mid \epsilon$</li><li>$B \rightarrow b$</li></ul><p>我们将其转换为 Greibach Normal Form：</p><ol><li><p><strong>移除空产生式</strong>：首先，移除空产生式 $A \rightarrow \epsilon$，并调整其他规则。</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow SA \mid S$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>移除单位产生式</strong>：从 $A \rightarrow S$ 和 $S \rightarrow B$ 可以看出我们有单位产生式。我们将其替换成等效的产生式。</p><ul><li>$S \rightarrow AB \mid a \mid b$</li><li>$A \rightarrow AB \mid a$</li><li>$B \rightarrow b$</li></ul></li><li><p><strong>替换长右边的产生式</strong>：没有长右边的产生式，所有产生式的右边已经以终结符开头。</p></li></ol><p>最终文法可能是：</p><ul><li>$S \rightarrow a \mid b$</li><li>$A \rightarrow aB \mid b$</li><li>$B \rightarrow b$</li></ul><hr><h4 id="4-5-3-CYK算法（Cocke-Younger-Kasami-Algorithm）"><a href="#4-5-3-CYK算法（Cocke-Younger-Kasami-Algorithm）" class="headerlink" title="4.5.3 CYK算法（Cocke-Younger-Kasami Algorithm）"></a>4.5.3 CYK算法（Cocke-Younger-Kasami Algorithm）</h4><p>CYK算法是一种用于上下文无关文法（CFG，Context-Free Grammar）分析的算法，主要用于确定一个给定的字符串是否能被某个上下文无关文法生成。CYK算法基于动态规划思想，通过构造一个三维表格来高效地判断一个字符串是否属于某个上下文无关文法所生成的语言。</p><p>假设我们有一个上下文无关文法 $G &#x3D; (N, \Sigma, P, S)$，其中：</p><ul><li>$N$ 是非终结符的集合，</li><li>$\Sigma$ 是终结符的集合，</li><li>$P$ 是文法规则的集合，</li><li>$S$ 是起始符号。</li></ul><p>给定一个字符串 $w &#x3D; w_1 w_2 \dots w_n$（长度为 $n$），我们通过 CYK 算法来判断 $w$ 是否能通过文法 $G$ 生成。</p><p><strong>具体步骤如下：</strong></p><ol><li><p><strong>构造三维表格：</strong>  创建一个三维表格 $T$，其中 $T[i,j]$ 表示字符串 $w_i, w_{i+1}, \dots, w_j$（从第 $i$ 个字符到第 $j$ 个字符）是否可以由某个非终结符生成。表格的大小为 $n \times n$，其中 $n$ 是输入字符串的长度。每个表格项 $T[i,j]$ 都会包含一些非终结符，表示该子字符串可以由哪些非终结符生成。</p></li><li><p><strong>初始化：</strong>  对于长度为 1 的子串（即单个字符），检查该字符是否是文法中的终结符。如果是，填充对应的非终结符。</p></li></ol><ul><li>比如，对于每个 $w_i \in \Sigma$，我们查找规则 $A \to w_i$，如果存在，将 $A$ 加入到 $T[i,i]$ 中。</li></ul><ol start="3"><li><p><strong>填充表格：</strong>  对于长度大于 1 的子串，遍历所有可能的分割点 $k$（从 1 到 $n-1$），并检查是否可以通过文法规则将其分割为两个子串。对于每一对非终结符 $A \to BC$，如果 $B$ 能生成左边的子串（即 $T[i,k]$），$C$ 能生成右边的子串（即 $T[k+1,j]$），则将 $A$ 加入 $T[i,j]$。</p></li><li><p><strong>终止条件：</strong>  最终，检查起始符号 $S$ 是否在 $T[1,n]$ 中。如果是，说明字符串 $w$ 可以由文法 $G$ 生成；否则不能。</p></li></ol><p>CYK算法的时间复杂度为 $O(n^3 \cdot |G|)$，其中：</p><ul><li>$n$ 是输入字符串的长度，</li><li>$|G|$ 是文法规则的数量。</li></ul><hr><p>举个例子，给定一个乔姆斯基范式的上下文无关文法：</p><p>$$G &#x3D; ({S, A, B, C}, {a, b}, S, P)$$</p><p>其中规则 $P$ 如下：</p><p>$S \to AB \mid BC$</p><p>$A \to BA \mid a$</p><p>$B \to CC \mid b$</p><p>$C \to AB \mid a$</p><p>问题：字符串 <code>bbabaa</code> 能不能通过该文法产生？</p><p>我们使用 CYK 算法来解决这个问题，CYK 算法通过构建一个表格来判断每个子串能由哪些非终结符生成。表格的第 $i$ 列和第 $j$ 行表示由哪些非终结符可以生成字字符串 $\sigma_i \dots \sigma_j$。</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><strong>i</strong></td><td>a</td><td>b</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td><strong>j&#x3D;1</strong></td><td>{$B$}</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>j&#x3D;2</strong></td><td></td><td>{$B$}</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>j&#x3D;3</strong></td><td>{$A$}</td><td>{$S, A$}</td><td>{$A, C$}</td><td></td><td></td><td></td></tr><tr><td><strong>j&#x3D;4</strong></td><td>{$S, C$}</td><td>{$S, C$}</td><td>{$S, C$}</td><td>{$B$}</td><td></td><td></td></tr><tr><td><strong>j&#x3D;5</strong></td><td>{$B$}</td><td>{$B$}</td><td>{$B$}</td><td>{$A, S$}</td><td>{$A, C$}</td><td></td></tr><tr><td><strong>j&#x3D;6</strong></td><td>{$A, S$}</td><td>{$A, S$}</td><td>{$A, S$}</td><td></td><td>{$B$}</td><td>{$A, C$}</td></tr></tbody></table><p><strong>判断过程如下：</strong></p><ul><li><p><strong>初始化</strong>：对于每个字符 $w_i$（即 $a$, $b$ 等），填充对应的非终结符。</p><ul><li>对于 $w_1 &#x3D; b$，由规则 $B \to b$，填充 $T[1, 1] &#x3D; \{B\}$。</li><li>对于 $w_2 &#x3D; b$，同理填充 $T[2, 2] &#x3D; \{B\}$。</li><li>以此类推，对于其他字符填充。</li></ul></li><li><p><strong>递推填充</strong>：根据文法规则检查可能的组合，填充表格中的其他位置。例如：</p><ul><li>$T[3, 3]$ 可以通过 $A \to a$ 填充为 $\{A\}$。</li><li>$T[2, 3]$ 可以通过 $S \to BC$ 或 $A \to BA$ 填充为 $\{S, A\}$ </li><li>如此继续填充整个表格。(比如生成<code>bba</code>这样的子串，那么就要考虑<code>b + ba</code> 或者<code>bb+a</code>这样的派生)</li></ul></li><li><p><strong>终止条件</strong>：最终检查 $T[1, 6]$ 是否包含文法的起始符号 $S$。如果包含，则说明该字符串可以由该文法生成。</p></li></ul><p>由于 $T[1, 6]$ 中包含了文法的起始符号 $S$，我们可以得出结论：<strong>字符串 <code>bbabaa</code> 能由文法 $G$ 生成</strong>。</p><hr><h3 id="4-6-Pumping-Lemma-for-CFLs"><a href="#4-6-Pumping-Lemma-for-CFLs" class="headerlink" title="4.6 Pumping Lemma for CFLs"></a>4.6 Pumping Lemma for CFLs</h3><p>上下文无关语言（CFL）的泵引理指出，对于任何上下文无关语言 $L$，如果 $L$ 是无限的，那么存在一个常数 $p$（泵长），使得对于所有长度大于等于 $p$ 的字符串 $s \in L$，$s$ 可以分解为五个部分 $s &#x3D; uvwxy$，满足以下条件：</p><ol><li>对于所有 $i \geq 0$，$uv^i w x^i y \in L$。</li><li>$|v| + |x| &gt; 0$ （也就是说，$v$ 和 $x$ 不全为空）。</li><li>$|vwx| \leq p$ （即 $v$ 和 $x$ 的长度加起来不能超过泵长 $p$）。</li></ol><p>我们假设 $L$ 是一个无限的上下文无关语言。由于 $L$ 是上下文无关语言，根据上下文无关文法的结构特性，它对应着一个下推自动机（PDA）。这个 PDA 需要满足一个条件：它可以“泵”字符串，即通过重复某些部分的字符串仍然保持在语言 $L$ 中。</p><p>根据泵引理的假设，存在一个泵长 $p$，使得对于所有长度大于等于 $p$ 的字符串 $s \in L$，该字符串 $s$ 可以分解为 $s &#x3D; uvwxy$，且满足以下条件：</p><ul><li>$|vwx| \leq p$。</li><li>$|v| + |x| &gt; 0$。</li></ul><p>上下文无关语言可以通过上下文无关文法（CFG）生成，也可以通过下推自动机（PDA）来接受。我们利用这些结构来展示泵引理。</p><ul><li>对于一个长度大于等于 $p$ 的字符串 $s \in L$，它一定可以通过上下文无关文法的推导生成。</li><li>由于 $L$ 是无限的，存在某些部分的推导树，可以分解成五个部分 $uvwxy$，其中：<ul><li>$v$ 和 $x$ 是可以被“泵”重复的部分。</li><li>$v$ 和 $x$ 的长度总和不超过 $p$。</li><li>这意味着，对于某些合适的 $i$，$v$ 和 $x$ 可以重复而不破坏语言的结构。</li></ul></li></ul><blockquote><p>这里的证明也会用到Pigeonhole Principal，就不细讲了</p></blockquote><p>根据上下文无关语言的结构，字符串 $s$ 可以分解为 $s &#x3D; uvwxy$，且满足以下条件：</p><ul><li>$|vwx| \leq p$，这意味着 $v$ 和 $x$ 的总长度不会超过泵长 $p$，它们的长度是有限的。</li><li>$|v| + |x| &gt; 0$，这表示 $v$ 和 $x$ 不能同时为空。</li></ul><p>通过泵引理，我们知道，如果我们“泵”字符串 $s$ 中的部分 $v$ 和 $x$，即重复它们的次数，则得到的新字符串 $uv^i w x^i y$ 仍然属于语言 $L$，对于所有 $i \geq 0$。</p><p>根据泵引理的假设，对于所有 $i \geq 0$，$uv^i w x^i y \in L$。这意味着，通过增加 $v$ 和 $x$ 部分的数量，字符串依然保持在语言 $L$ 中。</p><p>该过程的关键在于，通过适当的分解和“泵”操作，语言的结构保持不变，因此可以通过上下文无关文法或下推自动机接受。</p><p>通过泵引理，我们可以证明某些语言不是上下文无关语言。例如，反证法通常用于证明一个语言不符合上下文无关语言的要求。通过选择一个合适的字符串，并假设它满足泵引理的条件，我们可以展示某些操作导致字符串不再属于该语言，从而得出该语言不是上下文无关语言的结论。</p><hr><p>通过泵引理，我们可以用反证法证明某些语言不是上下文无关语言。假设我们要证明某个语言 $L$ 不是上下文无关语言，通常通过以下步骤：</p><ol><li>假设 $L$ 是上下文无关语言，并假设它满足泵引理。</li><li>选择一个字符串 $s \in L$，其长度大于等于泵长 $p$，然后将其分解为 $s &#x3D; uvwxy$，并使用泵引理。</li><li>展开 $uv^i w x^i y$ 并证明对于某些值的 $i$，$uv^i w x^i y$ 不属于 $L$，从而得出矛盾。</li><li>由此得出结论，$L$ 不是上下文无关语言。</li></ol><p>例子：证明 $L &#x3D; \{ a^n b^n c^n \mid n \geq 0 \}$ 不是上下文无关语言</p><p>我们使用上下文无关语言的泵引理来证明 $L &#x3D; \{ a^n b^n c^n \mid n \geq 0 \}$ 不是上下文无关语言。</p><ol><li><p><strong>假设 $L$ 是上下文无关语言：</strong><br>假设 $L$ 是上下文无关语言，且存在泵长 $p$。根据泵引理，任何长度大于或等于 $p$ 的字符串 $s$ 都可以分解为 $s &#x3D; uvwxy$，其中 $|vwx| \leq p$ 且 $|v| + |x| &gt; 0$。</p></li><li><p><strong>选择字符串 $s &#x3D; a^p b^p c^p$：</strong><br>选择字符串 $s &#x3D; a^p b^p c^p$，它显然属于语言 $L$，并且 $|s| &#x3D; 3p \geq p$。</p></li><li><p><strong>分解字符串 $s$：</strong><br>根据泵引理，$s &#x3D; uvwxy$，其中 $|vwx| \leq p$，并且 $|v| + |x| &gt; 0$。由于 $|vwx| \leq p$，它只能覆盖字符串中的某一部分（即 $a^n$、$b^n$ 或 $c^n$）。而且，由于 $|v| + |x| &gt; 0$，$v$ 和 $x$ 必定包含某些重复的字符。</p></li><li><p><strong>泵引理的应用：</strong><br>根据泵引理，对于所有的 $i \geq 0$，$uv^i w x^i y$ 应该仍然属于 $L$。但是，如果我们选择 $i &gt; 1$，则会得到不匹配的字符串，如 $uv^2 w x^2 y$，这个字符串在 $a^n b^n c^n$ 结构中就无法保持相同数量的 <code>a</code>、<code>b</code> 和 <code>c</code>，从而不再属于 $L$。</p></li><li><p><strong>得出矛盾：</strong><br>因此，我们得出结论，$L$ 不可能是上下文无关语言，因为泵引理得出的结论与 $L$ 的定义矛盾。</p></li></ol><p>上下文无关语言的泵引理是通过对语言字符串的分解和重复来证明语言的一些特性。它为我们提供了一个方法，可以通过反证法证明某些语言不是上下文无关语言。</p><hr><h3 id="4-7-上下文无关语言的封闭性"><a href="#4-7-上下文无关语言的封闭性" class="headerlink" title="4.7 上下文无关语言的封闭性"></a>4.7 上下文无关语言的封闭性</h3><p>CFL（上下文无关语言，Context-Free Languages）的运算封闭性是指当对CFL进行一些特定的语言运算时，运算结果是否仍然是CFL。这里先给出结论：</p><ul><li><strong>封闭性</strong>的运算有：<ul><li>代换（Substitution）</li><li>并（Union）</li><li>连接（Concatenation）</li><li>闭包（Kleene Star</li><li>同态（Homomorphism）</li><li>逆同态（Inverse Homomorphism）</li><li>反转（Reversal）</li></ul></li><li><strong>不封闭</strong>的运算有：<ul><li>交（Intersection）</li><li>补（Complement）</li></ul></li></ul><blockquote><p>这里的证明也是修考的常考点，必须掌握得滚瓜烂熟</p></blockquote><hr><h4 id="4-7-1-代换（Substitution）封闭"><a href="#4-7-1-代换（Substitution）封闭" class="headerlink" title="4.7.1 代换（Substitution）封闭"></a>4.7.1 代换（Substitution）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），并且每个符号$x$在$L$中都被替换成一个CFL语言$A_x$，那么代换后的语言也是CFL。</p><p>证明过程如下：</p><ol><li><p><strong>定义代换运算</strong>：<br>假设$L$是一个上下文无关语言，并且对于$L$中的每个符号$x$，我们定义一个CFL语言$A_x$。代换运算的结果$L’$是通过将$L$中的每个符号$x$替换为相应的语言$A_x$得到的，即<br>$$ L’ &#x3D; \{ w_1w_2 \cdots w_n \mid w_i \in A_{x_i} \text{，且} x_1x_2 \cdots x_n \in L \} $$<br>其中$w_i$是符号$x_i$在语言$A_{x_i}$中的一个字符串。</p></li><li><p><strong>构造文法</strong>：<br>由于$L$是一个CFL，假设$L$的文法是$G &#x3D; (V, \Sigma, R, S)$，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。</p><p>对于每个符号$x$，我们有一个CFL语言$A_x$，假设$A_x$的文法是$G_x &#x3D; (V_x, \Sigma_x, R_x, S_x)$。</p></li><li><p><strong>构造代换后的文法</strong>：<br>我们可以构造一个新文法$G’$来生成$L’$。文法$G’$的非终结符集合包括所有$G$中的非终结符以及所有$A_x$的非终结符。文法规则由以下部分构成：</p><ul><li><p>对于$G$中的每个产生式$A \to \alpha$，我们将其替换为：<br>$$ A \to \alpha’ $$<br>其中$\alpha’$是通过将$\alpha$中的每个符号$x_i$替换为$A_{x_i}$的开始符号$S_{x_i}$得到的。</p></li><li><p>对于每个$A_x$中的产生式$S_x \to w$，我们加入产生式$S_x \to w$到$G’$中。</p></li></ul><p>通过这些规则，$G’$可以生成代换后的语言$L’$。</p></li><li><p><strong>结论</strong>：<br>我们通过构造一个新的文法$G’$，使得$G’$生成代换后的语言$L’$。由于文法$G’$是上下文无关的（它是由上下文无关文法$G$和$A_x$的文法组合而成的），因此$L’$也是一个上下文无关语言。</p></li></ol><p>因此，CFL对于代换运算是封闭的。</p><hr><h4 id="4-7-2-并（Union）封闭"><a href="#4-7-2-并（Union）封闭" class="headerlink" title="4.7.2 并（Union）封闭"></a>4.7.2 并（Union）封闭</h4><p>我们需要证明：如果$L_1$和$L_2$都是上下文无关语言（CFL），那么$L_1 \cup L_2$也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L_1$和$L_2$都是上下文无关语言。根据定义，$L_1$和$L_2$分别可以由上下文无关文法$G_1 &#x3D; (V_1, \Sigma, R_1, S_1)$和$G_2 &#x3D; (V_2, \Sigma, R_2, S_2)$生成，其中$V_1$和$V_2$是非终结符集，$\Sigma$是终结符集，$R_1$和$R_2$是产生式规则，$S_1$和$S_2$是开始符号。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G &#x3D; (V, \Sigma, R, S)$，用来生成$L_1 \cup L_2$。新的文法$G$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V &#x3D; V_1 \cup V_2 \cup \{S\}$，其中$S$是$L_1 \cup L_2$的开始符号。</p></li><li><p><strong>终结符集</strong>：$\Sigma$与$L_1$和$L_2$的终结符集相同，都是$\Sigma$。</p></li><li><p><strong>产生式规则集</strong>：$R$包括以下规则：</p><ol><li>$S \to S_1 \mid S_2$，其中$S_1$是$L_1$的开始符号，$S_2$是$L_2$的开始符号。</li><li>对于$G_1$中的每个产生式$A \to \alpha$，将其直接加入$R$。</li><li>对于$G_2$中的每个产生式$B \to \beta$，将其直接加入$R$。</li></ol></li><li><p><strong>开始符号</strong>：$S$是新的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L_1 \cup L_2$：<br>通过新的文法$G$，我们可以生成任意一个$L_1$中的字符串或$L_2$中的字符串。具体来说：</p><ul><li>如果$w \in L_1$，则$w$可以通过$S \to S_1$产生，然后根据$G_1$中的产生式生成$w$。</li><li>如果$w \in L_2$，则$w$可以通过$S \to S_2$产生，然后根据$G_2$中的产生式生成$w$。</li></ul><p>因此，$L_1 \cup L_2$中的任意字符串都可以通过文法$G$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G$来生成$L_1 \cup L_2$，并且文法$G$是上下文无关的（由$G_1$和$G_2$组合而成），因此$L_1 \cup L_2$也是上下文无关语言。</p></li></ol><p>因此，CFL对于并运算是封闭的。</p><hr><h4 id="4-7-3-连接（Concatenation）封闭"><a href="#4-7-3-连接（Concatenation）封闭" class="headerlink" title="4.7.3 连接（Concatenation）封闭"></a>4.7.3 连接（Concatenation）封闭</h4><p>我们需要证明：如果$L_1$和$L_2$都是上下文无关语言（CFL），那么$L_1 \cdot L_2$（即$L_1$和$L_2$的连接）也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L_1$和$L_2$都是上下文无关语言。根据定义，$L_1$和$L_2$分别可以由上下文无关文法$G_1 &#x3D; (V_1, \Sigma, R_1, S_1)$和$G_2 &#x3D; (V_2, \Sigma, R_2, S_2)$生成，其中$V_1$和$V_2$是非终结符集，$\Sigma$是终结符集，$R_1$和$R_2$是产生式规则，$S_1$和$S_2$是开始符号。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G &#x3D; (V, \Sigma, R, S)$，用来生成$L_1 \cdot L_2$。新的文法$G$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V &#x3D; V_1 \cup V_2 \cup {S}$，其中$S$是$L_1 \cdot L_2$的开始符号。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与$L_1$和$L_2$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R$包括以下规则：</p><ol><li>$S \to S_1 S_2$，其中$S_1$是$L_1$的开始符号，$S_2$是$L_2$的开始符号。</li><li>对于$G_1$中的每个产生式$A \to \alpha$，将其直接加入$R$。</li><li>对于$G_2$中的每个产生式$B \to \beta$，将其直接加入$R$。</li></ol></li><li><p><strong>开始符号</strong>：$S$是新的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L_1 \cdot L_2$：<br>通过新的文法$G$，我们可以生成$L_1 \cdot L_2$中的任意字符串。具体来说：</p><ul><li>如果$w &#x3D; w_1w_2$，其中$w_1 \in L_1$且$w_2 \in L_2$，那么：<ul><li>首先通过$S \to S_1 S_2$产生$w_1w_2$。</li><li>然后，$w_1$可以通过$S_1$的产生式根据$G_1$中的规则生成，$w_2$可以通过$S_2$的产生式根据$G_2$中的规则生成。</li></ul></li></ul><p>因此，$L_1 \cdot L_2$中的每个字符串都可以通过文法$G$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G$来生成$L_1 \cdot L_2$，并且文法$G$是上下文无关的（由$G_1$和$G_2$组合而成），因此$L_1 \cdot L_2$也是上下文无关语言。</p></li></ol><p>因此，CFL对于连接运算是封闭的。</p><hr><h4 id="4-7-4-闭包（Kleene-Star）封闭"><a href="#4-7-4-闭包（Kleene-Star）封闭" class="headerlink" title="4.7.4 闭包（Kleene Star）封闭"></a>4.7.4 闭包（Kleene Star）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），那么$L^*$（即$L$的闭包）也是上下文无关语言。</p><p>证明：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言。根据定义，$L$可以由一个上下文无关文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G^* &#x3D; (V^*, \Sigma, R^*, S^*)$，用来生成$L^*$。新的文法$G^*$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V^* &#x3D; V \cup \{S^* \}$，其中$S^*$是新的开始符号。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与$L$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R^*$包括以下规则：</p><ol><li>$S^* \to \epsilon \mid S S^*$，这里$\epsilon$表示空串，$S$是$L$的开始符号。</li><li>对于$G$中的每个产生式$A \to \alpha$，将其直接加入$R^*$。</li></ol></li><li><p><strong>开始符号</strong>：$S^*$是新的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L^*$：<br>通过新的文法$G^*$，我们可以生成$L^*$中的任意字符串。具体来说：</p><ul><li>如果$w \in L^*$，那么$w$可以分解为若干个$L$中字符串的串联，假设$w &#x3D; w_1w_2\cdots w_n$，其中每个$w_i \in L$。</li><li>首先通过$S^* \to S S^*$规则生成前缀$w_1w_2 \cdots w_{n-1}$。</li><li>然后通过$S^* \to \epsilon$规则生成空串，结束生成过程。</li><li>对于每个$w_i \in L$，根据$G$中的产生式生成$w_i$。</li></ul><p>因此，$L^*$中的每个字符串都可以通过文法$G^*$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G^*$来生成$L^*$，并且文法$G^*$是上下文无关的（由$G$和$S^*$的规则组合而成），因此$L^*$也是上下文无关语言。</p></li></ol><p>因此，CFL对于Kleene闭包运算是封闭的。</p><hr><h4 id="4-7-5-同态（Homomorphism）封闭"><a href="#4-7-5-同态（Homomorphism）封闭" class="headerlink" title="4.7.5 同态（Homomorphism）封闭"></a>4.7.5 同态（Homomorphism）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），并且$h$是一个同态映射，那么$h(L)$也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言，且$L$由文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。$h$是一个同态映射，它将语言$\Sigma$中的每个符号映射到语言$\Sigma’$中的某个字符串。</p></li><li><p><strong>定义同态映射</strong>：<br>同态映射$h$是一个函数，它将$\Sigma$中的每个符号映射为一个字符串，即对于每个符号$a \in \Sigma$，$h(a)$是一个字符串。为了简便起见，我们假设$h$将$\Sigma$中的每个符号映射为$\Sigma’$中的一个子串。</p></li><li><p><strong>构造新的文法</strong>：<br>我们将构造一个新的文法$G_h &#x3D; (V, \Sigma’, R_h, S_h)$来生成$h(L)$。新的文法$G_h$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V$，即与$L$相同的非终结符集。</p></li><li><p><strong>终结符集</strong>：$\Sigma’$，这是映射$h$后得到的新的终结符集。</p></li><li><p><strong>产生式规则集</strong>：$R_h$包括以下规则：</p><ol><li>对于$G$中的每个产生式$A \to \alpha$，我们将其替换为$A \to h(\alpha)$，其中$h(\alpha)$表示将$\alpha$中的每个符号通过$h$映射到新的符号串上。</li><li>如果$A \to a_1 a_2 \cdots a_n$是$G$中的某个产生式，则$A \to h(a_1) h(a_2) \cdots h(a_n)$是$G_h$中的相应产生式。</li></ol></li><li><p><strong>开始符号</strong>：$S_h &#x3D; S$，即$L$的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$h(L)$：<br>通过新的文法$G_h$，我们可以生成$h(L)$中的每个字符串。具体来说：</p><ul><li>假设$w &#x3D; w_1 w_2 \cdots w_n \in L$，其中每个$w_i \in \Sigma$。</li><li>通过$G$中的产生式规则，我们可以生成$w$。</li><li>在$G_h$中，$w$会被映射为$h(w_1) h(w_2) \cdots h(w_n)$，这正是$h(L)$中的一个字符串。</li></ul><p>因此，$h(L)$中的每个字符串都可以通过文法$G_h$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G_h$来生成$h(L)$，并且文法$G_h$是上下文无关的（它仅仅是对$G$进行符号替换），因此$h(L)$也是上下文无关语言。</p></li></ol><p>因此，CFL对于同态运算是封闭的。</p><hr><h4 id="4-7-6-逆同态（Inverse-Homomorphism）封闭"><a href="#4-7-6-逆同态（Inverse-Homomorphism）封闭" class="headerlink" title="4.7.6 逆同态（Inverse Homomorphism）封闭"></a>4.7.6 逆同态（Inverse Homomorphism）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），并且$h$是一个同态映射，那么$h^{-1}(L)$（即$L$的逆同态映射）也是上下文无关语言。</p><p>证明过程如下：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言，且$L$由文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。$h$是一个同态映射，它将语言$\Sigma$中的每个符号映射到语言$\Sigma’$中的某个字符串。</p></li><li><p><strong>定义逆同态映射</strong>：<br>同态映射$h$将$\Sigma$中的每个符号映射为一个字符串，而逆同态映射$h^{-1}$将$\Sigma’$中的每个字符串反向映射到$\Sigma$中的符号集合。对于每个符号$a \in \Sigma$，$h(a)$是一个字符串，那么$h^{-1}(w)$将字符串$w$映射回其对应的符号集合。例如，如果$h(a) &#x3D; w$，那么$h^{-1}(w) &#x3D; a$。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G_{h^{-1}} &#x3D; (V, \Sigma, R_{h^{-1}}, S_{h^{-1}})$，用来生成$h^{-1}(L)$。新的文法$G_{h^{-1}}$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V$，即与$L$相同的非终结符集。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与原语言$L$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R_{h^{-1}}$包括以下规则：</p><ol><li>对于$G$中的每个产生式$A \to \alpha$，我们将其替换为$A \to h^{-1}(\alpha)$，其中$h^{-1}(\alpha)$表示将$\alpha$中的每个符号通过$h^{-1}$映射回符号集上的串。</li><li>对于$G$中的每个产生式$A \to a_1 a_2 \cdots a_n$，我们加入产生式$A \to h^{-1}(a_1) h^{-1}(a_2) \cdots h^{-1}(a_n)$。</li></ol></li><li><p><strong>开始符号</strong>：$S_{h^{-1}} &#x3D; S$，即$L$的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$h^{-1}(L)$：<br>通过新的文法$G_{h^{-1}}$，我们可以生成$h^{-1}(L)$中的每个字符串。具体来说：</p><ul><li>假设$w &#x3D; w_1 w_2 \cdots w_n \in L$，其中每个$w_i \in \Sigma$。</li><li>在$G$中，$w$可以通过产生式规则生成。</li><li>在$G_{h^{-1}}$中，通过将$w$中的每个符号$w_i$映射回原始符号，我们可以生成对应的字符串$h^{-1}(w_1) h^{-1}(w_2) \cdots h^{-1}(w_n)$。</li></ul><p>因此，$h^{-1}(L)$中的每个字符串都可以通过文法$G_{h^{-1}}$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G_{h^{-1}}$来生成$h^{-1}(L)$，并且文法$G_{h^{-1}}$是上下文无关的（它仅仅是对$G$进行符号替换），因此$h^{-1}(L)$也是上下文无关语言。</p></li></ol><p>因此，CFL对于逆同态运算是封闭的。</p><hr><h4 id="4-7-7-反转（Reversal）封闭"><a href="#4-7-7-反转（Reversal）封闭" class="headerlink" title="4.7.7 反转（Reversal）封闭"></a>4.7.7 反转（Reversal）封闭</h4><p>我们需要证明：如果$L$是一个上下文无关语言（CFL），那么$L^R$（即$L$的反转）也是上下文无关语言。</p><p>证明：</p><ol><li><p><strong>假设</strong>：<br>假设$L$是一个上下文无关语言，且$L$由文法$G &#x3D; (V, \Sigma, R, S)$生成，其中$V$是非终结符集，$\Sigma$是终结符集，$R$是产生式规则，$S$是开始符号。我们需要证明$L^R$（即$L$中所有字符串的反转）也是上下文无关语言。</p></li><li><p><strong>构造新的文法</strong>：<br>我们现在构造一个新的文法$G^R &#x3D; (V, \Sigma, R^R, S^R)$，用来生成$L^R$。新的文法$G^R$的组成如下：</p><ul><li><p><strong>非终结符集</strong>：$V$，即与$L$相同的非终结符集。</p></li><li><p><strong>终结符集</strong>：$\Sigma$，与$L$的终结符集相同。</p></li><li><p><strong>产生式规则集</strong>：$R^R$包括以下规则：</p><ol><li>对于$G$中的每个产生式$A \to \alpha$，将其替换为$A \to \alpha^R$，其中$\alpha^R$表示字符串$\alpha$的反转。</li><li>例如，如果$A \to a_1 a_2 \cdots a_n$是$G$中的产生式，那么$A \to a_n a_{n-1} \cdots a_1$是$G^R$中的对应产生式。</li></ol></li><li><p><strong>开始符号</strong>：$S^R &#x3D; S$，即$L$的开始符号。</p></li></ul></li><li><p>证明新文法生成的语言是$L^R$：<br>通过新的文法$G^R$，我们可以生成$L^R$中的每个字符串。具体来说：</p><ul><li>假设$w &#x3D; w_1 w_2 \cdots w_n \in L$，其中每个$w_i \in \Sigma$。</li><li>在$G$中，$w$可以通过产生式规则生成。</li><li>在$G^R$中，$w$将被反转为$w_n w_{n-1} \cdots w_1$，即$w$中的每个符号都会在生成过程中被反转。</li></ul><p>因此，$L^R$中的每个字符串都可以通过文法$G^R$生成。</p></li><li><p><strong>结论</strong>：<br>由于我们通过构造一个上下文无关文法$G^R$来生成$L^R$，并且文法$G^R$是上下文无关的（它仅仅是对$G$中的产生式规则进行了反转），因此$L^R$也是上下文无关语言。</p></li></ol><p>因此，CFL对于反转运算是封闭的。</p><h4 id="4-7-8-交（Intersection）不封闭"><a href="#4-7-8-交（Intersection）不封闭" class="headerlink" title="4.7.8 交（Intersection）不封闭"></a>4.7.8 交（Intersection）不封闭</h4><p>我们需要证明：上下文无关语言（CFL）对于交运算<strong>不封闭</strong>，即存在两个上下文无关语言$L_1$和$L_2$，使得它们的交集$L_1 \cap L_2$不是上下文无关语言。</p><p>证明：</p><ol><li><p>构造两个上下文无关语言$L_1$和$L_2$：<br>我们选择以下两个上下文无关语言：</p><ul><li>$L_1 &#x3D; \{a^n b^n c^n \mid n \geq 0\}$，这是一个标准的上下文无关语言，它表示由$a$、$b$、$c$组成的字符串，其中每种字符的数量相同。</li><li>$L_2 &#x3D; \{a^n b^m c^m \mid n \geq 0, m \geq 0\}$，这个语言包含任意数量的$a$，后面跟着相同数量的$b$，再后面跟着相同数量的$c$。</li></ul></li><li><p>求交集$L_1 \cap L_2$：<br>现在，我们来求$L_1$和$L_2$的交集：</p><ul><li>$L_1 \cap L_2 &#x3D; \{a^n b^n c^n \mid n \geq 0\} \cap \{a^n b^m c^m \mid n \geq 0, m \geq 0\}$。</li><li>交集的结果是$L_1 \cap L_2 &#x3D; \{a^n b^n c^n \mid n \geq 0\}$，即所有$ a $、$ b $和$ c $的数量都相同的字符串。</li></ul><p>这个语言$L_1 \cap L_2$其实就是$L_1$，即$\{a^n b^n c^n \mid n \geq 0\}$。</p></li><li><p><strong>$L_1 \cap L_2$是否是上下文无关语言</strong>：<br>我们知道，语言$L_1 &#x3D; {a^n b^n c^n \mid n \geq 0}$是<strong>非上下文无关</strong>的。原因是存在一个推理，可以证明使用上下文无关文法无法生成此语言：此问题可以通过泵引理等方法证明。</p><p>因此，$L_1 \cap L_2$并不是上下文无关语言。</p></li><li><p><strong>结论</strong>：<br>虽然$L_1$和$L_2$都是上下文无关语言，但它们的交集$L_1 \cap L_2 &#x3D; \{a^n b^n c^n \mid n \geq 0\}$不是上下文无关语言。因此，CFL对于交运算是不封闭的。</p></li></ol><h4 id="4-7-9-补（Complement）不封闭"><a href="#4-7-9-补（Complement）不封闭" class="headerlink" title="4.7.9 补（Complement）不封闭"></a>4.7.9 补（Complement）不封闭</h4><p>我们需要证明：上下文无关语言（CFL）对于补运算<strong>不封闭</strong>，即存在一个上下文无关语言$L$，使得$L$的补集$\overline{L}$不是上下文无关语言。</p><p>证明：</p><ol><li><p>构造上下文无关语言$L$：<br>我们选择一个已知的上下文无关语言$L$：</p><ul><li>$L &#x3D; \{a^n b^n c^n \mid n \geq 0\}$，这是一个标准的上下文无关语言，它表示由$a$、$b$、$c$组成的字符串，其中每种字符的数量相同。</li></ul></li><li><p>构造$L$的补集$\overline{L}$：<br>我们来求$L$的补集$\overline{L}$，即所有不属于$L$的字符串集合：</p><ul><li>$L &#x3D; \{a^n b^n c^n \mid n \geq 0\}$。</li><li>$\overline{L}$包含所有不是形如$a^n b^n c^n$的字符串。这意味着$\overline{L}$包含所有字符数量不相等或字符顺序不符合$a^n b^n c^n$模式的字符串。</li></ul></li><li><p><strong>证明$\overline{L}$不是上下文无关语言</strong>：<br>我们要证明$\overline{L}$不是上下文无关语言。考虑语言$L$中的字符串形态，它要求字符的数量严格匹配：$a$的数量、$b$的数量、$c$的数量相同。</p><ul><li><p>由于上下文无关文法无法在具有多个计数条件的语言中做出有效的限制（即无法处理像$a^n b^n c^n$这样的结构），$L$本身并不具备简单的反转特性。</p></li><li><p>如果我们通过推理$L$的补集，会发现它的复杂度远远超过了上下文无关文法能够处理的范围。换句话说，$\overline{L}$包含了非常多的字符串，其中一些字符串无法用上下文无关文法来生成。例如，如果字符数量不匹配或顺序不符合，文法的设计会变得非常复杂且不可处理。</p></li><li><p>我们这里可以用一个取巧的证明办法，根据德摩根律：$L_1 \cap L_2 &#x3D; \overline{\overline{L_1} \cup \overline{L_2}}$, 因为交运算不封闭，并运算封闭，那么我们可以推出补运算是不封闭的</p></li></ul></li><li><p><strong>结论</strong>：<br>虽然$L$是一个上下文无关语言，但它的补集$\overline{L}$不是上下文无关语言。因此，CFL对于补运算是不封闭的。</p></li></ol><h2 id="5-Pushdown-Automata"><a href="#5-Pushdown-Automata" class="headerlink" title="5. Pushdown Automata"></a>5. Pushdown Automata</h2><p>Pushdown Automata（PDA）是自动机的一种，它扩展了有限自动机（Finite Automaton, FA）的能力，引入了一个堆栈（Stack）作为额外的存储结构。PDA 特别适用于处理上下文无关语言（Context-Free Languages, CFLs），因为它能够在解析过程中记住之前的状态。</p><p>一个 Pushdown Automaton 可以通过五元组来表示：</p><p>$$PDA &#x3D; (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$$</p><p>其中：</p><ul><li>$Q$：状态集合，表示 PDA 的所有可能状态。</li><li>$\Sigma$：输入字母表（也叫终结符）。</li><li>$\Gamma$：堆栈字母表，表示堆栈中可能的符号。</li><li>$\delta$：转移函数，定义了 PDA 在特定状态下如何根据输入符号和堆栈顶部符号转移到新的状态，以及如何改变堆栈的内容。</li><li>$q_0$：初始状态，表示 PDA 开始的状态。</li><li>$Z_0$：堆栈初始符号，通常是一个特殊的符号，用于标记堆栈的底部。</li><li>$F$：接受状态的集合，PDA 只有进入一个接受状态时，才表示输入字符串被接受。</li></ul><p>PDA 的工作过程可以简单描述为以下步骤：</p><ol><li><p><strong>状态转移</strong>：PDA 根据当前状态、读取到的输入符号和堆栈顶部的符号来决定下一步的动作。PDA 的转移函数 $\delta$ 通常具有三个参数：</p><ul><li>当前状态 $q$。</li><li>当前输入符号 $a$，如果当前没有输入符号可读取，则为空（即 $\epsilon$）。</li><li>堆栈顶部符号 $X$，也可以是空的（即 $\epsilon$）。</li></ul><p>然后，PDA 会根据转移函数 $\delta$ 定义的规则来决定：</p><ul><li>转移到一个新状态。</li><li>改变堆栈的内容（压入或弹出符号）。</li></ul></li><li><p><strong>堆栈操作</strong>：堆栈是 PDA 的一个关键特性。它允许自动机记住状态信息，处理递归或嵌套结构（如括号匹配、算数表达式的解析等）。堆栈的操作包括：</p><ul><li><strong>Push</strong>：将一个符号压入堆栈。</li><li><strong>Pop</strong>：将堆栈顶部的符号弹出。</li><li><strong>No operation (NOP)</strong> ：不对堆栈进行任何操作。</li></ul></li><li><p><strong>接受条件</strong>：PDA 的接受有两种方式：</p><ul><li><strong>接受状态</strong>：当 PDA 进入一个接受状态 $q_f \in F$ 并且输入已经完全读取时，表示接受输入字符串。</li><li><strong>空堆栈</strong>：当 PDA 的堆栈为空且已经完全读取输入时，也可以接受输入字符串。</li></ul></li></ol><p>PDA 的重要特性是能够接受上下文无关语言。上下文无关语言（CFL）是指可以通过上下文无关文法（CFG）生成的语言。而 PDA 可以通过其堆栈的机制来模拟 CFG 生成语言的过程。</p><p>举一个简单的例子，考虑一个上下文无关文法生成的语言：</p><p>$$L &#x3D; \{ a^n b^n \mid n \geq 0 \}$$</p><p>这个语言由所有长度相等的由 $a$ 和 $b$ 组成的字符串组成。PDA 可以通过以下方式接受该语言：</p><ul><li>初始时，PDA 的堆栈为空。</li><li>每读取一个 $a$，PDA 就将一个符号（例如 $A$）压入堆栈。</li><li>每读取一个 $b$，PDA 就从堆栈中弹出一个符号。</li><li>如果堆栈最终为空，并且没有更多输入字符，则接受输入。</li></ul><p>考虑一个简单的 PDA 来接受语言 $L &#x3D; \{a^n b^n \mid n \geq 0 \}$：</p><ul><li>状态集合 $Q &#x3D; \{q_0, q_1, q_f\}$</li><li>输入字母表 $\Sigma &#x3D; \{a, b\}$</li><li>堆栈字母表 $\Gamma &#x3D; \{A, Z_0\}$（$Z_0$ 为堆栈底部符号）</li><li>初始状态 $q_0$</li><li>初始堆栈符号 $Z_0$</li><li>接受状态 $F &#x3D; \{q_f\}$</li><li>转移函数：<ul><li>$\delta(q_0, a, Z_0) &#x3D; (q_0, a Z_0)$（读取 $a$ 时，将 $a$ 压入堆栈）</li><li>$\delta(q_0, a, a) &#x3D; (q_0, aa)$（读取 $a$ 时，将 $a$ 压入堆栈）</li><li>$\delta(q_0, b, a) &#x3D; (q_1, \epsilon)$（读取 $b$ 时，从堆栈弹出 $a$）</li><li>$\delta(q_1, b, a) &#x3D; (q_1, \epsilon)$（读取 $b$ 时，从堆栈弹出 $a$）</li><li>$\delta(q_1, \epsilon, Z_0) &#x3D; (q_f, Z_0)$（当堆栈为空时，进入接受状态）</li></ul></li></ul><center><img src="/img/FL/pda.svg" alt="PDA状态转移" style="max-width: 100%; height: auto;" /></center><p>Pushdown Automaton（PDA）是一种能够处理上下文无关语言的计算模型，它通过引入堆栈这一额外存储结构来增强有限自动机的能力。PDA 的应用广泛，包括编译器中的语法分析、程序解析以及一些递归语言的处理。它可以分为确定性 PDA（DPDA）和非确定性 PDA（NPDA），其中非确定性 PDA 是最强大的，能够处理所有的上下文无关语言。</p><hr><h3 id="5-1-PDA的状态转移"><a href="#5-1-PDA的状态转移" class="headerlink" title="5.1 PDA的状态转移"></a>5.1 PDA的状态转移</h3><p>PDA 的状态转移函数 <strong>δ</strong> 描述了在特定的输入符号和栈顶符号下，PDA 会如何进行状态转移，以及是否需要对栈进行操作。它可以表示为：<br>$$<br>\delta(q, a, X) &#x3D; \{(p, \gamma)\}<br>$$<br>其中：</p><ul><li>$q$ 是当前状态。</li><li>$a$ 是当前的输入符号（如果为空，则是ε，表示没有输入）。</li><li>$X$ 是栈顶符号。</li><li>$p$ 是转移后的状态。</li><li>$\gamma$是栈操作，表示栈顶符号 <strong>X</strong> 被替换为字符串 $\gamma$（也可以是空字符串，表示栈顶符号被弹出）。</li></ul><p>PDA 的状态转移不仅可以改变自动机的状态，还可以对栈进行操作。栈操作有以下几种形式：</p><ul><li><strong>推入（Push）</strong>：将一个符号压入栈中。</li><li><strong>弹出（Pop）</strong>：从栈顶移除一个符号。</li><li><strong>保持不变</strong>：栈顶符号不发生变化。</li></ul><p>例如，假设当前的状态为 <strong>q₀</strong>，栈顶符号为 <strong>X</strong>，输入符号为 <strong>a</strong>，PDA 的状态转移规则可能是：</p><ul><li>$\delta(q₀, a, X) &#x3D; \{(q₁, YX)\}$，表示如果处于状态 <strong>q₀</strong>，读入符号 <strong>a</strong>，栈顶为 <strong>X</strong>，那么自动机转移到状态 <strong>q₁</strong>，并将 <strong>Y</strong> 压入栈顶，原有的 <strong>X</strong> 保留在栈中。</li><li>$\delta(q₀, \epsilon, X) &#x3D; \{(q₁, \epsilon)\}$，表示如果当前没有输入符号（<strong>ε</strong>），且栈顶是 <strong>X</strong>，自动机转移到状态 <strong>q₁</strong>，并弹出栈顶的符号 <strong>X</strong>。</li></ul><p>假设我们有一个 PDA，它的任务是接受语言 $L &#x3D; \{a^n b^n | n \geq 0\}$（即由相同数量的 <strong>a</strong> 和 <strong>b</strong> 组成的字符串）。该 PDA 可以通过以下状态转移来工作：</p><ol><li>初始状态 <strong>q₀</strong>，栈为空，读取到 <strong>a</strong> 时，PDA 将 <strong>a</strong> 推入栈中。</li><li>当 PDA 读取到 <strong>b</strong> 时，它会与栈顶的 <strong>a</strong> 配对，弹出一个 <strong>a</strong>。</li><li>如果字符串中的 <strong>a</strong> 和 <strong>b</strong> 数量相等，栈会空，自动机转到接受状态 <strong>q₁</strong>。</li></ol><p>具体的转移规则可能是：</p><ul><li>$\delta(q₀, a, \epsilon) &#x3D; \{(q₀, a)\}$，即在状态 <strong>q₀</strong>，读取 <strong>a</strong>，将 <strong>a</strong> 压入栈中。</li><li>$\delta(q₀, b, a) &#x3D; \{(q₀, \epsilon)\}$，即在状态 <strong>q₀</strong>，读取 <strong>b</strong>，弹出栈顶的 <strong>a</strong>。</li><li>$\delta(q₀, \epsilon, \epsilon) &#x3D; \{(q₁, \epsilon)\}$，当输入读完且栈为空时，转移到接受状态 <strong>q₁</strong>。</li></ul><p>通过这种方式，PDA 使用栈来“记住”输入中的 <strong>a</strong>，并在读取到 <strong>b</strong> 时进行配对，从而确保 <strong>a</strong> 和 <strong>b</strong> 的数量相等。</p><p>PDA 的状态转移是由当前状态、输入符号和栈顶符号决定的，它允许自动机在每个转移步骤中操作栈，进而能够处理更复杂的语言，如上下文无关语言。通过推入和弹出栈顶符号，PDA 可以模拟许多计算过程，例如平衡括号或匹配括号对等任务。</p><hr><h3 id="5-2-下推自动机接受的语言"><a href="#5-2-下推自动机接受的语言" class="headerlink" title="5.2 下推自动机接受的语言"></a>5.2 下推自动机接受的语言</h3><p><strong>下推自动机</strong>（PDA, Pushdown Automaton）可以通过两种方式来接受语言：<strong>以终态</strong>（final state）接受和<strong>以空栈</strong>（empty stack）接受。</p><p><strong>以终态方式接受的语言</strong></p><p>当 PDA 使用<strong>终态</strong>接受语言时，它通过进入某个特定的终态来判断输入是否被接受。具体来说，如果 PDA 在输入字符串完全读取完毕后，进入了某个 <strong>接受状态</strong>（或终态），那么这个字符串就被认为是被 PDA 接受的。</p><ul><li>输入字符串通过 PDA 的状态转移函数进行处理。</li><li>当输入字符串的所有符号都被读取完毕，PDA 必须进入某个 <strong>接受状态</strong>（或终态）。如果 PDA 达到了这个接受状态，并且已经没有更多的输入符号，那么该字符串就被认为是被接受的。</li></ul><p>这种接受方式类似于有限自动机（DFA 或 NFA），唯一的不同之处在于 PDA 在计算过程中使用了栈来存储中间信息，而不仅仅依赖状态来进行转移。</p><p>假设我们有一个 PDA，任务是接受语言 $L &#x3D; \{ a^n b^n | n \geq 0 \}$。该 PDA 的工作方式可能是：</p><ol><li>在状态 $q_0$，当读取到 $a$ 时，将 $a$ 压入栈。</li><li>当读取到 $b$ 时，弹出一个 $a$。</li><li>输入完全读完，并且 PDA 进入了终态 $q_1$，如果栈为空（所有 $a$ 都已经被匹配），则接受这个字符串。</li></ol><p><strong>以空栈方式接受的语言</strong></p><p>当 PDA 使用<strong>空栈</strong>方式来接受语言时，它并不依赖于终态的存在，而是依赖于栈的状态来判断输入是否被接受。具体来说，输入字符串被接受的条件是，当输入字符串完全读取完毕时，PDA 的栈必须为空。</p><ul><li>在读取输入字符串的过程中，PDA 根据当前输入符号和栈顶符号来进行状态转移。</li><li>当输入字符串完全读取完毕后，PDA 不要求进入特定的接受状态，而是检查栈是否为空。如果栈为空，则认为该字符串被接受。</li></ul><p>使用空栈方式的优点在于它能够仅依赖栈的内容来判断语言是否符合某种规则，而不必考虑终态的存在。</p><p>假设我们有一个 PDA，任务是接受语言 $L &#x3D; \{ a^n b^n | n \geq 0 \}$，此时 PDA 以空栈方式接受。可能的状态转移如下：</p><ol><li>在状态 $q_0$，当读取到 $a$ 时，将 $a$ 压入栈。</li><li>当读取到 $b$ 时，弹出栈顶的 $a$。</li><li>输入字符串读完后，栈应该为空。如果栈为空，则接受该字符串。</li></ol><p>这种方法没有要求 PDA 进入一个特定的接受状态，而仅仅依赖栈的状态来判断输入是否被接受。</p><p><strong>以终态方式接受 vs. 以空栈方式接受</strong></p><ul><li><strong>接受条件</strong>：以终态方式接受时，PDA 需要进入某个特定的接受状态；而以空栈方式接受时，PDA 需要栈为空。</li><li><strong>栈的作用</strong>：无论是终态方式还是空栈方式，栈都用来存储中间信息，以便处理更复杂的语言。不同的是，终态方式可能在栈中保留数据，而空栈方式则强调栈最终必须为空。</li></ul><p><strong>两种接受方式的差异：</strong></p><ul><li><strong>终态接受的语言</strong>：通常来说，终态接受的语言可以通过转换成一个<strong>有穷状态机</strong>（比如 NFA 或 DFA）来描述，尽管下推自动机在转换过程中使用了栈。</li><li><strong>空栈接受的语言</strong>：如果一个语言可以由一个 PDA 使用空栈方式接受，那么这个语言是<strong>上下文无关语言</strong>（CFL, Context-Free Language）。上下文无关语言在形式语言与自动机理论中是 PDA 的经典应用之一。</li></ul><p>实际上，这两种接受方式并不等价：</p><ul><li><strong>空栈接受的语言</strong>：比终态接受的语言的表达能力更强，因为空栈接受的 PDA 可以模拟上下文无关文法（CFG）来生成语言。</li><li><strong>终态接受的语言</strong>：虽然也可以描述某些上下文无关语言，但它通常只能描述一些较为简单的上下文无关语言，或者是某些有限的模式。</li></ul><p>通常，空栈接受方式更为常见和强大，因为它能直接描述<strong>上下文无关语言</strong>，而终态接受方式则较为有限。</p><div class="note note-success">            <p>结论：如果PDA $P_N$以空栈方式接受语言$L$，那么一定存在PDA $P_F$以终态方式接受$L$</p>          </div><hr><h3 id="5-3-PDA与CFG的等价性证明"><a href="#5-3-PDA与CFG的等价性证明" class="headerlink" title="5.3 PDA与CFG的等价性证明"></a>5.3 PDA与CFG的等价性证明</h3><p>在形式语言与自动机理论中，<strong>PDA</strong>（下推自动机，Pushdown Automaton）和 <strong>CFG</strong>（上下文无关文法，Context-Free Grammar）是紧密相关的，事实上，它们是等价的。也就是说，<strong>对于每一个上下文无关语言，都可以存在一个 PDA 来接受它，同时对于每一个 PDA 接受的语言，都可以构造出一个上下文无关文法</strong>。</p><p>这意味着，我们可以通过下推自动机和上下文无关文法之间的转换来证明它们的等价性。下面我将详细讲解 PDA 和 CFG 的等价性证明，主要分为两个部分：</p><ol><li><strong>PDA 和 CFG 等价性证明：从 PDA 到 CFG 的构造</strong></li><li><strong>PDA 和 CFG 等价性证明：从 CFG 到 PDA 的构造</strong></li></ol><hr><p><strong>从 PDA 到 CFG 的构造</strong></p><p>假设我们有一个 PDA，它接受某个上下文无关语言 $L$。我们需要构造一个上下文无关文法 $G$，使得 $G$ 生成的语言就是 $L$。下面是构造的基本思路。</p><ol><li><p><strong>构建一个文法的非终结符</strong>：文法的非终结符是由 PDA 的状态和栈符号构成的。具体来说，文法中的每个非终结符都表示 PDA 在某一状态下，通过一系列的栈操作可以推导出某种字符串。</p><p>假设 PDA 的状态集合为 $Q$，栈字母表为 $\Gamma$，则文法中的非终结符通常是形式为 $[q, X]$ 的符号，其中：</p><ul><li>$q \in Q$，表示 PDA 的一个状态。</li><li>$X \in \Gamma$，表示栈上的一个符号。</li></ul></li><li><p><strong>文法的产生式</strong>：文法的产生式是根据 PDA 的转移函数来构造的。PDA 的转移函数通常表示为 $\delta(q, a, X) &#x3D; { (p, \gamma) }$，其中：</p><ul><li>$q$ 和 $p$ 是 PDA 的状态。</li><li>$a$ 是输入符号。</li><li>$X$ 是栈顶符号。</li><li>$\gamma$ 是栈操作，可以是栈符号的一个串，表示将栈顶的 $X$ 替换为字符串 $\gamma$。</li></ul><p>对应的文法产生式有两种类型：</p><ol><li><p><strong>通过栈操作推出字符串</strong>：</p><ul><li>如果 $\delta(q, a, X) &#x3D; \{ (p, \gamma) \}$，则可以有一个产生式：<br>$$ [q, X] \rightarrow a[p, \gamma] $$<br>这表示在状态 $q$，读取符号 $a$，栈顶是符号 $X$ 时，可以推导出字符串 $a$，然后转移到状态 $p$，栈操作替换成 $\gamma$</li></ul></li><li><p><strong>通过状态转移推导空符号</strong>：</p><ul><li>如果有一个 $\delta(q, \epsilon, X) &#x3D; \{(p, \epsilon)\}$，表示没有输入符号并且弹出栈顶符号 $X$，则产生式为：<br>$$ [q, X] \rightarrow [p, \epsilon] $$<br>这表示在状态 $q$ 时，栈顶符号为 $X$，并且没有读取任何输入符号，可以通过弹出栈顶符号，转移到状态 $p$。</li></ul></li></ol></li><li><p><strong>文法的开始符号</strong>：文法的开始符号通常由 PDA 的初始状态和栈初始符号组成。例如，如果 PDA 的初始状态是 $q_0$，栈的初始符号是 $Z_0$，则文法的开始符号为 $[q_0, Z_0]$。</p></li></ol><p>通过上述步骤，我们可以为每个 PDA 构造出一个等价的上下文无关文法 $G$，使得 $L(G)$ 等于 PDA 所接受的语言 $L(PDA)$。</p><hr><p><strong>从 CFG 到 PDA 的构造</strong></p><p>接下来，我们要证明对于每一个上下文无关文法 $G$，都可以构造出一个等价的 PDA 来接受由该文法生成的语言。构造过程的基本思路是模拟文法的推导过程。</p><p><strong>构造 PDA 的基本思路：</strong></p><ol><li><p><strong>PDA 的状态集合</strong>：PDA 的状态集合包含两个状态：一个是初始状态 $q_0$，另一个是接受状态 $q_1$。</p></li><li><p><strong>栈操作的设计</strong>：栈用于模拟文法的推导过程。在文法中，每个非终结符都有一个产生式，而在 PDA 中，栈顶符号将被替换成对应的右侧部分。具体来说，当 PDA 读取输入符号时，它会根据当前栈顶符号（非终结符或终结符）和当前输入符号执行相应的栈操作。</p><ul><li><strong>对于终结符</strong>：当 PDA 遇到一个终结符（比如文法的终结符 $a$）时，它会检查栈顶是否是该终结符。如果是，则弹出该符号并读取下一个输入符号。</li><li><strong>对于非终结符</strong>：当 PDA 遇到一个非终结符（比如文法的非终结符 $A$），它会将栈顶的 $A$ 替换为该非终结符的右侧产生式。</li></ul></li><li><p><strong>PDA 的状态转移</strong>：</p><ul><li><strong>读取终结符</strong>：当 PDA 遇到输入符号 $a$，栈顶为 $a$ 时，执行操作：弹出 $a$，读取下一个输入符号。</li><li><strong>应用产生式</strong>：当 PDA 遇到栈顶是非终结符 $A$ 时，选择文法中的某个产生式 $A \rightarrow \alpha$，并将 $\alpha$ 推入栈中。</li></ul></li><li><p><strong>PDA 的接受条件</strong>：PDA 在输入字符串被完全读取完毕后，如果栈为空，则接受该字符串。</p></li></ol><p>根据上述过程，我们可以为每个上下文无关文法 $G$ 构造一个等价的 PDA，使得 PDA 接受的语言恰好是 $L(G)$，即文法 $G$ 生成的语言。</p><p>通过从 PDA 到 CFG 的构造，我们可以证明每个 PDA 接受的语言是上下文无关语言。而通过从 CFG 到 PDA 的构造，我们可以证明每个上下文无关语言都可以被某个 PDA 接受。这样，我们就证明了 PDA 和 CFG 在语言的接受能力上是等价的。换句话说，它们都可以接受<strong>所有的上下文无关语言</strong>。</p><hr><h3 id="5-4-DPDA"><a href="#5-4-DPDA" class="headerlink" title="5.4 DPDA"></a>5.4 DPDA</h3><p><strong>DPDA</strong>（Deterministic Pushdown Automaton，确定性下推自动机）是下推自动机（PDA）的一种特殊类型。与普通的 PDA 不同，DPDA 的转移是<strong>确定性的</strong>，即在任何给定的时刻，状态和栈顶符号以及当前输入符号的组合只能导致一个确定的转移。这个特性使得 DPDA 相较于一般的 PDA 更加有限，并且在一些语言的接受能力上有所限制。</p><p><strong>DPDA 与 PDA 的区别：</strong></p><p>普通的 PDA 在处理状态转移时，可能存在多个可行的转移路径，这通常是因为在同一状态下、相同输入符号和栈顶符号的条件下，PDA 可以选择不同的栈操作（推入不同的栈符号或弹出栈符号）。这使得 PDA 是<strong>非确定性的</strong>。</p><p>而在 <strong>DPDA</strong> 中，给定一个输入符号、当前状态和栈顶符号的组合时，转移是唯一的，只有一种可能的状态和栈变换。这种确定性意味着在任何时刻，DPDA 都只能做出一个明确的选择，因此称为<strong>确定性下推自动机</strong>。</p><p>DPDA 是 PDA 的一种特殊类型，其定义如下：</p><ul><li><p><strong>状态集合</strong> $Q$：有限的状态集合。</p></li><li><p><strong>输入字母表</strong> $\Sigma$：有限的输入符号集。</p></li><li><p><strong>栈字母表</strong> $\Gamma$：有限的栈符号集。</p></li><li><p><strong>转移函数</strong> $\delta$：转移函数 $\delta(q, a, X)$，其中 $q$ 是当前状态，$a$ 是当前输入符号（可以是空符号 $\epsilon$），$X$ 是栈顶符号。与普通 PDA 不同，<strong>对于每对 ($q, a, X$)，$\delta$ 中最多只有一个转移</strong>，这使得它是确定性的。</p><p>$\delta: Q \times (\Sigma \cup {\epsilon}) \times \Gamma \rightarrow Q \times \Gamma^*$，意味着从某个状态 $q$，读取输入符号 $a$ 和栈顶符号 $X$，转移到新的状态并且修改栈的内容。</p></li><li><p><strong>初始状态</strong> $q_0$：自动机的起始状态。</p></li><li><p><strong>初始栈符号</strong> $Z_0$：栈的初始符号。</p></li><li><p><strong>接受状态</strong> $F$：一个接受状态的集合，可以是空集（即仅以栈为空来接受）。</p></li></ul><p>DPDA 在读取输入符号的过程中，遵循以下步骤：</p><ol><li><p><strong>读取输入</strong>：从输入字符串中逐个读取字符。</p></li><li><p><strong>栈操作</strong>：</p><ul><li><strong>推入栈</strong>：在某些转移中，DPDA 会将符号压入栈。</li><li><strong>弹出栈</strong>：在其他转移中，DPDA 会从栈顶弹出符号。</li><li><strong>不操作</strong>：在某些情况下，DPDA 会保持栈不变。</li></ul><p>DPDA 的关键特点是，在每次状态转移时，必须有一个唯一的选择，不允许有多个转移选项。</p></li><li><p><strong>接受条件</strong>：</p><ul><li><strong>终止状态</strong>：如果 DPDA 在读取完所有输入符号后进入某个接受状态（$q \in F$），那么该字符串被接受。</li><li><strong>空栈接受</strong>：如果 DPDA 在读取完所有输入符号后栈为空（即栈没有任何符号），则该字符串也被接受。</li></ul></li></ol><p>DPDA 能够接受的语言是<strong>确定性上下文无关语言</strong>（D-CFLs）。这些语言是上下文无关语言的一个子集，限制了语言的结构，使得它们可以被确定性下推自动机处理。虽然 PDA 可以接受所有上下文无关语言（CFLs），但 DPDA 只能接受其中的一部分。</p><p><strong>确定性上下文无关语言</strong>相比一般的上下文无关语言有更严格的结构要求。例如，DPDA 无法处理某些语言，这些语言是上下文无关的，但由于其结构复杂（例如，需要“回溯”或存在“多重选择”），无法通过确定性方式来接受。</p><hr><p>举个例子：</p><ul><li><p>语言 $L &#x3D; \{ a^n b^n | n \geq 0 \}$ 是一个典型的上下文无关语言，它可以被 DPDA 接受。DPDA 可以通过以下方式处理：</p><ol><li>在栈中推入 $a$。</li><li>遇到 $b$ 时弹出栈中的 $a$，并继续。</li><li>输入完全结束时，如果栈为空，则接受该字符串。</li></ol></li><li><p>语言 $L &#x3D; \{ a^n b^n c^n | n \geq 0 \}$ 是一个上下文无关语言，但它不能被任何 DPDA 接受，因为它需要同时处理 $a$、$b$ 和 $c$ 的数量，这要求下推自动机能够在不同的符号之间进行回溯选择，而 DPDA 无法做到这一点。</p></li></ul><table><thead><tr><th>特性</th><th>PDA（下推自动机）</th><th>DPDA（确定性下推自动机）</th></tr></thead><tbody><tr><td><strong>确定性</strong></td><td>非确定性</td><td>确定性</td></tr><tr><td><strong>语言类型</strong></td><td>上下文无关语言（CFL）</td><td>确定性上下文无关语言（D-CFL）</td></tr><tr><td><strong>转移函数</strong></td><td>可能有多个转移</td><td>对每一组合，最多只有一个转移</td></tr><tr><td><strong>栈操作</strong></td><td>可以有多个栈操作</td><td>对每一输入符号和栈顶符号，栈操作唯一</td></tr><tr><td><strong>接受条件</strong></td><td>终态接受、空栈接受</td><td>终态接受、空栈接受</td></tr></tbody></table><hr><h3 id="5-5-正则语言与DPDA"><a href="#5-5-正则语言与DPDA" class="headerlink" title="5.5 正则语言与DPDA"></a>5.5 正则语言与DPDA</h3><ul><li><p><strong>正则语言</strong>（Regular Languages）是最简单的语言类别，可以通过有限自动机（DFA 或 NFA）来接受，也可以通过正则表达式来描述。正则语言的特点是它们的结构非常简单，不需要栈来存储额外的信息，自动机可以在处理时通过状态转移来完成任务。</p></li><li><p><strong>上下文无关语言</strong>（Context-Free Languages，简称 CFLs）是比正则语言更复杂的语言类别。它们可以通过上下文无关文法（CFG）来定义，并且通常需要栈来存储和操作语法信息。上下文无关语言的典型代表就是编程语言中的语法结构，如表达式解析、函数调用等。</p></li><li><p><strong>DPDA</strong>（Deterministic Pushdown Automaton，确定性下推自动机）是一种具有栈的自动机，用于接受上下文无关语言。DPDA 是 PDA（下推自动机）的一种特殊形式，区别在于 DPDA 的转移是<strong>确定性的</strong>，即在每一个状态和栈顶符号以及输入符号的组合下，DPDA 的行为是唯一的。</p></li></ul><p>正则语言比上下文无关语言简单，通常不需要栈来处理。例如，正则语言可以通过 DFA 或 NFA 来接受，利用有限的状态和简单的转移规则即可完成。</p><ul><li><strong>正则语言</strong> 是上下文无关语言的子集，这意味着每个正则语言都可以是上下文无关的。</li><li>因为 <strong>DPDA</strong> 用来接受上下文无关语言，所以它能够接受所有的正则语言。实际上，正则语言的结构不需要栈，因此我们可以认为 <strong>DPDA</strong> 接受正则语言时，栈是“过度”的，它实际上不需要使用栈来完成这个任务。</li></ul><p><strong>为什么 DPDA 可以接受正则语言？</strong></p><ul><li><strong>有限自动机</strong>（DFA 和 NFA）是最简单的自动机，它们仅使用状态来处理输入，而不需要栈。这些自动机能够接受正则语言。</li><li><strong>DPDA</strong> 比 DFA 更强大，因为它有栈可以使用。然而，对于正则语言来说，栈并没有实际的用途。DPDA 在接受正则语言时，仅仅依赖状态转移，而栈并没有被利用。因此，虽然正则语言可以被 DFA 接受，DPDA 也能接受它们，但 <strong>DPDA 是过度使用栈的</strong>，因为它实际上不需要栈的帮助。</li></ul><p>总结：所有的 <strong>正则语言</strong> 都可以通过 <strong>DPDA</strong> 接受。对于正则语言来说，DPDA 不必使用栈，DPDA 是一种比 DFA 更强的模型，但它的栈功能在正则语言中是多余的。</p><p><strong>DPDA 的限制</strong></p><p>虽然 DPDA 可以接受 <strong>确定性上下文无关语言</strong>，但它的能力比一般的 PDA 强度要小。一个普通的 PDA 可以接受 <strong>所有的上下文无关语言</strong>（CFLs），而 DPDA 只能接受其中的一部分，通常是那些 <strong>结构较为简单且具有确定性的</strong> 上下文无关语言。某些上下文无关语言，由于它们的结构过于复杂，DPDA 无法接受。</p><ul><li><strong>正则语言</strong> 是 <strong>最简单</strong> 的语言，可以通过 <strong>有限自动机（DFA）</strong> 来接受。由于正则语言的简单性，<strong>DPDA</strong> 可以接受这些语言，但它的栈功能并没有被实际利用。</li><li><strong>DPDA</strong> 能接受 <strong>所有正则语言</strong>，但它的能力不仅仅局限于此，DPDA 可以接受一些更复杂的语言——<strong>确定性上下文无关语言</strong>（D-CFLs）。</li><li><strong>DPDA</strong> 不能接受 <strong>所有的上下文无关语言</strong>，它只能接受 <strong>确定性上下文无关语言</strong>。对于那些复杂的上下文无关语言，特别是需要非确定性栈操作的语言，DPDA 无法接受。</li></ul><p><strong>总结</strong>：正则语言可以被 <strong>DPDA</strong> 接受，因为正则语言的结构不需要栈，DPDA 的能力足以接受正则语言。然而，DPDA 并不只接受正则语言，它也可以接受一些更复杂的语言，但它的能力是有局限的，不能接受所有的上下文无关语言。</p><hr><h3 id="5-6-语言类的关系"><a href="#5-6-语言类的关系" class="headerlink" title="5.6 语言类的关系"></a>5.6 语言类的关系</h3><p><strong>全语言（Recursively Enumerable Languages，RE）</strong>，也叫做 <strong>递归可枚举语言（RE）</strong>，是形式语言理论中的一个非常宽泛的类别，几乎包含了所有可以被某种计算模型识别的语言。它是语言类中最广泛的一类。全语言包含了所有可以被 <strong>图灵机</strong> 识别的语言。（后面章节讲解）</p><p>在形式语言的分类中，语言类之间的关系可以通过包含关系来描述。具体来说：</p><ul><li><strong>正则语言（Regular Languages）</strong> 是最简单的语言类，所有正则语言都是上下文无关语言（CFL）的子集。正则语言不能表示复杂的嵌套结构。</li><li><strong>上下文无关语言（CFL）</strong> 比正则语言更复杂，可以表示更多的语言结构。</li><li><strong>确定性上下文无关语言（DCFL）</strong> 是上下文无关语言的一个子集。并非所有上下文无关语言都是确定性上下文无关语言。</li><li><strong>全语言（RE）</strong> 是最广泛的语言类，包含了所有可以由图灵机识别的语言。它包含了上下文无关语言、正则语言等，但并不要求这些语言能够被判定。</li></ul><table><thead><tr><th>语言类别</th><th>特征</th><th>示例</th></tr></thead><tbody><tr><td><strong>全语言（RE）</strong></td><td>包含所有递归可枚举语言，可以被图灵机识别，但不一定是可判定的。</td><td>所有能够通过图灵机识别的语言。</td></tr><tr><td><strong>上下文无关语言（CFL）</strong></td><td>可以由上下文无关文法（CFG）生成，可以通过 PDA 识别。</td><td>括号匹配，$a^n b^n$， $S \to aSb | \varepsilon$</td></tr><tr><td><strong>确定性上下文无关语言（DCFL）</strong></td><td>可以由确定性下推自动机（DPDA）识别，是 CFL 的子集。</td><td>$a^n b^n$，$a^n b^n c^n$（非确定性上下文无关语言）</td></tr><tr><td><strong>正则语言（Regular Languages）</strong></td><td>可以由有限自动机（DFA 或 NFA）识别，最简单的语言。</td><td>$a^n b^n$，正则表达式 $a^* b^*$</td></tr></tbody></table><ul><li><strong>正则语言</strong> 是 <strong>最简单</strong> 的语言，可以通过 <strong>有限自动机（DFA）</strong> 来接受。由于正则语言的简单性，<strong>DPDA</strong> 可以接受这些语言，但它的栈功能并没有被实际利用。</li><li><strong>上下文无关语言</strong> 比正则语言更复杂，可以表示更多的语言结构。</li><li><strong>确定性上下文无关语言</strong> 是上下文无关语言的一部分，它们比一般的上下文无关语言更容易处理。</li><li><strong>全语言</strong> 是最广泛的语言类，包含了所有可以由图灵机识别的语言。</li></ul><center><img src="/img/FL/relation.svg" alt="语言类之间的关系" style="max-width: 100%; height: auto;" /></center><h2 id="6-图灵机（Turing-Machine）"><a href="#6-图灵机（Turing-Machine）" class="headerlink" title="6. 图灵机（Turing Machine）"></a>6. 图灵机（Turing Machine）</h2><p>图灵机是由数学家艾伦·图灵（Alan Turing）于1936年提出的一个理论计算模型，旨在为“可计算性”提供一个精确的定义。图灵机本质上是一个抽象的机器，用来模拟任何形式的计算过程。它由以下几个部分组成：</p><ol><li><p><strong>无限长的带子</strong>：带子被分为一格一格，每个格子可以存储一个符号，符号来自一个有限的字母表。带子可以在左右两个方向上移动，并且可以反复读取和修改。</p></li><li><p><strong>读&#x2F;写头</strong>：在带子上移动并读取符号，或者写入符号。读写头每次只能操作一个格子。</p></li><li><p><strong>状态控制器</strong>：图灵机有一个有限的状态集，其中包括一个初始状态、若干个中间状态和一个或多个接受状态（终止状态）。每个状态都可能有不同的行为，包括：读取当前格子的符号，写入新符号，移动带子，或者转到下一个状态。</p></li><li><p><strong>转移函数</strong>：定义了图灵机的行为。它规定了在某个状态下，根据当前读取的符号，图灵机应当写入什么符号，移动到哪个方向，并转移到哪个状态。</p></li></ol><p>图灵机的计算过程是通过状态控制器与带子上符号的交互来进行的。如果图灵机在某个状态下停下来且没有任何进一步的规则，或者进入一个终止状态，则计算结束。</p><p>图灵机是计算理论中的核心工具，它定义了“可计算性”的概念。图灵机不仅可以模拟任何形式的计算过程，也可以用来定义不同类型的语言（如正规语言、上下文无关语言、递归可枚举语言等）。以下是一些图灵机与其他语言之间的关系：</p><ol><li><p><strong>正规语言（Regular Languages）</strong>：正规语言可以由有限自动机（DFA&#x2F;NFA）识别，而图灵机能够识别更广泛的语言。事实上，所有正规语言都可以通过图灵机识别，但并非所有图灵机能识别的语言都是正规语言。</p></li><li><p><strong>上下文无关语言（Context-Free Languages, CFLs）</strong>：上下文无关语言可以由上下文无关文法生成，而图灵机的能力远超上下文无关文法。每个上下文无关语言都可以由图灵机识别，但图灵机可以识别更多类型的语言，包括无法由上下文无关文法生成的语言。</p></li><li><p><strong>递归可枚举语言（Recursively Enumerable Languages）</strong>：这些是所有可以被图灵机识别的语言。图灵机不仅能识别这些语言，还能生成它们的所有字符串，但不能保证总是能在有限的时间内做出决定。递归可枚举语言的一个例子是图灵机的输出语言。</p></li><li><p><strong>递归语言（Recursive Languages）</strong>：递归语言是那些能够由图灵机在有限时间内决定的语言。这些语言不仅可以被图灵机识别，还可以保证图灵机总是在有限时间内做出决定，即图灵机总是停机。</p></li></ol><p>图灵机是计算理论中的核心概念，它是一种抽象的计算模型，用来定义“可计算性”。它的强大之处在于能够识别递归可枚举语言，而在更小的类别中（如正规语言、上下文无关语言）有专门的机器来识别。图灵机的理论研究帮助我们理解了哪些问题是可以计算的，哪些是不可计算的。</p><h2 id="7-偷偷说"><a href="#7-偷偷说" class="headerlink" title="7. 偷偷说"></a>7. 偷偷说</h2><p>费了很大力气，终于把形式语言与自动机这门课的内容更完了。这门课的笔记的字数竟然超过了操作系统😂我觉得自动机的学习还是在关注几个模型上面还有正则语言和上下文无关语言性质的理解上。刷题的话，还是从九州大学的自动机过去问开始入手是最合适的，当然Sisper的课后书的例题也非常值得去做。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Formal Language and Automata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating System</title>
    <link href="/2024/12/11/Operation-System/"/>
    <url>/2024/12/11/Operation-System/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><p>This is for test takers to quickly review Operating System. Credit to 《Operating System, 9th Edition》。操作系统的知识看起来非常得杂乱无章，需要重点关注任务调度算法，内存管理分配算法，以及地址变换机制。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><h2 id="1-Introduction-to-Operating-System"><a href="#1-Introduction-to-Operating-System" class="headerlink" title="1. Introduction to Operating System"></a>1. Introduction to Operating System</h2><p>计算机系统可以划分为<strong>4个</strong>主要组件：</p><ol><li><p>硬件(hardware)：指的是物理设备，包括计算机的处理器、内存、硬盘、输入输出设备等。硬件如中央处理单元(CPU)、内存(memory)、输入输出设备(I&#x2F;O device)为系统提供基本的计算资源。</p></li><li><p>操作系统(Operating System)：软件层次上管理硬件资源并提供基本服务的平台，例如 Windows、Linux 等。</p></li><li><p>应用程序(application)：运行在操作系统之上的软件，提供具体的功能和服务，如浏览器、文字处理软件等。</p></li><li><p>用户(user)：使用计算机系统进行操作和执行任务的人员。</p></li></ol><hr><p><strong>单处理器系统（Single-Processor System）</strong> 是指只有一个中央处理单元（CPU）的计算机系统。其特点如下：  </p><ol><li><strong>核心数量</strong>：只有一个处理器核心，用于执行所有的指令和任务。  </li><li><strong>任务调度</strong>：通过时间分片等方法实现多任务操作，但实际上每个时刻只能执行一个任务。  </li><li><strong>适用场景</strong>：适合资源需求较低的应用场景，如传统的个人计算机和嵌入式系统。  </li><li><strong>优点</strong>：结构简单，成本较低，软件开发难度小。  </li><li><strong>缺点</strong>：处理能力有限，无法充分利用多核架构的优势。</li></ol><p><strong>多处理系统（multiprocessing system）(也称为并行系统（parallel system）)</strong> 是指拥有多个处理器（或多个核心）的计算机系统，允许多个任务同时运行。其特点如下：  </p><ol><li><strong>核心数量</strong>：包含两个或更多处理器（或多核），每个核心可以独立执行任务。  </li><li><strong>任务并行</strong>：支持真正的并行计算，显著提高计算速度和效率。  </li><li><strong>架构类型</strong>：分为<strong>对称多处理（Symmetric MultiProcessing, SMP）</strong>和<strong>非对称多处理（Asymmetric MultiProcessing, AMP）</strong>：  <ul><li>SMP：所有处理器平等共享内存和任务。  </li><li>AMP：不同处理器有专门的任务分工。</li></ul></li><li><strong>适用场景</strong>：高性能计算、服务器、多任务处理（如图像处理、机器学习等）。</li></ol><p><strong>多处理器系统的主要优点有：</strong></p><ol><li><p><strong>增加吞吐量</strong>  </p><ul><li>多处理器系统通过并行处理任务显著提高了整体计算吞吐量。  </li><li>多个处理器可以同时执行不同的任务，减少任务队列的等待时间，提高系统的运行效率。  </li><li>特别适用于计算密集型任务，如科学计算、数据处理和复杂的仿真。</li><li>采用N个处理器的加速比不是N，而是小于N（考虑资源共享竞争）</li></ul></li><li><p><strong>规模经济</strong>  </p><ul><li>多处理器系统通过共享内存、I&#x2F;O设备等资源，降低了每个处理器独立配备资源的成本。  </li><li>随着处理器数量增加，系统性能可以线性甚至超线性提升，使整体成本效益更高。  </li><li>常见于需要扩展性强的大型系统，如云计算和服务器集群。</li></ul></li><li><p><strong>增加可靠性</strong>  </p><ul><li>多处理器系统具备更高的容错能力，当一个处理器发生故障时，其他处理器可以接管任务，保证系统的连续运行。  </li><li>提供了冗余机制，使关键任务系统（如航空、医疗设备）在出现硬件问题时仍能保持稳定。比如10个处理器中的1个出了故障，剩下的9个会分担器故障处理器的那部分工作。</li><li>通过任务分配策略，还可有效防止单点故障的影响。</li></ul></li></ol><hr><p><strong>操作系统</strong>（Operating System，OS）是计算机系统中最基础且最重要的<strong>软件</strong>，它负责管理硬件资源并为用户和应用程序提供接口。其主要功能和定义如下：</p><ol><li><p><strong>资源管理者</strong>  : 操作系统负责管理和分配计算机的硬件资源，包括CPU、内存、存储设备和外部设备，以确保各类任务高效运行。</p></li><li><p><strong>用户与硬件之间的桥梁</strong>  : 操作系统提供用户与硬件交互的接口，使用户可以通过简单的命令或图形界面与计算机进行操作，而无需直接了解硬件的底层细节。</p></li><li><p><strong>程序执行的控制中心</strong>  : 操作系统负责调度和协调应用程序的运行，提供多任务处理和资源分配功能，保证系统的稳定性和性能。</p></li><li><p><strong>服务提供者</strong>  : 它为应用程序提供基本的服务，如文件管理、内存管理、进程调度和网络通信，简化了软件开发。</p></li></ol><p>操作系统是计算机系统的核心，它连接硬件和用户，为软件运行提供支持，同时确保系统的高效性和可靠性。</p><hr><p><strong>中断机制</strong>是操作系统中一个关键的功能，用于处理异步事件和高效管理硬件资源。它使得计算机可以响应各种外部或内部事件，如硬件故障、输入输出操作的完成、定时器到期等。下面详细介绍中断机制的各个方面：</p><p>1.<strong>中断的基本概念：</strong> 中断（Interrupt）是指计算机在执行程序的过程中，由于某些突发事件（如硬件设备请求、异常情况等），使得CPU暂时中止当前正在执行的程序，转而去处理这些事件的过程。当中断事件处理完毕后，CPU再回到中断前的程序继续执行。</p><p>2.<strong>中断的分类：</strong></p><ol><li><strong>硬件中断（Hardware Interrupt）</strong>：由外部硬件设备触发，如键盘按键、鼠标点击、网络数据包到达等。</li><li><strong>软件中断（Software Interrupt）</strong>：由软件触发的中断，如系统调用、程序异常等。</li><li><strong>定时器中断（Timer Interrupt）</strong>：由系统定时器触发，用于时间片轮转调度等操作。</li></ol><p>3.<strong>中断处理过程：</strong> 中断处理过程一般包括以下几个步骤：</p><ol><li><strong>中断请求</strong>：外部设备或软件发出中断请求信号。</li><li><strong>中断响应</strong>：CPU检查中断信号，并保存当前执行的上下文（如程序计数器、寄存器等）。</li><li><strong>中断向量</strong>：根据中断类型，CPU查找中断向量表以获取相应的中断服务程序（Interrupt Service Routine，ISR）的入口地址。</li><li><strong>执行中断服务程序</strong>：CPU跳转到ISR，执行相应的中断处理逻辑。</li><li><strong>恢复上下文</strong>：中断处理完成后，CPU恢复先前保存的上下文，继续执行被中断的程序。</li></ol><p>4.<strong>中断优先级：</strong><br>在多种中断同时发生时，需要确定哪个中断优先处理。中断优先级机制用于决定中断处理的顺序。一般来说，硬件中断优先级较高，而软件中断优先级较低。中断控制器（Interrupt Controller）用于管理中断优先级。</p><p>5.<strong>中断屏蔽：</strong> 中断屏蔽是指在某些关键操作期间，暂时禁止某些中断的发生，以防止中断打断正在进行的重要操作。通常使用中断屏蔽寄存器来实现。屏蔽中断可以避免在执行关键代码段时被中断打断，但也需要注意不能长时间屏蔽，以免丢失重要的中断信号。</p><p>6.<strong>中断的优点:</strong></p><ol><li><strong>响应及时</strong>：中断机制可以在事件发生时立即响应，提高系统的实时性。</li><li><strong>资源高效利用</strong>：通过中断机制，可以在硬件设备准备好时才进行处理，而不需要轮询，节省CPU资源。</li><li><strong>多任务处理</strong>：中断机制支持多任务并发处理，增强系统的灵活性和效率。</li></ol><p>7.<strong>中断的缺点:</strong></p><ol><li><strong>中断延迟</strong>：如果中断处理程序过多或过长，可能会导致系统响应延迟。</li><li><strong>复杂性增加</strong>：中断机制需要维护中断向量表和中断控制器，增加了系统的复杂性。</li><li><strong>上下文切换开销</strong>：每次中断处理都涉及上下文切换，带来一定的性能开销。</li></ol><p>以下是一个简单的中断处理流程示例：假设这是一个简单的汇编代码，演示中断处理</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ORG 100HMOV AX, 0          ; 初始化AX寄存器INTERRUPT_HANDLER:PUSH AX            ; 保存AX寄存器MOV AX, 1234H      ; 中断处理逻辑POP AX             ; 恢复AX寄存器IRET               ; 返回中断前的程序MAIN:MOV AX, 1INT 0              ; 触发中断MOV AX, 2HLT                ; 停止程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个示例中，当执行到 INT 0 指令时，会触发中断并调用 INTERRUPT_HANDLER 来处理中断。在中断处理程序中，保存了AX寄存器的值，并进行了简单的处理后恢复AX寄存器，然后返回到中断前的程序继续执行。通过中断机制，计算机系统可以高效处理各种异步事件，保证系统的稳定性和响应性。</p><hr><p><strong>轮询（Polling）</strong> 是一种通过主动检查设备或资源状态来判断是否需要处理某个事件的机制。操作系统或程序会周期性地访问设备或资源，以确定是否需要执行相关操作。</p><p><strong>轮询的特点：</strong></p><ol><li><p><strong>主动查询</strong>  : 系统不断循环检查设备或资源的状态，而不是等待设备主动通知。</p></li><li><p><strong>简单易实现</strong>  : 轮询机制实现起来比较简单，通常只需要循环读取设备的状态寄存器即可。</p></li><li><p><strong>低效</strong>  : 如果设备状态没有发生变化，CPU可能会浪费大量时间在无意义的查询上，无法高效利用资源。</p></li></ol><p><strong>轮询的工作流程：</strong></p><ol><li>系统通过读取设备状态寄存器获取设备当前状态。  </li><li>如果发现设备准备好（例如I&#x2F;O操作完成），则进行相应的处理。  </li><li>如果设备未准备好，则继续轮询，直到设备状态发生变化。</li></ol><p><strong>轮询的缺点：</strong></p><ul><li><strong>资源浪费</strong>：占用CPU时间，即使设备未准备好也会不断查询。  </li><li><strong>实时性差</strong>：对于需要快速响应的事件，轮询可能无法及时处理。  </li><li><strong>不适合频繁事件</strong>：当事件发生较多时，轮询会影响系统整体性能。</li></ul><p><strong>轮询的优点：</strong></p><ul><li><strong>简单性</strong>：实现简单，不需要复杂的硬件支持。  </li><li><strong>适用性</strong>：适合事件发生频率较低或硬件复杂度较低的场景。</li></ul><p><strong>轮询对比中断机制：</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>轮询</strong></th><th><strong>中断</strong></th></tr></thead><tbody><tr><td>响应方式</td><td>主动查询设备状态</td><td>被动响应设备的中断信号</td></tr><tr><td>资源利用效率</td><td>较低，可能浪费CPU资源</td><td>高效，只在事件发生时占用资源</td></tr><tr><td>实现复杂度</td><td>简单，不需要硬件支持</td><td>复杂，需要硬件和软件配合</td></tr><tr><td>实时性</td><td>较差</td><td>较强</td></tr></tbody></table><p>轮询虽然简单，但在现代操作系统中已逐渐被更高效的<strong>中断机制</strong>取代。</p><hr><p>在操作系统中，<strong>“异常(exception)”</strong> 指的是一种特殊的事件或情况，它们会导致当前正在执行的程序或系统行为发生中断。这些异常可能来自于硬件或软件，通常需要操作系统进行处理，以确保系统的稳定性和安全性。</p><p><strong>异常的分类：</strong></p><ol><li><strong>硬件异常</strong>：由于硬件故障或特殊硬件条件引起，例如内存访问违规、除零错误等。</li><li><strong>软件异常</strong>：由于软件执行过程中出现的非法操作或异常情况引起，例如非法指令、系统调用错误等。</li></ol><p><strong>异常处理过程：</strong></p><ol><li><strong>检测异常</strong>：当异常发生时，硬件或操作系统检测到异常情况。</li><li><strong>保存状态</strong>：当前处理器状态（例如寄存器值、程序计数器）被保存，以便后续恢复。</li><li><strong>调用异常处理程序</strong>：操作系统根据异常类型，调用相应的异常处理程序（Exception Handler）。</li><li><strong>处理异常</strong>：异常处理程序执行特定的操作，以处理或缓解异常情况。</li><li><strong>恢复状态</strong>：异常处理完成后，恢复处理器状态并继续执行被中断的程序。</li></ol><p><strong>常见的异常类型：</strong></p><ul><li><strong>访问违例</strong>：试图访问未授权的内存区域。</li><li><strong>非法指令</strong>：执行了无效或未定义的指令。</li><li><strong>除零错误</strong>：在计算过程中出现除数为零的情况。</li><li><strong>系统调用</strong>：用户程序请求操作系统提供服务时产生的异常。</li></ul><p><strong>异常处理的优点：</strong></p><ul><li><strong>提高系统稳定性</strong>：通过有效的异常处理机制，操作系统可以检测并处理各种错误，避免系统崩溃。</li><li><strong>增强安全性</strong>：异常处理可以防止非法操作，保护系统和用户数据的安全。</li></ul><p>异常处理是操作系统中的一个关键机制，用于管理和处理各种意外事件和错误情况。通过异常处理，操作系统能够保持系统的稳定性和安全性，确保用户和应用程序的正常运行。</p><hr><p>在操作系统中，<strong>中断（Interrupt）和异常（Exception）</strong> 是两种重要的事件，它们都会导致CPU暂停当前的任务，转而去处理这些事件。再总结一下就是：</p><ul><li>中断（Interrupt）：中断是由<u>硬件设备（如键盘，鼠标，网络接口卡等）发出的信号，</u>通知操作系统有一些重要的事件发生，需要立即处理。例如，当你按下键盘上的一个键时，键盘会向CPU发送一个中断信号，CPU会暂停当前的任务，转而去处理这个按键事件。处理完这个事件后，CPU会返回到被中断的任务，继续执行。</li><li>异常（Exception）：异常是由<u>CPU在执行指令过程中发现的问题，</u>如除以零，访问无效的内存地址等。当发生异常时，CPU会暂停当前的任务，转而去执行一个特殊的异常处理程序。处理完这个异常后，CPU可能会返回到被中断的任务，也可能会终止这个任务，这取决于异常的类型和严重性。</li></ul><p>总体来说，中断和异常都是操作系统用来响应和处理重要事件的机制。它们都会导致CPU暂停当前的任务，但来源和处理方式有所不同。<strong>中断通常由外部硬件或定时器触发，表示系统需要对外部事件进行响应，而异常则由程序内部的特殊或错误行为引发，表示需要操作系统介入进行修复或处理</strong>。发生中断或异常时，操作系统都会介入并展开管理工作；<strong>用户态和内核态的切换是通过中断或异常实现的，而中断是实现这种切换的唯一途径，通过修改程序状态字（PSW）来完成状态转换</strong>。</p><hr><p><strong>内存管理</strong> 是操作系统的一项重要功能，负责管理计算机的主存储器，并为应用程序分配和释放内存。内存管理的主要目标是提高内存的使用效率，保证系统的稳定性和安全性。以下是内存管理的一些关键概念和机制：</p><p><strong>内存管理的主要任务:</strong></p><ol><li><strong>内存分配</strong>：为进程分配所需的内存资源，包括动态分配和静态分配。</li><li><strong>内存保护</strong>：确保进程只能访问自己合法的内存区域，防止进程之间相互干扰。</li><li><strong>内存回收</strong>：回收不再使用的内存，以便分配给其他进程。</li></ol><p><strong>内存管理机制:</strong></p><p><strong>1.分段和分页:</strong></p><ul><li><strong>分页</strong>：内存被划分成大小相同的页，每个进程的地址空间也被划分成相同大小的页。通过页表（Page Table）映射进程页和物理内存页，实现内存的管理。</li><li><strong>分段</strong>：内存被划分成不同大小的段，每个段包含一段逻辑地址空间。通过段表（Segment Table）管理和映射各段地址。</li></ul><p><strong>2.虚拟内存:</strong></p><p>虚拟内存技术允许操作系统将实际物理内存与进程的逻辑内存分离，使得进程可以使用比实际物理内存更大的地址空间。虚拟内存通过页表和交换空间（Swap Space）管理，将不常用的页临时存储在磁盘上，需要时再调入内存。</p><p><strong>3.内存保护:</strong></p><ul><li><strong>基址寄存器和界限寄存器</strong>：通过设置每个进程的基址和界限，确保进程只能访问自己的内存区域，防止越界访问。</li><li><strong>页面保护</strong>：通过页表中的保护位控制每个页的访问权限（读、写、执行），保证进程的内存访问安全。</li></ul><p><strong>4. 内存回收:</strong></p><ul><li><strong>垃圾回收</strong>：通过自动检测和回收不再使用的内存，释放资源供其他进程使用。</li><li><strong>内存压缩</strong>：通过内存整理和压缩，减少内存碎片，提高内存利用率。</li></ul><p><strong>内存管理的重要性:</strong></p><ol><li><strong>提高系统性能</strong>：通过有效的内存分配和回收机制，保证进程的高效运行。</li><li><strong>增强系统稳定性</strong>：通过内存保护机制，防止进程之间的相互干扰，保证系统的稳定运行。</li><li><strong>优化资源利用</strong>：通过虚拟内存和分页技术，最大化内存资源的利用率，使得系统能够同时运行更多的进程。</li></ol><p>内存管理是操作系统的一项核心功能，涉及内存的分配、保护和回收等多个方面。通过有效的内存管理，操作系统能够提高系统性能、增强稳定性，并优化资源利用，为应用程序提供稳定可靠的运行环境。</p><hr><p>操作系统的<strong>进程管理</strong>是指对系统中所有进程的创建、调度、执行、和终止进行管理和协调的过程。它是操作系统的核心功能之一，负责保证多个任务能够高效、公平地共享CPU和其他资源。</p><p><strong>进程管理的主要功能：</strong></p><ol><li><p><strong>进程创建与终止</strong>  </p><ul><li>创建新进程：为程序分配必要的资源（如内存、文件句柄）并初始化进程控制块（PCB）。  </li><li>终止进程：释放进程所占用的资源并清理PCB。</li></ul></li><li><p><strong>进程调度</strong>  </p><ul><li>负责决定哪一个进程可以使用CPU。  </li><li>常用的调度算法包括：  <ul><li>先来先服务（FCFS）  </li><li>最短作业优先（SJF）  </li><li>时间片轮转（RR）  </li><li>多级队列调度等。</li></ul></li></ul></li><li><p><strong>进程同步</strong>  </p><ul><li>保证多个进程在访问共享资源时不会产生冲突。  </li><li>使用机制：信号量（Semaphore）、互斥锁（Mutex）、条件变量等。</li></ul></li><li><p><strong>进程通信</strong>  </p><ul><li>提供进程之间交换数据的手段。  </li><li>常用方式：管道（Pipe）、消息队列（Message Queue）、共享内存（Shared Memory）、信号（Signal）等。</li></ul></li><li><p><strong>进程状态管理</strong>  </p><ul><li>维护进程的状态：  <ul><li>新建（New）  </li><li>就绪（Ready）  </li><li>运行（Running）  </li><li>阻塞（Blocked）  </li><li>终止（Terminated）</li></ul></li><li>根据状态变化完成任务切换。</li></ul></li><li><p><strong>多线程支持</strong>  </p><ul><li>管理线程的创建、调度和同步，支持多线程模型（如用户线程和内核线程）。</li></ul></li></ol><p><strong>进程与线程的区别</strong></p><ul><li><strong>进程(Process)</strong> 是资源分配的最小单位，每个进程有独立的地址空间。进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。  </li><li><strong>线程(Thread)</strong> 是CPU调度的最小单位，线程共享进程的地址空间。线程是进程中的一条执行路径，是进程的一个实体，可作为系统独立调度和分派的基本单位。</li></ul><p>进程：就像一家物业管理公司，它独立运营，有自己的一套管理系统（相当于进程的独立地址空间）。这个公司可以接多个任务，但所有任务最终都需要公司的资源来完成。</p><p>单线程：假设你是这家公司的唯一员工。初期，业务量很小，每个任务都需要你亲自去完成。比如，给老张家修完暖气管道，然后再去老李家换电灯泡。这个过程类似于单线程执行——每次只能处理一个任务，必须按顺序进行。</p><ul><li>示例：修暖气管道 -&gt; 换电灯泡</li></ul><p>多线程：随着业务的发展，你雇佣了多个工人。这时，你的公司可以同时为多户人家提供服务。每个工人就是一个线程，他们可以独立处理自己的任务，但仍然共享公司的资源（如工具、交通工具等）。</p><ul><li>示例：工人A修暖气管道，工人B换电灯泡，工人C修水管</li></ul><p>主线程：你作为公司的老板和主线程，负责分配任务、协调工作，确保所有工人（线程）能顺利开展工作。如果某个工人遇到问题（冲突或需要协同），你可以及时介入解决，保持公司的正常运行。</p><p>通过这个类比，进程就像是一个独立的公司，每个线程就像是公司的员工，他们共享公司的资源，并共同完成任务。多线程能提高效率，但需要有效的管理和协调，确保资源的合理使用和任务的顺利完成。</p><p>进程管理是操作系统的核心功能之一，它通过对进程的调度和控制，实现了多任务并发，保证系统资源的高效利用和任务的公平执行。</p><hr><p><strong>API（Application Programming Interface, 应用程序编程接口）</strong> 是一种允许不同软件系统之间进行通信的接口。API 定义了一组函数、方法、协议或工具，使开发者可以利用这些接口来访问另一种软件的功能或数据，而无需了解其内部实现细节。</p><p><strong>API重要特点：</strong></p><ul><li><strong>抽象层（Abstraction Layer）</strong>：API 提供了对底层复杂操作的简化抽象，开发者不需要了解底层实现细节。</li><li><strong>功能封装（Function Encapsulation）</strong>：API 将常用功能封装为可复用的接口，方便开发者调用。</li><li><strong>互操作性（Interoperability）</strong>：不同的软件系统可以通过 API 进行互操作，提高系统的兼容性和可扩展性。</li></ul><p><strong>系统调用（System Call）</strong> 是操作系统内核提供的接口，允许应用程序请求操作系统提供服务。系统调用是程序与操作系统之间的桥梁，使应用程序可以执行底层硬件操作，如文件操作、进程管理和网络通信等。系统调用可以被看作是<strong>操作系统API的一部分</strong>。当你在编程时使用API，你可能会间接地使用系统调用。例如，当你使用C++的文件流对象（如std::fstream）来读写文件时，这些对象内部可能会使用到操作系统的系统调用来进行实际的文件操作。</p><p><strong>系统调用重要特点：</strong></p><ul><li><strong>内核模式（Kernel Mode）</strong>：系统调用将程序从用户模式切换到内核模式，以便执行特权操作。</li><li><strong>服务访问（Service Access）</strong>：通过系统调用，应用程序可以访问操作系统内核提供的服务。</li><li><strong>安全和稳定（Security and Stability）</strong>：系统调用由操作系统内核管理，确保了系统的安全性和稳定性。</li></ul><p><strong>总结：</strong></p><ul><li><strong>API（应用程序编程接口）</strong> 是软件之间进行通信的接口，通过提供预定义的函数和方法，使开发者能够利用现有功能来构建应用程序。</li><li><strong>系统调用（System Call）</strong> 是操作系统提供的接口，使应用程序可以请求操作系统执行底层硬件操作和特权任务。</li></ul><p>API 是一种更高层次的抽象，而系统调用是更底层的接口，两者都在不同层次上为软件开发提供了便利和功能。总的来说，API和系统调用都是使程序员能够更容易地编写代码和交互系统的工具。API提供了更高级别的抽象，而系统调用则提供了对操作系统服务的直接访问。</p><hr><p>操作系统的<strong>四个重要特征</strong>包括：</p><p><strong>1.并发（Concurrency）</strong> 并发是指两个或多个事件在同一时间间隔内发生。在操作系统中，并发可以通过多线程或多进程实现，线程或进程可以在一个处理器上交替执行，或者在多个处理器上同时执行。</p><ul><li><strong>并发（Concurrency）</strong> 是指多个任务在同一时间段内交替进行，给人的感觉是同时发生，但实际上每个任务并不是同时进行的。</li><li><strong>并行（Parallelism）</strong> 与并发不同，并行是指两个或多个事件在同一时刻同时发生。例如：多线程下载文件，多个进程同时处理不同任务。</li></ul><p><strong>2.共享（Sharing）</strong> 共享是指系统中的资源可以被多个并发进程共同使用。共享的方式有两种：同时访问（同时共享）和在一段时间内交替访问（互斥共享）。</p><ul><li><strong>同时共享（Concurrent Sharing）</strong>：多个进程同时访问同一资源。</li><li><strong>互斥共享（Mutual Exclusion Sharing）</strong>：多个进程轮流访问同一资源，以避免冲突。例如：多个进程共享打印机资源，互斥访问临界区。</li></ul><p><strong>3.虚拟化（Virtualization）</strong> 虚拟化是指把一个物理资源（如处理器、内存或磁盘）抽象为多个逻辑资源，或把多个物理资源抽象为一个逻辑资源。虚拟化使得用户感觉有更多的资源可用，或使得资源使用更加高效。</p><ul><li><strong>空分复用（Space Division Multiplexing）</strong>：如虚拟存储器，使4GB内存的计算机能够运行需要超过4GB内存的程序。</li><li><strong>时分复用（Time Division Multiplexing）</strong>：时分复用通过将时间划分为多个时间片，每个时间片分配给不同的任务执行。通过CPU时间片轮转技术实现多任务并行，使得每个任务在短时间内轮流占用CPU资源，给人一种同时执行多个任务的感觉。如虚拟处理器和多任务操作系统，通过CPU时间片轮转技术实现多任务并行。</li></ul><p><strong>4.异步性（Asynchronism）</strong> 异步性是指由于进程间的并发性，使得进程交替执行，进程的执行不是一贯的，也不是在固定的时间间隔内发生。这意味着进程可能走走停停，取决于系统资源的可用性和调度策略。</p><ul><li><strong>示例</strong>：异步I&#x2F;O操作，操作系统在等待I&#x2F;O操作完成时可以执行其他任务。</li></ul><p>这些特征共同作用，使操作系统能够有效地管理计算机资源，提供稳定和高效的运行环境。</p><div class="note note-success">            <p>以上就是操作系统主要关注的内容，后续章节就是扩展讲解上述内容中重要的技术细节和实现思想</p>          </div><h2 id="2-Process-Management"><a href="#2-Process-Management" class="headerlink" title="2. Process Management"></a>2. Process Management</h2><p>本章主要讲解操作系统里面的进程管理部分。理解进程和线程，掌握进程调度相关的各种策略算法，并且熟悉信号量的互斥机制是非常重要的。</p><h3 id="2-1-操作系统的用户交互"><a href="#2-1-操作系统的用户交互" class="headerlink" title="2.1 操作系统的用户交互"></a>2.1 操作系统的用户交互</h3><p>操作系统的用户交互主要分为两种类型：</p><h4 id="2-1-1-命令解释程序（Command-Interpreter）"><a href="#2-1-1-命令解释程序（Command-Interpreter）" class="headerlink" title="2.1.1 命令解释程序（Command Interpreter）"></a>2.1.1 命令解释程序（Command Interpreter）</h4><ul><li>又称为 <strong>命令行界面（CLI，Command Line Interface）</strong>。</li><li>用户通过输入文本命令与操作系统进行交互。</li><li>常见的命令解释程序包括 Unix&#x2F;Linux 系统的 Bash、Windows 的 CMD 和 PowerShell。</li><li><strong>优点</strong>：灵活性高，适合自动化脚本和高级用户。</li><li><strong>缺点</strong>：需要记住大量命令和语法，不直观。</li></ul><p>以下是一个简单的 shell 指令示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 创建一个新的目录mkdir my_new_directory# 进入新创建的目录cd my_new_directory# 创建一个新的空文件touch new_file.txt# 将一段文本写入文件中echo &quot;Hello, World!&quot; &gt; new_file.txt# 显示文件内容cat new_file.txt# 复制文件并重命名cp new_file.txt copy_of_new_file.txt# 显示当前目录中的文件和子目录列表ls -l# 删除复制的文件rm copy_of_new_file.txt# 返回上一级目录cd ..# 删除新创建的目录及其内容rm -r my_new_directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="2-1-2-图形用户界面（GUI，Graphical-User-Interface）"><a href="#2-1-2-图形用户界面（GUI，Graphical-User-Interface）" class="headerlink" title="2.1.2 图形用户界面（GUI，Graphical User Interface）"></a>2.1.2 图形用户界面（GUI，Graphical User Interface）</h4><ul><li>用户通过图形化元素（如窗口、图标、按钮）与操作系统进行交互。</li><li>常见的图形用户界面包括 Windows 的资源管理器（Windows Explorer）、macOS 的 Finder 以及 GNOME 和 KDE 等 Linux 桌面环境。</li><li><strong>优点</strong>：直观易用，适合初学者和普通用户。</li><li><strong>缺点</strong>：灵活性相对较低，复杂操作可能效率不高。</li></ul><p>这两种交互方式各有优缺点，通常操作系统会同时提供这两种方式，以满足不同用户的需求和使用场景。通过结合命令行界面和图形用户界面，用户可以在不同情况下选择最合适的交互方式，提高工作效率和使用体验。</p><hr><h3 id="2-2-操作系统中的系统调用"><a href="#2-2-操作系统中的系统调用" class="headerlink" title="2.2 操作系统中的系统调用"></a>2.2 操作系统中的系统调用</h3><p><strong>系统调用（System Call）</strong> 是操作系统提供的一组接口，允许应用程序与操作系统内核交互，以请求内核执行特权操作。系统调用是程序与操作系统之间的桥梁，使应用程序可以执行低级别的系统功能，如文件操作、进程管理和网络通信等。</p><p><strong>系统调用主要功能:</strong></p><ul><li><strong>文件操作</strong>：创建、打开、读取、写入和关闭文件。</li><li><strong>进程管理</strong>：创建、终止进程，分配资源，进程间通信等。</li><li><strong>内存管理</strong>：分配和释放内存，内存映射等。</li><li><strong>设备管理</strong>：访问和控制硬件设备，如磁盘、网络接口等。</li><li><strong>网络通信</strong>：发送和接收网络数据，设置网络连接等。</li></ul><p><strong>工作原理</strong></p><ol><li><strong>用户模式到内核模式切换</strong>：当应用程序发出系统调用时，CPU将从用户模式切换到内核模式。</li><li><strong>内核执行请求</strong>：操作系统内核接收系统调用请求，并执行相应的特权操作。</li><li><strong>返回结果</strong>：操作系统内核完成操作后，将结果返回给应用程序，并切换回用户模式。</li></ol><p><strong>系统调用示例:</strong></p><ul><li><code>open</code>：打开文件的系统调用。</li><li><code>read</code>：读取文件内容的系统调用。</li><li><code>write</code>：写入文件内容的系统调用。</li><li><code>fork</code>：创建新进程的系统调用。</li><li><code>exec</code>：执行新程序的系统调用。</li></ul><p>通过系统调用，应用程序可以安全、高效地访问操作系统提供的底层资源和服务，实现丰富的功能。</p><img src="/img/OS/system_call.svg" alt="系统调用" style="max-width: 100%; height: auto;" /><p>在后台，<strong>API 函数(Application Programming Interface, API<br>)</strong> 通常为应用程序开发人员提供了调用实际系统调用的函数。API 函数为开发人员提供了一个更高层次的抽象，使他们能够以更简单和统一的方式访问底层操作系统的功能，而不需要了解系统调用的具体实现细节。</p><p>通过调用 API 函数，开发人员可以间接地进行文件操作、进程管理、内存管理、设备控制等操作，这些 API 函数在后台会触发相应的系统调用来完成实际的操作。例如：</p><ul><li><strong>文件操作</strong>：<code>fopen</code> API 函数会调用 <code>open</code> 系统调用。</li><li><strong>进程管理</strong>：<code>fork</code> API 函数直接对应 <code>fork</code> 系统调用。</li><li><strong>内存管理</strong>：<code>malloc</code> API 函数可能会调用 <code>brk</code> 或 <code>mmap</code> 系统调用。</li></ul><p>总之，API 提供了一种方便的方式，使开发人员能够利用操作系统的功能，而不必处理系统调用的复杂性和底层细节。</p><blockquote><p>在后台，API函数通常为应用程序员调用实际的系统调用</p></blockquote><h3 id="2-3-进程的概念"><a href="#2-3-进程的概念" class="headerlink" title="2.3 进程的概念"></a>2.3 进程的概念</h3><p><strong>进程</strong>是计算机中一个正在运行的程序的实例。它不仅包括可执行程序的代码，还包含了该程序的运行状态信息，包括程序计数器、寄存器和变量的值。</p><p><strong>进程的主要特点:</strong></p><ol><li><strong>独立性</strong>：每个进程在其自己的内存空间中运行，独立于其他进程。</li><li><strong>资源拥有</strong>：进程拥有自己的系统资源，如文件句柄和内存段。</li><li><strong>并发性</strong>：操作系统可以在同一时间段内允许多个进程并发执行（即使在单个处理器系统中，通过时间分片实现）。</li><li><strong>状态</strong>：进程有多种状态，包括新建、就绪、运行、等待和终止。</li></ol><p><strong>进程的组成部分:</strong></p><ul><li><strong>可执行代码</strong>：实际的程序代码。</li><li><strong>进程控制块（PCB）</strong>：存储进程的状态信息，如程序计数器、寄存器、内存分配等。</li><li><strong>堆栈</strong>：存储临时数据（函数参数、返回地址、局部变量）。</li><li><strong>堆</strong>：动态分配的内存，用于存储运行时需要的数据。</li><li><strong>数据段</strong>：全局变量和静态变量。</li></ul><p><strong>进程状态切换：</strong></p><ol><li><p><strong>新建（New）</strong>：进程正在被创建。</p><ul><li>当一个程序被启动时，操作系统会为其创建一个新进程。此时进程处于新建状态。</li></ul></li><li><p><strong>就绪（Ready）</strong>：进程已经创建完毕，等待被调度执行。</p><ul><li>进程创建完成后，进入就绪队列，等待调度器将其调度到 CPU 上执行。</li><li><strong>切换方式</strong>：从新建状态切换到就绪状态。</li></ul></li><li><p><strong>运行（Running）</strong>：进程正在执行。</p><ul><li>当调度器选择一个就绪状态的进程并将其分配给 CPU 时，该进程进入运行状态，开始执行。</li><li><strong>切换方式</strong>：<ul><li>从就绪状态切换到运行状态。</li><li>当等待的事件完成后，进程返回就绪状态，待调度器再次分配 CPU。</li></ul></li></ul></li><li><p><strong>等待（Waiting）</strong>：进程在等待某些事件（如I&#x2F;O操作）完成。</p><ul><li>如果进程在执行过程中需要等待某些事件（如 I&#x2F;O 操作、资源可用等），它会进入等待状态。</li><li><strong>切换方式</strong>：从运行状态切换到等待状态（当进程请求的 I&#x2F;O 操作开始执行时）。</li></ul></li><li><p><strong>终止（Terminated）</strong>：进程已经完成执行或被强制终止。</p><ul><li>当进程完成其全部工作或被强制终止时，进入终止状态，等待操作系统回收资源。</li><li><strong>切换方式</strong>：从运行状态切换到终止状态（当进程正常完成或遇到无法恢复的错误时）。</li></ul></li></ol><p><strong>示例流程:</strong></p><ol><li><strong>创建一个新进程</strong>：新进程从新建状态切换到就绪状态。</li><li><strong>调度器选择进程</strong>：调度器将一个就绪进程分配给 CPU，进程从就绪状态切换到运行状态。</li><li><strong>进程请求 I&#x2F;O 操作</strong>：进程在运行过程中请求 I&#x2F;O 操作，切换到等待状态。</li><li><strong>I&#x2F;O 操作完成</strong>：I&#x2F;O 操作完成，进程从等待状态返回就绪状态。</li><li><strong>进程重新获得 CPU</strong>：调度器再次选择该进程，进程切换到运行状态。</li><li><strong>进程完成执行</strong>：进程完成所有任务或被强制终止，进入终止状态。</li></ol><p>这种状态切换机制是多任务操作系统有效管理和调度进程的重要方式，确保系统资源的合理分配和使用。</p><img src="/img/OS/process_diagram.svg" alt="进程状态图" style="max-width: 100%; height: auto;" /><p>当一个程序被加载到内存并开始执行时，操作系统为其创建一个进程，并分配所需的系统资源。操作系统通过进程调度程序管理和调度进程的执行，确保每个进程可以合理地使用 CPU 时间和其他资源。</p><p>进程是多任务操作系统的基础，允许多个程序同时运行，提高系统的效率和资源利用率。</p><hr><p>PCB（<strong>Process Control Block</strong>）是操作系统中用于管理进程的一个数据结构。每个正在运行的进程都有一个对应的 PCB，用于存储进程的各种信息。<u>PCB是进程存在的唯一标志。</u>常见的 PCB 内容包括：</p><ol><li><strong>进程状态</strong>：记录进程当前的状态（如运行、就绪、阻塞等）。</li><li><strong>程序计数器</strong>：指向下一条将执行的指令地址。</li><li><strong>CPU寄存器</strong>：保存进程执行时的 CPU 寄存器内容，包括通用寄存器、程序计数器等。</li><li><strong>内存管理信息</strong>：如进程的内存分配、页表等。</li><li><strong>进程标识符</strong>：进程的唯一标识（PID）。</li><li><strong>调度信息</strong>：包括优先级、调度队列指针等。</li><li><strong>I&#x2F;O信息</strong>：包括进程使用的输入输出设备信息和相关状态。</li></ol><p>PCB 是操作系统调度和管理进程的重要工具，确保操作系统能够有效地保存和恢复进程的状态。</p><h4 id="2-3-1-线程的概念"><a href="#2-3-1-线程的概念" class="headerlink" title="2.3.1 线程的概念"></a>2.3.1 线程的概念</h4><p>线程(Thread) 是操作系统中的基本调度单位，是进程中的一个执行单元。一个进程可以包含多个线程，多个线程共享进程的资源（如内存空间、文件描述符等），但每个线程都有自己的程序计数器、寄存器和堆栈。线程被用来执行并发任务。</p><p><strong>线程的特点：</strong></p><ol><li><strong>轻量级</strong>：相比进程，线程的创建和销毁成本较低，切换速度较快。</li><li><strong>共享资源</strong>：同一进程内的多个线程共享进程的地址空间、全局变量等资源。</li><li><strong>独立执行</strong>：每个线程有自己的程序计数器、栈和局部变量，可以独立执行任务。</li><li><strong>并发执行</strong>：多个线程可以并发或并行地执行，适用于多核处理器和多任务环境。</li></ol><p><strong>线程与进程的区别：</strong></p><ul><li><strong>进程</strong>是资源分配的基本单位，每个进程都有独立的内存空间。</li><li><strong>线程</strong>是 CPU 调度的基本单位，同一进程内的多个线程共享内存资源，但有独立的执行路径。</li></ul><h4 id="2-3-2-操作系统中的多线程模型（Multithreading-Models）"><a href="#2-3-2-操作系统中的多线程模型（Multithreading-Models）" class="headerlink" title="2.3.2 操作系统中的多线程模型（Multithreading Models）"></a>2.3.2 操作系统中的多线程模型（Multithreading Models）</h4><p>操作系统中的多线程模型决定了用户线程与内核线程之间的映射关系。主要有以下几种模型：</p><p><strong>1. 一对一模型（One-to-One Model）</strong></p><ul><li>每个用户线程映射到一个内核线程。</li><li><strong>优点</strong>：可以充分利用多处理器的并行性，因为每个线程可以在不同的处理器上独立运行。</li><li><strong>缺点</strong>：每个线程需要一个内核线程，导致线程的创建和管理开销较大，可能影响性能。</li></ul><p><strong>2. 多对一模型（Many-to-One Model）</strong></p><ul><li>多个用户线程映射到一个内核线程。</li><li><strong>优点</strong>：线程的创建和管理开销较小，因为内核只需要管理一个内核线程。</li><li><strong>缺点</strong>：由于所有用户线程都在同一个内核线程上运行，无法利用多处理器的并行性。如果一个线程阻塞，整个进程都会被阻塞。</li></ul><p><strong>3. 多对多模型（Many-to-Many Model）</strong></p><ul><li>多个用户线程映射到多个内核线程。</li><li><strong>优点</strong>：结合了前两种模型的优点，既可以利用多处理器的并行性，又能控制线程的创建和管理开销。</li><li><strong>缺点</strong>：需要复杂的调度和管理机制来平衡用户线程与内核线程之间的映射关系。</li></ul><p><strong>4. 二级模型（Two-Level Model）</strong></p><ul><li>是多对多模型的变体，允许多个用户线程映射到同一个内核线程，也允许一个用户线程映射到多个内核线程。</li><li><strong>优点</strong>：允许更灵活的线程管理，结合了多对多模型和一对一模型的优点。</li><li><strong>缺点</strong>：需要更复杂的调度机制，增加了系统的实现复杂性。</li></ul><img src="/img/OS/threading_models.svg" alt="多线程模型" style="max-width: 100%; height: auto;" /><h3 id="2-4-进程控制"><a href="#2-4-进程控制" class="headerlink" title="2.4 进程控制"></a>2.4 进程控制</h3><p>进程控制是操作系统管理和调度进程的关键任务。它包括创建、调度、终止进程等操作，以确保系统中的进程能高效、按需执行。</p><p><strong>1. 进程的创建</strong></p><ul><li><strong>创建新进程</strong>：操作系统通过系统调用（如 <code>fork</code> 在 Unix 系统中）创建一个新进程。新进程通常是当前进程的副本，称为子进程。</li><li><strong>资源分配</strong>：当创建新进程时，操作系统为其分配必要的资源（如内存、文件句柄等），并初始化进程控制块（PCB）以存储进程信息。</li></ul><p><strong>2. 进程调度</strong></p><ul><li><strong>进程状态</strong>：进程在执行过程中会经历不同的状态（如就绪、运行、阻塞等）。操作系统调度器负责决定进程在何时进入哪种状态。</li><li><strong>调度算法</strong>：操作系统使用各种调度算法（如先来先服务 FCFS、时间片轮转 RR、最短作业优先 SJF 等）来决定哪个进程应该获得 CPU 时间。</li><li><strong>多任务处理</strong>：操作系统允许多个进程并发运行，通过上下文切换在多个进程间分配 CPU 时间。</li></ul><p><strong>3. 进程同步与通信</strong></p><ul><li><strong>进程同步</strong>：在并发执行的多个进程间，操作系统提供同步机制（如信号量、互斥锁、条件变量等）以确保共享资源的正确使用，避免数据竞争和死锁。</li><li><strong>进程通信</strong>：进程之间可以通过多种方式进行通信，如管道、消息队列、共享内存等。操作系统提供通信机制以允许进程间交换数据。</li></ul><p><strong>4. 进程终止</strong></p><ul><li><strong>进程终止</strong>：进程执行完毕或由于错误发生时，会通过系统调用（如 <code>exit</code>）终止。操作系统会回收进程所占用的资源，关闭文件、释放内存等。</li><li><strong>父子进程的终止</strong>：当子进程终止时，操作系统会向父进程发送信号（如 Unix 系统中的 <code>SIGCHLD</code>），父进程可选择等待子进程的终止并回收子进程资源。</li></ul><p><strong>5. 进程控制块（PCB）</strong></p><ul><li><strong>PCB（Process Control Block）</strong>：每个进程在操作系统中都有一个对应的 PCB，用于存储进程的状态、程序计数器、CPU 寄存器、内存信息等。</li><li><strong>进程调度</strong>：PCB 是进程调度和管理的核心数据结构，操作系统通过它来实现上下文切换和进程状态的转换。</li></ul><p>进程控制是操作系统的重要功能，涉及进程的创建、调度、同步、通信以及终止等方面。通过有效的进程控制，操作系统能够确保多任务环境下的进程按预期运行，资源得到合理分配。</p><h3 id="2-5-进程间调度"><a href="#2-5-进程间调度" class="headerlink" title="2.5 进程间调度"></a>2.5 进程间调度</h3><p>操作系统中的进程调度是管理CPU资源分配的一项重要功能。它决定了哪些进程何时运行，以及如何在多个进程间切换，以实现系统资源的高效利用和响应。</p><p><strong>常见的调度算法主要有：</strong></p><p><strong>1. 先到先服务（First-Come First-Served, FCFS）</strong></p><ul><li>简单且直观，进程按照到达顺序执行。</li><li><strong>优点</strong>：实现简单。</li><li><strong>缺点</strong>：容易导致长进程阻塞短进程（队头阻塞），可能增加平均等待时间。</li></ul><p><strong>2. 短作业优先（Shortest-Job-First, SJF）</strong></p><ul><li>优先执行预计运行时间最短的进程。</li><li><strong>优点</strong>：减少平均等待时间。</li><li><strong>缺点</strong>：需要准确预测进程运行时间，长作业可能会长期得不到调度（饥饿现象）。</li></ul><p><strong>3. 优先级调度算法（Priority Scheduling）</strong></p><ul><li>根据进程的优先级调度，优先级高的进程先执行。</li><li><strong>优点</strong>：灵活性高，可以根据需求调整优先级。</li><li><strong>缺点</strong>：低优先级进程可能会长期得不到调度（饥饿现象）。</li></ul><p><strong>4. 轮转调度（Round-Robin，RR）算法</strong></p><ul><li>每个进程分配一个固定的时间片，时间片到后切换到下一个进程。</li><li><strong>优点</strong>：公平，适用于时间共享系统。</li><li><strong>缺点</strong>：时间片过大或过小会影响系统性能。</li></ul><p><strong>5. 多级反馈队列调度算法（Multilevel Feedback Queue）</strong></p><ul><li>结合多个优先级队列和时间片调度。</li><li>进程根据其行为动态调整优先级和队列位置。</li><li><strong>优点</strong>：灵活性高，能够较好地平衡响应时间和系统吞吐量。</li></ul><p>通过这些调度算法，操作系统能够高效管理和分配CPU资源，保证系统的稳定性和用户体验。下面分别分析上述调度算法.</p><hr><h4 id="2-5-1-先到先服务（First-Come-First-Served-FCFS）"><a href="#2-5-1-先到先服务（First-Come-First-Served-FCFS）" class="headerlink" title="2.5.1 先到先服务（First-Come First-Served, FCFS）"></a>2.5.1 先到先服务（First-Come First-Served, FCFS）</h4><p><strong>先到先服务（First-Come, First-Served，FCFS）</strong> 是一种简单的进程调度算法，它的工作原理是：当进程到达系统时，它们被放入就绪队列。调度器选择队列中的第一个进程进行执行，直到该进程完成或发生阻塞事件，然后调度器选择下一个进程。</p><ul><li>优点：<ul><li>公平性（Fairness）：FCFS算法对所有进程都是公平的，因为它按照进程到达的顺序进行调度。</li><li>简单性（Simplicity）：FCFS算法非常简单和易于实现。</li></ul></li><li>缺点：<ul><li>无法充分利用CPU（Poor CPU Utilization）：如果当前正在运行的进程需要大量的I&#x2F;O操作，那么CPU可能会在等待I&#x2F;O操作完成时处于空闲状态。</li><li>平均等待时间可能较长（Long Average Waiting Time）：在FCFS算法中，短的进程可能会被长的进程阻塞，这种现象被称为“饥饿”（Starvation）或“拖尾效应”（Convoy Effect）。</li><li>无法支持优先级（Lack of Priority Support）：FCFS算法不支持优先级，因此无法保证重要的进程能够优先执行。</li></ul></li></ul><p>总的来说，虽然FCFS算法简单且公平，但由于其无法有效地利用CPU和支持优先级，所以在需要高效率或优先级调度的系统中，通常不会使用FCFS算法。</p><img src="/img/OS/fcfs.svg" alt="先到先服务调度算法" style="max-width: 100%; height: auto;" /><hr><p>在操作系统中，<strong>饥饿（Starvation）</strong> 是指某些进程长时间得不到所需资源，从而无法执行的情况。这通常发生在资源分配机制不公平或不完善的情况下。饥饿现象主要出现在以下几种情况下：</p><ul><li>优先级调度：在优先级调度算法中，如果某些低优先级的进程始终被高优先级进程抢占，低优先级进程可能会一直得不到执行机会，从而陷入饥饿状态。</li><li>资源竞争：当多个进程竞争有限的资源时，某些进程可能持续无法获得资源，导致无法继续执行。</li><li>长作业排队：在先到先服务（FCFS）或短作业优先（SJF）等调度算法中，长时间运行的进程可能会因其他短作业的持续到达而长期得不到调度。</li></ul><p>解决饥饿问题的一种常见方法是<strong>老化机制（Aging）</strong>，即逐渐提高长期未被调度进程的优先级，使其最终能够获得资源并执行。</p><hr><h4 id="2-5-2-短作业优先（Shortest-Job-First-SJF）"><a href="#2-5-2-短作业优先（Shortest-Job-First-SJF）" class="headerlink" title="2.5.2 短作业优先（Shortest-Job-First, SJF）"></a>2.5.2 短作业优先（Shortest-Job-First, SJF）</h4><p>在这种算法中，调度器选择就绪队列中预计运行时间最短的进程进行执行。预计运行时间可以是进程的CPU突发时间（CPU burst time）或者是进程的剩余执行时间。（这里就要看是非抢占式的还是抢占式的了，可以直观理解）</p><p>短作业优先调度算法的主要优点是它最小化了平均等待时间。因为短的进程总是优先于长的进程，所以它们的等待时间会更短，从而使得平均等待时间最小。</p><p>然而，这种算法也有一些缺点。首先，它需要知道进程的预计运行时间，但在实际的系统中，这通常是无法预知的。其次，这种算法可能会导致 <strong>“饥饿”（Starvation）</strong> 现象，即长的进程可能会被无限期地推迟，因为总是有短的进程到来。<br>总的来说，短作业优先调度算法在理论上是非常有效的，但在实际的系统中，由于需要预知进程的运行时间以及可能导致的饥饿问题，它的应用受到了一些限制。</p><img src="/img/OS/sjf.svg" alt="短作业优先调度算法" style="max-width: 100%; height: auto;" /><hr><h4 id="2-5-3-优先级调度算法（Priority-Scheduling）"><a href="#2-5-3-优先级调度算法（Priority-Scheduling）" class="headerlink" title="2.5.3 优先级调度算法（Priority-Scheduling）"></a>2.5.3 优先级调度算法（Priority-Scheduling）</h4><p>优先级调度算法是一种操作系统中的进程调度算法。在这种算法中，每个进程都有一个优先级，操作系统总是选择优先级最高的进程来运行。这种算法的主要特点如下：</p><ul><li>优先级：每个进程都有一个优先级，优先级高的进程优先执行。（抢占式，preemptive）</li><li>动态调整：系统可以根据需要动态调整进程的优先级。例如，为了防止低优先级的进程永远得不到执行，系统可能会随着时间的推移提高等待进程的优先级。</li><li>饿死问题：如果总是有新的高优先级进程出现，那么低优先级的进程可能永远得不到执行，这就是所谓的饿死问题。为了解决这个问题，系统可能会采取一些策略，比如老化（随着时间的推移提高等待进程的优先级）。</li></ul><p>这种算法在实时系统中特别有用，因为在这些系统中，有些任务（比如控制飞机的自动驾驶仪）比其他任务更重要，因此需要优先执行。但是，这种算法也有一些缺点，比如可能会导致低优先级的进程饿死。因此，设计一个好的优先级调度算法需要权衡各种因素。</p><img src="/img/OS/priority.svg" alt="优先级调度算法" style="max-width: 100%; height: auto;" /><hr><h4 id="2-5-4-轮转调度（Round-Robin，RR）算法"><a href="#2-5-4-轮转调度（Round-Robin，RR）算法" class="headerlink" title="2.5.4 轮转调度（Round-Robin，RR）算法"></a>2.5.4 轮转调度（Round-Robin，RR）算法</h4><p>轮转调度（Round-Robin，RR）算法是一种非常常见的操作系统进程调度算法。以下是对其的简要解释：</p><ul><li>时间片（Time Quantum）：在轮转调度算法中，每个进程被分配一个固定长度的时间片来执行。当一个进程的时间片用完时，它将被移出CPU，下一个进程将开始执行。</li><li>公平性（Fairness）：由于每个进程都有相同长度的时间片来执行，因此这种算法被认为是公平的。没有进程会因为优先级低而被饿死。<br>上下文切换（Context Switch）：当一个进程的时间片用完，操作系统需要进行上下文切换，将CPU从当前进程切换到下一个进程。这会产生一定的开销。</li><li>响应时间（Response Time）：轮转调度算法通常能提供良好的响应时间，因为每个进程都会定期得到CPU时间。</li></ul><p>这种算法适用于时间共享系统，但如果时间片设置得不合适，可能会导致过多的上下文切换，从而降低系统性能。因此，选择合适的时间片长度是实现轮转调度算法的关键。如果时间片过长，那么系统的响应时间可能会变差；如果时间片过短，那么上下文切换的开销可能会变大。</p><p>同一时刻两个进程 A 和 B, A 刚下处理机, B 刚进入队列, 默认 B 先轮转时间片。</p><ul><li>如果时间片太大, 退化为FCFS, 会增大进程响应时间</li><li>如果时间片太小, 进程切换频繁, 切换进程会花费大量时间</li></ul><p>一般来说, 设计时间片要让切换进程的开销占比不超过 1%</p><img src="/img/OS/rr.svg" alt="轮转调度算法" style="max-width: 100%; height: auto;" /><hr><h4 id="2-5-5-多级反馈队列调度算法（Multilevel-Feedback-Queue）"><a href="#2-5-5-多级反馈队列调度算法（Multilevel-Feedback-Queue）" class="headerlink" title="2.5.5 多级反馈队列调度算法（Multilevel Feedback Queue）"></a>2.5.5 多级反馈队列调度算法（Multilevel Feedback Queue）</h4><p>多级反馈队列调度算法（Multilevel Feedback Queue Scheduling）是一种操作系统中的进程调度算法。以下是对其的简要解释：</p><ul><li>多级队列（Multilevel Queues）：在这种算法中，存在多个队列，每个队列都有自己的优先级。优先级最高的队列中的进程首先得到执行。（也就是前一队列为空的时候，才能执行当前队列！！）</li><li>反馈（Feedback）：如果一个进程在其分配的时间片内没有完成，那么它将被移动到优先级较低的队列。这就是所谓的“反馈”机制。</li><li>公平性和灵活性（Fairness and Flexibility）：这种算法旨在结合优先级调度和轮转调度的优点，以实现公平性和灵活性。它可以确保高优先级的进程快速执行，同时也不会饿死低优先级的进程。</li><li>动态优先级（Dynamic Priorities）：进程的优先级不是固定的，而是可以根据其行为动态改变。例如，如果一个进程经常阻塞等待I&#x2F;O操作，那么它的优先级可能会提高，以便在I&#x2F;O操作完成后能够快速得到执行。</li></ul><p>这种算法在许多操作系统中都得到了应用，因为它既可以处理交互式进程（这些进程需要快速响应），也可以处理批处理进程（这些进程需要长时间运行）。然而，它的实现相对复杂，需要维护多个队列，并动态调整进程的优先级。此外，选择合适的队列数量和时间片长度也是一个挑战。如果设置不当，可能会导致某些进程得不到公平的CPU时间，或者系统的上下文切换开销过大。因此，实现这种算法需要权衡各种因素。</p><p>这个算法无明显缺点，但是会导致饥饿！考虑一种情况：长时间运行的进程一直被降级到低优先级队列，而新到达的高优先级进程源源不断地占用CPU资源，那么低优先级的进程可能会长期得不到调度，导致饥饿。</p><img src="/img/OS/multive_queue.svg" alt="多级反馈队列调度算法" style="max-width: 100%; height: auto;" /><h3 id="2-6-进程间通信"><a href="#2-6-进程间通信" class="headerlink" title="2.6 进程间通信"></a>2.6 进程间通信</h3><p>进程间通信（IPC，Inter-Process Communication）是操作系统中的一项重要机制，用于让不同进程之间交换数据或同步操作。操作系统提供了多种进程间通信方式，每种方式有其特点和适用场景。以下是几种常见的进程间通信方式的详细讲解：</p><h4 id="2-6-1-管道（Pipe）"><a href="#2-6-1-管道（Pipe）" class="headerlink" title="2.6.1 管道（Pipe）"></a>2.6.1 管道（Pipe）</h4><p>管道是一种最基本的进程间通信方式，允许数据在一个进程与另一个进程之间单向流动。它适用于父子进程之间的通信。</p><ul><li><strong>匿名管道（Anonymous Pipe）</strong>：不具备名字，一般用于有亲缘关系的进程（如父子进程）。匿名管道是半双工的，即数据只能单向流动。</li><li><strong>命名管道（Named Pipe）</strong>：有名字，可以在无亲缘关系的进程间使用，因此适用于不同进程间的通信。命名管道是全双工的，即可以双向传输数据。</li></ul><img src="/img/OS/pipe.svg" alt="管道通信" style="max-width: 100%; height: auto;" /><p>匿名管道通常用于父子进程之间的通信。它是半双工的，只能进行单向数据流动。在下面这个示例中，父进程通过匿名管道发送数据给子进程，子进程接收并打印出来。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token comment"># 创建一个匿名管道</span>pipe_read<span class="token punctuation">,</span> pipe_write <span class="token operator">=</span> os<span class="token punctuation">.</span>pipe<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 创建子进程</span>pid <span class="token operator">=</span> os<span class="token punctuation">.</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 父进程</span>    <span class="token comment"># 关闭读端，只写</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_read<span class="token punctuation">)</span>    <span class="token comment"># 向管道中写入数据</span>    os<span class="token punctuation">.</span>write<span class="token punctuation">(</span>pipe_write<span class="token punctuation">,</span> <span class="token string">b"Hello from parent process!"</span><span class="token punctuation">)</span>    <span class="token comment"># 关闭写端</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_write<span class="token punctuation">)</span>    <span class="token keyword">elif</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 子进程</span>    <span class="token comment"># 关闭写端，只读</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_write<span class="token punctuation">)</span>    <span class="token comment"># 从管道中读取数据</span>    message <span class="token operator">=</span> os<span class="token punctuation">.</span>read<span class="token punctuation">(</span>pipe_read<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Child process received message: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>message<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>    <span class="token comment"># 关闭读端</span>    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>pipe_read<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>命名管道可以用于不同进程之间的通信。命名管道通过文件系统提供了一个可以由多个进程访问的接口。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token comment"># *****父进程写数据******* #</span><span class="token comment"># 创建命名管道（FIFO）</span>fifo_path <span class="token operator">=</span> <span class="token string">"/tmp/my_named_pipe"</span><span class="token keyword">try</span><span class="token punctuation">:</span>    os<span class="token punctuation">.</span>mkfifo<span class="token punctuation">(</span>fifo_path<span class="token punctuation">)</span><span class="token keyword">except</span> FileExistsError<span class="token punctuation">:</span>    <span class="token keyword">pass</span>  <span class="token comment"># 如果管道已经存在，跳过创建</span><span class="token comment"># 向命名管道写数据</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>fifo_path<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fifo<span class="token punctuation">:</span>    fifo<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"Hello from parent process!"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Parent process has written the message."</span><span class="token punctuation">)</span><span class="token comment"># 父进程使用 mkfifo() 创建一个命名管道 /tmp/my_named_pipe。然后，父进程通过写操作将消息写入管道。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token comment"># ****子进程读数据**** #</span>fifo_path <span class="token operator">=</span> <span class="token string">"/tmp/my_named_pipe"</span><span class="token comment"># 从命名管道读取数据</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>fifo_path<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fifo<span class="token punctuation">:</span>    message <span class="token operator">=</span> fifo<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Child process received message: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>message<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token comment"># 子进程打开相同的管道文件并从中读取消息。这说明命名管道是全双工的，可以在不同的进程间进行通信。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="2-6-2-消息队列（Message-Queue）"><a href="#2-6-2-消息队列（Message-Queue）" class="headerlink" title="2.6.2 消息队列（Message Queue）"></a>2.6.2 消息队列（Message Queue）</h4><p>消息队列是由内核维护的一种数据结构，用于在进程间传递消息。消息队列中的消息按照优先级或发送顺序排队，可以支持多个进程进行通信。</p><ul><li>消息队列是一种基于消息的通信机制，可以支持多对多的通信模式。</li><li>通过消息队列，进程可以通过发送消息和接收消息来进行数据交换。</li><li>它的优势是，进程间通信不需要共享内存，但也会有一定的性能开销。</li></ul><img src="/img/OS/message.svg" alt="消息队列" style="max-width: 100%; height: auto;" /><h4 id="2-6-3-共享内存（Shared-Memory）"><a href="#2-6-3-共享内存（Shared-Memory）" class="headerlink" title="2.6.3 共享内存（Shared Memory）"></a>2.6.3 共享内存（Shared Memory）</h4><p>共享内存是一种效率较高的进程间通信方式，多个进程可以直接访问同一块内存区域。一个进程创建并映射这块共享内存，其他进程可以直接访问该内存区域。</p><ul><li>共享内存允许多个进程共享数据，因此可以显著提高进程间的数据交换效率。</li><li>但由于多个进程可能同时读写共享内存，必须通过信号量等同步机制来保证数据一致性，避免竞争条件和冲突。</li></ul><img src="/img/OS/shared_memory.svg" alt="共享内存" style="max-width: 100%; height: auto;" /><h4 id="2-6-4-信号量（Semaphore）"><a href="#2-6-4-信号量（Semaphore）" class="headerlink" title="2.6.4 信号量（Semaphore）"></a>2.6.4 信号量（Semaphore）</h4><p>信号量是一种同步工具，通常用于控制多个进程对共享资源的访问。信号量内部包含一个计数器，该计数器控制访问共享资源的进程数目。</p><ul><li>信号量常用于控制对共享内存、文件等资源的访问，它可以防止资源竞争。</li><li>信号量有两种类型：<strong>计数信号量</strong>（控制资源的数量）和<strong>二值信号量</strong>（类似于锁，只允许一个进程访问资源）。</li><li>信号量通常与共享内存结合使用，用于保证对临界区的同步和互斥。</li></ul><p>信号量机制非常重要，随后仔细讲解这个内容。</p><img src="/img/OS/semaphore.svg" alt="信号量机制" style="max-width: 100%; height: auto;" /><h4 id="2-6-5-信号（Signal）"><a href="#2-6-5-信号（Signal）" class="headerlink" title="2.6.5 信号（Signal）"></a>2.6.5 信号（Signal）</h4><p>信号是一种异步通知机制，用于向进程发送通知，告知其某个事件已经发生。例如，操作系统可以向进程发送 <code>SIGINT</code> 信号来中断它，或者使用 <code>kill</code> 命令向一个进程发送信号。</p><ul><li>信号是一种非常轻量级的进程间通信方式，适用于通知进程发生了某种事件或请求处理。</li><li>信号通常不会携带大量数据，主要用于进程间的控制和通知。</li></ul><img src="/img/OS/signal.svg" alt="信号通信" style="max-width: 100%; height: auto;" /><h4 id="2-6-6-套接字（Socket）"><a href="#2-6-6-套接字（Socket）" class="headerlink" title="2.6.6 套接字（Socket）"></a>2.6.6 套接字（Socket）</h4><p>套接字是一种广泛用于进程间通信的机制，尤其适用于不同主机之间的通信。通过网络协议，套接字允许不同机器上的进程进行通信。</p><ul><li>套接字不仅可以用于不同主机间的进程间通信，也可以用于本地主机上的进程间通信。</li><li>套接字可以是<strong>面向连接的</strong>（如 TCP 套接字）或<strong>无连接的</strong>（如 UDP 套接字），适用于不同的应用场景。</li><li>它是进程间通信中最为通用和灵活的一种方式，尤其在分布式系统中具有重要作用。</li></ul><img src="/img/OS/socket.svg" alt="套接字" style="max-width: 100%; height: auto;" /><hr><p>总的来说，这些通信方式有下面的应用场景。</p><ul><li><strong>管道</strong>适用于父子进程的单向通信。</li><li><strong>消息队列</strong>适合需要按消息传递数据的多进程场景。</li><li><strong>共享内存</strong>提供高效的跨进程数据共享，但需要同步机制来保证数据一致性。</li><li><strong>信号量</strong>用于控制对共享资源的访问，并且用于进程间的同步与互斥。</li><li><strong>信号</strong>是一种简单的异步通信机制，用于进程间的通知。</li><li><strong>套接字</strong>是最通用的进程间通信机制，尤其在网络编程中得到广泛应用。</li></ul><h3 id="2-7-进程间的并发和同步"><a href="#2-7-进程间的并发和同步" class="headerlink" title="2.7 进程间的并发和同步"></a>2.7 进程间的并发和同步</h3><p>操作系统中的并发控制主要涉及多个进程或线程在共享资源时如何协调与管理，以避免冲突和问题。首先需要熟悉下面的几个概念：</p><h4 id="2-7-1-临界区（Critical-Section）"><a href="#2-7-1-临界区（Critical-Section）" class="headerlink" title="2.7.1. 临界区（Critical Section）"></a>2.7.1. 临界区（Critical Section）</h4><ul><li><strong>背景</strong>：  多个进程或线程需要访问共享资源（如内存、文件、设备等）时，为了防止并发访问导致数据错误，需要对访问过程进行限制。临界区是程序中可能发生资源竞争的部分，需要特殊保护。</li></ul><img src="/img/OS/critical_section.svg" alt="临界区" style="max-width: 100%; height: auto;" /><h4 id="2-7-2-互斥（Mutual-Exclusion）"><a href="#2-7-2-互斥（Mutual-Exclusion）" class="headerlink" title="2.7.2 互斥（Mutual Exclusion）"></a>2.7.2 互斥（Mutual Exclusion）</h4><ul><li><strong>背景</strong>：  为了解决共享资源访问冲突的问题，互斥保证任何时刻只有一个进程或线程可以进入临界区。  </li><li><strong>常见的实现方式</strong>：  <ul><li><strong>锁（Locks）</strong>  </li><li><strong>信号量（Semaphores）</strong>  </li><li><strong>监视器（Monitors）</strong></li></ul></li></ul><h4 id="2-7-3-死锁（Deadlock）"><a href="#2-7-3-死锁（Deadlock）" class="headerlink" title="2.7.3 死锁（Deadlock）"></a>2.7.3 死锁（Deadlock）</h4><ul><li><strong>背景</strong>：  死锁问题发生在资源分配和进程调度的场景中。当多个进程在相互等待对方释放资源时，系统进入无法继续运行的状态。  </li><li><strong>避免死锁需要使用特定的资源分配算法和机制</strong>：  <ul><li><strong>银行家算法（Banker’s Algorithm）</strong></li></ul></li></ul><h4 id="2-7-4-饥饿（Starvation）"><a href="#2-7-4-饥饿（Starvation）" class="headerlink" title="2.7.4 饥饿（Starvation）"></a>2.7.4 饥饿（Starvation）</h4><ul><li><strong>背景</strong>：  在资源分配和调度策略不公平的情况下，有些进程可能长时间得不到资源，无法执行。这种问题称为饥饿。  </li><li><strong>为了避免饥饿，需要使用公平的调度算法，确保每个进程都有机会进入临界区</strong>：  <ul><li><strong>先到先服务（FCFS）调度</strong>  </li><li><strong>动态优先级调整</strong></li></ul></li></ul><h4 id="2-7-5-信号（Signals）"><a href="#2-7-5-信号（Signals）" class="headerlink" title="2.7.5 信号（Signals）"></a>2.7.5 信号（Signals）</h4><ul><li><strong>背景</strong>：  信号是一种异步通信机制，用于通知进程某个事件的发生。例如，使用<code>kill</code>命令发送信号。</li><li><strong>应用</strong>： 常用于进程终止、定时器中断、资源耗尽等场景。</li></ul><h4 id="2-7-6-线程同步（Thread-Synchronization）"><a href="#2-7-6-线程同步（Thread-Synchronization）" class="headerlink" title="2.7.6 线程同步（Thread Synchronization）"></a>2.7.6 线程同步（Thread Synchronization）</h4><ul><li><strong>背景</strong>：  在多线程环境中，线程之间的同步与进程同步类似，但由于线程共享相同的内存地址空间，面临的问题和解决方案略有不同。</li><li><strong>实现方式</strong>：<ul><li><strong>互斥锁（Mutexes）</strong></li><li><strong>条件变量（Condition Variables）</strong></li><li><strong>读写锁（Read-Write Locks）</strong></li></ul></li></ul><h4 id="2-7-7-条件变量（Condition-Variables）"><a href="#2-7-7-条件变量（Condition-Variables）" class="headerlink" title="2.7.7 条件变量（Condition Variables）"></a>2.7.7 条件变量（Condition Variables）</h4><ul><li><strong>背景</strong>：  条件变量用于在线程之间实现复杂的同步机制，通过等待某一条件为真后再继续执行。</li><li><strong>应用</strong>： 常与互斥锁配合使用，解决生产者-消费者问题等。</li></ul><h4 id="2-7-8-自旋锁（Spin-Locks）"><a href="#2-7-8-自旋锁（Spin-Locks）" class="headerlink" title="2.7.8 自旋锁（Spin Locks）"></a>2.7.8 自旋锁（Spin Locks）</h4><ul><li><strong>背景</strong>：  自旋锁是一种忙等待的锁机制，用于保护短时间临界区。</li><li><strong>应用</strong>： 适用于临界区非常短且线程切换开销较大的情况。</li></ul><h4 id="2-7-9-信号量（Semaphores）"><a href="#2-7-9-信号量（Semaphores）" class="headerlink" title="2.7.9 信号量（Semaphores）"></a>2.7.9 信号量（Semaphores）</h4><ul><li><strong>背景</strong>：  信号量用于控制对资源的访问，支持同步和互斥机制。</li><li><strong>类型</strong>：<ul><li><strong>二进制信号量（Binary Semaphores）</strong>： 类似于互斥锁。</li><li><strong>计数信号量（Counting Semaphores）</strong>： 允许多个线程访问一定数量的资源。</li></ul></li></ul><p>以上概念是操作系统中<strong>并发程序设计和同步机制</strong>的核心问题，旨在协调多进程或线程的资源访问，确保系统的正确性和高效性。有了以上的背景，我们再来解决操作系统中进程同步互斥的经典问题如：</p><ul><li>生产者-消费者问题（Producer-Consumer Problem）</li><li>读者-写者问题（Readers-Writers Problem）</li><li>哲学家进餐问题（Dining Philosophers Problem）</li></ul><hr><h3 id="2-7-进程互斥"><a href="#2-7-进程互斥" class="headerlink" title="2.7 进程互斥"></a>2.7 进程互斥</h3><p>在操作系统中，<strong>进程互斥（Mutual Exclusion）</strong> 是确保多个进程在访问共享资源时不发生冲突的关键概念。互斥的目的是防止并发进程同时进入临界区（Critical Section），以避免数据不一致和其他错误。</p><h4 id="2-7-1-进程互斥的软件实现方法"><a href="#2-7-1-进程互斥的软件实现方法" class="headerlink" title="2.7.1 进程互斥的软件实现方法"></a>2.7.1 进程互斥的软件实现方法</h4><p>在操作系统中，为了解决多个进程共享资源时的互斥问题，可以通过<strong>标志检查算法</strong>实现互斥控制。以下是几种经典的软件实现方法：</p><hr><p><strong>1️⃣ 单标志法（Single Flag Method）</strong></p><ul><li>使用一个共享的布尔标志表示是否有进程正在执行临界区。  </li><li>如果标志为真，则其他进程必须等待，直到标志变为假。</li></ul><p><strong>代码示例：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 等待临界区空闲</span>    critical section<span class="token punctuation">;</span>    <span class="token comment">// 进入临界区</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 交出控制权</span>    remainder section<span class="token punctuation">;</span>   <span class="token comment">// 进入剩余区</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>turn <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>单标志法</strong>存在的问题是：</p><ul><li>访问顺序固定为 0 → 1 → 0 → 1…，不满足空闲让进原则。</li><li>当临界区空闲且 P0 未进入时，P1 仍无法进入，导致资源浪费。</li></ul><hr><p><strong>2️⃣ 双标志先检查法（Two Flags, Check First Method）</strong></p><ul><li>每个进程都有一个标志，表示它是否希望进入临界区。</li><li>进程在进入临界区前检查对方的标志，确保对方不需要进入临界区时才进入。</li></ul><p><strong>代码示例：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// flag[i] = true 表示进程 i 想进入临界区</span><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 检查对方标志</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment">// 设置自己的标志</span>    critical section<span class="token punctuation">;</span>  <span class="token comment">// 进入临界区</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>   <span class="token comment">// 离开时清除标志</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>双标志先检查法</strong>存在的问题是：</p><ul><li>如果 P0 在退出 while 循环后，标志尚未设置为 true 时被切换，P1 也可能进入临界区，导致不满足忙则等待原则。</li></ul><hr><p><strong>3️⃣ 双标志后检查法（Two Flags, Check Afterwards Method）</strong></p><ul><li>在设置自己的标志后，再检查对方的标志。</li><li>如果对方不需要进入临界区，当前进程即可进入。</li></ul><p><strong>示例代码：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>     <span class="token comment">// 先设置自己的标志</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 后检查对方标志</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>双标志后检查法</strong>存在的问题是：</p><ul><li>可能导致饥饿问题：如果两个进程交替设置标志，低优先级进程可能一直无法进入临界区。</li></ul><hr><p><strong>4️⃣ Peterson 算法（Peterson’s Algorithm）</strong></p><ul><li>通过两个共享变量实现互斥：<ul><li>flag[2] 表示每个进程是否希望进入临界区。</li><li>turn 表示轮到哪个进程进入临界区。</li></ul></li><li>设置自己的标志后，将进入权交给对方，主动等待对方进入临界区。</li></ul><p><strong>代码示例：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool flag<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>false<span class="token punctuation">,</span> false<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// P0:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token comment">// 设置自己的标志</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">// 让出优先权</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待对方离开或轮到自己</span>    critical section<span class="token punctuation">;</span>      <span class="token comment">// 进入临界区</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>       <span class="token comment">// 离开时清除标志</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// P1:</span><span class="token punctuation">&#123;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> turn <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    critical section<span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>    remainder section<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>Peterson 算法</strong>的优缺点有：</p><ul><li>优点<ul><li>满足互斥性：任意时刻只有一个进程能进入临界区。</li><li>避免死锁：两个进程不会无限等待。</li><li>满足空闲让进原则：当临界区空闲时，进程可立即进入。</li></ul></li><li>缺点<ul><li>仅适用于两个进程的场景。</li><li>扩展到多进程环境时，算法会变得复杂。</li></ul></li></ul><hr><p>简单总结一下以上进程互斥的软件实现方法</p><table><thead><tr><th>方法</th><th>优点</th><th>问题或缺点</th></tr></thead><tbody><tr><td>单标志法</td><td>简单易实现</td><td>可能导致竞态条件，不满足空闲让进原则</td></tr><tr><td>双标志先检查法</td><td>避免竞态条件</td><td>不满足忙则等待原则，可能导致数据竞争</td></tr><tr><td>双标志后检查法</td><td>避免死锁</td><td>可能导致饥饿问题</td></tr><tr><td>Peterson 算法</td><td>满足互斥性、避免死锁和饥饿，符合互斥原则</td><td>仅适用于两个进程的互斥场景</td></tr></tbody></table><h4 id="2-7-2-进程互斥的硬件实现方法"><a href="#2-7-2-进程互斥的硬件实现方法" class="headerlink" title="2.7.2 进程互斥的硬件实现方法"></a>2.7.2 进程互斥的硬件实现方法</h4><p><strong>1.禁止中断（Disable Interrupts）</strong></p><ul><li>机制：<br>在单处理器系统中，进程在进入临界区之前，通过禁用中断来保证它不被打断。这意味着在执行关键代码时，不会发生上下文切换，也就避免了其他进程同时访问共享资源的可能性。</li><li>优点：<ul><li>简单且易于实现。</li><li>在单处理器环境下，可以有效地防止竞态条件（Race Condition）。</li></ul></li><li>缺点：<ul><li>仅适用于单处理器系统：在多处理器系统中，禁止一个处理器的中断并不能阻止其他处理器访问共享资源。</li><li>影响系统响应性：如果进程在临界区花费较长时间，系统将无法及时响应硬件中断（如 I&#x2F;O 事件），可能导致性能问题。</li><li>不适合用户程序：只有操作系统（内核）才能控制中断，普通用户进程无法使用这一方法。</li></ul></li><li>适用场景：小型、实时性要求不高的单处理器系统。</li></ul><p>禁止中断通常由操作系统的内核代码实现。以下是一个伪代码示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 单处理器系统伪代码</span><span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">disable_interrupts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 禁止中断</span>        <span class="token comment">// 临界区代码</span>    shared_resource<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">enable_interrupts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 恢复中断</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>注意：</p><ul><li><code>disable_interrupts() </code>和 <code>enable_interrupts() </code>是硬件相关的低级操作，不适用于用户态程序。</li><li>这种方法仅用于单处理器环境。</li></ul><hr><p><strong>2.特殊机器指令（Special Machine Instructions）</strong></p><p>机制：</p><ul><li>现代硬件通常提供特殊指令来帮助实现进程互斥。这些指令能够在单个不可中断的原子操作中完成对共享内存位置的读取和修改。</li><li>常见的指令包括：<ul><li>测试并设置（Test and Set）：<ul><li>功能：检查一个变量的值是否为 0（或特定值），如果是则设置为 1，并返回原来的值。</li><li>应用：可以用它来实现一个简单的锁。</li></ul></li><li>交换（Swap）：<ul><li>功能：交换两个内存单元的值，保证操作是原子的。</li><li>应用：常用于实现信号量或互斥锁。</li></ul></li></ul></li></ul><p>优点：</p><ul><li>高效：不需要禁用中断，能在多处理器系统中使用。</li><li>硬件支持：这些指令的设计初衷就是为了解决同步问题。</li></ul><p>缺点：</p><ul><li>忙等待（Busy Waiting）：使用这些指令实现的锁通常基于自旋锁（Spinlock），可能导致等待进程一直占用 CPU（忙等），浪费计算资源。</li><li>增加硬件复杂性：硬件必须支持这些指令。</li><li>适用场景：<ul><li>多处理器系统。</li><li>临界区很短、避免禁用中断的情况下。</li></ul></li></ul><p>以下是使用 Test and Set 指令实现锁的示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 使用 Test and Set 指令实现的锁</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">lock_t</span><span class="token punctuation">;</span><span class="token class-name">lock_t</span> lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 0 表示未加锁，1 表示已加锁</span><span class="token keyword">int</span> <span class="token function">test_and_set</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token operator">*</span>lock<span class="token punctuation">;</span>    <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 将锁设置为 1</span>    <span class="token keyword">return</span> old<span class="token punctuation">;</span> <span class="token comment">// 返回原来的值</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">test_and_set</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 自旋等待</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加锁</span>        <span class="token comment">// 临界区代码</span>    shared_resource<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>说明：</p><ul><li><code>test_and_set() </code>是一个不可中断的原子操作，硬件确保其操作的原子性。</li><li>如果锁已被占用，进程会在循环中等待（自旋锁）。</li></ul><hr><p><strong>3.原子操作（Atomic Operations）</strong></p><p>机制：</p><ul><li>原子操作指的是在执行时不会被中断的一系列操作。这些操作通常是通过硬件或特殊指令实现的，确保即使多个进程或线程同时访问共享变量，操作的结果仍然是可预测的。</li><li>应用中最常见的是信号量和互斥锁的实现。</li><li>原子操作的核心是“不可分割性”：一次性完成对共享资源的修改，防止竞态条件。</li></ul><p>常见例子：</p><ul><li>增&#x2F;减操作：如 atomic_increment() 或 atomic_decrement()。</li><li>比较并交换（Compare and Swap, CAS）：<ul><li>功能：比较内存中的值和给定值，如果相等，则将内存中的值替换为新值。</li><li>应用：用于实现无锁数据结构。</li></ul></li></ul><p>优点：</p><ul><li>不需要禁用中断，适用于多处理器系统。</li><li>性能高效：适合在时间关键的并发操作中使用。</li></ul><p>缺点：</p><ul><li>与忙等待类似，使用不当可能导致资源浪费。</li><li>需要硬件支持，且某些复杂的原子操作可能受限于硬件实现。</li></ul><p>适用场景：</p><ul><li>多线程或多进程的同步场景，特别是当需要实现高性能无锁数据结构时。</li></ul><p>使用<strong>Compare and Swap (CAS)</strong> 指令实现锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 使用 Compare and Swap 实现锁</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token class-name">lock_t</span><span class="token punctuation">;</span><span class="token class-name">lock_t</span> lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 0 表示未加锁，1 表示已加锁</span><span class="token keyword">int</span> <span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span> <span class="token keyword">int</span> new_value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> old <span class="token operator">=</span> <span class="token operator">*</span>addr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>old <span class="token operator">==</span> expected<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>addr <span class="token operator">=</span> new_value<span class="token punctuation">;</span> <span class="token comment">// 将值替换为 new_value</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> old<span class="token punctuation">;</span> <span class="token comment">// 返回旧值</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 自旋等待</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token class-name">lock_t</span> <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">acquire_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加锁</span>        <span class="token comment">// 临界区代码</span>    shared_resource<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">release_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>说明：</p><ul><li>compare_and_swap() 是一个硬件提供的原子操作。</li><li>当 lock 的值是期望值（expected）时，才会将其更新为新值（new_value）。</li><li>CAS 在实现无锁数据结构时非常常用。</li></ul><hr><p>总结一下：</p><table><thead><tr><th><strong>方法</strong></th><th><strong>关键代码</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>禁止中断</td><td><code>disable_interrupts()</code></td><td>简单，适合单处理器系统</td><td>不适合多处理器，影响响应性</td></tr><tr><td>Test and Set</td><td><code>test_and_set(lock)</code></td><td>高效，适合多处理器系统</td><td>忙等待，自旋可能浪费资源</td></tr><tr><td>Compare and Swap</td><td><code>compare_and_swap(lock)</code></td><td>强大灵活，可用于无锁数据结构</td><td>忙等待，需要硬件支持</td></tr></tbody></table><h3 id="2-8-信号量机制"><a href="#2-8-信号量机制" class="headerlink" title="2.8 信号量机制"></a>2.8 信号量机制</h3><p><strong>信号量（Semaphore）</strong> 是一种用于同步进程或线程的机制，确保多个进程或线程可以安全、协调地访问共享资源。它通常用于解决临界区（Critical Section）问题。</p><p>信号量是一种整型变量，表示资源的可用数量。信号量分为两种类型：</p><ul><li>计数信号量（Counting Semaphore）：其值可以任意增减，通常用于管理多个相同的资源。</li><li>二进制信号量（Binary Semaphore）：其值只能为0或1，类似于互斥锁（Mutex）。</li></ul><hr><h4 id="2-8-1-信号量机制中的PV操作"><a href="#2-8-1-信号量机制中的PV操作" class="headerlink" title="2.8.1 信号量机制中的PV操作"></a>2.8.1 信号量机制中的PV操作</h4><p><strong>1. P操作（Proberen，Test）：</strong></p><ul><li>功能：试图获取信号量。将信号量的值减1。</li><li>逻辑：如果信号量的值大于0，表示有可用资源，继续执行。否则，进程进入等待状态，直到信号量的值大于0。</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token keyword">while</span> S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token operator">:</span>        wait    S <span class="token operator">=</span> S <span class="token operator">-</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>2. V操作（Verhogen，Increment）：</strong></p><ul><li>功能：释放信号量。将信号量的值加1。</li><li>逻辑：表示释放一个资源。如果有进程在等待信号量，该操作会唤醒其中一个进程.</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">:</span>    S <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>下面是使用Python实现的一个简单示例，演示如何使用信号量控制对共享资源的访问。假设我们有一个共享计数器，需要多个线程安全地访问。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token comment"># 定义一个信号量，初始值为1（相当于一个互斥锁）</span>semaphore <span class="token operator">=</span> threading<span class="token punctuation">.</span>Semaphore<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>counter <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 共享资源</span><span class="token comment"># 定义一个函数，使用信号量控制访问共享资源</span><span class="token keyword">def</span> <span class="token function">safe_increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> counter    <span class="token keyword">with</span> semaphore<span class="token punctuation">:</span>  <span class="token comment"># P操作，获取信号量</span>        temp <span class="token operator">=</span> counter        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>  <span class="token comment"># 模拟一些操作</span>        counter <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Counter value: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>counter<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token comment"># 创建多个线程</span>threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>safe_increment<span class="token punctuation">)</span>    threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 等待所有线程完成</span><span class="token keyword">for</span> t <span class="token keyword">in</span> threads<span class="token punctuation">:</span>    t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Final counter value: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>counter<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个示例中，信号量<code>semaphore</code>控制对共享资源<code>counter</code>的访问。每个线程在进入临界区前都会调用P操作（即<code>with semaphore</code>语句），在离开临界区时自动调用V操作（即退出<code>with</code>块）。</p><p>看一个更直观的示例代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-Cpp" data-language="Cpp"><code class="language-Cpp">Semaphore S &#x3D; 0;void P1()&#123;    code 1;    code 2;    V(S);    code 3;&#125;void P2()&#123;    P(S);    code 4;    code 5;    code 6;&#125;&#x2F;&#x2F; 这样P1先执行，P2后执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-9-经典同步互斥问题"><a href="#2-9-经典同步互斥问题" class="headerlink" title="2.9 经典同步互斥问题"></a>2.9 经典同步互斥问题</h3><p>操作系统中的同步与互斥问题涉及多个进程或线程在共享资源上的访问协调。它们解决了并发执行时资源共享所可能引发的冲突，确保系统的正确性和稳定性。</p><ol><li>同步问题（Synchronization）：<br>同步问题是指多个进程或线程需要按照某种顺序或时序执行，确保彼此之间的操作能够协调一致。同步的目的是保证特定的操作在适当的时机执行，以避免竞争条件和不一致状态。</li><li>互斥问题（Mutual Exclusion）：<br>互斥问题是指多个进程或线程在访问共享资源时，必须保证在同一时刻只有一个进程或线程能够访问该资源，避免冲突和不一致。</li></ol><p>假设两个线程 A 和 B 都需要访问一个共享的文件资源：</p><ul><li>同步：假如 A 必须在 B 完成某个任务后才能开始自己的任务，这时需要同步。</li><li>互斥：如果 A 和 B 同时修改文件内容，就需要互斥，确保只有一个线程可以修改文件。</li></ul><hr><h4 id="2-9-1-生产者-消费者问题（Producer-Consumer-Problem）"><a href="#2-9-1-生产者-消费者问题（Producer-Consumer-Problem）" class="headerlink" title="2.9.1 生产者-消费者问题（Producer-Consumer Problem）"></a>2.9.1 生产者-消费者问题（Producer-Consumer Problem）</h4><p>生产者-消费者问题描述了两个进程（或线程）之间的协调，一个是生产者，负责生产数据；另一个是消费者，负责消费数据。这个问题的核心是在生产者和消费者之间通过一个缓冲区（Buffer）进行数据传递，生产者和消费者必须正确同步，避免数据丢失或缓冲区溢出。以下是该问题的关键点：</p><ol><li><p>缓冲区：生产者将生产的数据放入缓冲区，而消费者从缓冲区中取出数据。当缓冲区满时，生产者必须等待，直到消费者消耗了数据；当缓冲区空时，消费者必须等待，直到生产者生产了新数据。</p></li><li><p>同步机制：为了避免竞争条件（Race Condition），需要使用同步机制（如信号量、互斥锁或条件变量）来确保生产者和消费者之间的正确协调。例如，信号量（Semaphore）可以控制生产者等待缓冲区有空位，消费者等待缓冲区有数据。</p></li><li><p>阻塞和唤醒：生产者和消费者在相应的条件下进行阻塞（等待）和唤醒（通知）。例如，当缓冲区满时，生产者阻塞；当缓冲区有空位时，唤醒生产者。消费者在缓冲区为空时阻塞；当缓冲区有数据时，唤醒消费者。</p></li></ol><p>下面是一个简化的伪代码示例：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 信号量初始化</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 表示缓冲区中的数据量</span>semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span>       <span class="token comment">// 表示缓冲区中的空位数（N为缓冲区大小）</span>mutex buffer_mutex<span class="token punctuation">;</span>        <span class="token comment">// 互斥锁，保护缓冲区的访问</span><span class="token comment">// 生产者</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 生产一个数据项</span>        <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 等待空位（empty信号量减1）</span>        <span class="token function">wait</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取缓冲区互斥锁</span>        <span class="token function">put_item_in_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 将数据项放入缓冲区</span>        <span class="token function">signal</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 释放缓冲区互斥锁</span>        <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 通知有新的数据（full信号量加1）</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 消费者</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 等待数据（full信号量减1）</span>        <span class="token function">wait</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取缓冲区互斥锁</span>        <span class="token function">remove_item_from_buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从缓冲区取出数据项</span>        <span class="token function">signal</span><span class="token punctuation">(</span>buffer_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 释放缓冲区互斥锁</span>        <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 通知有新的空位（empty信号量加1）</span>        <span class="token function">consume_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 消费数据项</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><hr><h4 id="2-9-2-读者-写者问题（Readers-Writers-Problem）"><a href="#2-9-2-读者-写者问题（Readers-Writers-Problem）" class="headerlink" title="2.9.2 读者-写者问题（Readers-Writers Problem）"></a>2.9.2 读者-写者问题（Readers-Writers Problem）</h4><p>读者-写者问题是操作系统中的另一个经典同步问题，涉及多线程的并发控制。它描述了多个线程在共享资源（例如数据库或文件）上执行读和写操作时的协调机制。这个问题的关键在于要确保以下几点：</p><ol><li><p>读操作和写操作的互斥：多个读者可以同时读取共享资源，但如果有一个写者正在写，则读者必须等待。同样，当有读者在读时，写者也必须等待。</p></li><li><p>避免饥饿：即使系统中有多个读者和写者，也要确保每个读者和写者都能最终访问到共享资源，避免某些读者或写者长时间无法获得访问权限。</p></li></ol><p>读者-写者问题的两种常见变体是：</p><ul><li><p>优先读者（Reader-Preference）：当有读者请求时，允许读者先行，写者只有在没有读者时才能进行写操作。这样可能会导致写者饥饿。</p></li><li><p>优先写者（Writer-Preference）：当有写者请求时，优先允许写者进行写操作，读者在写者完成后才能读取。这有助于避免写者饥饿，但可能会导致读者饥饿。</p></li></ul><p>以下是一个简单的伪代码示例，展示如何通过信号量（Semaphore）和互斥锁（Mutex）实现读者-写者问题的同步机制：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 信号量和互斥锁初始化</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 保护读者计数器的互斥锁</span>semaphore wrt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 用于写者的信号量</span><span class="token keyword">int</span> readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 记录当前正在读取的读者数量</span><span class="token comment">// 读者</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 进入临界区，保护readcount</span>        readcount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">wait</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 第一个读者阻塞写者</span>        <span class="token punctuation">&#125;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 退出临界区</span>        <span class="token function">read_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 执行读操作</span>        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 进入临界区</span>        readcount<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 最后一个读者解除写者阻塞</span>        <span class="token punctuation">&#125;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 退出临界区</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 写者</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 请求写操作</span>        <span class="token function">write_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 执行写操作</span>        <span class="token function">signal</span><span class="token punctuation">(</span>wrt<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 释放写操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><hr><h4 id="2-9-3-哲学家进餐问题（Dining-Philosophers-Problem）"><a href="#2-9-3-哲学家进餐问题（Dining-Philosophers-Problem）" class="headerlink" title="2.9.3 哲学家进餐问题（Dining Philosophers Problem）"></a>2.9.3 哲学家进餐问题（Dining Philosophers Problem）</h4><p>哲学家进餐问题用于展示多线程同步和资源共享的挑战。该问题描述了一组哲学家围坐在一张圆桌旁进餐的情景，他们在吃面条时需要使用筷子，但筷子的数量比哲学家少。</p><p>场景：有五个哲学家（可以是任意数量）围坐在一张圆桌旁，每个哲学家面前有一个碗和两根筷子。每对相邻的哲学家共享一根筷子，因此总共有五根筷子。</p><p>行为：哲学家交替进行思考和吃饭。当哲学家想要吃饭时，他们必须同时拿起左右两边的筷子。如果筷子被其他哲学家使用，则哲学家必须等待。</p><p>问题：如何设计一种机制，使得哲学家能够正确地同步使用筷子，避免死锁（即所有哲学家都在等待筷子，最终无人能吃饭）和饥饿（某个哲学家长时间不能吃饭）。</p><p>下面是一个简化的伪代码示例，展示如何通过互斥锁（Mutex）和条件变量（Condition Variable）实现哲学家进餐问题的同步机制：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 互斥锁和条件变量初始化</span>mutex chopsticks<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 每根筷子一个互斥锁</span><span class="token comment">// 哲学家编号为 0 到 4</span><span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哲学家思考</span>        <span class="token function">wait</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拿起左边的筷子</span>        <span class="token function">wait</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拿起右边的筷子</span>        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哲学家吃面条</span>        <span class="token function">signal</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 放下左边的筷子</span>        <span class="token function">signal</span><span class="token punctuation">(</span>chopsticks<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 放下右边的筷子</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这种简单的方案存在可能的死锁问题，为了避免死锁，可以引入一些改进方法，例如：</p><ol><li><p>规定顺序：规定所有哲学家必须按照某个顺序（如顺时针）拿筷子，从而避免循环等待。</p></li><li><p>允许最多四个哲学家同时拿筷子：限制最多允许四个哲学家同时尝试拿筷子，保证至少有一位哲学家可以吃饭。</p></li><li><p>随机背诵策略：引入随机元素，使哲学家在等待过程中进行随机的思考或其他操作，减少发生死锁的概率。</p></li></ol><hr><h3 id="2-10-管程（Monitor）"><a href="#2-10-管程（Monitor）" class="headerlink" title="2.10 管程（Monitor）"></a>2.10 管程（Monitor）</h3><p>管程是操作系统中一种用于同步并发进程的高级抽象机制，它为多线程程序提供了一种结构化的方法来管理共享资源的访问。通过管程，可以避免一些常见的并发问题，如死锁和资源竞争。</p><p>以下是管程的主要特点和工作原理：</p><ol><li><p>封装共享资源：管程封装了共享资源（如变量、数据结构等）以及访问这些资源的代码。只有通过调用管程中的方法，才能对共享资源进行访问，这样可以确保对资源的控制。</p></li><li><p>互斥访问：管程内部使用互斥锁（Mutex）来确保同一时间只有一个线程能够执行管程中的代码。这种互斥访问机制可以避免多个线程同时访问共享资源时产生的不一致性。</p></li><li><p>条件变量：管程中引入了条件变量（Condition Variable）来管理线程的等待和唤醒。线程可以在某个条件不满足时等待，并在条件满足时被唤醒。条件变量通常与互斥锁配合使用，以确保对条件的检查和修改是原子操作。</p></li><li><p>简化同步代码：使用管程可以将同步操作封装在管程内，使得并发程序的代码更加简洁和易于维护。这样，开发者不必直接处理低级别的锁和信号量，而是通过调用管程的方法进行同步。</p></li></ol><p>以下是一个简化的伪代码示例，展示如何使用管程来管理共享缓冲区的生产者-消费者问题：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c">monitor Buffer <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> buffer<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">// 共享缓冲区</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 当前缓冲区中的数据数量</span>    condition notFull<span class="token punctuation">;</span>     <span class="token comment">// 缓冲区未满的条件变量</span>    condition notEmpty<span class="token punctuation">;</span>    <span class="token comment">// 缓冲区未空的条件变量</span>    <span class="token comment">// 生产者方法</span>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 缓冲区满，等待</span>            <span class="token function">wait</span><span class="token punctuation">(</span>notFull<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        buffer<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>notEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 通知消费者缓冲区非空</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 消费者方法</span>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 缓冲区空，等待</span>            <span class="token function">wait</span><span class="token punctuation">(</span>notEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> item <span class="token operator">=</span> buffer<span class="token punctuation">[</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>notFull<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 通知生产者缓冲区未满</span>        <span class="token keyword">return</span> item<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><hr><h3 id="2-11-死锁的产生和处理"><a href="#2-11-死锁的产生和处理" class="headerlink" title="2.11 死锁的产生和处理"></a>2.11 死锁的产生和处理</h3><p><strong>死锁（Deadlock）</strong> 是操作系统中一种常见的并发问题，它发生在两个或多个进程（或线程）彼此等待对方释放资源，从而导致所有进程都无法继续执行的状态。简单来说，死锁是指一种资源争夺的僵局，进程永远无法获得所需的资源，导致系统停滞。</p><p>为了更好地理解死锁，假设有两个进程 $P_1$ 和 $P_2$ ，它们分别需要资源 $R_1$ 和 $R_2$ 来执行任务。以下情况可能导致死锁：</p><ul><li><p>资源保持和等待：进程 $P_1$ 已经持有资源 $R_1$，并请求资源 $R_2$ 但未获得；与此同时，进程 $P_2$ 已经持有资源 $R_2$，并请求资源 $R_1$ 但未获得。</p></li><li><p>循环等待：由于进程之间互相等待对方释放资源，形成了循环等待链。即 $P_1$ 等待 $P_2$ 释放资源 $R_2$，而 $P_2$ 等待 $P_1$ 释放资源 $R_1$。</p></li></ul><p>以下是一个简单的伪代码示例，展示了两个进程之间如何由于资源请求的顺序导致死锁：</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 假设有两个资源 R1 和 R2，以及两个进程 P1 和 P2</span><span class="token comment">// 进程 P1</span><span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R1</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R2</span>    <span class="token comment">// 执行某些操作</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R2</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R1</span><span class="token punctuation">&#125;</span><span class="token comment">// 进程 P2</span><span class="token keyword">void</span> <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R2</span>    <span class="token function">wait</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 请求资源 R1</span>    <span class="token comment">// 执行某些操作</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R1</span>    <span class="token function">signal</span><span class="token punctuation">(</span>R2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 释放资源 R2</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在这个示例中，进程 P1 先请求资源 R1，然后请求资源 R2；而进程 P2 先请求资源 R2，然后请求资源 R1。如果 P1 已经持有 R1 并且 P2 已经持有 R2，则 P1 会等待 R2，而 P2 会等待 R1，形成一个死锁循环，导致两个进程都无法继续执行。</p><p>在理解死锁的时候还要区分其他两个概念：</p><ol><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先 （SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”<br>而发生长进程</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是<br>程序员故意设计的。</li></ol><hr><h4 id="2-11-1-死锁产生的条件"><a href="#2-11-1-死锁产生的条件" class="headerlink" title="2.11.1 死锁产生的条件"></a>2.11.1 死锁产生的条件</h4><p>死锁的形成通常需要满足以下四个必要条件：</p><ul><li><p>互斥（Mutual Exclusion）：每个资源在一个时刻只能由一个进程使用。</p></li><li><p>保持并等待（Hold and Wait）：一个进程已经持有一个资源，并且等待其他资源的释放。</p></li><li><p>不可剥夺（No Preemption）：资源不能被强制从进程中剥夺，必须由持有进程主动释放。</p></li><li><p>循环等待（Circular Wait）：存在一组进程，每个进程都在等待资源，而这些资源正被这组中的其他进程持有。</p></li></ul><p>所有，可以有一个结论：发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p><h4 id="2-11-2-死锁常见问题"><a href="#2-11-2-死锁常见问题" class="headerlink" title="2.11.2 死锁常见问题"></a>2.11.2 死锁常见问题</h4><blockquote><p>问： 什么时候会发生死锁？</p></blockquote><ol><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的p操作在实现同步的p操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资<br>源）</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h4 id="2-11-3-死锁的处理策略"><a href="#2-11-3-死锁的处理策略" class="headerlink" title="2.11.3 死锁的处理策略"></a>2.11.3 死锁的处理策略</h4><p>处理死锁通常有有如下3种策略：</p><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><hr><p>先讲第1点，<strong>预防死锁</strong>策略主要是通过破坏死锁产生的四个必要条件中的一个或几个来实现。以下是具体的预防策略：</p><ol><li><strong>破坏互斥条件（Mutual Exclusion）：</strong></li></ol><p>这个策略很难完全实现，因为大部分资源都是互斥性的（例如打印机、文件）。但可以尝试将某些资源变为可共享的，例如只读文件可以同时被多个进程访问。这里可以了解一下SPOOLing技术</p><blockquote><p>SPOOLing技术：把独占设备在逻辑上改造成共享设备, 将输出传输到输出进程， 进程端视作完成了输出（打印机）</p></blockquote><img src="/img/OS/spooling.svg" alt="Spooling技术" style="max-width: 100%; height: auto;" /><ol start="2"><li><strong>破坏保持并等待条件（Hold and Wait）：</strong></li></ol><p>方案一： 进程请求新的资源得不到满足时， 它必须释放所保持的所有资源， 待以后需要时重新申请。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p><p>该策略的缺点：</p><ul><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ul><ol start="3"><li><strong>破坏不可剥夺条件（No Preemption）：</strong></li></ol><p>允许操作系统强制性地从进程中剥夺资源。如果一个进程请求某个资源但被拒绝，操作系统可以强制释放进程已持有的资源，使其他进程可以使用这些资源。</p><p>这个策略实现简单，但也有缺点：</p><ul><li>有些资源可能需要用很短的时间， 因此如果进程运行期间一直保持， 造成了严重的资源浪费，资源利用率低。</li><li>另外，该策略也有可能导致某些进程饥饿。</li></ul><ol start="4"><li><strong>破坏循环等待条件（Circular Wait）：</strong></li></ol><p>给所有资源定义一个线性顺序，并要求进程按这个顺序请求资源。即进程只能在获得序号较小的资源后，才能请求序号较大的资源。这可以有效避免形成循环等待链。</p><p>该策略的缺点：</p><ul><li>不方便增加新的设备，因为可能需要重新分配所有的编号。</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费。</li><li>必须按规定次序申请资源，用户编程麻烦。</li></ul><hr><p>现在讲解一下处理死锁的第二种策略，也就是<strong>避免死锁</strong>。我们引入一个银行家算法的策略。</p><p><strong>银行家算法（Banker’s Algorithm）</strong> 是由艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）提出的一种避免死锁的算法，主要用于资源分配系统。它通过模拟银行家为客户分配贷款的过程，判断系统是否会进入不安全状态，从而避免死锁的发生。</p><p>以下是银行家算法的基本原理和步骤：</p><ol><li><p>基本原理：银行家算法假设系统中的每个进程都会声明最大资源需求，并且在实际运行过程中不会超过这个声明。系统在每次资源分配时，都会检查分配后的状态是否安全。如果发现资源分配会导致系统进入不安全状态（即可能发生死锁），则拒绝分配请求。</p></li><li><p>关键概念：</p><ul><li><p>最大需求矩阵（Maximum Need Matrix）：表示每个进程可能需要的最大资源数量。</p></li><li><p>分配矩阵（Allocation Matrix）：表示当前已经分配给每个进程的资源数量。</p></li><li><p>需求矩阵（Need Matrix）：表示每个进程还需要的资源数量，计算公式为：Need &#x3D; Maximum - Allocation。</p></li><li><p>可用资源向量（Available Vector）：表示系统当前可用的资源数量。</p></li></ul></li><li><p>算法步骤：</p><ul><li><p>初始化：根据系统状态，初始化最大需求矩阵、分配矩阵、需求矩阵和可用资源向量。</p></li><li><p>资源请求：当进程请求资源时，系统会执行以下步骤：</p><ul><li><p>检查请求是否小于等于进程的最大需求（Request ≤ Need）。</p></li><li><p>检查请求是否小于等于系统的可用资源（Request ≤ Available）。</p></li></ul></li><li><p>模拟分配：系统假设满足进程的请求，并更新相应的矩阵和向量：</p><ul><li><p>Available &#x3D; Available - Request</p></li><li><p>Allocation &#x3D; Allocation + Request</p></li><li><p>Need &#x3D; Need - Request</p></li></ul></li></ul></li><li><p>安全性检查：使用安全性算法（Safety Algorithm）检查系统是否处于安全状态。如果系统仍然处于安全状态，则分配请求得到满足；否则，撤销模拟分配，拒绝请求。</p></li></ol><p><strong>示例</strong> ：假设系统有如下资源：</p><ul><li><p>总资源：$[10, 5, 7]$</p></li><li><p>可用资源：$[3, 3, 2]$</p></li></ul><p>最大需求矩阵：</p><p>$$\left[<br>\begin{matrix}<br>7 &amp; 5 &amp; 3\\<br>3 &amp; 2 &amp; 2 \\<br>9 &amp; 0 &amp; 2 \\<br>2 &amp; 2 &amp; 2 \\<br>4 &amp; 3 &amp; 3<br>\end{matrix}<br>\right]<br>$$</p><p>分配矩阵：</p><p>$$\left[<br>\begin{matrix}<br>0 &amp; 1 &amp; 0\\<br>2 &amp; 0 &amp; 0 \\<br>3 &amp; 0 &amp; 2 \\<br>2 &amp; 1 &amp; 1 \\<br>0 &amp; 0 &amp; 2<br>\end{matrix}<br>\right]<br>$$</p><p>需求矩阵（通过最大需求矩阵和分配矩阵计算得到）：</p><p>$$\left[<br>\begin{matrix}<br>7 &amp; 4 &amp; 3\\<br>1 &amp; 2 &amp; 2 \\<br>6 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 1 \\<br>4 &amp; 3 &amp; 1<br>\end{matrix}<br>\right]<br>$$</p><p>当一个进程请求资源时，银行家算法会检查系统是否能够在分配资源后保持安全状态，以避免死锁。我们就手动模拟给进程分配资源，然后进程结束收回资源，找到这样一个安全的进程序列的话，那么死锁就可以避免。</p><img src="/img/OS/bankers.svg" alt="银行家算法" style="max-width: 100%; height: auto;" /><hr><p>现在我们分析处理死锁的第三种策略：<strong>死锁的检测和解除</strong></p><img src="/img/OS/deadlock.svg" alt="死锁检测" style="max-width: 100%; height: auto;" /><p>在这个图中的死锁环路形成过程如下：</p><ol><li>P3已获得R2资源（绿色实线），同时请求R3资源（红色虚线）</li><li>R3已被分配给P4（绿色实线）</li><li>P4已获得R3，同时请求R2资源（红色虚线）</li><li>R2已被分配给P3（回到第1步）</li></ol><p>这形成了一个循环等待：P3等待P4释放R3，而P4等待P3释放R2。由于每个进程都在等待其他进程释放资源，且都不会主动释放自己持有的资源，因此形成了死锁。检测到这种循环等待关系，就意味着检测到了死锁的存在。</p><p>我们有如下的死锁的解决办法：</p><ol><li><p><strong>资源剥夺（Resource Preemption）：</strong> 通过强制性剥夺资源，可以打破循环等待链。例如，在图中的死锁情况下，可以选择剥夺 P3 持有的 R2 或剥夺 P4 持有的 R3，然后重新分配这些资源，从而打破死锁。</p></li><li><p><strong>终止进程（Process Termination）：</strong> 逐一终止进程是比较直接的方法。例如，首先终止 P3，使得 R2 被释放出来，然后 P4 就可以获得 R2，从而打破死锁链。</p></li><li><p><strong>资源回收（Resource Reclamation）：</strong> 强制进程在某个时间点释放资源（例如通过定时器），可以暂时打破资源占用状态，使得其他进程有机会获得资源。例如，要求 P3 或 P4 在一定时间段内释放资源，从而避免长时间的死锁状态。</p></li></ol><h2 id="3-Memory-Management"><a href="#3-Memory-Management" class="headerlink" title="3. Memory Management"></a>3. Memory Management</h2><p>本章讲解操作系统中的内存管理，主要的重点在虚实地址转换，段页式管理方式，以及页面置换算法。在了解虚实地址转换之前，首先要辨别虚拟地址和物理地址的概念。</p><p>在操作系统中，虚拟地址（<strong>Virtual Address</strong>）和物理地址（<strong>Physical Address</strong>）是两种不同层级的地址，它们涉及到内存管理的不同方面。理解这两个概念非常重要，因为它们与内存的访问、分配以及操作系统如何管理硬件资源密切相关。</p><h4 id="3-1-虚拟地址（Virtual-Address）与物理地址（Physical-Address）"><a href="#3-1-虚拟地址（Virtual-Address）与物理地址（Physical-Address）" class="headerlink" title="3.1 虚拟地址（Virtual Address）与物理地址（Physical Address）"></a>3.1 虚拟地址（Virtual Address）与物理地址（Physical Address）</h4><p>虚拟地址是由程序（或进程）在运行时所使用的地址。在现代操作系统中，每个进程都认为它有一整块连续的内存空间，这就是所谓的<strong>虚拟地址空间</strong>（<strong>Virtual Address Space</strong>）。操作系统通过虚拟内存管理（<strong>Virtual Memory Management</strong>）来提供这种抽象，使得程序不需要直接操作物理内存地址。</p><p><strong>虚拟地址的特点：</strong></p><ul><li><strong>独立性（Independence）</strong>：每个进程都有独立的虚拟地址空间，彼此之间互不干扰。</li><li><strong>抽象性（Abstraction）</strong>：程序只能看到虚拟地址，操作系统负责将这些虚拟地址映射到实际的物理内存地址。</li><li><strong>安全性（Security）</strong>：虚拟地址空间的使用减少了不同进程之间的干扰，增加了系统的安全性。例如，进程无法直接访问其他进程的内存，避免了内存泄漏或数据窃取。</li></ul><hr><p>物理地址是计算机硬件（如内存控制器、RAM）直接使用的内存地址，它表示了内存芯片中实际的位置。操作系统将虚拟地址通过一种称为<strong>地址映射</strong>（<strong>Address Mapping</strong>）的机制转换为物理地址，从而让 CPU 可以实际访问内存。</p><p><strong>物理地址的特点：</strong></p><ul><li><strong>实际存在（Real Existence）</strong>：物理地址代表的是计算机中的实际内存单元（如 RAM）。</li><li><strong>固定性（Fixed Nature）</strong>：物理地址通常与硬件布局相关，无法随操作系统的调度变化而变化。</li></ul><hr><p>虚拟地址与物理地址的关系：地址映射（Address Mapping）</p><p>操作系统通过硬件（通常是内存管理单元，<strong>MMU</strong>，<strong>Memory Management Unit</strong>）来实现虚拟地址和物理地址之间的映射。虚拟地址通过<strong>页表</strong>（<strong>Page Table</strong>）映射到物理地址。这一过程称为<strong>地址转换</strong>（<strong>Address Translation</strong>），它是现代操作系统内存管理的核心。</p><p><strong>地址转换的过程：</strong></p><ol><li><p><strong>分段与分页（Segmentation and Paging）</strong>：</p><ul><li><strong>分页（Paging）</strong>：操作系统将虚拟地址空间分为固定大小的页（Page），每一页会映射到物理内存中的一块区域。页的大小通常为 4 KB、8 KB 或更大。</li><li><strong>分段（Segmentation）</strong>：虚拟地址空间不仅可以通过分页来管理，还可以通过分段将地址空间分为不同的段（如代码段、数据段、堆栈段等）。</li></ul></li><li><p><strong>页表（Page Table）</strong>：操作系统通过维护页表来实现虚拟页到物理页的映射。页表记录了虚拟页和物理页之间的对应关系。MMU 会根据虚拟地址中的页号查找页表，从而获取对应的物理页号，完成虚拟地址到物理地址的转换。</p></li><li><p><strong>TLB（Translation Lookaside Buffer）</strong>：为了提高地址转换的效率，操作系统会使用一个硬件缓存（TLB）来存储最近使用的虚拟地址到物理地址的映射。</p></li></ol><p><strong>举个例子：</strong> 假设虚拟地址为 <code>0x7fffffff</code>，操作系统通过页表将其映射到物理地址 <code>0x1001ffff</code>，通过这种方式，程序就可以通过虚拟地址访问到实际的内存。</p><hr><p>虚拟地址与物理地址的优点：</p><ul><li><strong>内存保护（Memory Protection）</strong>：虚拟内存使得每个进程只能访问它自己被分配的内存空间，避免了进程间的内存干扰。</li><li><strong>进程隔离（Process Isolation）</strong>：操作系统能够通过虚拟内存为每个进程提供独立的内存地址空间，防止进程直接访问或修改其他进程的数据。</li><li><strong>内存共享（Memory Sharing）</strong>：操作系统可以通过映射不同进程的虚拟地址到相同的物理地址，实现进程间共享内存。</li></ul><p>最后简单总结一下：</p><ul><li><strong>虚拟地址（Virtual Address）</strong> 是程序用来访问内存的地址，操作系统通过虚拟内存技术提供给每个进程一个独立的虚拟地址空间。</li><li><strong>物理地址（Physical Address）</strong> 是实际的内存地址，由硬件使用。</li><li>操作系统通过内存管理单元（<strong>MMU</strong>）和页表（<strong>Page Table</strong>）将虚拟地址映射到物理地址，从而实现虚拟内存和物理内存之间的映射。</li></ul><p>虚拟地址和物理地址的映射机制使得操作系统能够高效、安全地管理内存资源，提供了内存保护、进程隔离以及高效的内存共享等优点。</p><p>本章接下来的内容就是深入底层探讨上面的涉及到的内容。</p><hr><h3 id="3-2-内存的概念"><a href="#3-2-内存的概念" class="headerlink" title="3.2 内存的概念"></a>3.2 内存的概念</h3><p>内存（Memory）是计算机中的一种硬件资源，主要用于存储和快速访问程序和数据。它是计算机系统中非常重要的一部分，负责存放正在运行的程序指令、数据以及操作系统的相关信息。内存主要有两种类型：</p><ul><li>RAM（随机存取存储器）：用于存储正在运行的程序和数据，是一种易失性存储器，断电后数据会丢失。</li><li>ROM（只读存储器）：存储系统启动时需要的固件或引导程序，通常是非易失性的。</li></ul><p>内存的编址方式有两种主要方式：<strong>按字节编址</strong>和<strong>按字编址</strong>。这两种方式的主要区别在于每个地址对应的数据单位的大小不同。</p><h4 id="3-2-1-按字节编址（Byte-Addressing）"><a href="#3-2-1-按字节编址（Byte-Addressing）" class="headerlink" title="3.2.1 按字节编址（Byte Addressing）"></a>3.2.1 按字节编址（Byte Addressing）</h4><ul><li><strong>内存地址从 00 开始，每个地址对应一个存储单元</strong>：每个内存地址指向 1 字节（8 bit）的数据。</li><li><strong>每个存储单元大小为 1 字节</strong>：即每个存储单元占用 1 字节（8 bit），1 字节 &#x3D; 8 bit。</li><li><strong>按字节编址</strong>：每个地址指向 1 字节。</li></ul><p>假设内存的内容如下，每个位置对应一个字节的数据：</p><table><thead><tr><th>地址</th><th>数据</th></tr></thead><tbody><tr><td>00</td><td>0x1A</td></tr><tr><td>01</td><td>0x2B</td></tr><tr><td>02</td><td>0x3C</td></tr><tr><td>03</td><td>0x4D</td></tr><tr><td>04</td><td>0x5E</td></tr></tbody></table><p>在这种情况下，每个内存地址对应一个字节（8 bit）的数据。例如：</p><ul><li>地址 00 存储的数据为 0x1A</li><li>地址 01 存储的数据为 0x2B</li><li>地址 02 存储的数据为 0x3C</li></ul><p>如果某程序需要访问地址 02 的数据，它将直接访问 0x3C。</p><hr><h4 id="3-2-2-按字编址（Word-Addressing）"><a href="#3-2-2-按字编址（Word-Addressing）" class="headerlink" title="3.2.2 按字编址（Word Addressing）"></a>3.2.2 <strong>按字编址（Word Addressing）</strong></h4><ul><li><strong>内存地址从 00 开始，每个地址对应一个存储单元</strong>：每个内存地址指向 1 个字（通常是 16 位或 2 字节）。</li><li><strong>每个存储单元大小为 1 个字</strong>：即每个存储单元占用 16 位（2 字节），1 字 &#x3D; 16 bit。</li><li><strong>按字编址</strong>：每个地址指向 1 个字。</li></ul><p>假设内存的内容如下，每个位置对应一个字（通常是 16 位或 2 字节）的数据：</p><table><thead><tr><th>地址</th><th>数据</th></tr></thead><tbody><tr><td>00</td><td>0x1A2B</td></tr><tr><td>01</td><td>0x3C4D</td></tr><tr><td>02</td><td>0x5E6F</td></tr><tr><td>03</td><td>0x7081</td></tr><tr><td>04</td><td>0x9ABC</td></tr></tbody></table><p>在这种情况下，每个内存地址对应一个字（16 bit 或 2 字节）的数据。例如：</p><ul><li>地址 00 存储的数据为 0x1A2B</li><li>地址 01 存储的数据为 0x3C4D</li><li>地址 02 存储的数据为 0x5E6F</li></ul><p>如果某程序需要访问地址 01 的数据，它将直接访问 0x3C4D。</p><hr><h4 id="3-2-3-按字节编址与按字编址的区别"><a href="#3-2-3-按字节编址与按字编址的区别" class="headerlink" title="3.2.3. 按字节编址与按字编址的区别"></a>3.2.3. <strong>按字节编址与按字编址的区别</strong></h4><table><thead><tr><th>特性</th><th>按字节编址（Byte Addressing）</th><th>按字编址（Word Addressing）</th></tr></thead><tbody><tr><td><strong>存储单元大小</strong></td><td>每个存储单元为 1 字节（8 bit）</td><td>每个存储单元为 1 个字（16 bit 或 2 字节）</td></tr><tr><td><strong>地址步进</strong></td><td>每个内存地址指向 1 字节</td><td>每个内存地址指向 1 个字</td></tr><tr><td><strong>内存访问单位</strong></td><td>字节（Byte）</td><td>字（Word）</td></tr><tr><td><strong>示例</strong></td><td>地址 <code>00</code> 存储 1 字节，地址 <code>01</code> 存储 1 字节</td><td>地址 <code>00</code> 存储 1 个字（16 bit），地址 <code>01</code> 存储下一个字（16 bit）</td></tr><tr><td><strong>常见应用</strong></td><td>现代计算机普遍采用（如 32 位系统、64 位系统）</td><td>较早或特定的计算机系统（如 16 位字长的机器）</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li><strong>按字节编址（Byte Addressing）</strong>：每个内存地址对应 1 字节（8 bit），常用于现代计算机系统。</li><li><strong>按字编址（Word Addressing）</strong>：每个内存地址对应 1 个字（16 bit 或 2 字节），通常出现在字长为 16 位的计算机系统中。</li></ul><p>这些编址方式对计算机的内存管理和程序的内存访问模式有重要影响。在字节编址中，内存的访问单位较小，适合处理各种小规模的数据。而在字编址中，内存访问通常更高效，特别是在处理需要 16 位宽度的数据时。</p><hr><h3 id="3-3-连续内存分配（Contiguous-Memory-Allocation）"><a href="#3-3-连续内存分配（Contiguous-Memory-Allocation）" class="headerlink" title="3.3 连续内存分配（Contiguous Memory Allocation）"></a>3.3 连续内存分配（Contiguous Memory Allocation）</h3><p>“连续内存分配”是操作系统中的一种内存管理方式，它要求程序在执行时必须占用一块连续的内存空间。这种方式通常用于简化内存管理，并提高内存访问的效率。它可以通过将程序所需的内存块按顺序分配，避免了碎片化问题，但也带来了一些局限性。</p><p><strong>分段（Segmentation）</strong> 在某些情况下可以看作是连续内存分配的一种扩展或优化方法。分段是一种逻辑上的内存划分，它把程序划分为多个不同的段（如代码段、数据段、堆栈段等），每个段是连续的，因此每个段的内存空间在物理内存中是连续的。这样，分段的方式不仅保持了连续内存分配的优点，还能够通过合理划分程序的不同部分，提供更好的内存管理和灵活性。</p><p><strong>连续内存分配的主要特点：</strong></p><ul><li><strong>连续性</strong>：每个进程或程序在内存中的存储空间是连续的，没有分散的碎片。分段也是基于这一理念，虽然程序被分成不同的段，但每个段内部仍然是连续分配的。</li><li><strong>简单性</strong>：实现比较简单，管理方便。分段虽然比纯粹的连续分配稍微复杂，但它仍然保持了分配连续内存的基本结构，只是对程序进行逻辑上的划分。</li><li><strong>内存浪费</strong>：由于要求分配的内存是连续的，容易造成内存碎片，从而导致内存利用率降低。分段同样也会面临内存碎片问题，尤其是<strong>外部碎片</strong>。不过，分段通过划分段的方式（例如代码段、数据段等）减少了内存管理的复杂度。</li></ul><p><strong>分配方式：</strong></p><p><strong>1.固定分区分配：</strong></p><ul><li>内存被划分为若干个固定大小的分区。每个分区只能分配给一个进程。分段和这种方式类似，但分段是将进程划分为多个段，而每个段的大小可以不同。</li></ul><p><strong>2.动态分区分配：</strong></p><ul><li>内存不预先划分为固定大小的分区，而是根据进程的需求动态分配。通过“首次适应算法”、“最佳适应算法”、“最差适应算法”等来寻找合适的内存块。分段的内存分配方式更灵活，可以根据进程的逻辑结构来动态调整段的大小。</li></ul><img src="/img/OS/memory_allocation.svg" alt="内存分配" style="max-width: 100%; height: auto;" /><p><strong>连续内存分配产生的内存碎片：</strong></p><ul><li><p><strong>外部碎片（External Fragmentation）</strong>：内存中的小块空闲空间，由于这些空间不连续，无法分配给新进程。分段同样可能会产生外部碎片，因为每个段的大小是动态的，释放的段可能导致空闲空间分散，无法为其他进程分配大块连续的内存区域。</p></li><li><p><strong>内部碎片（Internal Fragmentation）</strong>：分配的内存块比进程实际需要的内存大，导致分配的内存块内部存在未使用的空间。分段通常较少产生内部碎片，因为段是按需分配的，但如果段的大小过大，仍然可能存在一定的内部分配浪费。</p></li></ul><p><strong>连续内存分配的优缺点：</strong></p><ul><li><p><strong>优点</strong>：简单易实现，适用于内存需求较小、较少变化的系统。分段提供了更细粒度的内存分配，适合管理不同类型的内存需求（如代码、数据和堆栈等）。</p></li><li><p><strong>缺点</strong>：内存利用率较低，容易产生内存碎片，难以适应现代操作系统的需求。分段虽能够通过合理划分程序的不同部分来减少碎片，但仍然可能面临外部碎片问题，需要采取紧凑化（Compaction）等技术来缓解。</p></li></ul><img src="/img/OS/fragmentation.svg" alt="内存碎片" style="max-width: 100%; height: auto;" /><p><strong>内存碎片：</strong></p><ul><li><strong>紧凑（Compaction）</strong>：紧凑是一种用于解决外部碎片问题的技术。它的基本思想是将内存中的所有进程移动到内存的一端，使得所有的空闲分区都集中在内存的另一端，从而形成一个大的、连续的空闲分区。这样，就可以满足大的内存请求，从而解决外部碎片问题。然而，紧凑需要移动进程，因此会产生一定的开销。在分段中，紧凑化同样适用于解决外部碎片问题，但由于段的分配是按逻辑划分的，因此紧凑的过程可能更复杂。</li></ul><p><strong>总结：</strong><br>在 <strong>连续内存分配</strong> 中，程序的内存是按顺序分配的，保证了每个进程的内存空间是连续的。而 <strong>分段（Segmentation）</strong> 作为连续内存分配的一种扩展，它通过将程序划分为多个逻辑段（如代码段、数据段、堆栈段等），每个段在内存中仍然是连续的。虽然分段可以提供更多的灵活性，但它仍然面临外部碎片的问题，因此需要通过紧凑化等技术来优化内存使用。</p><h4 id="3-3-1-动态分区分配算法"><a href="#3-3-1-动态分区分配算法" class="headerlink" title="3.3.1 动态分区分配算法"></a>3.3.1 动态分区分配算法</h4><p>动态分区分配算法用于在内存中动态分配空闲区域，特别是在程序执行过程中。与静态分配不同，动态分区分配是根据程序的实际需求（如内存大小）动态调整内存的分配。主要的动态分区分配算法包括 <strong>首次适应（First-fit）</strong>、<strong>最优适应（Best-fit）</strong>、<strong>最坏适应（Worst-fit）</strong> 和 <strong>临近适应（Next-fit）</strong> 等。</p><hr><p><strong>1.首次适应（First-fit）</strong></p><p><strong>首次适应</strong>算法从内存的开始位置开始查找，寻找第一个足够大的空闲内存块来满足请求。当找到一个合适的空闲块后，立即分配内存。</p><p><strong>过程：</strong></p><ol><li>从内存中的第一个空闲块开始查找。</li><li>遍历空闲块，找到第一个可以满足请求的块。</li><li>如果找到合适的空闲块（Free block），则分配内存。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：实现简单，查找速度较快。</li><li><strong>缺点</strong>：可能导致内存碎片（Memory Fragmentation），因为分配的是第一个找到的块，后续的空闲块可能很小。</li></ul><img src="/img/OS/first_fit.svg" alt="首次适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>2.最优适应（Best-fit）</strong></p><p><strong>最优适应</strong>算法遍历整个内存，寻找所有能满足请求的空闲块，并选择<strong>最小的</strong>空闲块进行分配，即选择一个最接近请求大小的块。</p><p><strong>过程：</strong></p><ol><li>遍历所有空闲内存块。</li><li>选择一个大小最合适（最小且足够大）的空闲块。</li><li>分配内存。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：可以减少剩余空闲内存块的大小，从而减少碎片。</li><li><strong>缺点</strong>：查找过程较慢，因为需要遍历所有空闲块，效率较低。</li></ul><img src="/img/OS/best_fit.svg" alt="最优适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>3.最坏适应（Worst-fit）</strong></p><p><strong>最坏适应</strong>算法选择一个最大的空闲内存块来进行分配。这种方法的假设是，通过选择最大空闲块，可以避免创建过多的小碎片。</p><p><strong>过程：</strong></p><ol><li>遍历所有空闲内存块。</li><li>选择最大的空闲块。</li><li>将内存分配给进程。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：通过选择最大的空闲块，减少了碎片化的风险。</li><li><strong>缺点</strong>：可能会导致较大的空闲块被拆分成小块，减少了可用的空间。</li></ul><img src="/img/OS/worst_fit.svg" alt="最坏适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>4.临近适应（Next-fit）</strong></p><p><strong>临近适应</strong>算法与<strong>首次适应</strong>算法类似，不同之处在于，<strong>临近适应</strong>算法在上次分配的位置继续查找空闲块，而不是从内存的开头重新开始查找。</p><p><strong>过程：</strong></p><ol><li>从上次分配位置开始查找。</li><li>遍历空闲块，找到第一个足够大的空闲块。</li><li>分配内存。</li></ol><p><strong>优缺点：</strong></p><ul><li><strong>优点</strong>：避免了每次从内存的开头开始查找，查找过程较快。</li><li><strong>缺点</strong>：仍然可能会出现碎片化，尤其是在内存末尾。</li></ul><img src="/img/OS/next_fit.svg" alt="临近适应算法" style="max-width: 100%; height: auto;" /><hr><p><strong>动态分区分配算法总结</strong></p><table><thead><tr><th>算法</th><th>查找空闲块的顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>首次适应</strong></td><td>从头开始查找</td><td>实现简单，查找速度较快</td><td>可能产生较多的碎片</td></tr><tr><td><strong>最优适应</strong></td><td>遍历所有空闲块</td><td>减少剩余碎片，内存利用较好</td><td>查找速度较慢，可能产生小碎片</td></tr><tr><td><strong>最坏适应</strong></td><td>遍历所有空闲块</td><td>减少小碎片产生，较为稳定</td><td>可能浪费大量内存，产生较大碎片</td></tr><tr><td><strong>临近适应</strong></td><td>从上次分配位置开始查找</td><td>查找速度较快，避免从头开始查找</td><td>可能导致末尾碎片或不均匀的碎片分布</td></tr></tbody></table><p>这些算法都有各自的应用场景和适用范围，在实际系统中，操作系统可能会根据不同的内存需求，选择合适的分配算法，或采用多种算法的组合来平衡内存的分配效率和碎片化问题。</p><hr><h4 id="3-3-2-分段寻址（Segmentation-Addressing）"><a href="#3-3-2-分段寻址（Segmentation-Addressing）" class="headerlink" title="3.3.2 分段寻址（Segmentation Addressing）"></a>3.3.2 分段寻址（Segmentation Addressing）</h4><p>在分段管理中，程序的内存被划分为多个逻辑上的段，如代码段、数据段、堆栈段等。每个段在物理内存中都有一个连续的存储空间。分段寻址是通过两个部分来定位内存中的具体位置：</p><ol><li>段基址（Segment Base Address）：每个段在物理内存中的起始地址。</li><li>段内偏移量（Offset）：在该段内的具体位置，相对于该段的起始位置的偏移。</li></ol><p><strong>分段寻址过程：</strong><br>当程序需要访问某个内存位置时，操作系统会将逻辑地址转换为物理地址。逻辑地址由两个部分组成：</p><ul><li>段号（Segment Number）：指示需要访问的段。</li><li>内偏移量（Offset）：指示在该段内具体的位置。</li></ul><p>计算物理地址的公式：<strong>物理地址 &#x3D; 段基址 + 段内偏移量</strong></p><p>假设我们有以下段信息，存放在段表 (Segment Table)：</p><ul><li>代码段（Code Segment）：基址为<code>1000</code>，长度为<code>500</code>。</li><li>数据段（Data Segment）：基址为<code>2000</code>，长度为<code>300</code>。</li><li>堆栈段 (Stack Segment)：基址为<code>2500</code>，长度为<code>400</code>。</li></ul><p>步骤：</p><ol><li>查找段号：这里是<code>数据段</code>，段号为<code>2</code>。</li><li>获取段基址：数据段的基址是<code>2000</code>。</li><li>获取偏移量：我们需要访问数据段的第<code>150</code>个字节，所以偏移量是<code>150</code>。</li><li>计算物理地址：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">物理地址 = 段基址 + 偏移量 = 2000 + 150 = 2150<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>因此，访问<code>数据段</code>中第<code>150</code>个字节的物理地址是<code>2150</code>。</p><img src="/img/OS/segmentation_addressing.svg" alt="分段寻址" style="max-width: 100%; height: auto;" /><h3 id="3-4-分页（Paging）"><a href="#3-4-分页（Paging）" class="headerlink" title="3.4 分页（Paging）"></a>3.4 分页（Paging）</h3><p>在操作系统中，分页（Paging）是一种内存管理方案，它将物理内存分割成大小相等的块，称为页帧（Page Frames），而逻辑内存（也就是程序使用的内存）则被划分为相同大小的块，称为页（Pages）。分页的目标是将内存的使用更加高效地管理，减少内存碎片，提高系统的可用性和性能。</p><h4 id="3-4-1-分页的基本概念"><a href="#3-4-1-分页的基本概念" class="headerlink" title="3.4.1 分页的基本概念"></a>3.4.1 分页的基本概念</h4><ol><li>页（Page）：页是逻辑内存的基本单位，通常大小为4KB、8KB或更大。操作系统将程序的虚拟内存划分为若干页，每一页在物理内存中都有一个对应的页帧。</li><li>页帧（Page Frame）：页帧是物理内存中的基本单位。每个页帧与一个页一一对应。物理内存被划分成许多页帧，大小与页一致。</li><li>页表（Page Table）：页表是操作系统用来管理页与页帧之间映射关系的数据结构。每个进程都有自己的页表，页表中的每个条目包含一个页帧号（Page Frame Number），指示该逻辑页对应的物理页帧。</li><li>虚拟地址（Virtual Address）：程序使用的地址，是程序在执行时产生的地址，经过分页后可以转换为物理地址。</li><li>物理地址（Physical Address）：实际的硬件内存地址，通过页表映射从虚拟地址转换得到。</li><li>页表项（Page Table Entry, PTE）：页表中的每个条目，通常包含页帧号以及其他控制信息，如有效位（Valid Bit）、访问权限等。</li></ol><h4 id="3-4-2-分页地址转换"><a href="#3-4-2-分页地址转换" class="headerlink" title="3.4.2 分页地址转换"></a>3.4.2 分页地址转换</h4><p>在分页机制下，程序使用的是虚拟地址空间，而实际的内存地址是物理地址。分页地址转换的基本过程就是通过页表把虚拟地址转为物理地址。</p><p>在简单的分页系统中，虚拟地址通常被分为两部分：</p><ul><li>页号（Page Number）：虚拟地址的高位部分，用于索引页表，找到虚拟页号对应的物理页帧号。</li><li>页内偏移（Offset）：虚拟地址的低位部分，用来表示数据在该页内的偏移位置。<br>这种结构适用于简单的分页机制，每个虚拟地址空间的页表只有一级。</li></ul><p>举个例子，在按字节编址的存储器中，有32个页面，每页 1KB；内存为 64KB，页号和物理块号对应表如图所示，计算逻辑地址<code>0x0C5D</code>所对应的物理地址</p><table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody><tr><td>9</td><td>5</td></tr><tr><td>2</td><td>4</td></tr><tr><td>3</td><td>8</td></tr></tbody></table><p>紧接着，<code>0x0C5D</code>转换为二进制：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">0000 1100 0101 1101<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>紧接着，根据页表大小，$1KB &#x3D; 2^{10}B$，按字节编址，所以页内偏移需要$10\text{bit}$来表示，即为<code>0001011101</code></p><p>因为存储器有32个页面，$32 &#x3D; 2^5$,所以我们需要$5 \text{bit}$来表示页号,即为<code>00011</code>,虚拟页号对应十进制的<code>3</code>，通过查表，我们对应到物理地址的<code>8</code>号块，对应2进制<code>1000</code></p><p>内存为 $64 \text{KB} &#x3D; 2^{16}B$,按字节编址，需要$16 \text{bit}$来表示地址,因此需要补充前导0</p><p>因此最终的物理地址：</p><figure><div class="code-wrapper"><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">0010 0000 0101 1101    // 对应0x205D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="3-4-3-分页机制中的有效位"><a href="#3-4-3-分页机制中的有效位" class="headerlink" title="3.4.3 分页机制中的有效位"></a>3.4.3 分页机制中的有效位</h4><p>在分页机制中，操作系统使用页表（page table）来存储虚拟页和物理页框之间的映射关系。每个页表条目（PTE，Page Table Entry）通常包含以下信息：</p><ol><li><strong>物理页框地址</strong>：对应虚拟页映射到的物理页框地址。</li><li><strong>有效位（Valid Bit）</strong>：指示当前页是否有效，即该虚拟页是否已经映射到物理内存。</li><li><strong>其他控制位</strong>：如访问权限位、修改位（dirty bit）、引用位等。</li></ol><p>有效位的作用可以通过以下几种情况来解释：</p><p><strong>1. 有效位 &#x3D; 1</strong></p><ul><li>表示该页已经映射到物理内存，即虚拟页存在于物理页框中。操作系统可以直接访问该虚拟页对应的物理内存。</li><li>如果 CPU 要访问该虚拟页，硬件就会通过页表查找该页对应的物理页框地址，从而实现地址转换。</li></ul><p><strong>2. 有效位 &#x3D; 0</strong></p><ul><li>表示该虚拟页尚未映射到物理内存，或者该页映射不合法（例如，页未加载、该页不在物理内存中，或该页是无效的）。如果 CPU 尝试访问该虚拟页，会触发一个页错误（page fault）。</li><li>页错误通常会引发操作系统的处理机制（比如页面置换），它可能会从磁盘（例如交换空间或文件系统）加载该页到物理内存中，或者进行其他处理。</li></ul><p><strong>分页机制中的其他相关位：</strong></p><ol><li><p><strong>修改位（脏位，Dirty Bit）</strong>：表示该页自从加载到内存后是否被修改过。如果该页被修改过，操作系统可能会在需要将其写回磁盘时进行相应处理。</p></li><li><p><strong>访问位（Access Bit）</strong>：用于记录页是否被访问过，这对于实现页面置换算法（如最近最少使用算法，LRU）非常重要。</p></li><li><p><strong>保护位（Protection Bit）</strong>：用于控制该页的访问权限（如只读、可写、可执行等）。</p></li></ol><h3 id="3-5-段页式管理方式（Segmentation-with-Paging）"><a href="#3-5-段页式管理方式（Segmentation-with-Paging）" class="headerlink" title="3.5 段页式管理方式（Segmentation with Paging）"></a>3.5 段页式管理方式（Segmentation with Paging）</h3><p><strong>段页式管理（Segmentation with Paging）</strong> 结合了上述两种方式的优点。具体来说，段页式管理将进程的地址空间首先分为若干段，每个段再进一步划分为若干页。段页式管理的内存地址由两个部分组成：</p><ul><li><strong>段号（Segment Number）</strong>：指示访问的是哪个段。</li><li><strong>页号和页内偏移（Page Number and Offset）</strong>：指示访问的是哪个页和页内的具体位置。</li></ul><p><strong>步骤</strong></p><ol><li><strong>段表查找</strong>：根据段号查找段表，得到该段的基地址和段长。</li><li><strong>页表查找</strong>：根据页号查找页表，得到该页的物理地址。</li><li><strong>物理地址计算</strong>：将物理页框基地址与页内偏移合并，得到最终的物理地址。</li></ol><p><strong>优点</strong></p><ul><li><strong>逻辑清晰与高效利用</strong>：既保留了段式存储管理的逻辑单元划分，又利用了分页存储管理的高效内存利用方式。</li><li><strong>灵活性高</strong>：可以对每个段独立进行保护和管理。</li></ul><img src="/img/OS/segmentation_paging.svg" alt="段页式管理方式" style="max-width: 100%; height: auto;" /><p>段页式地址转换示例，这里假设：</p><ul><li>段大小：最大 4KB（$2^{12}$字节）</li><li>页大小：1KB（$2^{10}$字节）</li><li>每段最多可分4页</li><li>逻辑地址结构：3位段号 + 2位页号 + 10位页内偏移</li></ul><p>假设逻辑地址：<code>2,1,256</code>（段号2，页号1，偏移256）</p><p>段表：</p><table><thead><tr><th>段号</th><th>页表基址</th><th>段长度</th></tr></thead><tbody><tr><td>0</td><td>12000</td><td>2页</td></tr><tr><td>1</td><td>13000</td><td>4页</td></tr><tr><td>2</td><td>14000</td><td>3页</td></tr><tr><td>3</td><td>15000</td><td>1页</td></tr><tr><td>4</td><td>16000</td><td>4页</td></tr></tbody></table><p><strong>段2的页表（基址14000）</strong></p><table><thead><tr><th>页号</th><th>物理页号</th></tr></thead><tbody><tr><td>0</td><td>20</td></tr><tr><td>1</td><td>25</td></tr><tr><td>2</td><td>30</td></tr></tbody></table><p><strong>地址转换示例：</strong></p><ul><li>逻辑地址：段号&#x3D;2, 页号&#x3D;1, 页内偏移&#x3D;256</li><li>段表查找：段号2 → 页表基址14000</li><li>页表查找：页号1 → 物理页号25</li><li>计算物理地址：25 * 1024 + 256 &#x3D; 25856</li></ul><p>因此逻辑地址<code>2,1,256</code>转换为物理地址25856。</p><h3 id="3-6-TLB机制"><a href="#3-6-TLB机制" class="headerlink" title="3.6 TLB机制"></a>3.6 TLB机制</h3><p><strong>TLB（Translation Lookaside Buffer）</strong> 是一种高速缓存，用于加速虚拟地址到物理地址的转换过程。在现代操作系统中，虚拟内存技术使得程序运行时使用的是虚拟地址，而物理内存使用的是物理地址。每当程序访问内存时，硬件需要将虚拟地址转换为物理地址，这一过程通常由 <strong>内存管理单元（MMU）</strong> 完成。</p><p><strong>TLB机制的作用：</strong> 由于地址转换的过程可能涉及多次查找页表，而页表可能非常大，查找过程会比较慢。因此，TLB机制通过缓存最近使用的虚拟地址到物理地址的映射关系，来显著提高地址转换的速度。</p><hr><p><strong>TLB的工作原理</strong></p><ol><li><p><strong>TLB命中（Hit）</strong>：</p><ul><li>当CPU生成一个虚拟地址时，MMU会首先检查TLB是否已经缓存了该虚拟地址到物理地址的映射。如果找到映射（称为“TLB命中”），MMU直接返回物理地址，访问内存。</li></ul></li><li><p><strong>TLB未命中（Miss）</strong>：</p><ul><li>如果TLB中没有找到相应的映射（称为“TLB未命中”），MMU会访问页表，查找虚拟地址对应的物理地址，并将该映射加载到TLB中，以便下次访问时加速转换过程。</li></ul></li><li><p><strong>替换策略</strong>：</p><ul><li>当TLB已满且需要缓存新的映射时，硬件会采用一定的替换策略（如<strong>LRU</strong>，最近最少使用）来选择一个旧的映射项进行替换。</li></ul></li></ol><img src="/img/OS/tlb.svg" alt="TLB机制" style="max-width: 100%; height: auto;" /><p>举个例子来加深理解引入TLB之后的地址转换过程</p><p>当CPU需要访问内存时，会生成一个逻辑地址（虚拟地址）。MMU（内存管理单元）需要将该虚拟地址转换为物理地址。转换过程的第一步是检查TLB。</p><p>TLB是一个小型的、高速缓存，用于存储最近访问的虚拟地址到物理地址的映射。<br>当虚拟地址生成后，MMU首先使用虚拟页号查找TLB。</p><p>如果TLB中存储了虚拟页号对应的物理页框号（即映射），称为TLB命中。<br>如果命中，TLB直接返回物理页框号，然后将虚拟地址中的页内偏移与该物理页框号结合，形成完整的物理地址。</p><p><strong>物理地址 &#x3D; 物理页框号 + 页内偏移</strong></p><p><strong>示例：</strong></p><p>假设：</p><ul><li>虚拟地址：<code>0x1234 5678</code><ul><li>页号（20位）：<code>0x12345</code></li><li>页内偏移（12位）：<code>0x678</code></li></ul></li><li>TLB命中：虚拟页号 <code>0x12345</code> 映射到物理页框 <code>0x78901</code></li></ul><p>则物理地址：</p><ul><li><strong>物理地址 &#x3D; 0x78901 + 0x678</strong></li><li><strong>物理地址 &#x3D; 0x789679</strong></li></ul><p>如果在TLB中没有找到对应的映射（即TLB未命中），MMU会执行以下步骤：</p><ol><li><p><strong>访问页表</strong>：MMU会通过访问操作系统维护的页表来查找虚拟页号到物理页框号的映射。页表是一个数据结构，存储虚拟页号与物理页框号之间的关系。</p><p>页表的查找可能会采用多级页表（例如两级、三四级页表），每级页表根据虚拟地址的高位逐级查找。</p></li><li><p><strong>更新TLB</strong>：一旦页表返回物理页框号，MMU将这个映射加载到TLB中，以便下次访问时可以加速查找。</p></li><li><p><strong>生成物理地址</strong>：将页表中获取到的物理页框号与虚拟地址中的页内偏移结合，形成最终的物理地址。</p></li></ol><p><strong>物理地址 &#x3D; 物理页框号 + 页内偏移</strong></p><p><strong>示例：</strong></p><p>假设：</p><ul><li>虚拟地址：<code>0x1234 5678</code><ul><li>页号（20位）：<code>0x12345</code></li><li>页内偏移（12位）：<code>0x678</code></li></ul></li><li>TLB未命中：虚拟页号 <code>0x12345</code> 没有映射，需访问页表。</li><li>页表查询返回：物理页框号 <code>0x78901</code></li></ul><p>则物理地址：</p><ul><li><strong>物理地址 &#x3D; 0x78901 + 0x678</strong></li><li><strong>物理地址 &#x3D; 0x789679</strong></li></ul><p>如果TLB已满，需要替换其中的一个条目。常见的替换策略有：</p><ul><li>最佳页面置换算法（Optimal Page Replacement Algorithm）</li><li>最近最少使用页面置换算法（Least Recently Used, LRU）</li><li>先进先出页面置换算法（First-In-First-Out, FIFO）</li><li>时钟页面置换算法（Clock Page Replacement Algorithm）</li><li>最不常用页面置换算法（Least Frequently Used, LFU）</li></ul><hr><p>最后再简单做一个TLB的总结</p><table><thead><tr><th><strong>TLB的优点</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>提高性能</strong></td><td>由于TLB缓存了常用的虚拟地址到物理地址的映射，能够减少访问页表的次数，从而提高内存访问的速度。</td></tr><tr><td><strong>减少延迟</strong></td><td>通过快速查找TLB，减少了虚拟地址到物理地址转换的时间，减少了内存访问延迟。</td></tr></tbody></table><table><thead><tr><th><strong>TLB的局限性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>缓存命中率受限</strong></td><td>TLB的容量通常很小，仅能缓存最近访问的少量地址映射，因此，TLB的命中率可能受到限制。</td></tr><tr><td><strong>TLB Miss Penalty</strong></td><td>当发生TLB未命中时，访问页表会导致较大的延迟，因此TLB的命中率直接影响系统的性能。</td></tr></tbody></table><blockquote><p>TLB相关的有效内存访问时间计算，就根据概率来进行加权，可以直观理解，这里就不赘述了</p></blockquote><h3 id="3-7-请求调页（Demand-Paging）"><a href="#3-7-请求调页（Demand-Paging）" class="headerlink" title="3.7 请求调页（Demand Paging）"></a>3.7 请求调页（Demand Paging）</h3><p>请求调页是虚拟内存管理的一种机制，指的是：</p><ul><li>页面并不是在程序启动时就全部加载到内存，而是只有在程序访问某个页面时，操作系统才会将该页面从磁盘加载到物理内存中。</li><li>这种按需加载的方式避免了将整个程序或数据集加载到内存中，从而节省了内存空间。</li></ul><p>当程序访问一个尚未加载到内存的页面时，会触发缺页异常（Page Fault）。这时，操作系统会按照以下步骤处理：</p><ul><li>缺页异常触发：当进程访问一个不在物理内存中的虚拟页面时，硬件会触发缺页异常。</li><li>查找页面的磁盘位置：操作系统查找页表，确定虚拟页面的物理存储位置。如果该页面还未加载到内存中，操作系统会查找存储该页面的磁盘位置，通常是磁盘上的交换空间或文件系统。</li><li>从磁盘加载页面：操作系统会将该页面从磁盘加载到物理内存中的一个空闲页框（或通过页面置换腾出空间）。这个页面通常存储在交换空间（swap space）或映射文件中。</li><li>更新页表：一旦页面加载到内存中，操作系统会更新页表，将该虚拟页面的映射关系指向新的物理页框。</li></ul><img src="/img/OS/page_fault.svg" alt="缺页异常" style="max-width: 100%; height: auto;" /><p>在这里我们要区分2个重要的概念，分别是缺页（Page Fault）和抖动（Thrashing）</p><h4 id="3-7-1-缺页（Page-Fault）"><a href="#3-7-1-缺页（Page-Fault）" class="headerlink" title="3.7.1 缺页（Page Fault）"></a>3.7.1 缺页（Page Fault）</h4><p><strong>缺页</strong>是指在虚拟内存管理中，进程尝试访问的页面（虚拟地址空间中的一个块）不在物理内存中，导致操作系统需要处理的事件。</p><p><strong>缺页的发生过程</strong>：</p><ol><li><strong>进程访问虚拟地址</strong>：当进程尝试访问一个虚拟地址时，MMU（内存管理单元）会首先检查该地址是否已经映射到物理内存中的一个页面。</li><li><strong>缺页异常</strong>：如果虚拟地址对应的页面不在物理内存中，MMU会触发一个缺页异常（Page Fault）。这是操作系统介入并处理的信号。</li><li><strong>操作系统处理</strong>：<ul><li>操作系统通过查看进程的页表，确认该页面在磁盘上的位置，通常是在交换空间或某个文件中。</li><li>操作系统会将该页面从磁盘加载到物理内存中。</li><li>如果物理内存已满，操作系统需要使用<strong>页面置换算法</strong>选择一个页面从内存中换出并写回磁盘，以腾出空间给新的页面。</li></ul></li><li><strong>恢复程序执行</strong>：当页面被加载到内存后，操作系统更新页表，并恢复进程的执行，进程继续访问内存。</li></ol><p><strong>缺页的原因</strong>：</p><ul><li><strong>页面尚未加载</strong>：进程访问的页面可能从未加载到内存中。</li><li><strong>页面被换出</strong>：内存中的页面被操作系统换出到磁盘，以腾出空间给其他页面。</li><li><strong>大块数据访问</strong>：对于大数据结构或程序，操作系统可能会选择按需加载数据，避免加载整个文件或数据集。</li></ul><p><strong>缺页的影响</strong>：</p><ul><li>缺页会导致内存访问的延迟，因为需要从磁盘加载页面，而磁盘I&#x2F;O速度远慢于内存。</li><li>当缺页频繁发生时，会增加磁盘访问次数，降低系统性能。</li></ul><p><strong>缺页的处理策略</strong>：</p><ul><li>增加物理内存（最直接的办法）</li><li>优化程序内存使用</li><li>使用页面置换算法</li><li>减少并发进程数</li><li>使用压缩内存技术</li><li>优化内存映射文件的使用</li><li>使用合适的磁盘存储和交换空间</li></ul><h4 id="3-7-2-抖动（Thrashing）"><a href="#3-7-2-抖动（Thrashing）" class="headerlink" title="3.7.2 抖动（Thrashing）"></a>3.7.2 <strong>抖动（Thrashing）</strong></h4><p><strong>抖动</strong>是指系统由于频繁的页面缺失和页面置换导致的性能急剧下降的现象。抖动通常发生在系统的物理内存不足时，操作系统不停地将页面从内存换出到磁盘，又从磁盘换入新页面，造成大量的磁盘I&#x2F;O操作，从而使得系统的响应速度极慢，甚至完全停止响应。有的书对抖动也称之为<strong>颠簸（Bouncing）</strong>。</p><p><strong>抖动的发生过程</strong>：</p><ol><li><strong>内存不足</strong>：系统的物理内存不足以容纳当前运行的所有进程和页面。</li><li><strong>频繁的页面置换</strong>：由于内存不足，操作系统不断地将一些页面换出到磁盘，同时又需要加载新的页面。这会导致大量的页面置换操作，频繁的磁盘I&#x2F;O。</li><li><strong>严重的性能下降</strong>：每次页面缺失时，操作系统需要从磁盘加载页面，由于磁盘I&#x2F;O速度远低于内存，整个过程会非常缓慢。当页面置换频繁发生时，系统的性能会急剧下降，进程的执行几乎停滞。</li></ol><p><strong>抖动的症状</strong>：</p><ul><li><strong>CPU利用率低</strong>：虽然CPU处于工作状态，但由于大量时间被浪费在页面置换上，CPU的实际工作负载非常低。</li><li><strong>高磁盘I&#x2F;O</strong>：系统的磁盘I&#x2F;O非常高，因为操作系统需要频繁读写磁盘。</li><li><strong>响应缓慢</strong>：由于缺页和页面置换，进程的响应速度非常慢，甚至可能完全停止。</li></ul><p><strong>抖动的原因</strong>：</p><ul><li><strong>内存过载</strong>：系统没有足够的内存来运行当前的程序。当进程需要的内存页数超出了物理内存的容量时，就会频繁发生页面置换。</li><li><strong>不合理的页面置换策略</strong>：如果页面置换算法选择不当，可能导致过多的页面被频繁换出和换入，从而引发抖动。</li><li><strong>大量进程竞争内存</strong>：多个进程同时运行并争夺有限的内存资源，也会导致频繁的页面交换。</li></ul><p><strong>抖动的解决方法</strong>：</p><ol><li><strong>增加物理内存</strong>：最直接的方式是增加系统的物理内存容量，从而减少频繁的页面置换。</li><li><strong>优化程序</strong>：减少程序的内存使用，尤其是避免大数据结构在内存中的频繁访问。</li><li><strong>改进页面置换算法</strong>：选择更合适的页面置换算法，如LRU、时钟算法等，以减少不必要的页面置换。</li><li><strong>减少并发进程数</strong>：通过限制同时运行的进程数量，避免多个进程同时占用过多内存。</li></ol><figure>  <img src="/img/OS/thrashing.svg" alt="抖动" style="max-width: 100%; height: auto;" />  <figcaption style="font-size: small; text-align: center;">注意看，频繁换出换入的页面在闪烁</figcaption></figure><p><strong>总结：</strong></p><ul><li><strong>缺页</strong>是指进程尝试访问的页面不在物理内存中，需要从磁盘加载。</li><li><strong>抖动</strong>是系统因频繁的页面置换而导致的性能严重下降现象，通常发生在系统内存不足时，频繁的页面缺失和加载导致大量磁盘I&#x2F;O和系统响应迟缓。</li></ul><h3 id="3-8-页面置换算法"><a href="#3-8-页面置换算法" class="headerlink" title="3.8 页面置换算法"></a>3.8 页面置换算法</h3><p>页面置换算法是操作系统内存管理中的一个重要机制，用于决定在物理内存已满的情况下，哪一个页面应当被移出内存以腾出空间来加载新的页面。这个过程称为页面置换。页面置换算法的主要目的是提高系统的内存利用效率和整体性能。下面重点讲解一下常见的页面置换算法。</p><h4 id="3-8-1-最佳页面置换算法（Optimal-Page-Replacement-Algorithm）"><a href="#3-8-1-最佳页面置换算法（Optimal-Page-Replacement-Algorithm）" class="headerlink" title="3.8.1 最佳页面置换算法（Optimal Page Replacement Algorithm）"></a>3.8.1 最佳页面置换算法（Optimal Page Replacement Algorithm）</h4><p><strong>最佳页面置换算法（Optimal Page Replacement Algorithm）</strong> 是一种理论上的页面置换算法，它通过预见未来的页面访问模式来做出最优决策，选择在未来最长时间内不会再被访问的页面进行置换。</p><p><strong>算法原理</strong>：</p><ul><li><strong>基本思想</strong>：最佳页面置换算法的核心思想是，当内存中的页面已满，操作系统需要选择一个页面将其从内存中移除。该算法通过预测接下来最久不会被访问的页面进行置换，从而最小化缺页率。</li><li><strong>理想情况</strong>：由于它需要知道未来的页面访问序列，这使得该算法在实际操作系统中无法实现，因为操作系统无法预测未来的页面访问模式。但是，它是评估其他页面置换算法的一个理论基准。</li></ul><p><strong>具体操作</strong>：</p><ol><li><p><strong>判断是否缺页</strong>：当进程访问某个页面时，操作系统首先检查该页面是否已经在内存中。如果该页面已经在内存中，则继续执行；如果不在内存中，则发生缺页。</p></li><li><p><strong>选择页面置换</strong>：在内存已满的情况下，操作系统选择一个页面进行置换。最佳页面置换算法选择的是那些在接下来最长时间内不会被访问的页面进行置换。</p><ul><li>例如，如果某个页面接下来有很长一段时间不再被访问，而其他页面会在较短时间内被访问到，那么该页面就会被置换。</li></ul></li><li><p><strong>更新内存</strong>：将被置换的页面从内存中移出，并将新的页面加载到内存中。</p></li></ol><p><strong>优点</strong>：</p><ul><li><strong>理论最优</strong>：最佳页面置换算法在所有页面置换算法中提供了最小的缺页率，因为它总是选择最合适的页面进行置换，最大化内存的利用率。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不可实现</strong>：实际系统无法预测未来的页面访问顺序，因此无法实现最佳页面置换算法。操作系统只能依赖于当前的页面访问信息做出决策，无法像该算法那样知道未来的访问情况。</li><li><strong>计算成本高</strong>：如果实现类似的算法，可能需要持续追踪所有页面的未来访问情况，这在实际操作中开销较大。</li></ul><p>举个简单的例子：假设有一个内存管理系统，其物理内存有 3 个页框，进程产生的页面访问序列如下：<code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2</code></p><p>OPT算法步骤：</p><ol><li>初始状态：页框为空</li><li>访问页面 <code>7</code>：<ul><li>页面 <code>7</code> 加入内存，[7]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 加入内存，[7, 0]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，[7, 0, 1]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>OPT 算法会选择未来最久不使用的页面。此时，<code>7</code> 最久不使用，因此置换掉 <code>7</code>，加入 <code>2</code>，[2, 0, 1]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 1]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>OPT 算法选择未来最久不使用的页面。此时，<code>1</code> 最久不使用，因此置换掉 <code>1</code>，加入 <code>3</code>，[2, 0, 3]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 3]</li></ul></li></ol><blockquote><p>后面的顺序可以直观理解，这里就不赘述了</p></blockquote><p>最佳页面置换算法在理论上是最优的，但由于实际无法预测未来的页面访问模式，因此无法在实际操作系统中实现,但它为其他页面置换算法（如 LRU 和 FIFO）提供了一个参照标准，帮助我们评估这些算法的性能。</p><hr><h4 id="3-8-2-最近最少使用页面置换算法（Least-Recently-Used-LRU）"><a href="#3-8-2-最近最少使用页面置换算法（Least-Recently-Used-LRU）" class="headerlink" title="3.8.2 最近最少使用页面置换算法（Least Recently Used, LRU）"></a>3.8.2 最近最少使用页面置换算法（Least Recently Used, LRU）</h4><p>LRU 算法选择最近一段时间内最少使用的页面进行置换，基于这样一个假设：最近使用过的页面在未来仍然可能会被使用，而很久没使用的页面将来可能不再使用。</p><p>举例说明：假设有一个内存管理系统，其物理内存有 3 个页框，进程产生的页面访问序列如下：<code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2</code></p><p><strong>步骤如下：</strong></p><ol><li>初始状态 ：页框为空</li><li>访问页面 <code>7</code> ：<ul><li>页面 <code>7</code> 加入内存，[7]</li></ul></li><li>访问页面 <code>0</code> ：<ul><li>页面 <code>0</code> 加入内存，[7, 0]</li></ul></li><li>访问页面 <code>1</code> ：<ul><li>页面 <code>1</code> 加入内存，[7, 0, 1]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>LRU 算法会选择最近最少使用的页面。此时，<code>7</code> 最近最少使用，因此置换掉 <code>7</code>，加入 <code>2</code>，[2, 0, 1]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 1]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>1</code> 最近最少使用，因此置换掉 <code>1</code>，加入 <code>3</code>，[2, 0, 3]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[2, 0, 3]</li></ul></li><li>访问页面 <code>4</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>2</code> 最近最少使用，因此置换掉 <code>2</code>，加入 <code>4</code>，[4, 0, 3]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>3</code> 最近最少使用，因此置换掉 <code>3</code>，加入 <code>2</code>，[4, 0, 2]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>0</code> 最近最少使用，因此置换掉 <code>0</code>，加入 <code>3</code>，[4, 3, 2]</li></ul></li><li>访问页面 <code>0</code>（内存已满）：<ul><li>LRU 算法选择最近最少使用的页面。此时，<code>4</code> 最近最少使用，因此置换掉 <code>4</code>，加入 <code>0</code>，[0, 3, 2]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 已在内存中，无需置换，[0, 3, 2]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 已在内存中，无需置换，[0, 3, 2]</li></ul></li></ol><p>通过上述一系列页面访问，LRU 算法有效地将最近最少使用的页面置换出去，优化了内存使用效率。</p><hr><h4 id="3-8-3-先进先出页面置换算法（First-In-First-Out-FIFO）"><a href="#3-8-3-先进先出页面置换算法（First-In-First-Out-FIFO）" class="headerlink" title="3.8.3 先进先出页面置换算法（First-In-First-Out, FIFO）"></a>3.8.3 先进先出页面置换算法（First-In-First-Out, FIFO）</h4><p><strong>先进先出页面置换算法（FIFO）</strong> 是最简单的页面置换算法之一。其基本思想是，当内存已满且需要进行页面置换时，选择最早进入内存的页面进行置换。FIFO 算法的工作方式类似于排队的原理，先到的页面先被移出内存。</p><ul><li><strong>基本思路</strong>：FIFO 将页面访问序列看作一个队列。每当一个页面被加载到内存时，它会被放到队列的末尾。每当需要置换页面时，操作系统选择队列头部的页面进行置换，即最早进入内存的页面。</li><li><strong>页面置换</strong>：当进程需要访问一个页面，而该页面不在内存中时，发生缺页。此时操作系统会选择内存中最早加载的页面进行置换。</li></ul><p><strong>FIFO算法的工作流程</strong>：</p><ol><li><strong>页面访问</strong>：进程访问某个页面时，操作系统检查该页面是否已在内存中。如果在内存中，直接访问；如果不在内存中，则发生缺页。</li><li><strong>置换操作</strong>：当内存已满时，操作系统根据FIFO算法选择队列头部的页面进行置换，然后将新页面加载到内存中，并将其添加到队列的末尾。</li></ol><p>假设有一个内存管理系统，其物理内存有 3 个页框，进程产生的页面访问序列如下：<code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2</code></p><p><strong>FIFO算法步骤：</strong></p><ol><li>初始状态：页框为空</li><li>访问页面 <code>7</code>：<ul><li>页面 <code>7</code> 加入内存，[7]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 加入内存，[7, 0]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，[7, 0, 1]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>FIFO 算法会选择最早进入内存的页面。此时，<code>7</code> 最早进入，因此置换掉 <code>7</code>，加入 <code>2</code>，[0, 1, 2]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 已在内存中，无需置换，[0, 1, 2]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>0</code> 最早进入，因此置换掉 <code>0</code>，加入 <code>3</code>，[1, 2, 3]</li></ul></li><li>访问页面 <code>0</code>：<ul><li>页面 <code>0</code> 加入内存，替换最早进入的页面 <code>1</code>，[2, 3, 0]</li></ul></li><li>访问页面 <code>4</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>2</code> 最早进入，因此置换掉 <code>2</code>，加入 <code>4</code>，[3, 0, 4]</li></ul></li><li>访问页面 <code>2</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>3</code> 最早进入，因此置换掉 <code>3</code>，加入 <code>2</code>，[0, 4, 2]</li></ul></li><li>访问页面 <code>3</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>0</code> 最早进入，因此置换掉 <code>0</code>，加入 <code>3</code>，[4, 2, 3]</li></ul></li><li>访问页面 <code>0</code>（内存已满）：<ul><li>FIFO 算法选择最早进入内存的页面。此时，<code>4</code> 最早进入，因此置换掉 <code>4</code>，加入 <code>0</code>，[2, 3, 0]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 已在内存中，无需置换，[2, 3, 0]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 已在内存中，无需置换，[2, 3, 0]</li></ul></li></ol><p>通过上述一系列页面访问，FIFO 算法按照进入内存的顺序进行置换，维护了简单的页面管理逻辑。</p><p><strong>FIFO算法优点</strong>：</p><ul><li><strong>简单易懂</strong>：FIFO 算法非常简单，易于实现。</li><li><strong>实现简单</strong>：只需维护一个队列，记录页面的加载顺序。</li></ul><p><strong>FIFO算法缺点</strong>：</p><ul><li><strong>不考虑页面的实际使用频率</strong>：FIFO 仅根据页面的加载顺序进行置换，而不考虑页面被访问的频率或最近是否被访问过。因此，它可能会导致页面置换的效率低下。</li><li><strong>可能导致“Belady’s Anomaly”</strong>：在某些情况下，增加内存的数量反而可能导致缺页率增加，这种现象被称为 Belady’s Anomaly。</li></ul><blockquote><p>Belady现象：当为进程分配的物理块数增大时，缺页次数不减反增。<strong>只有FIFO算法</strong>发生Belady异常。FIFO实现简单，但不适应，算法性能差</p></blockquote><hr><h4 id="3-8-4-时钟页面置换算法（Clock-Page-Replacement-Algorithm）"><a href="#3-8-4-时钟页面置换算法（Clock-Page-Replacement-Algorithm）" class="headerlink" title="3.8.4 时钟页面置换算法（Clock Page Replacement Algorithm）"></a>3.8.4 时钟页面置换算法（Clock Page Replacement Algorithm）</h4><p>时钟页面置换算法是一种改进的最近最少使用（LRU）算法。它通过一个环形缓冲区（类似于时钟）和一个使用位（Use bit）来决定页面的置换。算法的核心思想是对页面进行循环扫描，当发现某个页面的使用位为 0 时，将其置换出去；否则，将其使用位清零，并继续扫描下一个页面。</p><p>假设有一个内存管理系统，其物理内存有 4 个页框，进程产生的页面访问序列如下：<code>1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5</code></p><p><strong>步骤：</strong></p><ol><li>初始状态：页框为空，指针指向第一个页框</li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*, 2*]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*]</li></ul></li><li>访问页面 <code>4</code>：<ul><li>页面 <code>4</code> 加入内存，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*, 4*]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 已在内存中，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*, 4*]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 已在内存中，设置使用位为 1，指针指向下一个页框 [1*, 2*, 3*, 4*]</li></ul></li><li>访问页面 <code>5</code>（内存已满）：<ul><li>指针指向页面 <code>1</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>2</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>3</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>4</code>，使用位为 1，将其使用位清零，指针移动</li><li>指针指向页面 <code>1</code>，使用位为 0，将其置换为 <code>5</code>，设置使用位为 1，指针移动 [5*, 2, 3, 4]</li></ul></li><li>访问页面 <code>1</code>：<ul><li>页面 <code>1</code> 加入内存，置换页面 <code>2</code>，设置使用位为 1，指针移动 [5*, 1*, 3, 4]</li></ul></li><li>访问页面 <code>2</code>：<ul><li>页面 <code>2</code> 加入内存，置换页面 <code>3</code>，设置使用位为 1，指针移动 [5*, 1*, 2*, 4]</li></ul></li><li>访问页面 <code>3</code>：<ul><li>页面 <code>3</code> 加入内存，置换页面 <code>4</code>，设置使用位为 1，指针移动 [5*, 1*, 2*, 3*]</li></ul></li><li>访问页面 <code>4</code>：<ul><li>页面 <code>4</code> 加入内存，置换页面 <code>5</code>，设置使用位为 1，指针移动 [4*, 1*, 2*, 3*]</li></ul></li><li>访问页面 <code>5</code>：<ul><li>页面 <code>5</code> 加入内存，置换页面 <code>1</code>，设置使用位为 1，指针移动 [4*, 5*, 2*, 3*]</li></ul></li></ol><hr><h4 id="3-8-5-最不常用页面置换算法（Least-Frequently-Used-LFU）"><a href="#3-8-5-最不常用页面置换算法（Least-Frequently-Used-LFU）" class="headerlink" title="3.8.5 最不常用页面置换算法（Least Frequently Used, LFU）"></a>3.8.5 最不常用页面置换算法（Least Frequently Used, LFU）</h4><p><strong>最不常用页面置换算法（LFU）</strong> 是一种根据页面访问频率进行页面置换的算法。LFU 的核心思想是将最少被访问的页面优先置换出去。即，系统会跟踪每个页面的访问次数，并选择访问次数最少的页面进行置换。</p><ul><li><strong>基本思路</strong>：LFU 维护一个计数器，用于记录每个页面被访问的频率。每当一个页面被访问时，其访问计数器增加。算法会选择那些访问次数最少的页面进行置换。</li><li><strong>页面置换</strong>：当内存已满且需要进行页面置换时，LFU 选择访问次数最少的页面。如果多个页面的访问频率相同，则选择其中最久未被访问的页面。</li></ul><p><strong>LFU算法的工作流程</strong>：</p><ol><li><strong>页面访问</strong>：每当一个页面被访问时，操作系统会将该页面的访问频率计数器加 1。</li><li><strong>页面置换</strong>：当内存已满时，系统选择访问频率最低的页面进行置换。如果多个页面的访问频率相同，系统将选择最久未被访问的页面进行置换。</li></ol><p>假设系统的内存可以存放 3 个页面，且进程的页面访问序列如下：<code>A, B, C, A, B, D, A, B, C, D</code></p><p><strong>初始状态：</strong></p><ul><li>内存容量为 3，初始为空。</li><li>访问序列：<code>A, B, C, A, B, D, A, B, C, D</code></li></ul><p><strong>按照访问序列进行页面置换</strong></p><ol><li><p><strong>访问页面 A</strong>：加载 A 到内存，访问频率为 1。</p><ul><li>内存状态：[A]</li></ul></li><li><p><strong>访问页面 B</strong>：加载 B 到内存，访问频率为 1。</p><ul><li>内存状态：[A, B]</li></ul></li><li><p><strong>访问页面 C</strong>：加载 C 到内存，访问频率为 1。</p><ul><li>内存状态：[A, B, C]</li></ul></li><li><p><strong>访问页面 A</strong>：A 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (2), B, C]</li></ul></li><li><p><strong>访问页面 B</strong>：B 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (2), B (2), C]</li></ul></li><li><p><strong>访问页面 D</strong>：内存已满，选择访问频率最低的页面 C 进行置换，加载 D 到内存。</p><ul><li>内存状态：[A (2), B (2), D (1)]</li></ul></li><li><p><strong>访问页面 A</strong>：A 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (3), B (2), D (1)]</li></ul></li><li><p><strong>访问页面 B</strong>：B 已经在内存中，访问频率加 1。</p><ul><li>内存状态：[A (3), B (3), D (1)]</li></ul></li><li><p><strong>访问页面 C</strong>：选择访问频率最低的页面 D 进行置换，加载 C 到内存。</p><ul><li>内存状态：[A (3), B (3), C (1)]</li></ul></li><li><p><strong>访问页面 D</strong>：选择访问频率最低的页面 C 进行置换，加载 D 到内存。</p><ul><li>内存状态：[A (3), B (3), D (2)]</li></ul></li></ol><p><strong>最终内存状态</strong>：</p><ul><li>内存状态：[A, B, D]</li><li>页面置换序列：[C -&gt; D, C -&gt; D]</li></ul><p><strong>LFU算法的优缺点</strong>：</p><p><strong>优点</strong>：</p><ul><li><strong>考虑访问频率</strong>：LFU 算法通过考虑页面的访问频率，更加合理地选择置换页面，通常可以减少置换不常用的页面，减少缺页率。</li><li><strong>适用于长期不变的访问模式</strong>：当某些页面频繁访问时，LFU 能够有效保留这些页面，避免频繁置换。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>需要额外的空间和计算</strong>：LFU 需要维护每个页面的访问计数，并且在页面置换时可能需要遍历所有页面来查找访问频率最少的页面，增加了额外的空间和计算开销。</li><li><strong>容易受到初始访问模式的影响</strong>：如果页面的访问模式变化较大，LFU 可能会将那些短期内访问较少的页面置换出去，导致“页面漂移”问题。</li></ul><p>LFU 算法根据页面的访问频率来决定置换哪个页面，优先置换那些访问频率较低的页面。尽管 LFU 能够较好地反映页面的实际访问情况，但它在实现上比较复杂，并且在一些动态变化的访问模式下可能效率较低。</p><h2 id="4-File-Management"><a href="#4-File-Management" class="headerlink" title="4. File Management"></a>4. File Management</h2><p>文件的常见属性如下：</p><ol><li><p><strong>文件名（File Name）</strong></p><ul><li><strong>定义</strong>：文件名是操作系统用来标识文件的名称，它通常包括文件的主名和扩展名（例如：<code>document.txt</code>）。</li><li><strong>特点</strong>：在同一目录下，文件名必须唯一，否则会发生冲突。不同操作系统对文件名的长度和字符限制有所不同（例如，Windows不允许使用某些特殊字符，如 <code>*</code>, <code>?</code>, <code>:</code>, 等）。</li></ul></li><li><p><strong>标识符（Identifier）</strong></p><ul><li><strong>定义</strong>：标识符是操作系统用来唯一标识一个文件的内部名称。它对用户是不可见的。</li><li><strong>作用</strong>：操作系统通过标识符来区分不同的文件，即使它们的文件名相同。在操作系统内部，每个文件都需要一个独立的标识符，以避免文件冲突或误操作。</li></ul></li><li><p><strong>类型（Type）</strong></p><ul><li><strong>定义</strong>：文件类型指示文件的内容类别或格式（例如，文本文件、图像文件、音频文件等）。</li><li><strong>作用</strong>：文件类型可以帮助操作系统和用户理解文件的内容，甚至决定如何打开或处理该文件。例如，一个 <code>.txt</code> 文件通常表示纯文本文件，而 <code>.jpg</code> 则表示图像文件。操作系统通过文件扩展名或文件头来判断文件类型。</li></ul></li><li><p><strong>位置（Location）</strong></p><ul><li><strong>定义</strong>：文件位置表示文件在存储设备中的存放路径。</li><li><strong>作用</strong>：<ul><li><strong>用户使用的路径</strong>：这通常是用户查看和访问文件时所看到的路径，例如 <code>/home/user/documents/file.txt</code>。</li><li><strong>操作系统使用的地址</strong>：这是文件实际在存储设备（如硬盘）上的物理存放位置。这个信息通常是操作系统内部使用的，用户一般无法直接看到或修改。</li></ul></li></ul></li><li><p><strong>大小（Size）</strong></p><ul><li><strong>定义</strong>：文件的大小表示文件占用的存储空间量，通常以字节（byte）为单位。</li><li><strong>作用</strong>：文件大小帮助操作系统了解文件所需的存储空间，并且对用户来说，它是了解文件内容多少的一个重要指标。例如，一个 1MB 的图像文件相较于一个 10KB 的文本文件显然占用了更多的存储空间。</li></ul></li><li><p><strong>创建信息、上次修改时间、文件所有者信息（Creation Info, Last Modified Time, File Owner Info）</strong></p><ul><li><strong>定义</strong>：这些是文件的元数据，记录了文件的创建时间、最后一次修改的时间以及文件的所有者等信息。</li><li><strong>作用</strong>：<ul><li><strong>创建信息</strong>：记录文件的创建时间，帮助用户或系统追踪文件的生命周期。</li><li><strong>上次修改时间</strong>：记录文件最后一次被修改的时间，通常用于文件管理和版本控制。</li><li><strong>文件所有者信息</strong>：记录文件的拥有者和对文件的权限，通常与操作系统的权限管理系统相关，用来决定谁可以访问、修改文件。</li></ul></li></ul></li><li><p><strong>保护信息（Protection Info）</strong></p><ul><li><strong>定义</strong>：保护信息是文件的访问控制信息，指定哪些用户或程序可以读取、修改或删除文件。</li><li><strong>作用</strong>：操作系统通常通过权限（如读、写、执行权限）来保护文件，防止未授权的访问或操作。文件的保护信息决定了文件的安全性，确保只有具有适当权限的用户能够进行相关操作。</li></ul></li></ol><h3 id="4-1-文件在外存的存在方式"><a href="#4-1-文件在外存的存在方式" class="headerlink" title="4.1 文件在外存的存在方式"></a>4.1 文件在外存的存在方式</h3><p>文件在外存中存在的方式是由操作系统和存储设备的类型（如硬盘、固态硬盘、光盘、磁带等）共同决定的。外存（外部存储）是指计算机系统中的长期存储介质，和内存（RAM）相比，外存具有更大的存储容量，但访问速度较慢。文件在外存中的存储方式涉及文件的组织结构、存储地址分配、数据存储方法等多个方面。以下是文件如何在外存中存储的详细解释：</p><p><strong>1.文件的逻辑组织与物理存储</strong></p><p><strong>逻辑组织</strong></p><ul><li><strong>文件</strong>：文件是操作系统管理的基本数据单位，通常由文件名、文件类型、文件内容和元数据（如创建时间、修改时间、权限等）组成。用户通过文件系统对文件进行访问，而不需要关注文件在物理设备上的存储方式。</li><li><strong>目录结构</strong>：文件在外存中通常通过目录结构进行管理。目录（也叫文件夹）用来组织文件，以便于查找和管理。操作系统通过文件路径来定位文件的位置，路径可以是相对路径或绝对路径。</li></ul><p><strong>物理存储</strong></p><ul><li><p><strong>存储介质</strong>：外存设备（如硬盘、SSD）提供了文件存储的实际硬件介质。不同的存储设备有不同的存储方式。例如：</p><ul><li>硬盘（HDD）存储数据为磁性信号，采用磁头在盘片上移动进行读写。</li><li>固态硬盘（SSD）使用闪存芯片存储数据，通过电子信号读写数据。</li><li>光盘（CD&#x2F;DVD）使用激光束读取和写入数据。</li></ul><p>虽然存储介质不同，但大多数情况下文件的存储方式都基于 <strong>块（Block）</strong> 或 <strong>簇（Cluster）</strong> 的概念，即文件会被划分成多个小块，分布在存储介质的不同位置。</p></li></ul><p><strong>2.文件在外存中的存储方式</strong></p><p><strong>连续存储方式（Contiguous Allocation）</strong></p><ul><li>在这种方式下，文件的所有数据块是连续存储的。即文件内容被写入外存时，操作系统会为其分配一段连续的存储空间，确保文件的所有数据都在这段空间内。</li><li><strong>优点</strong>：读取速度较快，因为文件的数据存储在连续的块中，磁头无需频繁跳转。</li><li><strong>缺点</strong>：随着文件的增加和删除，外存中的空闲空间可能变得零散，这会导致“外碎片”，并且难以为大型文件分配足够大的连续空间。</li></ul><p><strong>链式存储方式（Linked Allocation）</strong></p><ul><li>在这种方式下，文件被分成多个数据块，每个数据块都包含一个指向下一个数据块的指针。文件的数据块可以存储在磁盘上的任何位置，操作系统通过指针链接这些数据块。</li><li><strong>优点</strong>：可以灵活地分配空间，不需要连续的存储块，可以避免外碎片问题。</li><li><strong>缺点</strong>：由于每个数据块都包含指针，读取时需要多次磁盘寻址，速度相对较慢。</li></ul><p><strong>索引存储方式（Indexed Allocation）</strong></p><ul><li>在这种方式下，操作系统为每个文件创建一个索引块，该索引块包含指向文件数据块的指针。文件的实际数据块可以存储在磁盘上的任何位置，操作系统通过索引块来查找文件的各个数据块。</li><li><strong>优点</strong>：提高了查找效率，文件的各个数据块可以非连续存储，避免了外碎片问题。</li><li><strong>缺点</strong>：需要额外的存储空间来保存索引块，且对于大文件，索引块可能需要多级索引。</li></ul><img src="/img/OS/file_storage.svg" alt="文件在外存的存储方式" style="max-width: 100%; height: auto;" /><p><strong>3.文件系统（File System）</strong></p><p>文件系统是操作系统与存储设备之间的桥梁，它定义了文件如何在外存中存储、管理、访问和保护。文件系统负责将逻辑文件映射到物理存储介质上。</p><p><strong>常见的文件系统类型</strong></p><ul><li><strong>FAT（File Allocation Table）</strong>：FAT 是一种早期的文件系统，适用于小型存储设备。它采用简单的链式存储方式，通过一个文件分配表记录文件数据块的存储位置。</li><li><strong>NTFS（New Technology File System）</strong>：NTFS 是 Windows 操作系统常用的文件系统，支持更复杂的文件存储方式，如索引存储、文件权限管理、加密等。</li><li><strong>ext3&#x2F;ext4</strong>：Linux 操作系统常用的文件系统。ext4 是 ext3 的改进版，提供更好的性能、可靠性和更大的文件支持。</li><li>HFS+：macOS 使用的文件系统，支持元数据和文件权限控制。</li></ul><p><strong>文件系统的工作原理</strong></p><ul><li><strong>文件分配</strong>：操作系统通过文件系统将文件划分成多个数据块，并将这些数据块分配到外存中。不同文件系统可能使用不同的分配策略（如连续分配、链式分配、索引分配等）。</li><li><strong>目录管理</strong>：文件系统通过目录结构来组织文件。每个文件都有一个唯一的路径，路径帮助操作系统找到文件的位置。目录项通常包含文件名、文件大小、创建时间、修改时间、权限等信息。</li><li><strong>文件元数据</strong>：文件的元数据（如创建时间、权限等）存储在文件系统的索引节点（inode）或类似结构中。这些元数据有助于文件的管理和访问控制。</li></ul><p><strong>4.访问文件</strong></p><p>文件一旦存储到外存中，用户或程序就可以通过文件路径访问文件。操作系统通过文件系统将用户的请求转化为磁盘读写操作：</p><ul><li><strong>读取文件</strong>：操作系统根据文件路径找到文件的索引信息，然后查找文件在外存中的数据块。接着，操作系统读取这些数据块，并将文件内容返回给用户。</li><li><strong>写入文件</strong>：当文件需要修改时，操作系统会分配新的数据块（如果需要）并将修改后的内容写入外存。同时，文件的元数据（如修改时间）也会被更新。</li></ul><p><strong>5.文件的保护与安全</strong></p><p>操作系统通过文件系统提供对文件的保护机制，确保文件的安全性和完整性。这些保护措施包括：</p><ul><li><strong>权限控制</strong>：文件系统通常会为文件设置访问权限（如读、写、执行权限），并为每个用户或用户组设置不同的权限，以限制未授权的访问。</li><li><strong>加密与备份</strong>：操作系统还可以通过加密技术保护文件的内容，并通过备份机制防止文件丢失或损坏。</li></ul><hr><h3 id="4-2-文件管理功能"><a href="#4-2-文件管理功能" class="headerlink" title="4.2 文件管理功能"></a>4.2 文件管理功能</h3><p>操作系统向上提供的文件管理功能是通过系统调用来实现的。系统调用是程序与操作系统之间的接口，用户程序通过系统调用请求操作系统执行某些任务，如文件的创建、删除、读写等。以下是每个功能的详细解释：</p><p><strong>1.创建文件 (create 系统调用)</strong></p><p>功能：</p><ul><li><code>create</code> 系统调用用于在文件系统中创建一个新的文件。当用户希望在磁盘或其他外部存储设备上存储数据时，首先需要创建一个文件。</li></ul><p>过程：</p><ul><li>操作系统首先检查文件名是否有效，以及是否已经存在同名文件。</li><li>如果文件名有效且没有同名文件，操作系统会为该文件分配一个唯一的文件标识符，并在文件系统中为文件分配存储空间。</li><li>创建文件时，操作系统通常会为该文件生成相关的元数据（如创建时间、权限等）。</li></ul><p>返回值：</p><ul><li>成功时，返回一个指向新文件的文件描述符（用于后续的读写操作）。</li><li>失败时，返回错误代码（如文件已存在、权限不足等）。</li></ul><p><strong>2.删除文件 (delete 系统调用)</strong></p><p>功能：</p><ul><li><code>delete</code> 系统调用用于删除指定的文件。它将文件从文件系统中移除，释放文件所占用的存储空间。</li></ul><p>过程：</p><ul><li>操作系统首先会检查文件是否存在。如果文件不存在，删除操作将失败。</li><li>接着，操作系统会清除文件的目录项，删除与文件相关的元数据。</li><li>文件的实际数据块也会被标记为空闲，准备供其他文件使用。</li><li>删除文件时，操作系统还会处理可能的文件锁定和权限问题，确保删除操作不会影响正在访问该文件的进程。</li></ul><p>返回值：</p><ul><li>成功时，文件会被删除，返回成功状态。</li><li>失败时，返回错误代码（如文件不存在、权限不足等）。</li></ul><p><strong>3.读文件 (read 系统调用)</strong></p><p>功能：</p><ul><li><code>read</code> 系统调用用于从已经打开的文件中读取数据。进程使用 <code>read</code> 调用将文件中的内容加载到内存中，供程序使用。</li></ul><p>过程：</p><ul><li>操作系统检查文件是否已经被成功打开。</li><li>操作系统会根据文件描述符定位文件的当前读取位置，并从文件中读取指定大小的数据。</li><li>读取的数据会存储在用户提供的缓冲区中，供进程使用。</li><li>每次读取后，操作系统会更新文件的指针，指向下一个待读取的位置。</li></ul><p>返回值：</p><ul><li>成功时，返回实际读取的字节数。如果到达文件末尾，返回 0。</li><li>失败时，返回错误代码（如文件不存在、权限问题等）。</li></ul><p><strong>4.写文件 (write 系统调用)</strong></p><p>功能：</p><ul><li><code>write</code> 系统调用用于将数据写入到已经打开的文件中。进程通过该调用向文件中存储数据。</li></ul><p>过程：</p><ul><li>操作系统检查文件是否已经打开并具有写权限。</li><li>操作系统根据文件描述符定位文件的当前写入位置，并将数据写入文件。</li><li>写入操作可能会涉及到将数据从用户空间传输到内核空间，再由内核空间传输到存储设备（如硬盘）。</li><li>操作系统在写入数据后，会更新文件的指针，指向下一个待写入的位置。</li></ul><p>返回值：</p><ul><li>成功时，返回实际写入的字节数。</li><li>失败时，返回错误代码（如磁盘空间不足、权限问题等）。</li></ul><p><strong>5.打开文件 (open 系统调用)</strong></p><p>功能：</p><ul><li><code>open</code> 系统调用用于打开一个现有文件，或者创建一个新文件以供后续读写操作。打开文件时，操作系统会为文件分配一个文件描述符。</li></ul><p>过程：</p><ul><li>操作系统会检查文件路径和文件名是否有效，并确认文件是否存在。如果文件不存在且请求创建，操作系统会创建新文件。</li><li>操作系统会检查文件的访问权限（如读、写、执行等），以确保进程有足够的权限访问该文件。</li><li>文件描述符是文件在操作系统中的唯一标识符，打开文件时，操作系统会为文件分配一个文件描述符，并返回给用户进程。</li><li>如果成功打开文件，进程可以通过该文件描述符进行后续的读写操作。</li></ul><p>返回值：</p><ul><li>成功时，返回文件的文件描述符。</li><li>失败时，返回错误代码（如文件不存在、权限不足等）。</li></ul><p><strong>6.关闭文件 (close 系统调用)</strong></p><p>功能：</p><ul><li><code>close</code> 系统调用用于关闭一个已经打开的文件，释放文件描述符，使得该文件不再被当前进程使用。</li></ul><p>过程：</p><ul><li>操作系统检查文件描述符是否有效。如果有效，操作系统会关闭该文件，释放相关的资源。</li><li>关闭文件时，操作系统会更新文件的元数据（如最后访问时间），并确保文件的缓冲区数据已经刷新到存储设备中，防止数据丢失。</li><li>关闭文件后，文件描述符不再有效，进程无法再通过该描述符进行读写操作。</li></ul><p>返回值：</p><ul><li>成功时，返回成功状态。</li><li>失败时，返回错误代码（如文件描述符无效等）。</li></ul><hr><h3 id="4-3-文件控制块-FCB"><a href="#4-3-文件控制块-FCB" class="headerlink" title="4.3 文件控制块(FCB)"></a>4.3 文件控制块(FCB)</h3><p>操作系统中的 <strong>文件控制块</strong>（File Control Block，FCB）是操作系统用来管理文件的一种数据结构，它包含了文件的各种信息，支持操作系统对文件的有效管理和访问。每个文件在文件系统中都有一个与之对应的 FCB，当文件被打开时，操作系统会创建一个 FCB 并将其存储在内存中，以便对文件进行操作。</p><p>FCB 的主要作用是：</p><ol><li><strong>文件管理</strong>：操作系统通过 FCB 来管理文件的存储位置、大小、权限等元数据。</li><li><strong>文件访问</strong>：FCB 使得操作系统能够快速、准确地访问文件的相关信息，从而支持对文件的读写操作。</li><li><strong>资源管理</strong>：FCB 包含文件的使用信息，帮助操作系统协调对文件的访问，确保文件的安全性和一致性。</li></ol><p>FCB 中存储了与文件相关的多种信息，具体包括但不限于以下内容：</p><ol><li><p>文件名（File Name）：存储文件的名称。文件名用于标识文件，可以是文件的完整路径或仅是文件名。</p></li><li><p>文件标识符（File Identifier）：用于唯一标识一个文件。在文件操作中，操作系统通过文件标识符（例如文件描述符）来引用文件。</p></li><li><p>文件类型（File Type）：指定文件的类型，例如文本文件、二进制文件、图像文件等。操作系统根据文件类型来决定如何处理文件的内容。</p></li><li><p>文件大小（File Size）：文件的当前大小，通常以字节为单位。操作系统根据文件大小来分配空间、管理磁盘存储等。</p></li><li><p>文件位置（File Location）：存储文件的数据在磁盘中的位置。操作系统通过这一信息来找到文件的数据块并执行文件的读写操作。可能包含一个或多个数据块的位置信息。</p></li><li><p>访问权限（Access Control Information）：包含文件的访问控制信息，指定哪些用户或进程有权读取、写入或执行该文件。常见的权限包括读取权限、写入权限和执行权限。</p></li><li><p>文件状态（File Status）：记录文件的当前状态，例如是否被打开、是否被锁定等。操作系统根据文件状态来决定文件的访问和操作。</p></li><li><p>文件的创建时间、修改时间和访问时间（Timestamps）：记录文件的创建时间、最后修改时间以及最后访问时间。这些信息对文件的管理、审计和备份等操作非常重要。</p></li><li><p>文件的所有者信息（Owner Information）：文件的所有者或创建者的标识。操作系统利用这些信息来实施权限控制和安全性检查。</p></li><li><p>文件指针（File Pointer）：文件指针指向文件中当前读取或写入的位置。每次文件读取或写入时，操作系统会更新文件指针的位置，以便下一次操作。</p></li><li><p>文件锁定信息（File Locking Information）：用于文件锁定机制中，指示文件是否被某个进程锁定。文件锁定机制可以防止多个进程同时访问同一文件，造成数据冲突或损坏。</p></li></ol><hr><p>文件控制块的工作原理如下：</p><ol><li><p><strong>文件的创建和打开</strong>：</p><ul><li>当用户创建或打开一个文件时，操作系统会在内存中为该文件分配一个 FCB。FCB 包含了文件的各种元数据，操作系统会根据 FCB 来管理文件的存储和访问。</li></ul></li><li><p><strong>文件的访问</strong>：</p><ul><li>每当文件被读取或写入时，操作系统会通过 FCB 来获取文件的位置、大小、状态等信息，确保文件操作的正确性和安全性。</li></ul></li><li><p><strong>文件的关闭</strong>：</p><ul><li>当文件操作完成后，操作系统会更新文件的元数据（如修改时间、文件大小等），并释放 FCB。文件控制块在文件关闭时会被销毁。</li></ul></li><li><p><strong>文件的删除</strong>：</p><ul><li>删除文件时，操作系统会首先检查文件的 FCB，然后清除文件的元数据，并释放文件所占用的空间。删除文件的 FCB 通常会从文件控制块表中移除。</li></ul></li></ol><hr><p>文件控制块的具体结构和存储方式会根据不同的文件系统有所不同。例如：</p><ul><li><p><strong>FAT（File Allocation Table）文件系统</strong>：</p><ul><li>在 FAT 文件系统中，文件控制块通常包含一个指向文件分配表的指针。文件分配表记录了文件的数据块位置，因此操作系统可以通过文件控制块快速查找到文件的存储位置。</li></ul></li><li><p><strong>NTFS 文件系统</strong>：</p><ul><li>NTFS 使用称为 “MFT（Master File Table）条目” 的数据结构，每个文件在 MFT 中有一个对应的条目，类似于 FCB。这个条目中保存了文件的各种元数据，包括文件大小、存储位置、权限等。</li></ul></li><li><p><strong>ext3&#x2F;ext4 文件系统</strong>：</p><ul><li>在 Linux 的 ext 文件系统中，文件控制块类似于一个 inode（索引节点）。inode 中存储了文件的元数据，但不包括文件名，文件名存储在目录结构中。每个文件都对应一个 inode，操作系统通过 inode 来管理文件的存储。</li></ul></li></ul><p>文件控制块是操作系统中用于管理文件的核心数据结构，它包含了文件的各种元数据，帮助操作系统执行对文件的读取、写入、删除等操作。通过文件控制块，操作系统能够高效地管理文件系统，确保文件的完整性、安全性和一致性。</p><h2 id="5-I-O-Device-Management"><a href="#5-I-O-Device-Management" class="headerlink" title="5. I&#x2F;O Device Management"></a>5. I&#x2F;O Device Management</h2><p>I&#x2F;O（输入&#x2F;输出）设备管理是操作系统中一个重要的功能模块，它负责管理和调度计算机系统中各种硬件设备的输入和输出操作。I&#x2F;O 设备管理的主要任务是通过提供统一的接口，使得操作系统和应用程序能够方便、高效地与外部设备进行交互，而不需要直接操控硬件。操作系统通过一组 I&#x2F;O 控制器（I&#x2F;O Controllers）和驱动程序（Device Drivers）来实现对硬件设备的控制和管理。</p><p>I&#x2F;O 设备通常分为以下几种类型：</p><ul><li><strong>输入设备</strong>：如键盘、鼠标、扫描仪、麦克风等。</li><li><strong>输出设备</strong>：如显示器、打印机、扬声器等。</li><li><strong>存储设备</strong>：如硬盘、固态硬盘（SSD）、光盘、USB 驱动器等。</li><li><strong>网络设备</strong>：如网络接口卡（NIC）、无线适配器等。</li></ul><p>这些设备通常与计算机的中央处理单元（CPU）之间通过总线连接，操作系统需要负责这些设备的数据传输、缓冲区管理、设备调度等。</p><p>I&#x2F;O 设备管理的核心任务是提供一个抽象层，使得应用程序可以透明地访问不同类型的 I&#x2F;O 设备。具体包括以下几个方面：</p><p><strong>2.1 I&#x2F;O 调度（I&#x2F;O Scheduling）</strong></p><p>I&#x2F;O 调度是操作系统负责安排和管理对 I&#x2F;O 设备的访问。I&#x2F;O 调度的目标是优化 I&#x2F;O 操作，提高系统的整体性能和响应速度。常见的 I&#x2F;O 调度算法有：</p><ul><li><strong>先来先服务（FCFS，First-Come, First-Served）</strong>：按照 I&#x2F;O 请求的到达顺序进行处理。虽然简单，但可能导致较长的等待时间。</li><li><strong>最短寻道时间优先（SSTF，Shortest Seek Time First）</strong>：选择离当前磁头位置最近的 I&#x2F;O 请求，减少磁盘寻道时间。</li><li><strong>扫描算法（SCAN）</strong>：磁头从一端扫描到另一端，处理所有请求，然后反向扫描。又称电梯算法（Elevator Algorithm）。</li><li><strong>循环扫描算法（C-SCAN）</strong>：类似 SCAN，但在到达磁盘的一端后，磁头会跳回另一端，而不是反向扫描。</li></ul><hr><p><strong>2.2 I&#x2F;O 操作的抽象（Device Abstraction）</strong></p><p>I&#x2F;O 操作的抽象指的是将具体的硬件操作（如读写硬盘、打印文件等）转化为更高层次的操作接口。操作系统通过设备驱动程序提供一个标准化的接口，允许用户和应用程序在不考虑底层硬件的情况下进行操作。</p><p>例如，应用程序请求读取文件时，操作系统会将该请求转化为对硬件设备的读写操作，而不需要程序了解硬盘是如何工作的。这样，操作系统就屏蔽了硬件细节，为程序提供了统一的访问接口。</p><hr><p><strong>2.3 I&#x2F;O 缓冲（Buffering）</strong></p><p>I&#x2F;O 缓冲是操作系统用来提高 I&#x2F;O 性能的一种技术。缓冲区是一块在内存中的区域，用于暂时存储从 I&#x2F;O 设备读取的数据或写入 I&#x2F;O 设备的数据。通过使用缓冲区，操作系统可以在等待 I&#x2F;O 操作完成的同时执行其他任务，减少设备的空闲时间和等待时间。</p><ul><li><strong>输入缓冲（Input Buffering）</strong>：当从输入设备（如键盘、网络等）读取数据时，操作系统会先将数据存放在缓冲区，应用程序再从缓冲区读取数据。</li><li><strong>输出缓冲（Output Buffering）</strong>：操作系统将待写入输出设备的数据先放到缓冲区中，然后由设备驱动程序将数据写入实际的设备中。</li></ul><hr><p><strong>2.4 I&#x2F;O 错误处理（Error Handling）</strong></p><p>由于硬件设备可能会出现各种故障（如设备未响应、硬件损坏等），操作系统需要具备处理 I&#x2F;O 错误的能力。常见的错误处理策略包括：</p><ul><li><strong>重试机制</strong>：在发生 I&#x2F;O 错误时，操作系统可以重试操作，尝试恢复操作。</li><li><strong>错误日志记录</strong>：操作系统可以记录发生错误的详细信息，以便后续的调试和维护。</li><li><strong>设备替换或恢复</strong>：如果某个设备出现故障，操作系统可以尝试切换到备用设备或恢复设备的功能。</li></ul><hr><p><strong>2.5 设备驱动程序（Device Drivers）</strong></p><p>设备驱动程序是操作系统与硬件设备之间的桥梁。它提供了一个标准化的接口，允许操作系统控制各种硬件设备。设备驱动程序通常是为每个硬件设备单独编写的，负责管理设备的初始化、数据传输、错误处理等。</p><ul><li><strong>设备初始化</strong>：设备驱动程序负责初始化设备，使设备能够正常工作。</li><li><strong>数据传输</strong>：设备驱动程序负责从设备读取数据或将数据写入设备。</li><li><strong>设备控制</strong>：设备驱动程序通过控制命令（如启动、停止、暂停）管理设备的状态。</li></ul><hr><p><strong>2.6 I&#x2F;O 同步与异步（Synchronous vs Asynchronous）</strong></p><p>I&#x2F;O 操作可以是同步的（Synchronous）或异步的（Asynchronous）：</p><ul><li><strong>同步 I&#x2F;O</strong>：应用程序会等待 I&#x2F;O 操作完成后才继续执行后续操作。即，程序执行被阻塞，直到 I&#x2F;O 操作完成。</li><li><strong>异步 I&#x2F;O</strong>：应用程序发起 I&#x2F;O 操作后，不必等待操作完成，可以继续执行其他任务。操作系统会在 I&#x2F;O 操作完成时通知应用程序。</li></ul><hr><p>操作系统通常通过以下几个机制实现对 I&#x2F;O 设备的管理：</p><p><strong>3.1 I&#x2F;O 控制器</strong></p><p>I&#x2F;O 控制器（I&#x2F;O Controllers）是硬件组件，用于管理 I&#x2F;O 设备和 CPU 之间的通信。它负责将来自 CPU 的 I&#x2F;O 请求转化为适合设备理解的命令，并将设备的响应转化为 CPU 可理解的格式。</p><p><strong>3.2 I&#x2F;O 总线</strong></p><p>I&#x2F;O 总线（I&#x2F;O Bus）是连接 CPU、内存和 I&#x2F;O 设备的通信通道。通过 I&#x2F;O 总线，操作系统可以控制多个设备，同时传输数据。常见的 I&#x2F;O 总线包括 PCI（Peripheral Component Interconnect）、SATA（Serial ATA）、USB（Universal Serial Bus）等。</p><p><strong>3.3 设备独立性</strong></p><p>操作系统提供了设备独立性（Device Independence），使得应用程序可以在不关心底层硬件的情况下进行 I&#x2F;O 操作。设备独立性由设备驱动程序和操作系统的抽象机制提供。</p><p>I&#x2F;O 设备管理是操作系统中至关重要的组成部分，涉及设备调度、错误处理、数据传输、设备驱动程序等多个方面。操作系统通过设备驱动程序和 I&#x2F;O 调度算法提供了一个统一的接口，使得应用程序能够高效、可靠地与各种硬件设备进行交互。良好的 I&#x2F;O 管理不仅可以提高系统性能，还能有效提升用户体验。</p><hr><p>最后需要简单补充一下2个常用到的技术。</p><p><strong>DMA（Direct Memory Access，直接内存存取）</strong> 是一种允许外围设备（如硬盘、网络卡等）直接与内存之间进行数据传输的技术，而无需通过CPU。这种方式可以显著减少CPU的负担，提高系统的整体性能。</p><p><strong>DMA工作过程</strong></p><ol><li><strong>初始化</strong>：CPU首先向DMA控制器发送命令，指定数据传输的源地址、目的地址和传输的数据量。</li><li><strong>传输过程</strong>：DMA控制器接管总线的控制权，并在设备和内存之间直接进行数据传输。这时，CPU可以处理其他任务，不需要参与传输过程。</li><li><strong>传输完成</strong>：当数据传输完成后，DMA控制器会向CPU发送中断信号，通知CPU传输已经完成。</li></ol><p><strong>DMA优点</strong></p><ul><li><strong>提高效率</strong>：因为CPU不需要直接参与数据传输，所以可以腾出更多资源来处理其他任务。</li><li><strong>减少延迟</strong>：直接传输数据，减少了数据传输过程中的延迟。</li><li><strong>高效处理大量数据</strong>：适用于大规模数据传输，如多媒体文件的读取和写入。</li></ul><p><strong>DMA应用场景</strong></p><ul><li><strong>多媒体处理</strong>：视频、音频等大文件的快速传输。</li><li><strong>网络数据传输</strong>：如网络适配器中数据包的快速处理。</li><li><strong>硬盘数据读取&#x2F;写入</strong>：提升硬盘读写速度。</li></ul><img src="/img/OS/dma.svg" alt="DMA方式" style="max-width: 100%; height: auto;" /><hr><p>SPOOLing（Simultaneous Peripheral Operations On-Line）是一种将外围设备的输入&#x2F;输出操作排队等待执行的技术。它通过将任务临时存储在中间存储设备（如硬盘或内存）中，使CPU和外围设备能够同时处理多个任务，从而提高系统的整体效率。</p><p><strong>SPOOLing工作过程</strong></p><ol><li><strong>任务提交</strong>：作业被提交到系统中，系统将作业存储在一个临时存储区域（如磁盘）中，这个过程称为任务排队。</li><li><strong>任务排队</strong>：系统将多个作业排队等待处理。当外围设备空闲时，系统从队列中取出一个作业进行处理。</li><li><strong>任务执行</strong>：外围设备（如打印机、磁带机等）根据排队的顺序依次处理每个作业。处理完成后，系统将作业从队列中移除。</li></ol><p><strong>优点</strong></p><ul><li><strong>提高资源利用率</strong>：通过任务排队和并行处理，提高了系统资源（CPU、外围设备等）的利用率。</li><li><strong>减少等待时间</strong>：作业可以在外围设备空闲时自动开始处理，减少了用户的等待时间。</li><li><strong>高效处理大量任务</strong>：适用于需要处理大量I&#x2F;O操作的场景，如打印作业、磁带备份等。</li></ul><p><strong>应用场景</strong></p><ul><li><strong>打印作业</strong>：多个打印任务被排队等待处理，提高打印机的利用率。</li><li><strong>磁带备份</strong>：备份任务排队等待磁带机处理，提高备份效率。</li><li><strong>批处理作业</strong>：适用于需要批量处理的任务，如数据处理、报表生成等。</li></ul><img src="/img/OS/spooling_diagram.svg" alt="SPOOLing方式" style="max-width: 100%; height: auto;" /><blockquote><p>这里再啰嗦一下SPOOling技术，因为我在很多修考题里面看到了对这个名词的解释的题目</p></blockquote><h2 id="6-Large-Capacity-Storage-Structures"><a href="#6-Large-Capacity-Storage-Structures" class="headerlink" title="6. Large Capacity Storage Structures"></a>6. Large Capacity Storage Structures</h2><p>操作系统中的大容量存储结构主要用于持久存储大量数据，确保数据的长期保存和高效访问。常见的大容量存储结构包括以下几种：</p><p>1.硬盘（Hard Disk Drive, HDD）：硬盘是最常见的大容量存储设备，广泛应用于计算机中。它通过磁性介质（通常是磁盘盘片）来存储数据，使用磁头进行读写操作。</p><ul><li><strong>特点</strong>：容量大、成本相对低、读写速度较慢。</li><li><strong>存储结构</strong>：磁盘被划分为多个<strong>磁道（Track）</strong>和<strong>扇区（Sector）</strong>，数据以块的形式存储。多个磁道组成一个<strong>柱面（Cylinder）</strong>。</li></ul><p>2.固态硬盘（Solid State Drive, SSD）:SSD是近年来发展迅速的存储设备，它使用闪存（Flash Memory）来存储数据，没有机械部件，因此在性能上优于HDD。</p><ul><li><strong>特点</strong>：读写速度快、抗震、噪音低、功耗低，但成本较高。</li><li><strong>存储结构</strong>：SSD没有机械盘片，数据存储在<strong>NAND闪存单元</strong>中，数据存储结构是基于<strong>块（Block）</strong>和<strong>页面（Page）</strong>，每个块由多个页面组成。</li></ul><p>3.光盘（CD&#x2F;DVD&#x2F;Blu-ray）:光盘通过激光读取和写入数据，适用于大容量数据的长期存储和归档。</p><ul><li><strong>特点</strong>：容量较大、价格便宜、便于携带，但读写速度较慢，且不适用于频繁读写。</li><li><strong>存储结构</strong>：光盘上的数据通过螺旋轨迹排列，可以按块存储数据。常见的结构包括<strong>光盘的扇区</strong>，和不同容量的光盘（如CD、DVD、Blu-ray）。</li></ul><p>4.磁带（Magnetic Tape）:磁带是较早的存储设备，通常用于大规模数据备份和归档。它通过磁性介质进行数据存储。</p><ul><li><strong>特点</strong>：存储容量大，成本低，但随机访问速度慢，主要用于长期存储和备份。</li><li><strong>存储结构</strong>：数据以顺序方式存储在磁带上，采用线性存储结构。通过磁头顺序读取数据，适合用于批量处理和备份。</li></ul><p>5.网络附加存储（NAS, Network Attached Storage）:NAS是一种通过网络连接的存储设备，允许多个用户和计算机共享存储资源，常用于文件存储和数据备份。</p><ul><li><strong>特点</strong>：容量可扩展、支持共享存储、易于管理，但性能依赖网络带宽和设备配置。</li><li><strong>存储结构</strong>：NAS使用文件系统来组织和管理数据，可以支持多种存储结构，如<strong>RAID</strong>、<strong>LUN（Logical Unit Number）</strong>等。</li></ul><p>6.存储区域网络（SAN, Storage Area Network）:SAN是一种专门为存储设备提供高速网络连接的架构，主要用于数据中心、企业级存储。</p><ul><li><strong>特点</strong>：高性能、高可扩展性、支持大容量数据存储和快速访问。</li><li><strong>存储结构</strong>：SAN一般使用<strong>块存储</strong>，通常配合<strong>RAID技术</strong>进行冗余存储。通过高速光纤通道（Fibre Channel）或iSCSI协议连接存储设备和服务器。</li></ul><p>7.云存储（Cloud Storage）:云存储指通过互联网将数据存储在远程数据中心的服务，通常由第三方提供，如Amazon S3、Google Drive、OneDrive等。</p><ul><li><strong>特点</strong>：易于扩展、数据安全性高、可以实现跨平台访问，但依赖于网络连接。</li><li><strong>存储结构</strong>：云存储通常采用<strong>对象存储</strong>（如Amazon S3）或<strong>块存储</strong>（如EBS），并通过网络接口与用户的设备进行交互。</li></ul><p>8.闪存卡（Flash Card）:闪存卡是一种基于闪存的存储设备，常见的如SD卡、CF卡等，广泛用于移动设备和相机等设备中。</p><ul><li><strong>特点</strong>：容量适中、速度较快、便于携带。</li><li><strong>存储结构</strong>：与SSD类似，闪存卡的数据以块和页面为单位存储。</li></ul><p>9.RAM磁盘（RAM Disk）:RAM磁盘是一种使用计算机内存作为虚拟磁盘的技术，通常用于需要极高速访问的临时数据存储。</p><ul><li><strong>特点</strong>：极高的读写速度，但数据会随着断电丢失。</li><li><strong>存储结构</strong>：RAM磁盘使用系统内存中的一部分区域来模拟磁盘，数据以块的方式进行存储。</li></ul><p>10.分布式存储系统分布式存储是通过多个节点（服务器）共同协作，提供一个虚拟化的存储空间，常用于大规模数据存储和处理，如HDFS（Hadoop分布式文件系统）。</p><ul><li><strong>特点</strong>：高可扩展性、高容错性、适合大规模数据存储。</li><li><strong>存储结构</strong>：数据通常分布</li></ul><h3 id="6-1-磁盘调度算法"><a href="#6-1-磁盘调度算法" class="headerlink" title="6.1 磁盘调度算法"></a>6.1 磁盘调度算法</h3><p>磁盘调度算法是操作系统用来决定磁盘请求的处理顺序的策略，目的是优化磁盘的性能，减少磁头的寻道时间，从而提高系统的整体性能。磁盘的读写操作需要移动磁头到不同的磁道，而磁头的移动时间被称为<strong>寻道时间</strong>。磁盘调度算法通过合理安排请求的处理顺序，减少磁头的移动，提高磁盘的利用效率。</p><p>下面介绍一下常见的磁盘调度算法</p><h4 id="6-1-先来先服务（FCFS-First-Come-First-Served）"><a href="#6-1-先来先服务（FCFS-First-Come-First-Served）" class="headerlink" title="6.1 先来先服务（FCFS, First-Come First-Served）"></a>6.1 先来先服务（FCFS, First-Come First-Served）</h4><p><strong>FCFS</strong>是最简单的一种磁盘调度算法，磁盘请求按照到达的顺序处理，不进行优化。</p><ul><li><strong>原理</strong>：按请求到达的顺序处理磁盘请求。</li><li><strong>优点</strong>：<ul><li>实现简单，易于理解。</li><li>无需额外的计算开销。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能导致磁头来回移动，增加寻道时间，特别是当请求在磁盘的两端时。</li><li><strong>寻道时间</strong>不确定，效率较低。</li></ul></li></ul><h4 id="6-2-最短寻道时间优先（SSTF-Shortest-Seek-Time-First）"><a href="#6-2-最短寻道时间优先（SSTF-Shortest-Seek-Time-First）" class="headerlink" title="6.2 最短寻道时间优先（SSTF, Shortest Seek Time First）"></a>6.2 最短寻道时间优先（SSTF, Shortest Seek Time First）</h4><p><strong>SSTF</strong>算法每次选择离当前磁头位置最近的请求进行处理，优先处理距离当前磁头最近的磁道请求。</p><ul><li><strong>原理</strong>：每次处理最接近当前磁头的请求，从而最小化寻道时间。</li><li><strong>优点</strong>：<ul><li>比FCFS更高效，因为它减少了磁头的移动。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能会导致“饥饿”现象，即距离磁头较远的请求可能长时间得不到处理。</li><li>无法保证所有请求的公平性。</li></ul></li></ul><h4 id="6-3-扫描算法（SCAN）"><a href="#6-3-扫描算法（SCAN）" class="headerlink" title="6.3 扫描算法（SCAN）"></a>6.3 扫描算法（SCAN）</h4><p><strong>SCAN</strong>算法也叫电梯算法，它模拟电梯的运动方式，磁头在一个方向上扫描，直到达到磁盘的一端，再反向扫描，处理请求。</p><ul><li><strong>原理</strong>：磁头沿着磁盘扫描，遇到请求就处理，直到扫描到磁盘的边缘，然后反方向扫描。</li><li><strong>优点</strong>：<ul><li>较为平衡，能够避免“饥饿”现象。</li><li>磁头的运动有规律，寻道时间较为可控。</li></ul></li><li><strong>缺点</strong>：<ul><li>磁头每次扫描到磁盘的最远端后，再反向扫描，可能导致一端的请求处理得较慢。</li></ul></li></ul><h4 id="6-4-循环扫描算法（C-SCAN）"><a href="#6-4-循环扫描算法（C-SCAN）" class="headerlink" title="6.4 循环扫描算法（C-SCAN）"></a>6.4 循环扫描算法（C-SCAN）</h4><p><strong>C-SCAN</strong>是对<strong>SCAN</strong>算法的改进。当磁头扫描到一端后，不返回，而是立即跳到另一端继续扫描。</p><ul><li><strong>原理</strong>：磁头向一个方向扫描，扫描到达磁盘一端后，迅速跳到另一端继续扫描。每次都从一端扫描到另一端。</li><li><strong>优点</strong>：<ul><li>提供了更加均衡的响应时间，避免了SCAN中一端请求较慢的问题。</li><li>改进了磁头的移动模式，减少了等待时间。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能会浪费一些时间来跳转磁盘的两端。</li></ul></li></ul><h4 id="6-5-LOOK算法"><a href="#6-5-LOOK算法" class="headerlink" title="6.5 LOOK算法"></a>6.5 LOOK算法</h4><p><strong>LOOK</strong>算法与SCAN类似，不同之处在于磁头在扫描到达请求的最远端后就会反向，而不是继续扫描到磁盘的最端点。</p><ul><li><strong>原理</strong>：磁头扫描时，遇到磁盘请求后进行处理，但扫描到最远请求后即返回，而不必扫描到磁盘的最后端。</li><li><strong>优点</strong>：<ul><li>更高效，因为它避免了不必要的扫描。</li></ul></li><li><strong>缺点</strong>：<ul><li>与SCAN类似，可能造成某些请求的延迟处理。</li></ul></li></ul><h4 id="6-6-C-LOOK算法"><a href="#6-6-C-LOOK算法" class="headerlink" title="6.6 C-LOOK算法"></a>6.6 C-LOOK算法</h4><p><strong>C-LOOK</strong>是对<strong>LOOK</strong>算法的进一步优化。当磁头到达最远请求时，它会跳到最远请求的另一端继续扫描，而不继续扫描到磁盘的末端。</p><ul><li><strong>原理</strong>：类似于C-SCAN，磁头扫描到一个方向的最远请求后，跳转到另一端继续扫描。</li><li><strong>优点</strong>：<ul><li>提供更加均衡的响应时间，并减少了不必要的寻道。</li></ul></li><li><strong>缺点</strong>：<ul><li>在某些场景下，跳转过程可能会引入额外的开销。</li></ul></li></ul><h4 id="6-7-最短请求时间优先（SRTF-Shortest-Request-Time-First）"><a href="#6-7-最短请求时间优先（SRTF-Shortest-Request-Time-First）" class="headerlink" title="6.7 最短请求时间优先（SRTF, Shortest Request Time First）"></a>6.7 最短请求时间优先（SRTF, Shortest Request Time First）</h4><p><strong>SRTF</strong>算法选择响应时间最短的请求优先处理。这种算法与SSTF类似，不过SRTF更加关注请求的响应时间，而不仅仅是距离。</p><ul><li><strong>原理</strong>：选择响应时间最短的请求进行处理，类似于CPU调度中的最短剩余时间优先（SRTF）算法。</li><li><strong>优点</strong>：<ul><li>可以最大化磁盘请求的响应速度。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现较复杂，可能会增加系统的计算开销。</li></ul></li></ul><p>磁盘调度算法的选择取决于具体的应用场景。不同的算法在不同的情况下有不同的优势和劣势。以下是一些选择考虑因素：</p><ul><li><strong>FCFS</strong>：适合请求到达时间比较均匀、对性能要求不高的场景。</li><li><strong>SSTF</strong>：适用于请求较为密集，磁头位置较为接近的场景，但可能会造成“饥饿”现象。</li><li><strong>SCAN和C-SCAN</strong>：适合请求在磁盘两端不均匀的情况，能够减少磁头的频繁反向运动。</li><li><strong>LOOK和C-LOOK</strong>：比SCAN更加高效，适用于对磁头寻道次数要求较高的环境。</li></ul><p>磁盘调度算法的核心目标是减少磁头的移动，优化磁盘访问的效率。每种算法都有其适用的场景，了解每种算法的原理和特点，有助于在不同的实际应用中选择最合适的磁盘调度策略。</p><h2 id="7-偷偷说"><a href="#7-偷偷说" class="headerlink" title="7. 偷偷说"></a>7. 偷偷说</h2><p>我写的第四篇关于计算机修考专业科目的笔记终于结束了，太不容易了。操作系统真的是一门非常非常深奥的学问！我已经尝试写完所有我认为能接触到的知识点了，但我觉得这也仅仅是冰山一角，尽管操作系统这篇的字数已经超过算法，机组，数电的总和，甚至还多出1万字…</p><p>在写这篇笔记的时候，我觉得异常异常的乏力！乏力的地方在于我很难把从上层到下层的逻辑串起来。我已经很努力的在梳理整个操作系统的框架了，从最上层的进程开始，再下到我们的存储结构，再下到文件系统，再下到我们的输出设备管理，最后下到大容量存储结构。</p><p>操作系统我认为也非常体现能计算机体系的精华，我们可以从上面的内容提取到冗余（redundancy）、并行（parallel）、分而治之提升效率等思想。</p><p>我在第一次学习操作系统的时候，纯纯的就是在背概念和记题型，并没有深刻体会到操作系统的内涵。现在当我重新串一遍操作系统的知识时，我又有了很多更深入的理解。</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>东北大学2024年冬计算机组成_问题5</title>
    <link href="/2024/12/10/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A62024%E5%B9%B4%E5%86%AC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E6%83%85%E6%8A%A5%E7%94%9F%E5%91%BD/"/>
    <url>/2024/12/10/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A62024%E5%B9%B4%E5%86%AC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E6%83%85%E6%8A%A5%E7%94%9F%E5%91%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="东北大学2024年冬计算机-问题5-by-偷偷"><a href="#东北大学2024年冬计算机-问题5-by-偷偷" class="headerlink" title="东北大学2024年冬计算机_问题5 by 偷偷"></a>东北大学2024年冬计算机_问题5 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p>Consider the following recursive function $f$ that takes an integer and returns an integer.</p><p>$$<br>f(n)&#x3D;<br>\begin{cases}<br>0,\quad n\leq 0 \\<br>f(n-1) \times 2 + n, \quad n&gt;0<br>\end{cases}<br>$$</p><p>Answer the following questions.</p><hr><p><strong>(1)</strong> Find the value of $f(3)$. Show also the intermediate steps in the calculation.</p><p>$$f(0) &#x3D; 0$$<br>$$f(1) &#x3D; f(0) \times 2 + 1 &#x3D; 1$$<br>$$f(2) &#x3D; f(1) \times 2 + 2 &#x3D; 4$$<br>$$f(3) &#x3D; f(2) \times 2 + 3 &#x3D; 11$$</p><hr><p><strong>(2)</strong> Consider a machine with three integer registers $r_{0}$, $r_{1}$, and $r_{2}$, a stack of sufficient size, and the instruction set in Fig.5(a). A program is a sequence of instructions and there is no limit on the size of integers. The program in Fig.5(b) displays the value of $f(30)$ on the screen and terminates. Give an instruction (or part of an instruction) that is appropriate for each of <u>(A), (B), (C),</u> and <u>(D).</u> Also explains in several lines of text how this program goes.</p><center><img src="/img/exam_other/tohoku24.jpg" alt="Memory Access" style="max-width: 100%; height: auto;" /></center><p>Let’s briefly read the assembly language</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">1. set 30, $r12. set 5, $r0      # 这里的‘5’用来记录函数退出的位置，即第5行代码3. push r04. jmp 65. halt r1         # r1用来返回最终的计算结果6. ifpos r1, ______(A) # 循环7. set 0, r18. ret9. push r1              # 不断往栈放入r1，后续必定有弹出r1的动作10. dec r111. set ____(B), r012. push r013. jmp 6              # 循环14. add r1, r1, r2     # 计算乘2的过程，即f(n-1) x 215. ____(C)16. add r1, r2, r1     # 计算加n的过程17. ____(D)            # 需要找准时机退出循环，即要和‘5’呼应上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p><strong>Hint:</strong> 可以尝试令$r1 &#x3D; 3, 然后手动模拟栈计算f(3)的过程</p></blockquote><p>Ans:</p><ul><li>(A): jmp 9</li><li>(B): 14</li><li>(C): pop r1</li><li>(D): ret</li></ul><p>This program initially places the calculation of the recursive endpoint $f(30)$ at the bottom of the stack. It then recursively processes from the bottom upwards until the starting value of the recursion is placed at the top of the stack. Following this, it begins to recursively process from the top downward until it reaches the calculation of the recursive endpoint $f(30)$.</p>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>东北大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>东北大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2023年夏计算机组成</title>
    <link href="/2024/12/08/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A620223%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/08/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A620223%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2023年计算机组成答案-by-偷偷"><a href="#九州大学2023年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2023年计算机组成答案 by 偷偷"></a>九州大学2023年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider a microprocessor having a pipelined datapath. Program execution time ET can be represented by using the three parameters, instruction count required to complete the whole program execution IC, the number of executed instructions per clock cycle IPC, and clock frequency F, as shown in the following equation.<br>$$ET &#x3D; \frac{IC}{IPC \times F}$$</p><p>Answer the following questions.</p><hr><p><strong>(1)</strong> Consider an in-order microprocessor whose instruction issue width is one. Explain the effects of pipelined datapath implementation on IC, IPC, and F, compared to a single-cycle datapath implementation where each instruction is executed in a single clock cycle, respectively. If there are no effects on each parameter, answer “no effects.”</p><ul><li><p><strong>IC：</strong> <strong>No effects.</strong> The instruction count is determined by the program being executed and is independent of whether the processor uses a pipelined or a single-cycle datapath. The same number of instructions will be executed in both cases.</p></li><li><p><strong>IPC:</strong> IPC typically <strong>increases</strong> in a pipelined processor because multiple instructions can be in different stages of execution at the same time. This allows the processor to issue a new instruction each cycle, leading to higher throughput.</p></li><li><p><strong>F</strong>: The clock frequency F can potentially be <strong>higher</strong> in a pipelined processor. This is because each stage of the pipeline is smaller (handling only part of the instruction) compared to the single-cycle implementation where the entire instruction is processed in one cycle. This smaller stage size allows for faster clock cycles, thus enabling a higher frequency.</p></li></ul><hr><p><strong>(2)</strong> We extend the pipelined datapath by increasing the instruction issue width from one to two that forms an in-order superscalar microprocessor, i.e., at most two independent instructions can be executed in parallel. Explain the effects of this extension on IC, IPC, and F, respectively. If there are no effects on each parameter, answer “no effects.”</p><ul><li><p><strong>IC:</strong> <strong>No effects.</strong> The instruction count is still determined by the program being executed.</p></li><li><p><strong>IPC:</strong>  In general, increasing the issue width should <strong>increase IPC</strong>, assuming there are enough independent instructions to take advantage of the increased width. Consider other factors, such as dependencies (data hazards, control hazards) can reduce the potential benefit.</p></li><li><p><strong>F:</strong> <strong>No effects.</strong> Although there may be a slight decrease in frequency due to the added complexity of issuing two instructions per cycle.</p></li></ul><hr><p><strong>(3)</strong> Assume that the instruction issue width is four. Answer the upper limit of IPC that can be achieved by the pipelined datapath.</p><p>Ans: <strong>4</strong></p><hr><p><strong>[Q3]</strong> Consider computer memory systems. Assume a direct-mapped cache memory implemented in a microprocessor chip. The microprocessor uses word addressing, the word size is 4 bytes, the cache size is 16 bytes, the block size is 4 bytes, and the address width is 4 bits. Suppose the cache was initially empty, and the memory access sequence for the following word addresses (represented in the binary numeral system) has occurred. 1101 ⇒ 1010 ⇒ 1111 ⇒ 1101 </p><p>Then we have the following five memory accesses (memory access  ① -⑤ ) consecutively.</p><center><img src="/img/exam/kyusyu23.jpeg" alt="Memory Access" style="max-width: 100%; height: auto;" /></center><p>Answer the following questions.</p><hr><p>(1) Find all of the memory accesses among ① -⑤ that cause a cache hit. If there is no corresponding memory access, answer “not applicable.”</p><blockquote><p><strong>Hint:</strong> Word Addressing. 按字编址</p></blockquote><ul><li>Block offset：block size is <strong>4 bytes(1 word)</strong> and it requires 1 bit.</li><li>Index bit: the number of cache blocks is $\frac{16bytes}{4bytes} &#x3D; 4 &#x3D; 2^2$,the index bit requires 2 bits.</li><li>Tag bits: it requires 4 - 2 - 1 &#x3D; 1 bits</li></ul><p>Before：</p><table><thead><tr><th>Cache Block</th><th>Accessing Order</th></tr></thead><tbody><tr><td>00</td><td></td></tr><tr><td>01</td><td>1010</td></tr><tr><td>10</td><td>1101</td></tr><tr><td>11</td><td>1111</td></tr></tbody></table><p>After：</p><ul><li>1010: hit</li><li>1001: miss</li><li>1000: hit</li><li>0011: miss</li><li>1111: hit</li></ul><hr><p><strong>(2)</strong> Find all of the memory accesses among  ① -⑤  that cause a compulsory miss. If there is no corresponding memory access, answer “not applicable.”</p><p>Compulsory miss: ②</p><hr><p><strong>(3)</strong> Explain how to modify this cache memory to reduce the conflict miss. Also, if there are any demerits to the modification, explain them.</p><p>Modigy the cache to fully associative cache. The index now maps to a set of multiple cache lines, and the block can be placed in any available line within the set, reducing the likelihood of conflicts. However, it requires additional hardware for selecting the correct cache line.</p>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2022年夏计算机组成</title>
    <link href="/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2022年计算机组成答案-by-偷偷"><a href="#九州大学2022年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2022年计算机组成答案 by 偷偷"></a>九州大学2022年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider an in-order microprocessor that has 5-stage pipelined datapath. The implemented pipeline stage are IF, ID, EX, MEM, and WB. The operations in each stage for the “add” are defined in the following table. Assume that the operations in each pipeline stage can be completed in one clock cycle. The written data in the WB stage of an instruction can be read in the ID stage of a subsequent instruction in the same clock cycle. All RAW(Read-After-Write) hazards are resolved by applying a pipeline stall mechanism. Answer the following questions.</p><center><img src="/img/exam/kyusyu22.jpg" alt="Operations of the pipelined datapath" style="max-width: 100%; height: auto;" /></center><hr><p><strong>(1)</strong> Consider the following assembly program. The words on the right of the ‘#’ symbol in each line are comments. Identify all flow dependencies by describing which instruction depends on which instructions through which register.</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">add $1, $3, $5 # &lt;1&gt;add $9, $2, $3 # &lt;2&gt;add $6, $3, $3 # &lt;3&gt;add $3, $4, $3 # &lt;4&gt;add $4, $7, $1 # &lt;5&gt;add $5, $7, $4 # &lt;6&gt;add $9, $3, $6 # &lt;7&gt;add $2, $7, $6 # &lt;8&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p><strong>Hint:</strong> 流依赖（Flow Dependency），也称为Read-After-Write (RAW) 依赖，是指一条指令需要读取一个由前一条指令写入的寄存器值。</p></blockquote><p>从上到下依次分析写入的寄存器，可以得到存在的Flow Dependencies 有：</p><ul><li>&lt;5&gt; depends on &lt;1&gt; through $1</li><li>&lt;7&gt; depends on &lt;3&gt; through $6</li><li>&lt;8&gt; depends on &lt;3&gt; through $6</li><li>&lt;7&gt; depends on &lt;4&gt; through $3</li><li>&lt;6&gt; depends on &lt;5&gt; through $4</li></ul><hr><p><strong>(2)</strong> Assume the instruction issue width is one. Answer the number of clock cycles required for the execution of the assembly program.</p><blockquote><p><strong>Hint:</strong> 一条指令在写回（WB）阶段写入的数据，可以在同一个时钟周期内被随后的指令在指令解码（ID）阶段读取。</p></blockquote><p>We can draw the pipeline stages below.</p><img src="/img/exam/kyusyu22.svg" alt="pipeline" style="max-width: 100%; height: auto;" /><p>According to the pipeline stages, it requires <strong>14</strong> clock cycles for the execution of the assembly program.</p><hr><p><strong>(3)</strong> We extend the datapath by increasing the instruction issue width from one to two that forms an in-order superscalar microprocessor, i.e., at most, two independent instructions can be executed in parallel. Answer the number of clock cycles required for the execution of the assembly program on the extended datapath.</p><p>We can draw the pipeline stages below.</p><img src="/img/exam/kyusyu22-2.svg" alt="pipeline" style="max-width: 100%; height: auto;" /><p>According to the pipeline stages, it requires <strong>12</strong> clock cycles for the execution of the assembly program.</p><hr><p><strong>(4)</strong> The data path extension presented in (3) causes a 5% decrease in its clock frequency. Answer the performance improvement rate achieved by implementing the extension.</p><p>We know that,</p><p>$$\text{CPU Time} &#x3D; IC \times CPI \times \frac{1}{f}$$</p><p>When extending the datapath, IC reimains the same, CPI improves $\frac{14}{12}$ and the frequency decreases 5%. The improvement $K$ is:</p><p>$$ K &#x3D; \frac{\text{CPU Time}}{\text{CPU Time’}}&#x3D; \frac{14 \times 0.95}{12} \approx \text{111%} $$</p><hr><p><strong>[Q3]</strong> Explain what “compulsory misses”, “conflict misses”, and what “capacity misses” are in cache memory systems, respectively.</p><blockquote><p><strong>Hint:</strong> 直接映射缺失的3C模型</p></blockquote><ul><li><p><strong>Compulsory Misses:</strong> Misses that occur when data is accessed for the first time.</p></li><li><p><strong>Conflict Misses:</strong> Misses that occur  when different data blocks are mapped to the same cache line position causing frequent replacements, resulting in misses even if the cache capacity is sufficient.</p></li><li><p><strong>Capacity Misses:</strong> Due to limited cache capacityeven if all blocks in the cache are fully utilized, it still cannot accommodate all the needed data blocks, resulting in misses.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九州大学2021年夏计算机组成</title>
    <link href="/2024/12/06/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    <url>/2024/12/06/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="九州大学2021年计算机组成答案-by-偷偷"><a href="#九州大学2021年计算机组成答案-by-偷偷" class="headerlink" title="九州大学2021年计算机组成答案 by 偷偷"></a>九州大学2021年计算机组成答案 by 偷偷</h1><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div><p><strong>[Q2]</strong> Let us consider a microprocessor that has a 5-stage pipelined datapath. The implemented pipeline stages are IF (Instruction Fetch), ID (Instruction Decode), EX (EXecution),MEM (MEMory access), and WB (Write Back). Answer the following questions.</p><hr><p><strong>(1)</strong> The latency of pipeline stages, IF, ID, EX, MEM, and WB, is 240 ps, 400 ps, 200ps, 250 ps, and 180 ps, respectively. Answer the maximum clock frequency of this datapath (unit is GHz).</p><blockquote><p><strong>Hint:</strong> The clock period is determined by the slowest (longest latency) pipeline stage.</p></blockquote><p>The slowest stage is ID with a latency of 400 ps. The clock period must be at least as long as this latency to ensure that the slowest stage completes in one cycle.</p><p>$$<br>\text{Clock Frequency} &#x3D; \frac{1}{\text{Clock Period}} &#x3D; \frac{1}{400 \ \text{ps}} &#x3D; \frac{1}{400 \times 10^{-12}} &#x3D; 2.5\ \text{GHz}<br>$$</p><hr><p><strong>(2)</strong> Consider increasing the number of pipeline stages from 5 to 6 by partitioning a single pipeline stage, IF, ID, EX, MEM, or WB, to two stages. Assume the latency of the partitioned pipeline stages is half of that of the original stage. Choose one pipeline stage that should be partitioned for maximising the clock frequency of the datapath, and answer the maximum clock frequency we can achieve by this design optimization (unit is GHz).</p><p>To get the maximum clock frequency, we need to minimize the clock period, thus the best stage to partition for maximizing the clock frequency is the ID stage.</p><ul><li>By splitting the ID stage, its latency is halved to 200 ps.</li><li>The MEM stage becomes the longest (250 ps), so the clock period is now determined by MEM.</li></ul><p>$$<br>\text{Clock Frequency} &#x3D; \frac{1}{\text{Clock Period}} &#x3D; \frac{1}{250 \ \text{ps}} &#x3D; \frac{1}{250 \times 10^{-12}} &#x3D; 4 \ \text{GHz}<br>$$</p><hr><p><strong>(3)</strong> For the execution of a program, the pipeline stage partitioning presented in (2)caused 10 % increase in CPI (Clock cycles Per Instruction). Assume there are no negative effects caused by the pipeline stage partitioning except for the CPI increase.Answer the performance improvement rate achieved by applying the pipeline stage partitioning.</p><ul><li>Before:</li></ul><p>$$\text{CPU Time} &#x3D; \frac {IC \cdot CPI}{f} &#x3D; \frac{IC \cdot CPI} {2.5 \ \text{GHz}}$$</p><ul><li>After partitioning:</li></ul><p>$$ \text{CPU Time’} &#x3D; \frac {IC \cdot CPI \cdot \text{110%} }{f’} &#x3D; \frac{IC \cdot CPI \cdot  \text{110%}}{4 \ \text{GHz}} $$</p><ul><li>The improvement rate K is:</li></ul><p>$$ K &#x3D; \frac{\text{CPU Time}}{\text{CPU Time’}} \approx \text{145%} $$</p><hr><p><strong>(4)</strong> Explain the advantages and disadvantages of increasing the number of pipeline stages.</p><ol><li><p><strong>Advantages：</strong></p><ul><li><strong>Higher Clock Frequency：</strong> each stage performs a smaller part of the instruction cycle. This can reduce the latency of each stage, allowing the processor to run at a higher clock frequency.</li><li><strong>Improved Instruction Throughput：</strong> With more pipeline stages, instructions can be processed more concurrently. This increases the potential instruction throughput because multiple instructions can be in different stages of execution at the same time.</li></ul></li><li><p><strong>Disadvantages:</strong></p><ul><li><strong>Increased Latency per Instruction:</strong> With more stages being executed in the pipeline, even though each individual stage is shorter, an instruction still takes more cycles to pass through all the stages which leads to the increasing of CPI</li><li><strong>More Complex Control Logic:</strong> As the number of pipeline stages increases, the control logic required to manage the pipeline also becomes more complex, which may results in pipeline hazards</li></ul></li></ol><hr><p><strong>[Q3]</strong> Consider a direct-mapped cache memory that accepts a 32-bit memory address consisting of a cache tag field, a cache index field, and a cache block offset field. Suppose a byte addressing scheme, the word size is 4 bytes, the cache size is 16 Kilo-bytes, and the cache block size is 32 bytes. Answer the bit-width of the cache tag field.</p><p>$32 \ bytes &#x3D; 2^5 \ bytes$, the block offset is $5 \ bits$</p><p>$\text{number of cache blocks} &#x3D; \frac{16KByte}{32Byte} &#x3D; 2^9$, the cache index requires $9 \ bits$</p><p>$$ Cache \ tag \ width &#x3D; 32 − Index bits − Offset bits &#x3D; 32 - 9 - 5 &#x3D; 18\ bits $$</p><hr>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>计算机组成</category>
      
      <category>九州大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>修考答案</tag>
      
      <tag>CA</tag>
      
      <tag>九州大学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Digital Circuit</title>
    <link href="/2024/11/04/Digital-Circuit/"/>
    <url>/2024/11/04/Digital-Circuit/</url>
    
    <content type="html"><![CDATA[<h1 id="Digital-Circuit"><a href="#Digital-Circuit" class="headerlink" title="Digital Circuit"></a>Digital Circuit</h1><p>Credit to《Digital Design and Computer Architecture, Second Edition》🤯 Let’s quickly review this subject. The diagram is powered by <a href="https://github.com/jgraph/drawio-desktop">@drawio</a></p><blockquote><p> 催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Logic-Gates"><a href="#1-Logic-Gates" class="headerlink" title="1. Logic Gates"></a>1. Logic Gates</h2><p>第一章主要认识最基础的逻辑门元件，然后熟悉其对应的真值表(Truth Table),主要是为第二章的组合电路(combinational circuit)做铺垫。</p><p><strong>NOT 门（非门）:</strong> 输出是输入的逻辑反， $Y &#x3D; \neg A$</p><p><strong>BUF 门（缓冲器）:</strong> 输出与输入相同，用于信号强化。$Y &#x3D; A$</p><p><strong>AND 门（与门）:</strong> 所有输入均为1时，输出才为1。$Y &#x3D; A \cap B$</p><p><strong>OR 门（或门）:</strong> 任意输入为1时，输出为1。$Y &#x3D; A \cup B$</p><img src="/img/DC/add.svg" alt="逻辑门1" style="max-width: 100%; height: auto;" /><p><strong>NAND 门（与非门）:</strong> 与门输出取反。 $ Y &#x3D; \neg (A \cap B) $</p><p><strong>NOR 门（或非门）:</strong> 或门输出取反。 $ Y &#x3D; \neg (A \cup B) $</p><p><strong>XOR 门（异或门）:</strong> 相异为1，相同为0。 $ Y &#x3D; A \oplus B $</p><p><strong>XNOR 门（同或门）:</strong> 相同为0，相异为1。 $ Y &#x3D; \neg (A \oplus B) $</p><img src="/img/DC/nand.svg" alt="逻辑门2" style="max-width: 100%; height: auto;" /><p><strong>三态缓冲器（tristate buffer）</strong> 是一种数字电路元件，其输出可以处于三种状态之一：高电平（1）、低电平（0）或高阻态（Z）。高阻态表示输出像断开一样，不驱动任何电流，可以用于总线控制等应用。</p><p><strong>高水平有效（Active High）</strong></p><p>在高水平有效的三态缓冲器中，当控制信号为高电平（1）时，缓冲器输出有效，即输出输入信号的值。当控制信号为低电平（0）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 &#x3D; 1：输出 &#x3D; 输入信号</li><li>控制信号 &#x3D; 0：输出 &#x3D; 高阻态（Z）</li></ul><p><strong>低水平有效（Active Low）</strong></p><p>在低水平有效的三态缓冲器中，当控制信号为低电平（0）时，缓冲器输出有效，即输出输入信号的值。当控制信号为高电平（1）时，缓冲器输出高阻态（Z）。</p><ul><li>控制信号 &#x3D; 0：输出 &#x3D; 输入信号</li><li>控制信号 &#x3D; 1：输出 &#x3D; 高阻态（Z）</li></ul><p align="center">  <img src="/img/DC/buffer.svg" alt="逻辑门3" style="max-width: 110%; height: auto;" /></p><h2 id="2-Combinational-Logic-Circuit"><a href="#2-Combinational-Logic-Circuit" class="headerlink" title="2. Combinational Logic Circuit"></a>2. Combinational Logic Circuit</h2><p>组合逻辑电路（Combinational Logic Circuit）是一种数字电路，其中输出仅依赖于当前输入，而不依赖于之前的输入状态。这意味着组合电路没有存储元件，因此它没有记忆功能。其主要特性包括：</p><ul><li><p>无记忆功能：输出<strong>仅由当前输入决定</strong>，与之前的输入无关。</p></li><li><p>固定的逻辑功能：根据输入信号的组合，输出信号以确定的方式变化。</p></li><li><p>构建简单：组合电路通常由基本逻辑门（如AND、OR、NOT、NAND、NOR、XOR、XNOR）构建，可以用来实现任意逻辑功能。</p></li></ul><p>在有逻辑门的基础知识下，还需要有布尔表达式以及卡诺图的基础下才能完成组合电路的设计。</p><h3 id="2-1-Boolean-Equation"><a href="#2-1-Boolean-Equation" class="headerlink" title="2.1 Boolean Equation"></a>2.1 Boolean Equation</h3><p><strong>与或式（Sum of Products, SOP）</strong> 是一种布尔表达式形式，表示多个与项（积项）之间的或操作。每个积项由一个或多个变量通过与操作连接而成。与或式通常用于表达布尔函数的标准形式之一。例如：</p> <center>$ Y = A \cdot B + \overline{A}  \cdot C + B \cdot \overline{C} $</center><p><strong>或与式（Product of Sums, POS）</strong> 是布尔表达式的另一种形式，表示多个或项（和项）之间的与操作。每个和项由一个或多个变量通过或操作连接而成。或与式也常用于表达布尔函数的标准形式之一。例如：</p><center> $ Y = (A + B) \cdot (\overline {A} + C) \cdot (B + \overline{C}) $</center><p><strong>最小项 (Minterms)</strong> 是布尔函数的标准形式之一，其中每个最小项对应一个输出为1的输入组合。最小项由所有变量的与运算构成，每个变量可能是原变量或其补变量。通俗解释就是输出为1对应积项为1的累加。</p><p>示例：考虑一个布尔函数 ( F(A, B, C) )：</p><ul><li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最小项为 $ ( A \cdot \overline{B} \cdot C )$ </li><li>当 ( A &#x3D; 0 ), ( B &#x3D; 1 ), ( C &#x3D; 0 ) 时，最小项为 $ ( \overline{A} \cdot B \cdot \overline{C} )$</li></ul><p>假设布尔函数在以下输入组合下输出为1：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>相应的最小项表示为：</p><center>$ F(A, B, C) = \overline{A} \cdot \overline{B} \cdot C + \overline{A} \cdot B \cdot \overline{C} + A \cdot \overline{B} \cdot C $</center><p><strong>最大项 (Maxterms)</strong> 是布尔函数的另一种标准形式，其中每个最大项对应一个输出为0的输入组合。最大项由所有变量的或运算构成，每个变量可能是原变量或其补变量。通俗解释就是输入为0所对应的和项为0的累乘</p><p>示例：同样考虑布尔函数 ( F(A, B, C) )：</p><p>这两个组合对应的最大项为：</p><ul><li>当 ( A &#x3D; 0 ), ( B &#x3D; 0 ), ( C &#x3D; 0 ) 时，最大项为$ (A + B + C) $</li><li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最大项为$ (\overline{A} + B + \overline{C} ) $</li></ul><p>假设布尔函数 ( F(A, B, C) ) 在以下输入组合下输出为0：</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>因此，相应的最大项表达式为：</p><center> \[F(A, B, C) = (A + B + C) \cdot (\overline{A} + \overline{B} + C)\] </center><p><strong>总结</strong></p><ul><li><strong>最小项</strong>：布尔函数输出为1时，对应输入组合的与运算。</li><li><strong>最大项</strong>：布尔函数输出为0时，对应输入组合的或运算。</li></ul><blockquote><p>这些概念在布尔代数和数字电路设计中非常有用，也是这门课的高频考点</p></blockquote><h3 id="2-2-Boolean-Operation-Rules"><a href="#2-2-Boolean-Operation-Rules" class="headerlink" title="2.2 Boolean Operation Rules"></a>2.2 Boolean Operation Rules</h3><p>布尔运算的基本定律，和卡诺图一样，是逻辑电路化简的主要手段</p><h4 id="2-2-1-交换律（Commutative-Law）"><a href="#2-2-1-交换律（Commutative-Law）" class="headerlink" title="2.2.1 交换律（Commutative Law）"></a>2.2.1 交换律（Commutative Law）</h4><p>交换律表示在布尔运算中，操作数的位置可以互换。</p><ul><li><strong>与运算</strong>：$ A \cdot B &#x3D; B \cdot A $</li><li><strong>或运算</strong>：$ A + B &#x3D; B + A $</li></ul><h4 id="2-2-2-结合律（Associative-Law）"><a href="#2-2-2-结合律（Associative-Law）" class="headerlink" title="2.2.2 结合律（Associative Law）"></a>2.2.2 结合律（Associative Law）</h4><p>结合律表示在布尔运算中，操作数的组合方式不影响运算结果。</p><ul><li><strong>与运算</strong>：$ (A \cdot B) \cdot C &#x3D; A \cdot (B \cdot C) $</li><li><strong>或运算</strong>：$ (A + B) + C &#x3D; A + (B + C) $</li></ul><h4 id="2-2-3-分配律（Distributive-Law）"><a href="#2-2-3-分配律（Distributive-Law）" class="headerlink" title="2.2.3 分配律（Distributive Law）"></a>2.2.3 分配律（Distributive Law）</h4><p>分配律表示一种运算可以分配到另一种运算上。</p><ul><li><strong>与对或</strong>：$ A \cdot (B + C) &#x3D; (A \cdot B) + (A \cdot C) $</li><li><strong>或对与</strong>：$ A + (B \cdot C) &#x3D; (A + B) \cdot (A + C) $</li></ul><h4 id="2-2-4-吸收律（Absorption-Law）"><a href="#2-2-4-吸收律（Absorption-Law）" class="headerlink" title="2.2.4 吸收律（Absorption Law）"></a>2.2.4 吸收律（Absorption Law）</h4><p>吸收律表示通过某些布尔运算可以简化表达式。</p><ul><li>$ A + (A \cdot B) &#x3D; A $</li><li>$ A \cdot (A + B) &#x3D; A $</li></ul><h4 id="2-2-5-合并律（Combining-Law）"><a href="#2-2-5-合并律（Combining-Law）" class="headerlink" title="2.2.5 合并律（Combining Law）"></a>2.2.5 合并律（Combining Law）</h4><p>合并律表示布尔变量和其补变量的某些组合具有特定的结果。</p><ul><li>$ A + \overline{A} &#x3D; 1 $</li><li>$ A \cdot \overline{A} &#x3D; 0 $</li></ul><h4 id="2-2-6-一致律（Identity-Law）"><a href="#2-2-6-一致律（Identity-Law）" class="headerlink" title="2.2.6 一致律（Identity Law）"></a>2.2.6 一致律（Identity Law）</h4><p>一致律表示布尔变量与1和0的运算结果。</p><ul><li><strong>与1</strong>：$ A \cdot 1 &#x3D; A $</li><li><strong>与0</strong>：$ A \cdot 0 &#x3D; 0 $</li><li><strong>或1</strong>：$ A + 1 &#x3D; 1 $</li><li><strong>或0</strong>：$ A + 0 &#x3D; A $</li></ul><h4 id="2-2-7-德摩根律（De-Morgan’s-Laws）"><a href="#2-2-7-德摩根律（De-Morgan’s-Laws）" class="headerlink" title="2.2.7 德摩根律（De Morgan’s Laws）"></a>2.2.7 德摩根律（De Morgan’s Laws）</h4><p>德摩根律表示对布尔表达式取反的规则。</p><ul><li>$ \overline{A \cdot B} &#x3D; \overline{A} + \overline{B} $</li><li>$ \overline{A + B} &#x3D; \overline{A} \cdot \overline{B} $</li></ul><h4 id="2-2-8-部分二级公式推导"><a href="#2-2-8-部分二级公式推导" class="headerlink" title="2.2.8 部分二级公式推导"></a>2.2.8 部分二级公式推导</h4><ul><li>$ A + \overline{A}B &#x3D; A + B$</li></ul><p>证明: $A(1 + B) + {A}B &#x3D; A + AB + \overline{A}B &#x3D; A + B $ </p><ul><li>$ (A + B) \cdot (A + C) &#x3D; A + (B \cdot C) $</li></ul><p>证明: $ AA + AC + AB + BC &#x3D; A + AB + AC + BC &#x3D; A(1 + B + C) + BC &#x3D; A + BC $</p><ul><li>$A \cdot (A + B) &#x3D; A$</li></ul><p>证明: $AA + AB &#x3D; A + AB &#x3D; A(1 + B) &#x3D; A$</p><ul><li>$BC + B\overline{C} &#x3D; B$</li></ul><p>证明: $B \cdot (C + \overline{C}) &#x3D; B \cdot 1 &#x3D; B$</p><ul><li>$(A + B) \cdot (A + \overline{B}) &#x3D; A$</li></ul><p>证明: $AA + A\overline{B} + AB + B\overline{B} &#x3D; A + A(B + \overline{B}) &#x3D; A + A &#x3D; A$</p><ul><li>$AB + \overline{A}C + BC &#x3D; AB + \overline{A}C$</li></ul><p>证明关键：使用吸收律 $A + AB &#x3D; A$, 推广为$AB + ABC &#x3D; AB$</p><p>$$<br>\begin{aligned}<br>&amp;AB + \overline{A}C + BC \\<br>&amp;&#x3D; AB + \overline{A}C + (A + \overline{A})BC \\<br>&amp;&#x3D; AB + \overline{A}C + ABC + \overline{A}CB \\<br>&amp;&#x3D; AB + ABC + \overline{A}C + \overline{A}CB \text{(使用推广公式)} \\<br>&amp;&#x3D; AB + \overline{A}C<br>\end{aligned}<br>$$</p><p>根据吸收律可继续推广下去：<br>$$AB + \overline{A}C + BC\cdot(\text{其他任何项}) &#x3D; AB + \overline{A}C  $$ </p><p>在表达式中，无论包含 $B$ 和 $C$ 的项如何复杂（例如 $BCDEFGH$），它都不会改变整个表达式的最终结果。</p><div class="note note-primary">            <p>渲染上述公式太折磨了！修考一般不考如此复杂的化简，一般掌握K-Map化简足够应付</p>          </div><h3 id="2-3-K-Map"><a href="#2-3-K-Map" class="headerlink" title="2.3 K-Map"></a>2.3 K-Map</h3><p>在绘制卡诺图的时候需要用到格雷码的表格。首先引入一个格雷码的概念。</p><h4 id="2-3-1-Gray-Code"><a href="#2-3-1-Gray-Code" class="headerlink" title="2.3.1 Gray Code"></a>2.3.1 Gray Code</h4><p>格雷码（Gray Code）是一种<strong>特殊的二进制编码方式</strong>，其特点是<strong>相邻的两个数码之间仅有一位二进制数不同</strong>。格雷码的发明即是用来将误差之可能性缩减至最小，编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码，可以使装置做数字步进时只更动最少的位元数以提高稳定性。</p><p><strong>格雷码的特性</strong></p><ul><li><strong>相邻差一位</strong>：每个相邻编码仅一位不同，减少了转换时的误差风险。</li><li><strong>非权重编码</strong>：格雷码不按照传统二进制编码的权值（如 $1, 2, 4, 8, \dots$）累加。</li></ul><p><strong>2 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>01</td></tr><tr><td>1</td><td>11</td><td>10</td></tr></tbody></table><p><strong>3 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>001</td><td>011</td><td>010</td></tr><tr><td>1</td><td>110</td><td>111</td><td>101</td><td>100</td></tr></tbody></table><p><strong>4 位格雷码卡诺图</strong></p><table><thead><tr><th></th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>00</td><td>0000</td><td>0001</td><td>0011</td><td>0010</td></tr><tr><td>01</td><td>0110</td><td>0111</td><td>0101</td><td>0100</td></tr><tr><td>11</td><td>1110</td><td>1111</td><td>1101</td><td>1100</td></tr><tr><td>10</td><td>1010</td><td>1011</td><td>1001</td><td>1000</td></tr></tbody></table><blockquote><p>上述表格，无论是以x轴对称，或者y轴对称，或者中心对称，均只有1位的差异</p></blockquote><h4 id="2-3-2-卡诺图化简步骤"><a href="#2-3-2-卡诺图化简步骤" class="headerlink" title="2.3.2 卡诺图化简步骤"></a>2.3.2 卡诺图化简步骤</h4><ol><li><p>构建 K 图：根据布尔函数的输入变量数量，构建相应大小的 K 图：</p><ul><li>2 位变量：4 格（2×2）</li><li>3 位变量：8 格（2×4）</li><li>4 位变量：16 格（4×4）</li></ul></li></ol><p>横轴和纵轴的变量顺序需按照<strong>格雷码</strong>排列，以确保相邻格子之间只有一个变量不同。</p><ol start="2"><li><p>填写真值表和无关项：</p><ul><li>根据逻辑函数或真值表，在 K 图中标记输出为 1 的位置。</li><li>将无关项标(Don’t Care Conditions)记为 X。无关项是那些对最终结果没有影响的输入组合，可以被自由选择为 1 或 0，以帮助扩大合并区域。</li></ul></li><li><p>寻找最大合并区域：</p><ul><li>在 K 图中，寻找可以合并的 1 和 X 区域。合并的目标是形成2 的幂次方大小的区域（例如 1、2、4、8 等格），并使每个 1 尽量包含在最大的区域中。</li><li>合并时遵循以下规则：<ul><li>只允许合并相邻的 1 和 X（上下、左右、包围环绕相邻）。</li><li>尽量优先选择包含更多无关项 X 的区域，以增加合并区域的大小。</li><li>合并区域可以是矩形、正方形，甚至是环绕 K 图的封闭区域。</li></ul></li></ul></li><li><p>合并相邻项：</p><ul><li>每个合并区域中的变量中，如果某个变量在区域内既有 0 又有 1，则忽略该变量（因为它在该区域中无关紧要）。</li><li>将每个合并区域的共同变量提取为一个积项。对于每个变量：<ul><li>如果变量在区域内始终为 1，则使用原变量（如 $A$）。</li><li>如果变量在区域内始终为 0，则使用其反码（如 $\overline{A}$）。</li></ul></li></ul></li><li><p>写出最简化表达式：</p><ul><li>将所有合并区域的积项求和，得到逻辑函数的最简化形式。</li><li>所有包含在化简表达式中的项应尽量少，以确保表达式是最简形式。</li></ul></li></ol><blockquote><p>多练多化简就行了，没什么难度</p></blockquote><h3 id="2-4-常见数字模块"><a href="#2-4-常见数字模块" class="headerlink" title="2.4 常见数字模块"></a>2.4 常见数字模块</h3><p>这一小节跟计算机组成中的算术运算关联度很高，数字电路就是来讲解计算机所呈现出来的算术运算在底层是如何用逻辑元器件实现的。</p><h4 id="2-4-1-Half-Adder"><a href="#2-4-1-Half-Adder" class="headerlink" title="2.4.1 Half Adder"></a>2.4.1 Half Adder</h4><p><strong>半加器 (Half Adder)</strong> 是一个基本的数字电路，用于计算两个单比特二进制数的和。它的功能是执行二进制加法，并且产生两个输出：</p><ul><li>Sum：表示两个输入二进制数加法的结果（不考虑进位）。这里用$S$来表示和。</li><li>Carry：表示加法结果中<strong>产生的进位</strong>。这里用$Cout$来表示产生的进位了。</li></ul><p>根据如下K-Map我们可以得出和与进位的表达式，分别为：$S &#x3D; A \oplus B$ , $Cout &#x3D; A\cdot B$，再把组合电路进行封装📦(encapsulation)可以得到半加器这个电路元件<br><img src="/img/DC/half_adder.svg" alt="半加器" style="max-width: 100%; height: auto;" />  </p><h4 id="2-4-2-Full-Adder"><a href="#2-4-2-Full-Adder" class="headerlink" title="2.4.2 Full Adder"></a>2.4.2 Full Adder</h4><p><strong>全加器 (Full Adder)</strong> 是数字电路中的一种基本元件，用于对二进制数进行加法运算。与半加器（Half Adder）相比，全加器可以对两个二进制数和一个进位位进行加法运算，并输出结果和新的进位位。</p><p>全加器的输入包括三个位：</p><ul><li><p>A（第一个加数位）</p></li><li><p>B（第二个加数位）</p></li><li><p>Cin（输入进位位）</p></li></ul><p>全加器的输出包括两个位：</p><ul><li><p>S（和位）：表示加法结果的当前位。</p></li><li><p>Cout（输出进位位）：表示加法结果的进位位。</p></li></ul><img src="/img/DC/full_adder.svg" alt="全加器" style="max-width: 100%; height: auto;" />  <p>首先分析真值表写出最小项表达式，对于$S$有：</p><p>$$<br>\begin{aligned}<br>S &amp;&#x3D; \overline{A} \cdot B \cdot \overline{C_{in}} + A \cdot\overline{B} \cdot \overline{C_{in}} + \overline{A} \cdot \overline{B} \cdot C_{in} + A \cdot B \cdot C_{in} \\<br>&amp;&#x3D; \overline{C_{in}}(A \oplus B) + C_{in} \overline{(A \oplus B)} \\<br>&amp;&#x3D; A \oplus B \oplus C_{in}<br>\end{aligned}<br>$$</p><p>对于$C_{out}$有：</p><p>$$<br>\begin{aligned}<br>C_{out} &amp;&#x3D; AB \overline{C_{in}} + \overline{A}BC_{in} + A \overline{B}C_{in} + ABC_{in} \\<br>&amp;&#x3D; AB + C_{in}(A \oplus B)<br>\end{aligned}<br>$$</p><p><strong>思考🤔</strong> ：为什么黑书给的是 $C_{out} &#x3D; AB + AC_{in} + BC_{in}$ ，这时候可以借助K-Map化简：如下图所示</p><div style="text-align: center;">  <img src="/img/DC/fa1.svg" alt="k-map" style="max-width: 100%; height: auto;" /></div><p>根据K-Map化简，我们的全加器的画法会得出上图的电路，而如果根据真值表进行表达式化简，我们会得到下图的全加器。</p><img src="/img/DC/fa2.svg" alt="Full Adder" style="max-width: 100%; height: auto;" />  <p>我们可以用2个半加器和一个或门封装成一个全加器,具体的计算过程就不赘述了，这是修考重点！</p><img src="/img/DC/fa3.svg" alt="全加器封装" style="max-width: 100%; height: auto;" />  <h4 id="2-4-3-Ripple-Carry-Adder"><a href="#2-4-3-Ripple-Carry-Adder" class="headerlink" title="2.4.3 Ripple-Carry Adder"></a>2.4.3 Ripple-Carry Adder</h4><p><strong>Ripple-Carry Adder</strong> （行波进位加法器）是一种用于二进制数加法的简单组合逻辑电路，由多个一位全加器（Full Adder）级联而成，每个全加器负责处理输入位和进位。</p><ol><li><p><strong>组成结构</strong>  </p><ul><li>Ripple-Carry Adder 包括 $n$ 个全加器，用于计算 $n$ 位二进制数的加法。  </li><li>每个全加器接收两个输入位 $A[i]$ 和 $B[i]$，以及前一位的进位 $C[i]$。  </li><li>输出为和 $S[i]$ 和进位 $C[i+1]$。</li></ul></li><li><p><strong>进位传播</strong>  </p><ul><li>第一个全加器处理最低有效位 $A[0]$ 和 $B[0]$ 以及初始进位（通常为 0），产生和 $S[0]$ 和进位 $C[1]$。  </li><li>进位 $C[1]$ 传递到下一个全加器，依次类推，直到最高有效位。</li></ul></li><li><p><strong>优缺点</strong></p><ul><li><p><strong>优点</strong>  </p><ul><li>设计简单，硬件实现容易。</li></ul></li><li><p><strong>缺点</strong>  </p><ul><li><strong>进位传播延迟</strong>：每个全加器必须等待前一级的进位信号，导致延迟随位数线性增长，影响运算速度。</li></ul></li></ul><p>Ripple-Carry Adder 适用于简单、低速应用；但无法满足更高速的加法需求。</p></li></ol><img src="/img/DC/ripple.svg" alt="4bit行波进位加法器" style="max-width: 100%; height: auto;" />  <h4 id="2-4-4-Carry-Lookahead-Adder-CLA"><a href="#2-4-4-Carry-Lookahead-Adder-CLA" class="headerlink" title="2.4.4 Carry-Lookahead Adder (CLA)"></a>2.4.4 Carry-Lookahead Adder (CLA)</h4><p><strong>Carry-Lookahead Adder (CLA)</strong> ，即先行进位加法器，是一种改进的加法器，用于快速执行二进制加法，解决 Ripple-Carry Adder 中进位传播延迟的问题。</p><p>Carry-Lookahead Adder 通过并行计算进位信号，而不依赖逐级传播，从而显著提高速度。其核心思想是利用生成信号和传播信号：</p><ol><li><p><strong>生成信号 (Generate)</strong>  ：表示某一位的加法会直接产生一个进位：<br>$G_i &#x3D; A_i \cdot B_i$</p></li><li><p><strong>传播信号 (Propagate)</strong>  ：表示某一位的加法会将来自上一位的进位传递下去：<br>$P_i &#x3D; A_i + B_i$</p></li><li><p><strong>进位计算公式</strong>  ：根据生成和传播信号，计算每一位的进位：<br>$C_{i+1} &#x3D; G_i + P_i \cdot C_i$   其中，$C_0$ 是初始进位。</p></li></ol><p><strong>推导证明：</strong><br>根据前面全加器的结论，我们有：</p><ol><li><p><strong>初始公式</strong><br>$$C_{i + 1} &#x3D; A_{i} \cdot B_{i} + (A_{i} + B_{i}) \cdot C_{i}$$</p></li><li><p><strong>引入生成信号和传播信号</strong>(都是已知信号)<br>$$G_{i} &#x3D; A_{i} \cdot B_{i}$$<br>$$P_{i} &#x3D; A_{i} + B_{i}$$</p></li><li><p><strong>公式代换</strong><br>$$C_{i + 1} &#x3D; G_{i} + P_{i} \cdot C_{i} \quad \text{(用 $P_{i}$ 代换 $(A_{i} + B_{i})$)}$$</p></li></ol><p>那么我就可以用已知的输入 $A_{0}$  ~  $A_{n-1}$ 和 $B_{0}$  ~  $B_{n-1}$ 以及 $C_{0}$ 来确定进位是什么了。比如：</p><p>$$C_{1} &#x3D; G_{0} + P_{0} \cdot C_{0}$$</p><p>$$C_{2} &#x3D; G_{1} + P_{1} \cdot C_{1} &#x3D; G_{1} + P_{1} G_{0} + P_{1}P_{0}C_{0}$$<br>不断迭代我们可以得出 $C_{3}$ 和 $C_{4}$ ，甚至到 $C_{n-1}$ ，但是！考虑到电路的复杂程度和电路成本的情况下，我们可以稍微妥协一下，采用分块的策略，比如实现一个32bit的加法器，我们可以将四个全加器分成一个块使用上面推导出来的门电路封装成一个块打包好。然后我们就可以迅速确定当前块的进位，减少等待进位的时间。<em>在不考虑其他门延迟的情况下</em></p><ul><li>不分块的情况下：需要等32次进位的传递</li><li>4个为一块的情况下：只需要等$32&#x2F;4 &#x3D; 8$次进位传递</li></ul><img src="/img/DC/lookahead.jpeg" alt="黑书: 32bit超前进位加法器" style="max-width: 100%; height: auto;" />  <p><strong>优点</strong></p><ul><li><strong>减少延迟</strong>：进位计算是并行完成的，速度显著快于 Ripple-Carry Adder。</li><li><strong>高效的硬件实现</strong>：适合多位二进制数加法的高速场景。</li></ul><p><strong>缺点</strong></p><ul><li><strong>硬件复杂度增加</strong>：需要额外的逻辑电路来计算生成和传播信号，随着位数增加，复杂性迅速提高。</li><li><strong>功耗较高</strong>：更多逻辑门导致功耗增加。</li></ul><p>Carry-Lookahead Adder 是一种高效的加法器设计，常用于高速处理器中。相比 Ripple-Carry Adder，它通过并行化进位计算显著提高了运算速度，但也牺牲了一定的硬件简单性。</p><h4 id="2-4-5-Half-Subtractor"><a href="#2-4-5-Half-Subtractor" class="headerlink" title="2.4.5 Half Subtractor"></a>2.4.5 Half Subtractor</h4><p>半减法器（Half Subtractor）可以对两个单个位的二进制数进行减法运算。它有两个输入：被减数$A$和减数$B$，输出包括差值（Difference, $D$）和借位（Borrow, $B_{0}$）。</p><ul><li><p>差值 $D &#x3D; A \oplus B$</p></li><li><p>借位$B_{0} &#x3D; \overline{A}B$</p></li></ul><div style="text-align: center;"><img src="/img/DC/half.svg" alt="半减法器" style="max-width: 100%; height: auto;" />  </div><h4 id="2-4-6-Full-Subtractor"><a href="#2-4-6-Full-Subtractor" class="headerlink" title="2.4.6 Full Subtractor"></a>2.4.6 Full Subtractor</h4><p>全减法器（Full Subtractor）可以对两个单个位的二进制数以及一个借位输入进行减法运算。它有三个输入：被减数$X$，减数$Y$，来自低位借位输入（Borrow_in, $B_{in}$），输出包括差值（Difference, $D$）和向高位的借位输出（Borrow_out, $B_{out}$）。</p><p>差值$D &#x3D; X ⊕ Y ⊕ B_{in}$</p><p>借位输出$<br>B_{out}&#x3D; \overline{X}B_{in} + \overline{X}Y + YB_{in}<br>$</p><blockquote><p>上述公式可以通过真值表和K-map得出，这里就省略了</p></blockquote><div style="text-align: center;"><img src="/img/DC/sub2.svg" alt="半减法器" style="max-width: 100%; height: auto;" />  </div><p>Q：<em>如何用N-bit全加器实现全减器？</em></p><p>计算机中的加减运算都是通过补码进行的，根据补码运算有$A - B$ 实现的时候可以转化为$A + (-B)$, 我们又有 $\overline{B} + 1 &#x3D; -B$，所以$Y &#x3D; A - B &#x3D; A + \overline{B} + 1$</p><div style="text-align: center;"><img src="/img/DC/sub3.svg" alt="N-bit减法器" style="max-width: 100%; height: auto;" />  </div><h4 id="2-4-7-Multiplexer"><a href="#2-4-7-Multiplexer" class="headerlink" title="2.4.7 Multiplexer"></a>2.4.7 Multiplexer</h4><p>复用器(Multiplexer)是一种数字电路元件，它的主要功能是将多个输入信号中的一个传递到输出端。复用器可以被视为一个多路选择开关，通过控制选择信号选择特定的输入线路。</p><p><strong>工作原理：</strong></p><ul><li><strong>输入信号</strong>：有 $2^n$ 个输入信号线，每条线路可传递一个信号。</li><li><strong>选择信号</strong>：通过 $n$ 条选择线决定选取哪一个输入信号。</li><li><strong>输出信号</strong>：仅有一个输出，输出选定的输入信号。</li></ul><p>复用器的输出可表示为：<br>$$<br>Y &#x3D; I_i \quad (i \text{由选择信号确定})<br>$$<br>其中 $I_i$ 是第 $i$ 个输入。下图是一个用门电路设计2:1 MUX并封装的过程</p><img src="/img/DC/mux.svg" alt="2:1 MUX" style="max-width: 100%; height: auto;" />  <p><strong>基本结构：</strong></p><ul><li><strong>数据输入端（Data Inputs）</strong>：多路信号的输入端口。</li><li><strong>选择端（Select Lines）</strong>：控制信号，决定选用哪个输入。</li><li><strong>输出端（Output Line）</strong>：传递选定信号的端口。</li></ul><p>例如：<br>对于一个 <strong>4路复用器（4-to-1 MUX）</strong>：</p><ul><li>有 4 个输入线：$I_0, I_1, I_2, I_3$。</li><li>有 2 个选择线：$S_1, S_0$。</li><li>有 1 个输出线：$Y$。</li></ul><p>输出由选择信号 $S_1$ 和 $S_0$ 确定：</p><p>$$<br>Y &#x3D;<br>\begin{cases}<br>I_0, &amp; \text{if } S_1S_0 &#x3D; 00 \\<br>I_1, &amp; \text{if } S_1S_0 &#x3D; 01 \\<br>I_2, &amp; \text{if } S_1S_0 &#x3D; 10 \\<br>I_3, &amp; \text{if } S_1S_0 &#x3D; 11<br>\end{cases}<br>$$</p><p>通过增加选择信号线数，复用器可以扩展为更大的多路选择器（如 8-to-1、16-to-1）。</p><img src="/img/DC/mux2.svg" alt="MUX" style="max-width: 100%; height: auto;" />  <h4 id="2-4-8-Decoder"><a href="#2-4-8-Decoder" class="headerlink" title="2.4.8 Decoder"></a>2.4.8 Decoder</h4><p>译码器是一种<strong>组合逻辑电路</strong>，其主要功能是将输入的<strong>二进制代码</strong>转换为<strong>独热码（one-hot code）</strong>，即在输出中只有一条线路为高电平，其余为低电平。</p><div class="note note-success">            <p>独热码工作原理:如果有 $n$ 个类别，则需要一个长度为 $n$ 的二进制向量。对应某个类别的位置为1，其余位置为0。例如，对于3个类别：A, B, C：</p><ul><li>类别 A 编码为：$[1, 0, 0]$</li><li>类别 B 编码为：$[0, 1, 0]$</li><li>类别 C 编码为：$[0, 0, 1]$</li></ul>          </div><p><strong>译码器工作原理</strong></p><ul><li><strong>输入信号</strong>：有 $n$ 条输入信号线，用于表示二进制编码。</li><li><strong>输出信号</strong>：有 $2^n$ 条输出信号线，每个输出对应一种输入组合。</li><li><strong>控制信号（可选）</strong>：部分译码器可能需要使能信号（Enable），用于控制译码器的工作状态。</li></ul><p>译码器根据输入信号的值，激活唯一对应的输出线。例如：</p><ul><li>输入：$00, 01, 10, 11$</li><li>输出：$Y_0, Y_1, Y_2, Y_3$ 依次被激活。</li></ul><p><strong>译码器基本结构</strong></p><p>对于一个 $n$ 位输入的译码器：</p><ul><li>有 $2^n$ 个输出信号线。</li><li>每个输出信号线对应一个输入组合。</li></ul><p>例如，一个 <strong>2-to-4 译码器</strong>（2位输入，4个输出）：</p><ul><li>输入：$A_1, A_0$。</li><li>输出：$Y_0, Y_1, Y_2, Y_3$。</li><li>输出逻辑：<br>$$<br>Y_0 &#x3D; \overline{A_1} \cdot \overline{A_0}, \quad<br>Y_1 &#x3D; \overline{A_1} \cdot A_0, \quad<br>Y_2 &#x3D; A_1 \cdot \overline{A_0}, \quad<br>Y_3 &#x3D; A_1 \cdot A_0<br>$$</li></ul><p>译码器是数字电路中重要的基础模块，用于信号的<strong>解码与路由</strong>。</p><img src="/img/DC/decoder.svg" alt="译码器" style="max-width: 100%; height: auto;" />  <h3 id="2-5-传播延迟和最小延迟"><a href="#2-5-传播延迟和最小延迟" class="headerlink" title="2.5 传播延迟和最小延迟"></a>2.5 传播延迟和最小延迟</h3><p><strong>传播延迟（Propagation Delay, $t_{pd}$）</strong></p><ul><li>定义：信号从输入端变化到输出端<strong>完全稳定</strong>所需的时间。对于组合电路来说就是关键路径上面每一个元件的传播延迟之和</li><li>影响因素：<ul><li>器件特性：如晶体管的开关速度、驱动能力。</li><li>负载电容：较大的负载电容会增加传播延迟。</li><li>电路拓扑：更复杂的路径结构会增加延迟。</li></ul></li><li>意义：传播延迟决定了电路的速度性能，即最大运行频率。</li></ul><p><strong>最小延迟（Contamination Delay, $t_{cd}$）</strong></p><ul><li>定义：信号在电路中传输所需的<strong>最短时间</strong>，反映信号可能在某些路径上过快到达输出端的时间。对于组合电路来说是最短路径上面每个元件的最小延迟之和。</li><li>影响因素：<ul><li>布线长度和材料特性。</li><li>逻辑门数量与优化设计。</li></ul></li><li>意义：<ul><li>保持时间（Hold Time）违规：最小延迟可能导致竞争冒险或保持时间问题。</li><li>必须确保最小延迟不会破坏电路的时序完整性。</li></ul></li></ul><img src="/img/DC/pd.svg" alt="传播延迟和最小延迟" style="max-width: 100%; height: auto;" />  <div class="note note-success">            <p>Note: 每个门的传播延迟和最小延迟要看参数表,而且传播延迟和最小延迟这个问题非常艰深…</p>          </div><h3 id="2-6-Glitch"><a href="#2-6-Glitch" class="headerlink" title="2.6 Glitch"></a>2.6 Glitch</h3><p><strong>毛刺（Glitch）</strong> 是数字电路中由于信号传播延迟或竞争冒险导致的短暂错误信号脉冲，通常表现为在信号稳定之前出现的意外高电平或低电平跳变。</p><p><strong>产生原因：</strong></p><ul><li>竞争冒险（Hazards）：当多条信号路径的传播延迟不一致时，可能导致某一时刻输出信号短暂错误。</li><li>门延迟： 逻辑门的延迟导致信号在不同路径上到达输出端的时间不同。</li><li>不完全同步：异步信号未正确对齐，导致输出出现瞬时错误信号。</li></ul><img src="/img/DC/glitch.svg" alt="毛刺时序图" style="max-width: 100%; height: auto;" />  <p>为了消除毛刺，可以通过添加冗余项优化逻辑表达式，确保信号在所有可能的变化路径中保持稳定。</p><p><strong>步骤：</strong></p><ul><li>构造卡诺图：根据真值表将逻辑表达式填入卡诺图。</li><li>标记相邻格子：将输出为“1”的相邻单元块分组，覆盖现有的逻辑区域。<br>检查是否有相邻的“1”之间存在空隙（可能导致冒险）。</li><li>添加冗余项：对于无法完全覆盖的相邻“1”之间的空隙，添加额外的逻辑项来补充。<br>确保每一个相邻的“1”都连通，避免由于输入信号变化导致逻辑的不连续。</li><li>生成优化后的逻辑表达式：将包含冗余项的逻辑表达式写出并实现。</li></ul><p>通过使用卡诺图消除毛刺的关键是：</p><ol><li>识别相邻逻辑之间的不连续性。</li><li>添加冗余项确保逻辑表达式的稳定性。</li><li>优化后可减少信号跳变，避免毛刺的产生。</li></ol><img src="/img/DC/glitch2.svg" alt="毛刺消除" style="max-width: 100%; height: auto;" />  <h2 id="3-Sequential-Logic-Circuit"><a href="#3-Sequential-Logic-Circuit" class="headerlink" title="3. Sequential Logic Circuit"></a>3. Sequential Logic Circuit</h2><p><strong>时序逻辑电路（Sequential Logic Circuit）</strong> 是一类输出<u>不仅取决于当前输入，还与电路的历史状态相关的电路。</u>它通过存储元件（如触发器、锁存器等）记录状态，具有<em>记忆功能</em>。</p><p><strong>时序逻辑电路特点:</strong></p><ul><li>记忆功能：与组合逻辑电路不同，时序逻辑电路可以存储数据。</li><li>状态变化：状态的变化通常由时钟信号控制，随着时钟信号的边沿（上升沿或下降沿）进行更新。</li><li>输出依赖性：输出依赖于当前输入和之前的状态。</li></ul><h3 id="3-1-Latch"><a href="#3-1-Latch" class="headerlink" title="3.1 Latch"></a>3.1 Latch</h3><p><strong>锁存器（Latch）</strong>是一种<strong>基本的存储元件</strong>，用于存储一个<strong>单个位的二进制信息</strong>。它的输出状态会随输入信号的变化而更新，具体取决于使能信号（通常称为<strong>控制信号</strong>或<strong>使能信号</strong>）。</p><p>工作方式为<strong>电平触发</strong>：  锁存器根据控制信号的电平（高电平或低电平）决定是否更新输出。  </p><ul><li>当使能信号为有效电平时，输出跟随输入变化。</li><li>当使能信号为无效电平时，锁存器保持当前状态（记忆功能）。</li></ul><p><strong>1. 锁存器类型：</strong></p><ul><li><p><strong>SR锁存器（Set-Reset Latch）</strong>：</p><ul><li>基于两个交叉耦合的与非门（NAND）或或非门（NOR）构成。</li><li>通过 $S$（置位）和 $R$（复位）信号控制状态。</li><li>存在不允许 $S &#x3D; R &#x3D; 1$ 的<strong>无效状态</strong>（对于NOR实现）。</li></ul></li><li><p><strong>D锁存器（Data Latch）</strong>：</p><ul><li>又称为<strong>数据锁存器</strong>。</li><li>有效控制信号时，输出 $Q$ 跟随输入 $D$；无效时，输出保持不变。</li></ul></li><li><p><strong>JK锁存器</strong>：</p><ul><li>改进了SR锁存器的无效状态问题，能够实现翻转（Toggle）功能。</li></ul></li></ul><p><strong>2. 锁存器特点：</strong></p><ul><li><strong>电平敏感</strong>：锁存器会在控制信号有效的整个时间内更新状态，而不是像触发器那样在时钟边沿更新。</li><li><strong>记忆功能</strong>：能够存储当前状态，直到输入或控制信号改变。</li></ul><p><strong>3. 锁存器应用</strong></p><ul><li><strong>数据暂存</strong>：存储单个位的信息。</li><li><strong>寄存器的构成</strong>：多个锁存器组合可以组成寄存器，用于数据存储和处理。</li><li><strong>时序电路</strong>：如简单的状态存储元件。</li></ul><p>锁存器是电平触发的基本存储元件，可以根据输入和使能信号存储信息或保持状态。其在数字电路中的作用类似“开关”，用以暂存和传递数据。</p><h4 id="3-1-1-SR锁存器（Set-Reset-Latch）"><a href="#3-1-1-SR锁存器（Set-Reset-Latch）" class="headerlink" title="3.1.1 SR锁存器（Set-Reset Latch）"></a>3.1.1 SR锁存器（Set-Reset Latch）</h4><p>SR锁存器是一种<strong>基本的锁存器类型</strong>，用于通过置位信号（Set）和复位信号（Reset）控制输出状态。它是由两个交叉耦合的逻辑门（通常是 NAND 或 NOR 门）构成的。</p><p><strong>SR Latch工作方式：</strong></p><ul><li><strong>输入信号</strong>：  <ul><li>$S$（Set）：置位信号，用于将输出 $Q$ 设置为高电平（1）。</li><li>$R$（Reset）：复位信号，用于将输出 $Q$ 设置为低电平（0）。</li></ul></li><li><strong>输出信号</strong>：<ul><li>$Q$：当前状态输出。</li><li>$\overline{Q}$：$Q$ 的反相输出，满足 $Q \cdot \overline{Q} &#x3D; 0$。</li></ul></li></ul><p>SR 锁存器的状态随 $S$ 和 $R$ 的变化而更新，具体规则如下：</p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$\overline{Q}$</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>保持</td><td>保持</td><td>保持当前状态</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>复位（Reset）</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>置位（Set）</td></tr><tr><td>1</td><td>1</td><td>无效</td><td>无效</td><td>无效状态（禁止）</td></tr></tbody></table><p><strong>SR Latch特点：</strong></p><ul><li><strong>电平敏感</strong>：<br>SR锁存器根据 $S$ 和 $R$ 的电平信号控制输出状态。</li><li><strong>无效状态</strong>：<br>当 $S &#x3D; 1$ 且 $R &#x3D; 1$ 时，$Q$ 和 $\overline{Q}$ 都为 0，这种状态被定义为无效状态，通常在设计中需要避免。</li></ul><p><strong>SR Latch实现：</strong> SR锁存器可以通过以下两种逻辑门实现：</p><ul><li><strong>NOR门实现：</strong>：<ul><li>当 $S &#x3D; 1$ 时，置位 $Q &#x3D; 1$；当 $R &#x3D; 1$ 时，复位 $Q &#x3D; 0$。</li></ul></li><li><strong>NAND门实现：</strong>：<ul><li>信号逻辑与 NOR 门相反，通常 $S$ 和 $R$ 信号需要取反。</li></ul></li></ul><p><strong>SR Latch应用：</strong></p><ul><li><strong>状态存储</strong>：  记录电路中的状态信号。</li><li><strong>控制电路</strong>：  用于实现简单的时序控制功能。</li><li><strong>锁存电路</strong>：  用作更复杂存储元件（如触发器）的基础单元。</li></ul><p>SR锁存器是最基本的锁存器，通过置位和复位信号控制输出状态，但需要避免无效状态。它在简单存储和状态保持电路中有广泛应用。</p><img src="/img/DC/sr.svg" alt="NOR门SR锁存器" style="max-width: 100%; height: auto;" />  <p>还有一种是由NAND门构成的SR锁存器，注意真值表和由NOR门构成的SR锁存器的区别</p><table><thead><tr><th>$S$</th><th>$R$</th><th>$Q$</th><th>$\overline{Q}$</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td><strong>无效状态</strong>（禁止）</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>复位（Reset）</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>置位（Set）</td></tr><tr><td>1</td><td>1</td><td>保持</td><td>保持</td><td>保持当前状态</td></tr></tbody></table><img src="/img/DC/sr2.svg" alt="NAND门SR锁存器" style="max-width: 100%; height: auto;" />  <h4 id="3-1-2-D锁存器（Data-Latch）"><a href="#3-1-2-D锁存器（Data-Latch）" class="headerlink" title="3.1.2 D锁存器（Data Latch）"></a>3.1.2 D锁存器（Data Latch）</h4><p>D锁存器是一种基本的时序逻辑电路，用于存储1位二进制数据。它根据时钟信号的状态决定是否允许数据输入被存储。</p><ol><li><p><strong>输入和输出：</strong></p><ul><li><strong>D（Data）输入</strong>：需要存储的数据。</li><li><strong>使能信号（Enable&#x2F;Clock，通常用<code>E</code>或<code>EN</code>表示）</strong>：控制数据存储的信号。</li><li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li></ul></li><li><p><strong>工作原理：</strong></p><ul><li>当 <strong>使能信号为高</strong>（<code>E = 1</code>）：锁存器“打开”，D输入的值直接通过电路输出到 Q。</li><li>当 <strong>使能信号为低</strong>（<code>E = 0</code>）：锁存器“锁住”，Q 保持之前存储的值，不受 D 输入变化的影响。</li></ul></li><li><p><strong>特性：</strong></p><ul><li>数据在 <strong>使能信号有效期间</strong> 会被更新。</li><li>D锁存器消除了竞争（Race）条件，因为它只有一个数据输入（D），避免了像 SR 锁存器中的非法状态（S&#x3D;R&#x3D;1）。</li></ul></li><li><p><strong>应用：</strong></p></li></ol><ul><li><strong>数据存储单元</strong>：用作基本的位存储器。</li><li><strong>数据保持电路</strong>：维持信号的稳定性。</li><li><strong>边沿触发寄存器</strong>（如 D 触发器）的基本构造单元。</li></ul><table><thead><tr><th>Enable (E)</th><th>Data (D)</th><th>Output (Q)</th></tr></thead><tbody><tr><td>0</td><td>X (任意)</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>D锁存器逻辑门组成：</p><ul><li>两个<strong>与非门（NAND）或与门（AND）</strong>用来生成控制信号。</li><li>两个交叉耦合的 NAND 门（或 NOR 门）构成一个基本的锁存器（SR 锁存器）。</li></ul><img src="/img/DC/dlatch.svg" alt="D锁存器" style="max-width: 100%; height: auto;" />  <h4 id="3-1-3-JK锁存器（JK-Latch）"><a href="#3-1-3-JK锁存器（JK-Latch）" class="headerlink" title="3.1.3 JK锁存器（JK Latch）"></a>3.1.3 JK锁存器（JK Latch）</h4><p>JK锁存器是一种增强型的时序逻辑电路，是对 SR 锁存器的改进，避免了 SR 锁存器中 <code>S=1</code> 和 <code>R=1</code> 时的非法状态问题。它被广泛用于时序电路中，能够实现多种功能，如保持、置位、复位和翻转。</p><ol><li><p><strong>输入和输出：</strong></p><ul><li><strong>J（Set）</strong>：对应置位功能。</li><li><strong>K（Reset）</strong>：对应复位功能。</li><li><strong>使能信号（Enable 或 Clock）</strong>：控制锁存器工作状态。</li><li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li></ul></li><li><p><strong>功能定义：</strong></p><ul><li><strong>J&#x3D;0, K&#x3D;0</strong>：保持状态（Q 保持不变）。</li><li><strong>J&#x3D;0, K&#x3D;1</strong>：复位（Q&#x3D;0）。</li><li><strong>J&#x3D;1, K&#x3D;0</strong>：置位（Q&#x3D;1）。</li><li><strong>J&#x3D;1, K&#x3D;1</strong>：翻转状态（Q 从 0 变为 1，或从 1 变为 0）。</li></ul></li></ol><table><thead><tr><th>Enable (E)</th><th>J</th><th>K</th><th>Q (Next State)</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>X</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>0</td><td>保持原值</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>Q̅（翻转）</td></tr></tbody></table><ol start="3"><li><strong>JK锁存器应用:</strong></li></ol><ul><li><strong>寄存器设计</strong>：作为存储单元使用。</li><li><strong>计数器</strong>：通过翻转功能实现二进制计数器。</li><li><strong>时序电路</strong>：作为基本的控制逻辑单元。</li></ul><img src="/img/DC/jklatch.svg" alt="JK锁存器" style="max-width: 100%; height: auto;" />  <h3 id="3-2-Flip-FLop"><a href="#3-2-Flip-FLop" class="headerlink" title="3.2 Flip-FLop"></a>3.2 Flip-FLop</h3><p>触发器是数字电路中的一种基本<strong>时序逻辑电路</strong>，用于存储一个二进制位的信息。它具有<strong>存储能力</strong>和<strong>同步性</strong>，是寄存器、计数器等时序电路的基础组件。</p><p><strong>触发器的特点：</strong></p><ol><li><strong>存储能力</strong>：可以存储1位二进制数据（0或1）。</li><li><strong>同步性</strong>：大多数触发器通过<strong>时钟信号（Clock）</strong>控制状态的改变。</li><li><strong>状态保持</strong>：在没有输入信号变化时，触发器会保持当前状态。</li></ol><p><strong>常见触发器类型：</strong></p><p><strong>SR触发器：</strong></p><ul><li>基本类型，具有两个输入：<strong>Set（置1）</strong> 和 <strong>Reset（清0）</strong>。</li><li>特点：<ul><li>S&#x3D;1, R&#x3D;0：输出为1。</li><li>S&#x3D;0, R&#x3D;1：输出为0。</li><li>S&#x3D;0, R&#x3D;0：保持状态。</li><li><strong>S&#x3D;1, R&#x3D;1</strong>：不稳定状态（无效）。</li></ul></li></ul><p><strong>D触发器（数据触发器）：</strong></p><ul><li>具有一个数据输入端（D）和一个时钟输入端（CLK）。</li><li>特点：<ul><li>在时钟信号的有效边沿（上升沿或下降沿）到来时，将输入D的值传递到输出Q。</li></ul></li><li>应用：<ul><li>常用于数据同步和寄存器设计。</li></ul></li></ul><p><strong>JK触发器：</strong></p><ul><li>是RS触发器的改进型，消除了<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态。</li><li>输入为J和K：<ul><li>J&#x3D;1, K&#x3D;0：置1。</li><li>J&#x3D;0, K&#x3D;1：清0。</li><li>J&#x3D;K&#x3D;1：状态翻转。</li></ul></li><li>应用：<ul><li>广泛用于计数器和状态机设计。</li></ul></li></ul><p><strong>T触发器（触发翻转器）：</strong></p><ul><li>只有一个输入（T）。</li><li>特点：<ul><li>T&#x3D;1：状态翻转。</li><li>T&#x3D;0：状态保持。</li></ul></li><li>应用：<ul><li>常用于计数器电路。</li></ul></li></ul><p>触发器是数字电路中<strong>存储单元的核心</strong>，用来实现数据存储和同步控制。不同类型的触发器适用于不同的功能需求：</p><ul><li>SR触发器用于简单存储；</li><li>D触发器用于数据锁存；</li><li>JK触发器适合复杂逻辑控制；</li><li>T触发器常用于计数和分频。</li></ul><h4 id="3-2-1-SR-Flip-Flop"><a href="#3-2-1-SR-Flip-Flop" class="headerlink" title="3.2.1 SR Flip-Flop"></a>3.2.1 SR Flip-Flop</h4><p><strong>SR触发器</strong>是一种基本的双稳态存储单元，用于存储1位二进制信息。SR触发器由 <strong>Set（S）</strong> 和 <strong>Reset（R）</strong> 两个输入控制输出状态，常用于简单的存储和逻辑控制。</p><p><strong>工作原理</strong></p><ul><li><strong>S（Set）</strong>：设置触发器的输出为1（Q&#x3D;1）。</li><li><strong>R（Reset）</strong>：重置触发器的输出为0（Q&#x3D;0）。</li><li>$Q$ 和 $\overline{Q}$：为触发器的输出和其反向输出。</li></ul><p><strong>逻辑功能表</strong></p><table><thead><tr><th>S</th><th>R</th><th>Q（输出）</th><th>状态</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>保持</td><td>保持上次状态</td></tr><tr><td>0</td><td>1</td><td>0</td><td>清零</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置1</td></tr><tr><td>1</td><td>1</td><td>无效</td><td>不允许状态</td></tr></tbody></table><p> <strong>状态说明</strong></p><ol><li><strong>S&#x3D;0, R&#x3D;0</strong>：触发器保持当前状态，不发生变化。</li><li><strong>S&#x3D;1, R&#x3D;0</strong>：输出Q被置为1（Set）。</li><li><strong>S&#x3D;0, R&#x3D;1</strong>：输出Q被重置为0（Reset）。</li><li><strong>S&#x3D;1, R&#x3D;1</strong>：为无效状态，因Q和Q’会同时为1，违背Q和Q’互补的逻辑。</li></ol><p> <strong>应用场景</strong></p><ul><li><strong>存储单元</strong>：用于存储1位数据。</li><li><strong>逻辑控制</strong>：作为简单的状态保持和切换电路。</li><li><strong>锁存器</strong>：用于构成其他类型的触发器（如D触发器和JK触发器）。</li></ul><p>SR触发器是最基本的触发器类型，但存在<strong>S&#x3D;1, R&#x3D;1</strong>的不允许状态，限制了它在复杂电路中的使用。改进型触发器（如JK触发器）解决了这一问题。</p><p>SR触发器状态转移公式：<br>$$<br>\begin{cases}<br>Q_{n+1}  &#x3D; S + \overline{R}Q_{n} \\<br>S \cdot R &#x3D; 0  (约束条件)<br>\end{cases}<br>$$</p><img src="/img/DC/srff.svg" alt="SR触发器" style="max-width: 100%; height: auto;" />  <h4 id="3-2-2-D-Flip-Flop"><a href="#3-2-2-D-Flip-Flop" class="headerlink" title="3.2.2 D Flip-Flop"></a>3.2.2 D Flip-Flop</h4><p><strong>D触发器</strong>（Data Flip-Flop, DFF）是数字电路中一种基本的时序逻辑电路，用于存储1位二进制数据。它通过 <strong>数据输入端（D）</strong> 和 <strong>时钟信号（CLK）</strong> 实现同步数据存储。D触发器也经常称为主从触发器（master-slave flip-flop），边沿触发器（edge-triggered flip-flop）或者正边沿触发器（positive edge-triggered flip-flop）。</p><p> <strong>工作原理:</strong></p><ul><li><strong>D输入</strong>：决定触发器的输出值。</li><li><strong>CLK输入</strong>：控制触发器的状态更新，确保输出只有在特定时钟条件下（如上升沿或下降沿）才更新。</li><li>当时钟信号有效时，<strong>D的值会传递到输出Q</strong>，同时Q’为Q的反相。</li></ul><p> <strong>逻辑功能表:</strong></p><table><thead><tr><th>CLK（时钟）</th><th>D（数据）</th><th>Q（输出）</th><th>状态</th></tr></thead><tbody><tr><td>上升沿</td><td>0</td><td>0</td><td>输出清零</td></tr><tr><td>上升沿</td><td>1</td><td>1</td><td>输出置1</td></tr><tr><td>其他</td><td>-</td><td>保持</td><td>状态不变</td></tr></tbody></table><p> <strong>DFF特点:</strong></p><ol><li><strong>同步性</strong>：依赖时钟信号控制，输出只在时钟有效时更新。</li><li><strong>无争议状态</strong>：相比SR触发器，D触发器没有无效状态。</li><li><strong>锁存功能</strong>：在时钟无效时，输出保持上一次的状态。</li></ol><p> <strong>DFF应用场景:</strong></p><ol><li><strong>寄存器</strong>：用于存储和传输数据。</li><li><strong>移位寄存器</strong>：通过多级D触发器实现数据位移。</li><li><strong>计数器</strong>：作为计数器电路的基础单元。</li><li><strong>同步电路</strong>：用于数据同步或信号稳定。</li></ol><p>D触发器是一种<strong>简单高效的存储单元</strong>，它通过时钟信号的控制实现数据的同步存储，广泛应用于各种数字电路中。一个D触发器可以由反相时钟控制的2个背靠背的D锁存器构成。</p><img src="/img/DC/dff.svg" alt="D触发器" style="max-width: 100%; height: auto;" />  <p><em>对于上升沿触发的DFF的时序图：</em></p><div style="text-align: center;"><img src="/img/DC/dff2.svg" alt="DFF" style="max-width: 100%; height: auto;" />  </div><div class="note note-success">            <p>至于为什么是上升沿触发，可以画一下主锁存器的值和从锁存器的值的时序图，此处省略</p>          </div><p><em>当然还有下降沿触发的DFF的时序图：</em></p><img src="/img/DC/dff3.svg" alt="下降沿DFF" style="max-width: 100%; height: auto;" />  <p>D触发器状态转移公式：<br>$$Q_{n+1} &#x3D; D$$</p><h4 id="3-2-3-JK-Flip-Flop"><a href="#3-2-3-JK-Flip-Flop" class="headerlink" title="3.2.3 JK Flip-Flop"></a>3.2.3 JK Flip-Flop</h4><p><strong>JK触发器</strong>是一种改进型的双稳态触发器，是对<strong>SR触发器</strong>的增强，解决了SR触发器中<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态问题。它通过输入信号J和K以及时钟信号CLK实现状态控制，具有更强的功能和更广的应用。</p><p> <strong>JKFF工作原理：</strong></p><ul><li><strong>J（Set）</strong>：与SR触发器的S功能类似，用于设置输出Q&#x3D;1。</li><li><strong>K（Reset）</strong>：与SR触发器的R功能类似，用于清零输出Q&#x3D;0。</li><li><strong>CLK（时钟信号）</strong>：用于同步控制，触发器的状态仅在时钟信号的有效边沿发生变化。</li></ul><p><strong>JKFF逻辑功能表：</strong></p><table><thead><tr><th>J</th><th>K</th><th>$Q_{n}$（输出）</th><th>$Q_{n+1}$（下一状态）</th><th>状态描述</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>Q</td><td>保持</td><td>状态保持</td></tr><tr><td>0</td><td>1</td><td>0</td><td>清零</td><td>Reset</td></tr><tr><td>1</td><td>0</td><td>1</td><td>置1</td><td>Set</td></tr><tr><td>1</td><td>1</td><td>Q’（反相）</td><td>翻转</td><td>Toggle（翻转）</td></tr></tbody></table><p> <strong>JKFF特点：</strong></p><ol><li><strong>无无效状态</strong>：J&#x3D;1, K&#x3D;1 时，触发器的输出状态翻转，解决了SR触发器的争议状态问题。</li><li><strong>同步性</strong>：在时钟信号控制下工作，确保状态变化的同步。</li><li><strong>功能多样</strong>：可以通过J和K的输入实现保持、置1、清零、翻转等功能。</li></ol><p> <strong>JKFF结构组成：</strong></p><ul><li>由SR触发器扩展而来，增加了逻辑门以控制输入S和R，确保J&#x3D;1, K&#x3D;1 时实现输出翻转。</li><li>常采用 <strong>边沿触发（Edge-triggered）</strong> 的设计，使其适用于复杂的时序电路。</li></ul><p> <strong>JKFF应用场景：</strong></p><ol><li><strong>计数器</strong>：JK触发器在计数器电路中广泛应用，用于实现递增或递减计数。</li><li><strong>状态机</strong>：设计复杂的同步时序电路。</li><li><strong>分频器</strong>：利用J&#x3D;1, K&#x3D;1的翻转特性实现时钟信号分频。</li></ol><p>JK触发器的实现可以通过主从结构，由两个SR触发器级联完成。</p><img src="/img/DC/jkff.svg" alt="JKFF" style="max-width: 100%; height: auto;" />  <p>下面是<em>下降沿触发</em>的JKFF的时序图:</p><img src="/img/DC/jkff2.svg" alt="JKFF时序图" style="max-width: 100%; height: auto;" />  <p>我们可以得出JKFF的状态转移公式：</p><p>$$Q_{n+1} &#x3D; J\overline{Q_{n}} + \overline{k}Q_{n}$$</p><div class="note note-success">            <p>JKFF时序图口诀：00不变，11翻转，10置1，01置0</p>          </div><h4 id="3-2-4-T-Flip-Flop"><a href="#3-2-4-T-Flip-Flop" class="headerlink" title="3.2.4 T Flip-Flop"></a>3.2.4 T Flip-Flop</h4><p><strong>T触发器</strong>（Toggle Flip-Flop）是一种基本的时序逻辑电路，用于实现<strong>状态翻转</strong>或<strong>分频功能</strong>。</p><p><strong>TFF工作原理：</strong></p><ul><li><strong>T输入（Toggle）</strong>：用于控制触发器的翻转功能。<ul><li>T&#x3D;0：保持当前状态</li><li>T&#x3D;1：状态翻转</li></ul></li><li><strong>CLK（时钟信号）</strong>：控制T触发器的状态更新，输出仅在时钟信号的有效边沿发生变化。</li></ul><p><strong>TFF逻辑功能表：</strong></p><table><thead><tr><th>CLK（时钟）</th><th>T（输入）</th><th>$Q_{n}$（输出）</th><th>$Q_{n+1}$（下一状态）</th><th>状态描述</th></tr></thead><tbody><tr><td>上升沿</td><td>0</td><td>Q</td><td>保持</td><td>状态保持</td></tr><tr><td>上升沿</td><td>1</td><td>Q’</td><td>翻转</td><td>Toggle（翻转）</td></tr><tr><td>其他</td><td>-</td><td>保持</td><td>保持</td><td>状态不变</td></tr></tbody></table><p><strong>TFF特点：</strong></p><ol><li><strong>状态翻转</strong>：当T&#x3D;1时，输出状态在每个时钟边沿发生翻转。</li><li><strong>分频功能</strong>：每次翻转需要一个时钟信号，因此输出频率为输入时钟频率的一半。</li><li><strong>简化结构</strong>：通过将JK触发器的J和K输入连接为同一信号T，简化了设计。</li></ol><p><strong>TFF实现方式：</strong></p><ol><li><strong>由JK触发器实现</strong>：将J&#x3D;K&#x3D;T，形成T触发器的逻辑。</li><li><strong>直接实现</strong>：通过逻辑门电路设计，实现T输入控制翻转功能。</li></ol><p><strong>TFF应用场景：</strong></p><ol><li><strong>计数器</strong>：用于实现二进制计数器的单个计数位。</li><li><strong>分频器</strong>：将时钟信号的频率降低一半，用于时钟分频。</li><li><strong>状态机</strong>：在简单状态转换电路中用作基本单元。</li></ol><p>TFF的一种实现如下图：<br><img src="/img/DC/tff.svg" alt="TFF" style="max-width: 100%; height: auto;" />  </p><p>TFF的时序图如下：<br><img src="/img/DC/tff2.svg" alt="TFF Time Diagram" style="max-width: 100%; height: auto;" />  </p><p>我们可以得出TFF的状态转移方程式为：</p><p>$$Q_{n+1} &#x3D; T \oplus Q_{n}$$</p><h3 id="3-3-Synchronous-Sequential-Logic"><a href="#3-3-Synchronous-Sequential-Logic" class="headerlink" title="3.3 Synchronous Sequential Logic"></a>3.3 Synchronous Sequential Logic</h3><p>Synchronous Sequential Logic（同步时序逻辑）是一类数字逻辑电路，其输出不仅取决于当前的输入，还取决于电路的状态（通常存储在触发器中）。这种电路的状态变化由一个<u>全局时钟信号</u>同步控制。</p><p>同步时序电路可以设计为两种类型：</p><ul><li>Mealy电路：输出依赖于当前状态和输入（对应有限自动机中的 Mealy 机）。</li><li>Moore电路：输出<strong>仅依赖于</strong>当前状态（对应有限自动机中的 Moore 机）。</li></ul><div class="note note-success">            <p>记忆：摩尔庄园–&gt;摩尔当前–&gt;摩尔电路只依赖于当前状态</p>          </div><img src="/img/DC/fsm.svg" alt="FSM" style="max-width: 100%; height: auto;" />  <p>根据上图可以再深入理解一下两种有限状态机（Finite State Machine, FSM），举个例子，判断输出1是如何依赖的：</p><ul><li>Mealy型FSM输出1需要同时依赖<strong>当前状态</strong>和<strong>输入</strong><ul><li>当前状态B并且输入1，可以输出1</li><li>当前状态B并且输入0，可以输出1</li></ul></li><li>Moore型FSM输出1只依赖当前状态：<ul><li>当前状态是B是，输出1</li><li>当前状态是C，输出1</li></ul></li></ul><p>关于同步时序电路的设计一般有如下步骤：</p><ol><li>原始状态图</li><li>状态图化简（当两个状态具有同样的输入时，也具有相同的输出和相同的次态时，可以合并）</li><li>状态分配（画状态表的时候与卡诺图一一对应比较合理高效！例如00、01、11、10这样子）</li><li>选触发器（D、JK；3个状态选2个FF，5个状态选3个FF； $2^{n-1} &lt; M \leq 2^{n}$）</li><li>确定激励方程组以及输出方程组</li><li>画图✍️检查能否自启动</li></ol><p>常见的同步时序电路设计一般包含：计数器，序列检测器，串行数据检测器等。</p><div class="note note-primary">            <p>同步时序电路设计的思路都很固定，参考过去问巩固练习即可</p>          </div><p>计数器过去问典型题目：马不停蹄🐎</p><p>序列检测器典型题目：马不停蹄🐎</p><p>串行数据检测器典型题目：马不停蹄🐎</p><h3 id="3-4-Asynchronous-Sequential-Logic"><a href="#3-4-Asynchronous-Sequential-Logic" class="headerlink" title="3.4 Asynchronous Sequential Logic"></a>3.4 Asynchronous Sequential Logic</h3><p><strong>Asynchronous Sequential Logic（异步时序逻辑）</strong> 是一种不依赖全局时钟信号的逻辑电路设计。其状态的变化由输入信号的变化直接触发，而不是由时钟脉冲控制。与同步时序逻辑相比，异步逻辑更灵活，但设计和调试更复杂。</p><p><strong>异步时序逻辑特点：</strong></p><ol><li>无全局时钟信号：异步电路的状态变化完全由输入信号或内部信号的变化触发，而不需要时钟信号协调。</li><li>依赖传播延迟：异步逻辑的行为受门延迟和信号传播时间的影响，可能会导致竞争和冒险现象。</li><li>更快的响应速度：输入变化会立即影响输出，因此响应速度通常比同步电路快。</li><li>更复杂的设计：需要解决元态（Metastability）、竞争（Race Condition）和冒险（Hazard）问题，设计和验证复杂度较高。</li></ol><div class="note note-primary">            <p>修考基本很少考异步时序电路设计，参考过去问巩固练习。</p>          </div><p>异步时序电路设计题目：马不停蹄🐎</p><h2 id="4-偷偷说"><a href="#4-偷偷说" class="headerlink" title="4. 偷偷说"></a>4. 偷偷说</h2><p>数字电路的重点就是组合电路和时序电路的设计，在理解每个元件特性的基础上，设计类的题目都非常固定。数字电路的黑书说实话写的很差劲：一是逻辑不连贯，二是忽略了很多推导细节。相反，《論理回路入門》by：坂井 修一，这本书我觉得写的非常不错，短小精悍，非常适合修考备考。</p><p>Thanks <a href="https://github.com/jgraph/drawio-desktop">@drawio</a> for generating the powerful diagrams.</p><div class="note note-success">            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Digital Circuit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Architecture</title>
    <link href="/2024/10/21/Computer-Architecture/"/>
    <url>/2024/10/21/Computer-Architecture/</url>
    
    <content type="html"><![CDATA[<h1 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h1><p>This is for test takers to quickly review Computer Architecture. The whole notes contain 5 parts and I try to make it clear and simple. Credit to《Computer Organization and Design : The Hardware&#x2F;Software Interface, 5th Edition》</p><blockquote><p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p></blockquote><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>在本章中，主要引入一下计算机组成的概念然后讲解衡量计算机的性能指标，并着重讲解涉及到的计量单位和公式。</p><h3 id="1-1-常用单位"><a href="#1-1-常用单位" class="headerlink" title="1.1 常用单位"></a>1.1 常用单位</h3><p>容量单位常用<strong>字节(Byte)</strong> ,衡量单位是<em>2进制(Binary)</em> ,容量之间的数量级关系是：$2^{10}$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如： $1TB&#x3D;2^{10} GB&#x3D; 1024GB$; $1GB&#x3D;2^{10}MB&#x3D;1024MB$</p></blockquote><p>衡量传输速度常用<strong>位每秒(bps,bit per secod)</strong> ,衡量单位是<em>10进制(Decimal)</em> ,传输速度之间的数量级关系是：$10^3$; 常见的有$K$,$M$,$G$,$T$。</p><blockquote><p>例如：$1kbit&#x2F;s&#x3D;1000bit&#x2F;s$, $1mbit&#x2F;s&#x3D;1000kbit&#x2F;s$</p></blockquote><p>另外需要注意的单位换算是：</p><ul><li>$bit&#x2F;s$记作$bps$</li><li>$1 Byte &#x3D; 8 bit$</li><li>$1 Bps &#x3D; 1 Byte&#x2F;second &#x3D; 8 bit&#x2F;second &#x3D; 8 bps$</li></ul><h3 id="1-2-计算机结构中的8个伟大思想"><a href="#1-2-计算机结构中的8个伟大思想" class="headerlink" title="1.2 计算机结构中的8个伟大思想"></a>1.2 计算机结构中的8个伟大思想</h3><ul><li>Moore’s Law: 芯片上的集成度每18～24个月翻一番</li><li>Abstraction：使用抽象来表示不同设计层次，化繁为简</li><li>Common Case Fast: 加速大概率事件远比优化小概率事件更能提高性能，即抓住主要矛盾</li><li>Parallel Performance: 并行操作来提高性能，说白了就是<del>打工人能做多少做多少</del></li><li>Pipeline: 这是一个并行场景的具体实现，后面章节会详细讲解🔎</li><li>Prediction：通过猜测的方式提前启动某些操作，提高性能，投资人讲究一个增收降本的策略。</li><li>Hierachy of memory: 用存储器层次来解决容量，速度，成本之间的相互矛盾需求。小而精则贵，大而糙则贱</li><li>Dependable：任何一个物理器件都有可能失效，使用冗余部件的方式来提高系统的可靠性，即备胎🛞</li></ul><p>在加速大概率事件中有一个定量分析的<strong>Amdahl定律</strong>：</p><center>$改进后的执行时间 = 改进影响的执行时间 / 加速比 + 改进不影响的执行时间$</center><center>$t_{\text{改进}} = t_{\text{相关}} / S + t_{\text{无关}}$</center><h3 id="1-3-计算机语言"><a href="#1-3-计算机语言" class="headerlink" title="1.3 计算机语言"></a>1.3 计算机语言</h3><p>计算机语言主要分为三类：<strong>高级语言</strong>、<strong>汇编语言</strong>和<strong>机器语言</strong>。程序执行的过程是先将高级语言编译为汇编语言，然后通过汇编，将汇编语言转化为相应的机器语言。</p><h4 id="1-3-1-高级语言-High-level-programming-language"><a href="#1-3-1-高级语言-High-level-programming-language" class="headerlink" title="1.3.1 高级语言(High-level programming language)"></a>1.3.1 高级语言(High-level programming language)</h4><p>最接近人类自然语言的编程语言。常见的高级语言包括C++, Java, Python, 和JavaScript。</p><h4 id="1-3-2-汇编语言-Assembly-language"><a href="#1-3-2-汇编语言-Assembly-language" class="headerlink" title="1.3.2 汇编语言(Assembly language)"></a>1.3.2 汇编语言(Assembly language)</h4><p>汇编语言是一种低级编程语言，它直接对应于机器语言，但使用人类更易理解的符号和短语来表示。每条汇编指令通常都对应一条机器语言指令，因此汇编语言被认为是机器语言的符号表示。汇编语言需要使用汇编器（Assembler）将代码转换为机器语言。这种语言通常用于编写需要精确控制硬件的程序，如操作系统内核和驱动程序。汇编语言的分类一般有两种主要类型：<strong>RISC指令集（Reduced Instruction Set Computing）</strong> 和 <strong>CISC指令集（Complex Instruction Set Computing）</strong>。</p><ul><li><strong>RISC指令集：</strong> 即简化指令集计算（Reduced Instruction Set Computing）：这种类型的指令集特点是<em>指令集较为简单，每条指令执行时间固定而短，通常在一个时钟周期内完成</em>。这使得RISC处理器能够更快速地执行大量简单的指令。代表性的RISC架构包括<u>ARM、MIPS和SPARC。</u></li><li><strong>CISC指令集：</strong>即复杂指令集计算（Complex Instruction Set Computing），这种类型的指令集特点是指令集复杂，每条指令可能<em>需要多个时钟周期</em>才能完成执行。CISC处理器通过一个复杂的指令集试图降低编程的复杂性，使得某些复杂操作能通过一条指令完成。典型的CISC架构包括<u>x86和VAX。</u></li></ul><div class="note note-success">            <p>在修考中，出现的汇编语言是RISC指令集，因此在后序章节只讲解RISC指令</p>          </div><h4 id="1-3-3-机器语言-Machine-language"><a href="#1-3-3-机器语言-Machine-language" class="headerlink" title="1.3.3 机器语言(Machine language)"></a>1.3.3 机器语言(Machine language)</h4><p>机器语言是计算机能够直接执行的最底层编程语言。它由二进制代码组成，每条指令由一串0和1表示（eg. 00000111111010001），直接控制计算机的硬件操作。由于其复杂性和难以阅读，人类很少直接编写机器语言程序。</p><blockquote><p>总结：高级语言编译为汇编语言，然后汇编语言通过汇编转化为由01串组成的机器语言</p></blockquote><h3 id="1-4-冯·诺伊曼结构-Von-Neumann-architecture"><a href="#1-4-冯·诺伊曼结构-Von-Neumann-architecture" class="headerlink" title="1.4 冯·诺伊曼结构(Von Neumann architecture)"></a>1.4 冯·诺伊曼结构(Von Neumann architecture)</h3><img src="/img/CA/von.svg" alt="冯诺伊曼结构" style="max-width: 100%; height: auto;" /><p><strong>输入设备(Input Devices)</strong> 是用于向计算机输入数据和指令的硬件。例如，键盘（Keyboard）、鼠标（Mouse）、扫描仪（Scanner）、话筒（Microphone）等。它们将用户的操作转化为计算机能够理解的信号。</p><p><strong>输出设备(Output Devices)</strong> 是用于从计算机输出数据和结果的硬件。例如，显示器（Monitor）、打印机（Printer）、扬声器（Speakers）等。它们将计算机处理后的数据转化为用户可以理解的信息。</p><p><strong>控制器(Control Unit, CU)</strong> 是负责从存储器读取指令，并解释和执行指令的计算机部件。它管理和协调计算机的各个部分，以确保指令被按顺序执行。</p><p><strong>运算器(Arithmetic Logic Unit, ALU)</strong> 是执行算术运算和逻辑运算的核心部件。它能处理整数和浮点数的加、减、乘、除等运算，也能进行与、或、非等逻辑运算。</p><p><strong>存储器(Memory)</strong> 是存储数据和指令的地方。分为主存储器（Main Memory）和辅助存储器（Secondary Storage）。主存储器（如RAM，随机存取存储器，Random Access Memory）用于存储当前正在使用的数据和指令；辅助存储器（如硬盘，Hard Disk Drive）用于长期存储数据。</p><p><strong>中央处理器(Central Processing Unit, CPU)</strong> 是计算机的“大脑”，负责解释和执行指令。它由控制器（Control Unit, CU）和运算器（Arithmetic Logic Unit, ALU）组成，管理并处理所有的计算任务。</p><h3 id="1-5-计算机性能指标"><a href="#1-5-计算机性能指标" class="headerlink" title="1.5 计算机性能指标"></a>1.5 计算机性能指标</h3><p><strong>响应时间（Response Time）：</strong> 响应时间，又称执行时间，是指系统从接收到请求到开始产生输出结果所经过的时间。</p><p><strong>吞吐率（Throughput）：</strong> 吞吐率是指在单位时间内系统能够处理的请求数量。它衡量的是系统的处理能力。高吞吐率意味着在同样的时间内，系统能够处理更多的请求或完成更多的工作。</p><p><strong>CPU性能公式(Performance)：</strong></p><center>$CPU性能 = 1 / 执行时间$</center><p>A的性能比B的性能高$X$倍计算：  $X&#x3D;t_{B执行时间}&#x2F;t_{A执行时间}$</p><p><strong>时钟周期长度(Clock Cycle Length):</strong><br>是指计算机时钟信号中相邻两个相同状态（如两个上升沿）之间的时间间隔。CPU做的任何动作所消耗的时间都是一个时钟周期的整数倍。通常以纳秒（ns）为单位,记作 $T$</p><p><strong>时钟周期频率(Clock Cycle Frequency):</strong><br>则是时钟信号每秒钟振荡的次数，通常以赫兹（Hz）为单位。它是时钟周期长度的倒数。例如，如果时钟周期长度是2纳秒，那么时钟频率就是0.5 GHz,记作 $f$</p><p>两者之间的关系是：</p><ul><li><p>时钟周期长度 &#x3D; 1 &#x2F; 时钟周期频率, 即 $T &#x3D; 1 &#x2F; f$</p></li><li><p>时钟周期频率 &#x3D; 1 &#x2F; 时钟周期长度, 即 $f &#x3D; 1 &#x2F; T$</p></li></ul><p><strong>CPI(Cycles Per Instruction):</strong><br>是计算机性能指标，用于衡量每条指令所需的平均时钟周期数。它反映了CPU执行指令的效率。CPI的计算公式是：</p><center>$ \text{CPI} = \frac{\text{总时钟周期数}}{\text{指令数}} $</center><p><strong>时钟周期数计算公式(Clock Cycle):</strong></p><center>$Clock Cycle=指令数\times平均每条指令所需周期数 = IC \times CPI$</center><blockquote><p>注：指令数(Instruction Count, IC)是指CPU在执行一个程序时，需要执行的指令总数。</p></blockquote><p><strong>CPU执行时间：</strong></p><center>$ \text{CPU Time} = \text{指令数} \times \text{CPI} \times \text{时钟周期长度} = IC \times CPI \times T = IC \times CPI / f$</center><p>还有一个衡量指标<strong>是MIPS(million instructions per second)</strong>:</p><center>$ MIPS = IC / (\text{CPU Time} \times 10^{6}) = f / (CPI \times 10^{6})$</center><p><strong>功耗计算公式：</strong> 记住就行</p><center> $P = \frac{1}{2} \times U^2 \times f$</center><blockquote><p>注： $P$ 是功耗，$C$ 是负载电容， $U$ 是电压， $f$ 是开关频率</p></blockquote><h2 id="2-Instructions-The-Language-of-Computers"><a href="#2-Instructions-The-Language-of-Computers" class="headerlink" title="2. Instructions: The Language of Computers"></a>2. Instructions: The Language of Computers</h2><p>这一章非常重要，因为修考题目中经常出现理解汇编语言的题目。本章主要讲解RISC-V指令集架构还有五种寻址方式</p><h3 id="2-1-Instrcucton"><a href="#2-1-Instrcucton" class="headerlink" title="2.1 Instrcucton"></a>2.1 Instrcucton</h3><p>计算机在底层执行程序时，通过读取由0和1组成的机器指令来执行命令。在RISC-V指令集中，所有的机器指令都是32位长，也就是32位的二进制串。这些32位的机器指令对应的汇编语言指令通常由操作码和两个地址码组成（形式：操作码 + 地址码 + 地址码）。规定：</p><ul><li>程序中的变量存放在保存寄存器（store reg）中：$s0~$s7共8个</li><li>临时变量，中间变量存放在临时寄存器（temp reg）中：$t0~$t7共8个</li><li>零寄存器，永远存放32位的0，记作$zero</li></ul><h3 id="2-2-RISC-V-Instruction-Set"><a href="#2-2-RISC-V-Instruction-Set" class="headerlink" title="2.2 RISC-V Instruction Set"></a>2.2 RISC-V Instruction Set</h3><h4 id="2-2-1-基本指令"><a href="#2-2-1-基本指令" class="headerlink" title="2.2.1 基本指令"></a>2.2.1 基本指令</h4><p><strong>加法，减法指令(add, sub):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; c &#x3D; a + b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; badd $s2, $s0, $s1  &#x2F;&#x2F; c &#x3D; a - b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; bsub $s2, $s0, $s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>加立即数指令(addi):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; i &#x3D; i + 1, i存放在$s0寄存器中addi $s0, $s0, 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>逻辑运算指令:</strong> and(与)，or(或)，nor（或非）</p><p><strong>逻辑左移(shift left logic, sll)和右移(shift right logic, srl):</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sll $to, $s2, 2 &#x2F;&#x2F; 将$s2寄存器的值左移2位，即变为4倍，存放在$t0中srl $to, $s2, 1 &#x2F;&#x2F; 将$s2寄存器的值右移1位，即变为1&#x2F;2倍，存放在$t0中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p><strong>取字指令(load word, lw)和存字指令(save word, sw):</strong><br>因为寄存器是按字(Word)存储，而内存是按字节(Byte)编址,在RISC-V指令集中，约定：1 Word &#x3D; 32 bit &#x3D; 4 Byte。</p><blockquote><p>举个例子：已知a[0]的地址存放在寄存器s0中，现在需要取a[2]的值存放在寄存器t0中；a[2]和a[0]之间的字节偏移有 2 * 4 &#x3D; 8 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw $t0, 8($s0)  &#x2F;&#x2F; 取出$s0偏移8字节的位置的值，存放在$t0寄存器中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><blockquote><p>同理，如果我们要把t0寄存器的值存到a[4]中去，可以知道a[4]与a[0]的字节偏移有 4 * 4 &#x3D; 16 Byte。RISC-V指令可写为：</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw $t0, 16($s0) &#x2F;&#x2F; 注意操作的方向和lw相反<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h4 id="2-2-2-装载32位立即数到寄存器"><a href="#2-2-2-装载32位立即数到寄存器" class="headerlink" title="2.2.2 装载32位立即数到寄存器"></a>2.2.2 装载32位立即数到寄存器</h4><p>因为装载的32位立即数不能完全放进32位的机器指令中，因此寄存器可以通过两条指令来完成：LUI (Load Upper Immediate) 和 ORI (OR Immediate)。比如将立即数 0xF7EE57AD 装载到寄存器中这个两个指令需要完成的动作是：</p><blockquote><p>0xF7EE57AD 对应的 32 位二进制数是：1111 0111 1110 1110 0101 0111 1010 1101</p></blockquote><ul><li><p>LUI 指令：取0xF7EE57AD的高16位数（1111 0111 1110 1110) 放入寄存器的高16位</p></li><li><p>ORI 指令：将寄存器和剩下的低16位数做立即与的动作(0101 0111 1010 1101)</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $s1, 63470 &#x2F;&#x2F; 1111 0111 1110 1110 对应的十进制数是 63470ori $s1, 22957 &#x2F;&#x2F; 0101 0111 1010 1101 对应的十进制数是 22957&#x2F;* 整个动作如下：step1: 取到高16位数，$s1的值为 1111 0111 1110 1110 0000 0000 0000 0000step2: $s1的值与低16位数立即与 0000 0000 0000 0000 0101 0111 1010 1101最终$s1的值为 1111 0111 1110 1110 0101 0111 1010 1101*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然还有其他写法：比如lui和addi。例如，要将立即数 0x12345678 装载到寄存器 t0 中</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $t0, 0x12345 &#x2F;&#x2F; 将高20位0x12345装载到t0addi $t0, $t0, 0x678 &#x2F;&#x2F; 将剩余的12位0x678添加到t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li></ul><h4 id="2-2-3-判断和决策指令"><a href="#2-2-3-判断和决策指令" class="headerlink" title="2.2.3 判断和决策指令"></a>2.2.3 判断和决策指令</h4><p><strong>BEQ（Branch if Equal） 指令：</strong></p><ul><li><strong>功能</strong>：比较两个寄存器的值，如果它们相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>beq rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">beq $t0, $t1, label &#x2F;&#x2F; 如果t0和t1相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>BNE（Branch if Not Equal） 指令：</strong></li></ul></li><li><strong>功能</strong>：比较两个寄存器的值，如果它们不相等，则跳转到指定的目标地址。</li><li><strong>格式</strong>：<code>bne rs1, rs2, offset</code><ul><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li><li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">bne $t0, $t1, label &#x2F;&#x2F; 如果t0和t1不相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><strong>小于则置位(set less than, slt)：</strong></li></ul></li></ul><p><strong>功能</strong>：将两个寄存器中的值进行比较，如果第一个寄存器的值小于第二个寄存器的值，则将目标寄存器设为1，否则设为0。</p><ul><li><strong>格式</strong>：<code>slt rd, rs1, rs2</code><ul><li><code>rd</code>：目标寄存器</li><li><code>rs1</code>：第一个源寄存器</li><li><code>rs2</code>：第二个源寄存器</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">slt $t0, $t1, $t2 &#x2F;&#x2F; 如果t1 &lt; t2，则将t0设为1；否则设为0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>J指令(JUMP)</strong></p><ul><li><strong>功能</strong>：无条件跳转到指定的目标地址。这个指令改变了程序的执行流程，立即将控制转移到指定的地址。</li><li><strong>格式</strong>：<code>j offset</code><ul><li><code>offset</code>：相对当前地址的跳转偏移量</li></ul></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j label &#x2F;&#x2F; 无条件跳转到label标记的位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h3 id="2-3-Assembly-language-and-High-level-programming-language"><a href="#2-3-Assembly-language-and-High-level-programming-language" class="headerlink" title="2.3 Assembly language and High-level programming language"></a>2.3 Assembly language and High-level programming language</h3><p>举个例子，有C++代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value3 <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t0 <span class="token operator">=</span> value1<span class="token punctuation">;</span>    <span class="token keyword">int</span> t1 <span class="token operator">=</span> value2<span class="token punctuation">;</span>    <span class="token keyword">int</span> t2 <span class="token operator">=</span> t0 <span class="token operator">+</span> t1<span class="token punctuation">;</span> <span class="token comment">// t2 = t0 + t1</span>    <span class="token keyword">int</span> t3 <span class="token operator">=</span> t1 <span class="token operator">-</span> t0<span class="token punctuation">;</span> <span class="token comment">// t3 = t1 - t0</span>    <span class="token keyword">int</span> t4 <span class="token operator">=</span> t0 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment">// t4 = t0 + 4</span>    <span class="token keyword">int</span> t5 <span class="token operator">=</span> t0 <span class="token operator">&amp;</span> t1<span class="token punctuation">;</span> <span class="token comment">// t5 = t0 AND t1</span>    <span class="token keyword">int</span> t6 <span class="token operator">=</span> t0 <span class="token operator">|</span> t1<span class="token punctuation">;</span> <span class="token comment">// t6 = t0 OR t1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t0 <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> ELSE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">goto</span> main<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>ELSE<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于 nop)</span>    <span class="token keyword">goto</span> EXIT<span class="token punctuation">;</span>main<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于循环到 main)</span>EXIT<span class="token operator">:</span>    <span class="token comment">// Do nothing (类似于结束)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>其对应的汇编语言是</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.datavalue1: .word 5value2: .word 10value3: .word 15.textmain:    lw $t0, value1      # 将value1的值加载到$t0    lw $t1, value2      # 将value2的值加载到$t1    add $t2, $t0, $t1     # $t2 &#x3D; $t0 + $t1    sub $t3, $t1, $t0     # $t3 &#x3D; $t1 - $t0    addi $t4, $t0, 4     # $t4 &#x3D; $t0 + 4    and $t5, $t0, $t1     # $t5 &#x3D; $t0 AND $t1    or $t6, $t0, $t1      # $t6 &#x3D; $t0 OR $t1    beq $t0, $t1, ELSE   # 如果$t0 &#x3D;&#x3D; $t1，则跳转到ELSE    bne $t0, $t1, main   # 如果$t0 !&#x3D; $t1，则跳转到mainELSE:    j EXIT             # 无条件跳转到EXITEXIT:    nop                # 无操作（用于占位）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="2-4-Three-Instruction-Formats"><a href="#2-4-Three-Instruction-Formats" class="headerlink" title="2.4 Three Instruction Formats"></a>2.4 Three Instruction Formats</h3><p>在汇编语言中，主要有三种指令格式：R型指令、I型指令和J型指令。每种格式有特定的结构，用于不同类型的操作。</p><h4 id="2-4-1-R-type-Register-Instructions"><a href="#2-4-1-R-type-Register-Instructions" class="headerlink" title="2.4.1 R-type (Register) Instructions"></a>2.4.1 R-type (Register) Instructions</h4><ul><li><strong>目的</strong>：用于需要三个寄存器的算术和逻辑操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：第一个源寄存器。</li><li><code>rs2</code>：第二个源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>funct3</code> 和 <code>funct7</code>：附加功能代码，用于指定具体操作。</li></ul></li><li><strong>例子</strong>：<code>add rd, rs1, rs2</code> <ul><li>将 <code>rs1</code> 和 <code>rs2</code> 中的内容相加，并将结果存储在 <code>rd</code> 中。</li></ul></li></ul><h4 id="2-4-2-I-type-Immediate-Instructions"><a href="#2-4-2-I-type-Immediate-Instructions" class="headerlink" title="2.4.2 I-type (Immediate) Instructions"></a>2.4.2 I-type (Immediate) Instructions</h4><ul><li><strong>目的</strong>：用于带有立即数（嵌入指令中的常数）的操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>rs1</code>：源寄存器。</li><li><code>rd</code>：目标寄存器。</li><li><code>imm</code>：立即数（常数）。</li><li><code>funct3</code>：附加功能代码。</li></ul></li><li><strong>例子</strong>：<code>addi rd, rs1, imm</code><ul><li>将 <code>rs1</code> 和 <code>imm</code> 的内容相加，并将结果存储在 <code>rd</code></li></ul></li></ul><h4 id="2-4-3-J-type-Jump-Instructions"><a href="#2-4-3-J-type-Jump-Instructions" class="headerlink" title="2.4.3 J-type (Jump) Instructions"></a>2.4.3 J-type (Jump) Instructions</h4><ul><li><strong>目的</strong>：用于修改程序控制流的跳转操作。</li><li><strong>格式</strong>：<ul><li><code>opcode</code>：指定指令类型的操作码。</li><li><code>offset</code>：跳转偏移量。</li></ul></li><li><strong>例子</strong>：<code>j offset</code><ul><li>跳转到通过将 <code>offset</code> 添加到当前程序计数器（PC）计算出的地址。</li></ul></li></ul><h3 id="2-5-Five-Addressing-Modes"><a href="#2-5-Five-Addressing-Modes" class="headerlink" title="2.5 Five Addressing Modes"></a>2.5 Five Addressing Modes</h3><h4 id="2-5-1-立即寻址（Immediate-Addressing）"><a href="#2-5-1-立即寻址（Immediate-Addressing）" class="headerlink" title="2.5.1 立即寻址（Immediate Addressing）"></a>2.5.1 立即寻址（Immediate Addressing）</h4><ul><li><strong>定义</strong>：操作数直接在指令中给出。</li><li><strong>例子</strong>：<code>MOV AL, 5</code><ul><li>这里，数值 <code>5</code> 直接被移动到寄存器 <code>AL</code> 中。</li></ul></li></ul><h4 id="2-5-2-直接寻址（Direct-Addressing）"><a href="#2-5-2-直接寻址（Direct-Addressing）" class="headerlink" title="2.5.2 直接寻址（Direct Addressing）"></a>2.5.2 直接寻址（Direct Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址在指令中明确给出。</li><li><strong>例子</strong>：<code>MOV AX, [1234H]</code><ul><li>该指令将内存地址 <code>1234H</code> 的值移动到寄存器 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-3-间接寻址（Indirect-Addressing）"><a href="#2-5-3-间接寻址（Indirect-Addressing）" class="headerlink" title="2.5.3 间接寻址（Indirect Addressing）"></a>2.5.3 间接寻址（Indirect Addressing）</h4><ul><li><strong>定义</strong>：操作数的地址存储在寄存器或内存位置中。</li><li><strong>例子</strong>：<code>MOV AX, [BX]</code><ul><li>内存位置 <code>[BX]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-4-索引寻址（Indexed-Addressing）"><a href="#2-5-4-索引寻址（Indexed-Addressing）" class="headerlink" title="2.5.4 索引寻址（Indexed Addressing）"></a>2.5.4 索引寻址（Indexed Addressing）</h4><ul><li><strong>定义</strong>：操作数的最终地址由寄存器内容与常数相加生成。</li><li><strong>例子</strong>：<code>MOV AX, [SI+20H]</code><ul><li>内存位置 <code>[SI + 20H]</code> 中的值被移动到 <code>AX</code> 中。</li></ul></li></ul><h4 id="2-5-5-寄存器寻址（Register-Addressing）"><a href="#2-5-5-寄存器寻址（Register-Addressing）" class="headerlink" title="2.5.5 寄存器寻址（Register Addressing）"></a>2.5.5 寄存器寻址（Register Addressing）</h4><ul><li><strong>定义</strong>：操作数位于寄存器中，寄存器在指令中直接指定。</li><li><strong>例子</strong>：<code>MOV AX, BX</code><ul><li><code>BX</code> 中的值被移动到 <code>AX</code></li></ul></li></ul><div class="note note-primary">            <p>程序计数器PC在取指令时会自增4（每条指令是4字节），因此，下一条指令的地址是PC + 4。若当前指令需要进行跳转或分支，字地址偏移量则用于计算目标地址。具体来说，如果你有一个偏移量offset，在跳转指令中，你通常会将其左移2位（因为地址是字节为单位的），然后加到PC + 4上来获得目标地址。</p>          </div><h2 id="3-Arithmetic-Operations-in-Computers"><a href="#3-Arithmetic-Operations-in-Computers" class="headerlink" title="3. Arithmetic Operations in Computers"></a>3. Arithmetic Operations in Computers</h2><p>本章主要讲解的知识点有，计算机是如何表示整数和进行整数运算的，以及浮点数的表示规范。本章在修考的考察非常精细，一定要理清每种数的表示。下面的例子都用8bit来表示并且给出对应的表示范围。</p><h3 id="3-1-Integer-Representation"><a href="#3-1-Integer-Representation" class="headerlink" title="3.1 Integer Representation"></a>3.1 Integer Representation</h3><p>本小节介绍无符号整数、原码、反码和补码的表示方法。</p><h4 id="3-1-1-无符号整数（Unsigned-Integer）"><a href="#3-1-1-无符号整数（Unsigned-Integer）" class="headerlink" title="3.1.1 无符号整数（Unsigned Integer）"></a>3.1.1 无符号整数（Unsigned Integer）</h4><p><strong>表示方法</strong>：<br>无符号整数只表示<strong>非负数</strong>，使用所有位表示数值，不用负号。8位无符号整数的取值范围是从0到255。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$0$</li><li>最大值：$2^8 - 1 &#x3D; 255$</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的无符号表示：<code>00000101</code></li><li>十进制数255的无符号表示：<code>11111111</code></li></ul><h4 id="3-1-2-原码（Sign-Magnitude）"><a href="#3-1-2-原码（Sign-Magnitude）" class="headerlink" title="3.1.2 原码（Sign-Magnitude）"></a>3.1.2 原码（Sign-Magnitude）</h4><p><strong>表示方法</strong>：<br>原码使用最高位作为符号位（0表示正数，1表示负数），其余位表示数值的绝对值。对于8位原码，正数的最高位是0，负数的最高位是1。因此原码有$+0$和$-0$两种表示方法，分别是$00000000$,$10000000$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>11111111</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的原码表示：<code>00000101</code></li><li>十进制数-5的原码表示：<code>10000101</code></li></ul><h4 id="3-1-3-反码（One’s-Complement）"><a href="#3-1-3-反码（One’s-Complement）" class="headerlink" title="3.1.3 反码（One’s Complement）"></a>3.1.3 反码（One’s Complement）</h4><p><strong>表示方法</strong>：<br>反码对正数和负数的表示方法稍有不同。正数的反码与原码相同，负数的反码是将其绝对值的原码的每一位取反（0变1，1变0）。因此反码有也有$+0$和$-0$两种表示方法，分别是$00000000$和$11111111$。</p><p><strong>表示范围</strong>：</p><ul><li>最小值：$-127$（<code>10000000</code>）</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的反码表示：<code>00000101</code></li><li>十进制数-5的反码表示：<code>11111010</code>（原码<code>00000101</code>取反）</li></ul><h4 id="3-1-4-补码（Two’s-Complement）"><a href="#3-1-4-补码（Two’s-Complement）" class="headerlink" title="3.1.4 补码（Two’s Complement）"></a>3.1.4 补码（Two’s Complement）</h4><p><strong>表示方法</strong>：<br>补码是最常用的负数表示方法。正数的补码与原码相同，负数的补码是其绝对值的原码取反后加1。补码的意义是<em>消除原码和反码有2种零的表示方法</em>，可以用于直接计算。计算机都是用补码进行整数加减运算。因为补码只有一种$0$的表示方法，因此负数的表示范围会比整数多一个。</p><blockquote><p>补码非常爱考的一个点：$11111111$(-1), $10000000$(-128,因为超出8位范围), $00000000$(0)</p></blockquote><p><strong>表示范围</strong>：</p><ul><li>最小值：$-128$（<code>10000000</code>），🚨重中之重</li><li>最大值：$127$（<code>01111111</code>）</li></ul><p><strong>例子</strong>：</p><ul><li>十进制数5的补码表示：<code>00000101</code></li><li>十进制数-5的补码表示：<code>11111011</code>（原码<code>00000101</code>取反后加1）</li></ul><h4 id="3-1-5-表示方法总结"><a href="#3-1-5-表示方法总结" class="headerlink" title="3.1.5 表示方法总结"></a>3.1.5 表示方法总结</h4><table><thead><tr><th>表示法</th><th>最小值</th><th>最大值</th><th>示例 - 正数</th><th>示例 - 负数</th><th>0的表示个数</th></tr></thead><tbody><tr><td>无符号整数</td><td>0</td><td>255</td><td><code>00000101</code> (5)</td><td>N&#x2F;A</td><td>1</td></tr><tr><td>原码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>10000101</code> (-5)</td><td>2</td></tr><tr><td>反码</td><td>-127</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111010</code> (-5)</td><td>2</td></tr><tr><td>补码</td><td>-128</td><td>127</td><td><code>00000101</code> (5)</td><td><code>11111011</code> (-5)</td><td>1</td></tr></tbody></table><h3 id="3-2-符号位扩展与大小端编址"><a href="#3-2-符号位扩展与大小端编址" class="headerlink" title="3.2 符号位扩展与大小端编址"></a>3.2 符号位扩展与大小端编址</h3><p>这几个考点经常出现在题目的开胃前菜，是很容易忽略的一个考点，切记切记。</p><h4 id="3-2-1-符号位扩展（sign-extension）"><a href="#3-2-1-符号位扩展（sign-extension）" class="headerlink" title="3.2.1 符号位扩展（sign extension）"></a>3.2.1 符号位扩展（sign extension）</h4><p><strong>符号位扩展（sign extension）</strong> 是指在将带符号的数从较小的位数扩展到较大位数时，保持其数值的正负性。这个过程通常在处理数值的运算或数据类型转换时使用。<br>填充高位：</p><ul><li>如果符号位为0，扩展时在左边填充0。</li><li>如果符号位为1，扩展时在左边填充1。<br>假设我们要将一个8位的补码数扩展到16位：</li></ul><p><strong>8位正数</strong></p><ul><li>原数：<code>00001010</code>（十进制10）</li><li>扩展后：<code>00000000 00001010</code>（仍然是十进制10）</li></ul><p><strong>8位负数</strong></p><ul><li>原数：<code>11111010</code>（十进制-6）</li><li>扩展后：<code>11111111 11111010</code>（仍然是十进制-6）</li></ul><h4 id="3-2-2-大端编址（Big-endian）和小端编址（Little-endian）"><a href="#3-2-2-大端编址（Big-endian）和小端编址（Little-endian）" class="headerlink" title="3.2.2 大端编址（Big-endian）和小端编址（Little-endian）"></a>3.2.2 大端编址（Big-endian）和小端编址（Little-endian）</h4><p>大端编址（Big-endian）和小端编址（Little-endian）是两种不同的数据存储方式，决定了多字节数据在内存中的排列顺序。</p><p><strong>大端编址（Big-endian）</strong></p><ul><li><strong>定义</strong>：在大端模式下，数据的高位字节存储在低地址，低位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>12</code></li><li>地址 <code>0x01</code>：<code>34</code></li><li>地址 <code>0x02</code>：<code>56</code></li><li>地址 <code>0x03</code>：<code>78</code></li></ul></li></ul><p><strong>小端编址（Little-endian）</strong></p><ul><li><strong>定义</strong>：在小端模式下，数据的低位字节存储在低地址，高位字节存储在高地址。</li><li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul><li>地址 <code>0x00</code>：<code>78</code></li><li>地址 <code>0x01</code>：<code>56</code></li><li>地址 <code>0x02</code>：<code>34</code></li><li>地址 <code>0x03</code>：<code>12</code></li></ul></li></ul><p><strong>应用</strong></p><ul><li><strong>大端</strong>：常用于网络协议（如TCP&#x2F;IP），因为网络字节顺序采用大端。</li><li><strong>小端</strong>：通常用于个人电脑（如x86架构的处理器）。</li></ul><img src="/img/CA/endianness.svg" alt="大端和小端序" style="max-width: 100%; height: auto;" /><h3 id="3-3-Arithmetic-Operations-Logic"><a href="#3-3-Arithmetic-Operations-Logic" class="headerlink" title="3.3 Arithmetic Operations Logic"></a>3.3 Arithmetic Operations Logic</h3><p>参照<a href="https://toutou.zeabur.app/2024/11/04/Digital-Circuit/">数字电路笔记</a>第二章的算术运算实现</p><h3 id="3-4-IEEE754-Float-Point-Number"><a href="#3-4-IEEE754-Float-Point-Number" class="headerlink" title="3.4 IEEE754 Float Point Number"></a>3.4 IEEE754 Float Point Number</h3><p><strong>IEEE 754 单精度浮点数</strong></p><p>IEEE 754 单精度浮点数总共32位：1位符号位（S），8位指数位（E），23位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为127，即实际的指数值是存储的指数值减去127。<ul><li>例如，如果指数部分存储的是10000001（二进制的129），实际的指数就是129-127&#x3D;2。</li></ul></li><li><strong>尾数位（F）</strong>：23位，表示小数部分。注意尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 127)} \times 1.F$ </center><p><strong>IEEE 754 双精度浮点数</strong></p><p>IEEE 754 双精度浮点数总共64位：1位符号位（S），11位指数位（E），52位尾数位（F）。</p><ul><li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li><li><strong>指数位（E）</strong>：偏阶值(Bias)为1023，即实际的指数值是存储的指数值减去1023。<ul><li>例如，如果指数部分存储的是10000000010（二进制的1026），实际的指数就是1026-1023&#x3D;3。</li></ul></li><li><strong>尾数位（F）</strong>：52位，表示小数部分。尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li></ul><p><strong>计算公式</strong>：</p><center> $(-1)^S \times 2^{(E - 1023)} \times 1.F$ </center><img src="/img/CA/float.svg" alt="浮点数表示格式" style="max-width: 100%; height: auto;" /><blockquote><p>思考：为什么需要偏阶值(Bias)的存在？</p></blockquote><p>偏阶（Bias）的存在主要是为了简化浮点数的比较和计算过程。以下是几个具体原因：</p><ol><li><p><strong>简化比较操作</strong>：<br>通过使用偏阶，所有可能的指数值都被映射到一个非负范围内，使得比较浮点数时可以简单地比较其指数部分的数值。例如，对于单精度浮点数，偏阶127确保了指数范围从 -127 到 128 被映射到 0 到 255。</p></li><li><p><strong>标准化表示</strong>：<br>使用偏阶可以确保指数部分总是一个非负数，从而使浮点数表示更为统一和标准化。这对于硬件电路设计和算法实现有很大的便利性。</p></li><li><p><strong>处理负指数</strong>：<br>偏阶允许使用非负整数来表示负指数，这对表示非常小的浮点数（接近于0）尤其有用。通过偏阶值，可以直接在指数部分进行加法和减法，而不需要额外处理负数。</p></li></ol><p>举个例子，对于单精度浮点数，偏阶是127。这意味着：</p><ul><li>实际指数为0时，存储的指数值是127。</li><li>实际指数为-1时，存储的指数值是126。</li><li>实际指数为+1时，存储的指数值是128。</li></ul><p>这种设计大大简化了计算和比较过程，让浮点运算变得高效和准确。</p><h2 id="4-Processor"><a href="#4-Processor" class="headerlink" title="4.  Processor"></a>4.  Processor</h2><p>MIPS是一种采取RISC的架构。MIPS 处理器的指令执行过程被分为<strong>五个主要阶段。</strong> 通过流水线的设计，MIPS 能够在每个时钟周期执行多个指令阶段，从而提升性能。以下是每个阶段的详细说明：</p><h3 id="4-1-指令周期分解"><a href="#4-1-指令周期分解" class="headerlink" title="4.1 指令周期分解"></a>4.1 指令周期分解</h3><ol><li><p><strong>取指令（IF，Instruction Fetch）</strong></p><ul><li>从指令存储器中读取当前指令，将其载入到指令寄存器（IR，Instruction Register）中。</li><li>将程序计数器（PC）更新为下一条指令的地址，一般为当前 PC 值加 4（因为每条指令长度固定为 4 字节）。</li><li>在这个阶段，通常也会将 PC 的值保存，以备后续的跳转或分支指令使用。</li></ul></li><li><p><strong>指令译码（ID，Instruction Decode）</strong></p><ul><li>解析指令的操作码（opcode），以确定指令类型和具体的操作。</li><li>从寄存器文件中读取操作数（源寄存器数据）。在 R 型指令中读取两个寄存器，而 I 型和 J 型指令则根据需求读取一个或不读取。</li><li>进行分支地址的计算（PC + 偏移量），以备可能的跳转或分支指令使用。</li><li>根据指令类型生成控制信号，控制信号会影响后续各个阶段的具体操作。</li></ul></li><li><p><strong>执行（EX，Execute）</strong></p><ul><li><strong>算术或逻辑操作</strong>：如果是算术或逻辑指令，ALU（算术逻辑单元）执行相应操作，例如加法、减法、与或非等。</li><li><strong>内存地址计算</strong>：若是加载或存储指令，ALU 计算内存访问的目标地址（基地址 + 偏移量）。</li><li><strong>分支判断</strong>：若是分支指令，在 ALU 进行判断后决定是否采用分支地址。</li><li>这一阶段的结果（例如运算结果或目标地址）将传递给下一阶段。</li></ul></li><li><p><strong>访存（MEM，Memory Access）</strong></p><ul><li><strong>加载指令</strong>：如果是加载指令（如 <code>lw</code>），从内存中读取数据，并将其存入一个临时寄存器。</li><li><strong>存储指令</strong>：如果是存储指令（如 <code>sw</code>），将寄存器中的数据写入指定的内存地址。</li><li>其他指令在这一阶段不做任何操作，直接进入下一个阶段。</li></ul></li><li><p><strong>写回（WB，Write Back）</strong></p><ul><li>将执行结果写回到寄存器文件中（如 <code>R</code> 型和 <code>I</code> 型指令）。</li><li>对于加载指令，将从内存读取的数据写入目标寄存器。</li><li>此阶段完成后，处理器准备进入下一条指令的执行。</li></ul></li></ol><h3 id="4-2-Pipeline-Basics"><a href="#4-2-Pipeline-Basics" class="headerlink" title="4.2 Pipeline Basics"></a>4.2 Pipeline Basics</h3><p>在指令周期的五个阶段，可以把数据通路分为5个阶段，形成流水线(pipeline)。<br><img src="/img/CA/pipeline.png" alt="流水线" style="max-width: 100%; height: auto;" /><br>根据上图，可以很直观的给出流水线相关计算公式：</p><center>$时钟周期数 = 指令数 + 流水级级数 - 1 = IC + n - 1$</center><center>$理想加速比 = 流水线级数 = n$</center><blockquote><p>注意⚠️：时钟周期取5个阶段中最慢的阶段作为时钟周期（木桶效应）</p></blockquote><h3 id="4-3-Pipeline-Hazards"><a href="#4-3-Pipeline-Hazards" class="headerlink" title="4.3 Pipeline Hazards"></a>4.3 Pipeline Hazards</h3><p><strong>流水线冒险（Pipeline Hazards）</strong> 是在指令流水线中可能导致流水线停顿或性能下降的问题。主要有三种类型的流水线冒险：数据冒险、控制冒险和结构冒险。下面是对每种冒险的详细讲解：</p><h4 id="4-3-1-数据冒险-Data-Hazard"><a href="#4-3-1-数据冒险-Data-Hazard" class="headerlink" title="4.3.1 数据冒险 (Data Hazard)"></a>4.3.1 数据冒险 (Data Hazard)</h4><p>数据冒险是由于指令之间的数据依赖性导致的。例如，一条指令需要使用前一条指令的计算结果，如果在计算结果尚未写回寄存器时就使用该结果，流水线会因为缺少数据而停顿。常见的数据冒险有以下几种类型：</p><ul><li><p><strong>RAW（Read After Write，读后写）</strong>：最常见的数据冒险类型。假设有指令 A 和指令 B，A 先于 B 执行。如果 B 读取 A 的结果而 A 还未写回寄存器，则会产生数据冒险。例如：</p><figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A: R1 &#x3D; R2 + R3B: R4 &#x3D; R1 + R5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>指令 B 在 A 的结果写回之前读取了 R1，造成数据冒险。</p></li><li><p><strong>WAR（Write After Read，写后读）</strong>：较少见，发生在指令先读取了寄存器的值，而后续指令修改了该寄存器的值。这种冒险通常在特定的流水线架构中才会发生。</p></li><li><p><strong>WAW（Write After Write，写后写）</strong>：如果流水线支持多发射或指令乱序执行，就可能发生这种冒险。即先有一条指令写一个寄存器，后续指令也写相同寄存器，但乱序执行导致后面的指令先写完。</p></li></ul><p>解决方法：</p><ul><li>数据转发 (Data Forwarding)或旁路（bypass）：将未写回寄存器的数据直接转发给下一条指令的执行单元，从而避免等待写回寄存器的过程。</li><li>插入气泡 (Bubble)：让流水线停顿一个或多个周期，直到所需数据准备就绪。</li></ul><h4 id="4-3-2-控制冒险-Control-Hazard"><a href="#4-3-2-控制冒险-Control-Hazard" class="headerlink" title="4.3.2 控制冒险 (Control Hazard)"></a>4.3.2 控制冒险 (Control Hazard)</h4><p>控制冒险是因为分支指令或跳转指令的出现，使得流水线不能确定下一条要执行的指令，从而导致流水线停顿。分支指令可能改变程序执行的路径，而在确定跳转目标前，流水线并不知道应该继续取哪条指令。</p><p>例如，以下代码段中，当执行<code>if</code>判断时，可能会发生控制冒险：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span>    <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>    <span class="token function">do_something_else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在判断 <code>a &gt; b</code> 之前，流水线不知道下一步应该执行 <code>do_something</code> 还是 <code>do_something_else</code>。</p><p>解决方法：</p><ul><li>分支预测 (Branch Prediction)：利用硬件预测分支指令的执行路径。现代处理器使用动态分支预测，根据历史执行情况预测下一步操作。</li><li>延迟槽 (Delay Slot)：将分支指令后的指令提前执行，即使分支结果不确定也先执行下一条指令，从而减少停顿，但这种方法需要编译器支持。</li><li>分支目标缓冲区 (Branch Target Buffer, BTB)：缓存分支指令的目标地址，减少分支跳转的停顿时间。</li></ul><h4 id="4-3-3-结构冒险-Structural-Hazard"><a href="#4-3-3-结构冒险-Structural-Hazard" class="headerlink" title="4.3.3 结构冒险 (Structural Hazard)"></a>4.3.3 结构冒险 (Structural Hazard)</h4><p>结构冒险是由于硬件资源的竞争导致的。在指令执行过程中，如果两个或多个指令同时需要访问同一硬件资源（例如，内存、寄存器或 ALU 单元），但硬件资源不能同时支持多个访问请求，则会产生结构冒险。</p><p>例如，如果处理器的内存访问和取指令共享相同的内存端口，且一个指令在内存中读取数据的同时，另一个指令需要从内存中取指令，就会产生结构冒险。</p><p>解决方法：</p><ul><li>增加硬件资源：在流水线设计时，增加必要的硬件资源。例如，为指令存储和数据存储提供独立的内存端口，避免资源竞争。</li><li>流水线停顿：当资源不可用时，让流水线停顿一个周期，以等待资源的释放。</li></ul><div class="note note-primary">            <p>流水线在修考里面是非常非常重要的存在‼️我更希望用经典的例题讲解然后来帮助理解。</p>          </div><p>经典流水线问题：<a href="https://toutou.zeabur.app/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">九州大学2022年夏季计算机组成过去问</a></p><h2 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h2><p>本章主要讲解存储器的层次和局部性原理。这一章和操作系统的重合度非常高，建议配合操作系统复习。本章的Cache映射和TLB映射在修考题中出现的频率非常高。</p><h3 id="5-1-Memory-Hierachy"><a href="#5-1-Memory-Hierachy" class="headerlink" title="5.1 Memory Hierachy"></a>5.1 Memory Hierachy</h3><p>如标题所见，这是计算机8大设计思想之一，采用层次结构将存储器主要分为4个层次，从顶层到底层依次是：寄存器，高速缓存，主存，外存。<br><img src="/img/CA/memory.svg" alt="存储器层次" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-Register"><a href="#5-1-1-Register" class="headerlink" title="5.1.1 Register"></a>5.1.1 Register</h4><p>寄存器是 CPU 中的高速存储单元，用于暂时存储指令和数据，帮助 CPU 进行快速计算。它们是 CPU 中访问速度最快的存储器，因为它们直接位于 CPU 内核中，靠近运算单元（如算术逻辑单元，ALU）。</p><p><strong>寄存器的特点</strong></p><ul><li><strong>速度快</strong>：寄存器的访问速度比 Cache 和主存（RAM）都要快，能满足 CPU 的即时需求。</li><li><strong>容量小</strong>：寄存器数量有限，通常每个寄存器只有几个字节或几十个字节的容量。</li><li><strong>功能明确</strong>：寄存器根据用途被分为不同类型，每种寄存器在特定的指令或运算中起特定的作用。</li></ul><p><strong>常见的寄存器类型</strong></p><ol><li><strong>通用寄存器</strong>：用于临时存储数据，支持基本的加、减、乘、除等运算。</li><li><strong>程序计数器 (PC)</strong> ：保存下一条要执行指令的地址，用于控制程序执行的顺序。</li><li><strong>状态寄存器&#x2F;标志寄存器</strong>：存储运算结果的状态信息，如是否为零、是否有溢出等，用于条件判断。</li><li><strong>堆栈指针 (SP)</strong> ：指向栈顶位置，用于函数调用和返回的管理。</li><li><strong>地址寄存器</strong>：存储内存地址，用于快速访问特定的内存位置。</li></ol><p><strong>寄存器的作用</strong><br>寄存器用于 CPU 执行指令时的临时数据存储，避免频繁访问较慢的内存单元。它们直接与 CPU 核心连接，确保计算快速、高效。</p><h4 id="5-1-2-Cache"><a href="#5-1-2-Cache" class="headerlink" title="5.1.2 Cache"></a>5.1.2 Cache</h4><p><strong>Cache</strong>（缓存）是位于 CPU 和主存（RAM）之间的高速存储器，用于缓解 CPU 与主存之间的速度差异。Cache 通过暂时存储常用的数据和指令，减少 CPU 访问主存的次数，从而提高整体运算速度。Cache 通常是由 <strong>SRAM（静态随机存取存储器）</strong> 组成的；SRAM是易失性存储器，尽管 SRAM 的数据不需要周期性刷新，但一旦电源关闭，存储在其中的数据就会丢失。这是因为 SRAM 的存储原理基于晶体管的电状态，当电源断开时，这些状态会消失。<strong>DRAM</strong>则有些许不同，需要定期刷新以维持数据，刷新操作会耗费一定时间和电力，但也是易失性存储器(volatile memory)。</p><p><strong>Cache 的特点</strong></p><ul><li><strong>访问速度快</strong>：Cache 的访问速度比主存快，仅次于寄存器，能快速提供数据。</li><li><strong>层级结构</strong>：Cache 通常分为多级，包括 L1、L2 和 L3 缓存，分别位于不同的 CPU 层次上，L1 速度最快但容量最小，L3 容量最大但速度相对较慢。</li><li><strong>自动管理</strong>：Cache 由硬件自动管理，CPU 根据访问数据的频率和规律自动将数据加载到 Cache 中，无需程序员手动干预。</li></ul><p><strong>Cache 的作用</strong><br>Cache 主要用于存储 CPU 经常访问的数据或指令，以减少访问主存的延迟，提升 CPU 的执行效率。现代处理器通常会采用多级缓存结构，以平衡容量与速度之间的需求。</p><h4 id="5-1-3-Main-Memory"><a href="#5-1-3-Main-Memory" class="headerlink" title="5.1.3 Main Memory"></a>5.1.3 Main Memory</h4><p><strong>内存</strong>（Memory）一般称为主存(Main Memory)，是计算机中用于临时存储数据和程序的部件，CPU 可以快速访问其中的数据。内存的主要作用是为 CPU 提供运行时的工作区，用于存放操作系统、应用程序和当前处理的数据。</p><p><strong>内存的特点</strong></p><ul><li><strong>速度适中</strong>：内存的访问速度介于 Cache 和硬盘之间。尽管比硬盘快很多，但比不上 CPU 内部的寄存器和缓存。</li><li><strong>容量较大</strong>：内存容量一般较大，能够存储多个程序和大量数据，以满足系统的多任务需求。</li><li><strong>易失性</strong>：内存（RAM）通常由 DRAM（动态随机存取存储器）组成。DRAM 由于容量大、成本相对较低，也是一种易失性存储器，断电后数据会丢失。</li></ul><p><strong>内存的作用</strong></p><p>内存用于临时存放正在执行的程序和正在处理的数据，起到了 CPU 与硬盘之间的缓冲作用，使得系统运行更加高效。计算机在开机后，将程序从硬盘加载到内存中，CPU 再从内存中读取指令执行。</p><h4 id="5-1-4-Secondary-Memory"><a href="#5-1-4-Secondary-Memory" class="headerlink" title="5.1.4 Secondary Memory"></a>5.1.4 Secondary Memory</h4><p><strong>Secondary Memory</strong>（二级存储器）是计算机的外部存储，用于长期存储数据和程序，断电后数据不会丢失。常见的二级存储器包括硬盘驱动器 (HDD)、固态硬盘 (SSD)、光盘、以及 USB 闪存等。</p><p><strong>辅助存储器的特点</strong></p><ul><li><strong>非易失性(nonvolatile)</strong> ：辅助存储器断电后仍能保留数据，适合长期存储文件、程序和系统数据。</li><li><strong>大容量</strong>：相比于主存，辅助存储器容量更大，能够存储大量的数据和文件。</li><li><strong>较慢的访问速度</strong>：辅助存储器的读写速度比内存慢，因此用于存储不需要频繁访问的数据。</li></ul><p><strong>辅助存储器的作用</strong></p><p>辅助存储器用于存储计算机的操作系统、应用程序、用户文件和其他数据，提供数据的长期保存。计算机在启动时会将操作系统和相关程序从辅助存储器加载到内存中，以便 CPU 处理。</p><h3 id="5-2-Principle-of-Locality"><a href="#5-2-Principle-of-Locality" class="headerlink" title="5.2 Principle of Locality"></a>5.2 Principle of Locality</h3><p>局部性原理(principle of locality)是计算机组成中的一个关键概念，用来描述程序在执行过程中，访问内存地址或存储单元的一种倾向。局部性原理主要分为以下两类：</p><p><strong>时间局部性（Temporal Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么在不久的将来它很可能会再次被访问。</li><li><strong>例子</strong>：在循环中多次访问某个变量。比如循环计数器，每次迭代都会访问该变量。</li></ul><p><strong>空间局部性（Spatial Locality）</strong></p><ul><li><strong>定义</strong>：如果一个数据被访问过，那么它附近的数据也很可能会在不久的将来被访问。</li><li><strong>例子</strong>：遍历数组时，逐个访问数组中的元素。比如访问数组<code>arr[0]</code>后，很可能访问<code>arr[1]</code>。</li></ul><blockquote><p>局部性原理在设计计算机缓存（Cache）时尤为重要。因为缓存利用局部性原理，通过临时存储经常访问的数据或地址来减少访问主内存的次数，提高整体系统性能。</p></blockquote><h3 id="5-3-Cache’s-Performance"><a href="#5-3-Cache’s-Performance" class="headerlink" title="5.3 Cache’s Performance"></a>5.3 Cache’s Performance</h3><p>Cache的主要考点围绕在命中率和缺失率的计算；在Cache映射中也有非常多的改进策略。</p><h4 id="5-3-1-Cache-Hit-Miss"><a href="#5-3-1-Cache-Hit-Miss" class="headerlink" title="5.3.1 Cache Hit &amp; Miss"></a>5.3.1 Cache Hit &amp; Miss</h4><p><strong>Cache命中（Cache Hit）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据在缓存中找到时，就称为Cache命中。命中率（Hit Rate）是命中次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它已经在缓存中，直接读取数据，避免了访问慢速的主内存，从而提高了整体性能。</li></ul><p><strong>Cache缺失（Cache Miss）</strong></p><ul><li><strong>定义</strong>：当处理器需要的数据不在缓存中，必须从主内存中读取时，就称为Cache缺失。缺失率（Miss Rate）是缺失次数占总访问次数的百分比。</li><li><strong>示例</strong>：处理器需要读取一个数据块，如果它不在缓存中，处理器需要从主内存中读取该数据块，并将其放入缓存中。这个过程比直接从缓存读取要慢得多。</li></ul><p>命中率(Hit Rate)和缺失率(Miss Rate)的计算方法非常直观，分别是命中&#x2F;缺失的次数占访存次数的比例。</p><h4 id="5-3-2-命中时间、缺失代价和访存阻塞周期"><a href="#5-3-2-命中时间、缺失代价和访存阻塞周期" class="headerlink" title="5.3.2 命中时间、缺失代价和访存阻塞周期"></a>5.3.2 命中时间、缺失代价和访存阻塞周期</h4><p><strong>命中时间（Hit Time）</strong></p><ul><li><strong>定义</strong>：命中时间是指CPU在缓存中找到数据所需的时间，包括地址翻译、缓存访问和数据返回给处理器的时间。通常只有1个时钟周期长度。</li><li><strong>计算</strong>：命中时间通常由缓存访问的硬件特性决定，具体时间取决于缓存的层级和设计。</li></ul><p><strong>缺失代价（Miss Penalty）</strong></p><ul><li><strong>定义</strong>：缺失代价是指当数据不在缓存中，需要从较低层级的缓存或主存中加载数据所需的时间。</li><li><strong>计算</strong>：缺失代价 &#x3D; 低层级缓存或主存的访问时间 + 将数据传送到缓存中的时间。</li></ul><p><strong>访存阻塞周期（Memory Stall Cycles）</strong></p><ul><li><strong>定义</strong>：访存阻塞周期是指由于缓存缺失导致处理器需要等待数据加载而停顿的周期数。</li><li><strong>计算</strong>：访存阻塞周期 &#x3D; 缺失率 × 缺失代价</li></ul><p>假设：</p><ul><li>命中时间为1个周期。</li><li>缺失代价为50个周期。</li><li>缺失率为5%。</li></ul><p>那么：访存阻塞周期 &#x3D; 5% × 50个周期 &#x3D; 2.5个周期。</p><p>普适性的衡量会给上一个缺失率(Miss Rate), 那么</p><center>$访存阻塞周期 = 访存次数 \times 缺失率 \times 缺失代价$</center><h3 id="5-4-Cache的三种映射方式"><a href="#5-4-Cache的三种映射方式" class="headerlink" title="5.4 Cache的三种映射方式"></a>5.4 Cache的三种映射方式</h3><p><strong>1. 直接映射（Direct Mapped Cache）</strong></p><ul><li><strong>定义</strong>：每个内存块都映射到缓存的一个特定位置。缓存中的每个位置可以存储多个内存块，但在任意时间只能存储一个。</li><li><strong>优点</strong>：实现简单且成本低。</li><li><strong>缺点</strong>：冲突较多，即不同内存块可能会映射到同一个缓存位置，导致频繁替换。</li></ul><p><strong>2. 全关联映射（Fully Associative Cache）</strong></p><ul><li><strong>定义</strong>：内存块可以映射到缓存的任何位置。缓存中的每个位置都可以存储任何内存块。</li><li><strong>优点</strong>：减少了冲突，因为任何内存块都可以放到任何缓存位置。</li><li><strong>缺点</strong>：实现复杂且成本高，需要比较所有缓存位置以找到匹配的块。</li></ul><p><strong>3. 组关联映射（Set Associative Cache）</strong></p><ul><li><strong>定义</strong>：缓存分成多个组，每个组包含若干个位置。内存块首先映射到某个组，然后可以存储在该组的任意位置。</li><li><strong>优点</strong>：在复杂度和性能之间取得平衡，减少了直接映射中的冲突，同时实现比全关联映射更简单。</li><li><strong>缺点</strong>：组的选择可能会导致一些复杂度，但总的来说，比全关联映射低。<img src="/img/CA/cache_map.svg" alt="Cache三种映射方式" style="max-width: 100%; height: auto;" /></li></ul><h4 id="5-4-1-直接映射"><a href="#5-4-1-直接映射" class="headerlink" title="5.4.1 直接映射"></a>5.4.1 直接映射</h4><p>映射规则：Cache块号 &#x3D; 内存块号 % Cache块数</p><blockquote><p>比如，Cache共有8块，内存的十号块映射在Cache的块号是：10 % 8 &#x3D; 2</p></blockquote><p>直接映射缓存（Direct Mapped Cache）内存地址通常被分成三个字段：块内字节偏移、索引位和标记位。</p><p><strong>1. 块内字节偏移（Block Offset）</strong></p><ul><li><strong>定义</strong>：块内字节偏移用于定位一个块中的具体字节。</li><li><strong>计算</strong>：偏移位的数量取决于块的大小。例如，如果块大小为4个字节，则需要2位来表示块内字节偏移。<ul><li>例子：对于一个块大小为4个字节的缓存，偏移位可能是<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>。</li></ul></li></ul><p><strong>2. 索引位（Index Bits）</strong></p><ul><li><strong>定义</strong>：索引位用于定位缓存中的具体行（块）。</li><li><strong>计算</strong>：索引位的数量取决于缓存的行数。例如，如果缓存有8行，需要3位索引位来标识具体的行。<ul><li>例子：对于一个有8行的缓存，索引位可能是<code>000</code>到<code>111</code>。</li></ul></li></ul><p><strong>3. 标记位（Tag Bits）</strong></p><ul><li><strong>定义</strong>：标记位用于区分不同内存块，它们映射到同一个缓存行。</li><li><strong>计算</strong>：标记位的数量 &#x3D; 内存地址总位数 - 索引位数量 - 块内字节偏移位数量。<ul><li>例子：假设内存地址总位数为16位，块大小为4字节（2位块内偏移），缓存有8行（3位索引），那么标记位数量为11（16-3-2&#x3D;11）。</li></ul></li></ul><blockquote><p><strong>示例</strong> ：假设有一个16位的内存地址，缓存有8行，每行块大小为4字节。</p></blockquote><p>内存地址：<code>1010110010101110</code></p><ul><li><strong>块内字节偏移</strong>：2位（最右边的2位），<code>10</code> 表示块内的某个字节。</li><li><strong>索引位</strong>：3位（次右边的3位），<code>110</code> 表示缓存的具体行。</li><li><strong>标记位</strong>：11位（剩余左边的位），<code>10101100101</code> 用于区分不同的内存块。</li></ul><p><strong>内存地址分解</strong>：</p><ul><li>标记位（Tag）：<code>10101100101</code></li><li>索引位（Index）：<code>110</code></li><li>块内字节偏移（Block Offset）：<code>10</code></li></ul><center>$Cache容量 = （标记位 + 数据位）\times 行数 $</center>补充：如果题目强调了有效位的存在，那么Cache的每一行需要多1bit的有效位，则<center>$Cache容量 = （1 + 标记位 + 数据位）\times 行数 $</center><p>有效位是缓存系统中的一个重要概念，用于指示缓存块中的数据是否有效。具体来说，有效位帮助确定当前缓存块是否包含可以被处理器使用的有效数据。</p><ol><li><strong>指示数据有效性</strong>：有效位为1表示缓存块中的数据有效且可用；为0表示缓存块中的数据无效，可能未被使用或需要更新。</li><li><strong>管理缓存块</strong>：当一个新的内存块被加载到缓存时，会设置有效位为1。当缓存块的数据被替换或失效时，有效位被设置为0。</li></ol><p><strong>实现原理</strong></p><ul><li><strong>检查有效位</strong>：每次缓存访问时，首先检查有效位。如果有效位为0，即使缓存地址匹配，数据也不被使用，因为它无效。</li><li><strong>缓存替换</strong>：在缓存替换时，新的数据块写入缓存，并将对应的有效位设置为1。被替换的数据块的有效位通常被设置为0，表示数据无效。</li></ul><p><strong>示例</strong><br>假设一个缓存系统有4个块，每个块都有一个有效位：</p><ul><li>块0：有效位&#x3D;1（数据有效）</li><li>块1：有效位&#x3D;0（数据无效）</li><li>块2：有效位&#x3D;1（数据有效）</li><li>块3：有效位&#x3D;0（数据无效）</li></ul><p>当处理器访问一个地址时，它首先检查缓存块的有效位。如果有效位为1，它会进一步检查地址是否匹配；如果有效位为0，则直接从主存获取数据。</p><h4 id="5-4-2-直接映射缺失的3C模型"><a href="#5-4-2-直接映射缺失的3C模型" class="headerlink" title="5.4.2 直接映射缺失的3C模型"></a>5.4.2 直接映射缺失的3C模型</h4><p><strong>1. 冷缺失（Cold Miss）</strong></p><ul><li><strong>定义</strong>：也称为强制缺失或首次缺失。这种情况发生在缓存首次加载数据块时，因为缓存中还没有存储该数据块。</li><li><strong>示例</strong>：程序第一次访问一个数据块时，缓存中还没有该数据块，导致冷缺失。</li></ul><p><strong>2. 容量缺失（Capacity Miss）</strong></p><ul><li><strong>定义</strong>：由于缓存容量有限，即使缓存中所有块都被充分利用，仍然无法容纳所有需要的数据块，从而导致缺失。</li><li><strong>示例</strong>：程序需要访问的数据块数量超过了缓存容量，导致一些较早访问的数据块被驱逐，再次访问时需要重新加载。</li></ul><p><strong>3. 冲突缺失（Conflict Miss）</strong></p><ul><li><strong>定义</strong>：也称为干扰缺失。这种情况发生在直接映射缓存中，不同的数据块映射到同一个缓存块位置，导致频繁替换，即使缓存容量足够也会出现缺失。</li><li><strong>示例</strong>：两个或多个数据块映射到同一个缓存位置，导致数据块被替换，从而产生冲突缺失。</li></ul><img src="/img/CA/map_miss.svg" alt="3C模型" style="max-width: 100%; height: auto;" />  <p>直接映射在应对上面的Cache缺失的时候有三种处理方式：</p><p><strong>1.写直达（Write Through）：</strong></p><ul><li>CPU同时向Cache和主存写入数据</li><li>实现简单，但写入速度慢</li><li>保持了Cache和主存的一致性</li></ul><p><strong>写缓冲（Write Buffer）：</strong></p><ul><li>CPU先写入Cache</li><li>数据暂存在写缓冲区</li><li>后台异步写入主存</li><li>提高了写入效率</li></ul><p><strong>写回（Write Back）：</strong></p><ul><li>CPU只写入Cache</li><li>使用脏位(Dirty Bit)标记修改</li><li>仅在数据被替换时才写回主存</li><li>最高效但实现复杂</li></ul><img src="/img/CA/map_strategy.svg" alt="Cache缺失策略" style="max-width: 100%; height: auto;" /><h4 id="5-4-3-多级缓存机制"><a href="#5-4-3-多级缓存机制" class="headerlink" title="5.4.3 多级缓存机制"></a>5.4.3 多级缓存机制</h4><p>多级缓存（Multilevel Cache）是一种在计算机系统中提高处理器访问数据速度的技术，通常将缓存分为多个层次，如 L1、L2 和 L3 缓存。这些缓存层次的设置能够平衡存取速度、容量和成本，确保 CPU 能更快地获取需要的数据。</p><p><strong>多级缓存的主要特点</strong></p><ol><li><p><strong>L1缓存</strong>（一级缓存）：通常集成在 CPU 内核中，速度最快，容量较小（一般为几十KB）。L1缓存分为指令缓存（I-Cache）和数据缓存（D-Cache），分别用于存储指令和数据，帮助 CPU 快速访问常用数据。</p></li><li><p><strong>L2缓存</strong>（二级缓存）：相比 L1 缓存稍慢，但容量更大（几百KB到几MB），通常也集成在处理器中。L2 缓存为 L1 提供数据支援，命中率高，进一步减少了 CPU 对主存（RAM）的访问需求。</p></li><li><p><strong>L3缓存</strong>（三级缓存）：用于共享多个 CPU 内核的数据，容量较大（几MB到几十MB），但访问速度比 L2 缓慢。L3缓存作为所有内核的公共缓存，提升了多核处理器的并行性能。</p></li><li><p><strong>工作原理</strong>：CPU 会首先查找 L1 缓存，如果未命中则依次查找 L2 和 L3 缓存，直到最后访问主存。这样的分级缓存结构可以减少主存访问次数，从而提高系统性能。</p></li><li><p><strong>优点</strong>：多级缓存结构能显著降低数据访问延迟，提高处理器的执行效率；而且它能有效利用缓存的层级特性，合理分配存取速度和容量。</p></li></ol><p><strong>多级缓存背景下的平均 CPI 计算</strong></p><p>在多级缓存系统中，平均每条指令的周期数（CPI，Cycles Per Instruction）可以通过考虑每一级缓存的缺失率和缺失代价来计算。这里的缺失率指的是每一级缓存未命中（缺失）的概率，缺失代价则是缓存未命中时所需要的额外处理周期数。平均 CPI 的计算可以按以下步骤进行。</p><p>假设：</p><ul><li>$\text{CPI}_{\text{ideal}}$ 是理想情况下（没有缓存缺失）的 CPI，即不考虑缓存缺失时每条指令的周期数。</li><li>L1、L2、L3 分别是一级、二级和三级缓存。</li><li>$\text{MR}_n$ 表示第 $n$ 级缓存的缺失率（Miss Rate）。</li><li>$\text{MC}_n$ 表示第 $n$ 级缓存的缺失代价（Miss Penalty），即在第 $n$ 级缓存缺失时需要的额外周期数。</li></ul><p>平均 CPI 的计算可以分为以下步骤：</p><ol><li><p><strong>L1 缓存的贡献</strong>：L1 缓存缺失的情况下，需要访问 L2 缓存，因此 L1 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L1}} = \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}}$ </center></li><li><p><strong>L2 缓存的贡献</strong>：L1 缓存缺失时会访问 L2 缓存，如果 L2 缓存也缺失，则需要访问 L3 缓存。L2 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L2}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$ </center></li><li><p><strong>L3 缓存的贡献</strong>：当 L1 和 L2 都缺失时，才会访问 L3 缓存。如果 L3 缓存也缺失，就会访问主存，因此 L3 缓存的平均贡献为：</p><center> $\text{CPI}_{\text{L3}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}}$ </center></li><li><p><strong>主存的贡献</strong>：当 L1、L2 和 L3 缓存都缺失时，才会访问主存。因此主存的平均贡献为：</p><center> $\text{CPI}_{\text{memory}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$ </center></li></ol><p>把各级缓存和主存的贡献相加，再加上理想情况下的 CPI，得到总的平均 CPI：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{CPI}_{\text{L1}} + \text{CPI}_{\text{L2}} + \text{CPI}_{\text{L3}} + \text{CPI}_{\text{memory}}$ </center><p>展开后，即：</p><center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$$+ \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$</center><blockquote><ul><li>每一级缓存的贡献都是基于它前一级缓存的缺失率和自身的缺失代价递归计算的。</li><li>这个公式综合了各级缓存的缺失率和缺失代价，提供了一个较为准确的平均 CPI 估计。</li></ul></blockquote><h3 id="5-5-Virtual-Memory"><a href="#5-5-Virtual-Memory" class="headerlink" title="5.5 Virtual Memory"></a>5.5 Virtual Memory</h3><p>虚拟存储器通过地址映射机制，将操作系统使用的虚拟地址转换为不同的物理地址。这个过程涉及多层缓存和映射关系，例如：</p><ul><li>Cache 将处理器寄存器访问的地址映射到内存中的物理地址，以加速数据读取。</li><li>主存（内存）充当磁盘的缓存，从磁盘读取数据时，常用的数据会保存在内存中以加快访问速度。</li><li>TLB（快表）是页表的缓存，用于快速查找虚拟地址到物理地址的映射，减少页表查找的开销。</li></ul><p>将虚拟地址转换为物理地址的过程通常涉及几个关键步骤：</p><ol><li><p>地址生成：当程序访问某个内存位置时，它会生成一个虚拟地址。</p></li><li><p>页号和偏移量：虚拟地址被分为两个部分：页号和偏移量。页号用于识别该地址所属的页，而偏移量则指定了在该页内的具体位置。</p></li><li><p>快速表 (Translation Lookaside Buffer, TLB)：在检查页表之前，系统首先检查快速表 (TLB)，这是一个小而快速的缓存，存储最近的虚拟到物理地址的转换。如果在 TLB 中找到转换（TLB 命中），则可以快速检索物理地址。</p></li><li><p>页表查找：如果在 TLB 中未找到转换（TLB 未命中），系统将访问页表。页表包含条目，将每个虚拟页号映射到内存中相应的物理页框号。</p></li><li><p>物理地址形成：一旦访问了页表，就可以获得物理页框号。然后，物理地址通过将该页框号与原虚拟地址中的偏移量结合来形成。</p></li><li><p>访问内存：系统现在使用物理地址访问 RAM 中的数据。</p></li><li><p>页面缺失处理：如果所需的页面不在内存中（页面缺失），操作系统将从磁盘存储中检索该页面，并相应地更新页表。</p></li></ol><img src="/img/CA/address.svg" alt="Address Translation" style="max-width: 100%; height: auto;" /><p>关于虚拟地址和物理地址还有更多的考点内容，比如各种替换策略和写策略，这里的内容我更愿意放到操作系统的对应章节来讲解😈马不停蹄更新中🐎</p><div class="note note-primary">            <p>完结撒花🎉<br>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>Computer Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語語彙まとめ</title>
    <link href="/2024/09/28/JPN-Words/"/>
    <url>/2024/09/28/JPN-Words/</url>
    
    <content type="html"><![CDATA[<h1 id="日语单词自测"><a href="#日语单词自测" class="headerlink" title="日语单词自测"></a>日语单词自测</h1><p><em>配合moji插件查看中文释义👀</em></p><h2 id="1-動詞"><a href="#1-動詞" class="headerlink" title="1. 動詞"></a>1. 動詞</h2><p>欺く「あざむく」、覗く「のぞく」、湧く「わく」、逃れる「のがれる」、挑む「いどむ」、固める「かためる」、奪う「うばう」、紛れ込む「まぎれ込む」、仕掛ける「しかける」、強引「ごういん」、溢れる「あふれる」、謙る「へりくだる」、絡み合う「からみあう」、仰ぐ「あおぐ」、耽る「ふける」、眩む「くらむ」、紡ぐ「つむぐ」、辿り着く「たどりつく」、戒める「いましめる」、親しむ「したしむ」、身構える「みがまえる」、草臥れる「くたびれる」、勤める「つとめる」、睨む「にらむ」、濁る「にごる」、融合「ゆうごう」、襲う「おそう」、押し込む「おしこむ」、焚く「たく」、惑う「まどう」、傾ける「かたむける」、金縛り「かなしばり」、軋む「きしむ」、免れる「まぬかれる」、与かる「あずかる」、炙る「あぶる」、嘆く「なげく」、誂える「あつらえる」、埋める「うずめる」、頷く「うなずく」、貫く「つらぬく」、授ける「さずける」、値する「あたいする」、省みる「かえりみる」、打ち明ける「うちあける」、押し寄せる「おしよせる」、呆れる「あきれる」、綴る「つずる」、攫う「さらう」、専ら「もっぱら」、呟く「つぶやく」、呼び掛ける「よびかける」、見なす「みなす」、戸惑う「とまどう」、透き通る「すきとおる」、怒鳴る「どなる」、齎す「もたらす」、富む「とむ」、拗ねる「すねる」、威張る「いばる」、凌ぐ「しのぐ」、弁償「べんしょう」、安らぐ「やすらぐ」、見合わせる「みあわせる」、気軽「きがる」、見込む「みこむ」、奉る「たてまつる」、緩める「ゆるめる」、磨く「みがく」、充ちる「みちる」、跨る「またがる」、覆う「おおう」、吹き出す「ふきだす」、交じる「まじる」、紡ぐ「つむぐ」、慰める「なぐさめる」、実る「みのる」、叱る「しかる」、馳せる「はせる」、愚か「おろか」、疑う「うたがう」、探る「さぐる」、痺れる「しびれる」、食い違う「くいちがう」、窺う「うかがう」、揃う「そろう」、報いる「むくいる」、撒く「まく」、拘る「こだわる」、気に障る「きにさわる」、押し切る「おしきる」、立ち寄る「たちよる」、蹴る「ける」、除去「じょきょ」、囁く「ささやく」、志す「こころざす」、伏せる「ふせる」、巫山戯る「ふざける」、奢る「おごる」、褪せる「あせる」、記す「しるす」、絶る「たえる」、背く「そむく」、取り払う「とりはらう」、俯く「うつむく」、照れる「てれる」、掲げる「かかげる」、仕上げる「しあげる」、映える「はえる」、乱れる「みだれる」、惜しむ「おしむ」、呼び寄せる「よびよせる」、衰える「おとろえる」、慣らす「ならす」、治る「なおる」、遂げる「とげる」、費やす「ついやす」、励ます「はげます」、滞る「とどこおる」、隔てる「へだてる」、謝る「あやまる」、昇進「しょうしん」、睨む「にらむ」、急かす「せかす」、帯びる「おびる」、冷やす「ひやす」、潤す「うるおす」、狼狽える「うろたえる」、濡らす「ぬらす」、庇う「かばう」、抱え込む「かかえこむ」、秘める「ひめる」、割り当てる「わりあてる」、思い詰める「おもいつめる」、練る「ねる」、持て成す「もてなす」、賄う「まかなう」、跳ねる「はねる」、募る「つのる」、絡める「からめる」、転がる「ころがる」、労わる「いたわる」、復旧「ふっきゅう」、薄まる「うすまる」、遠ざける「とおざける」、お詫び「おわび」、躊躇う「ためらう」、潰れる「つぶれる」、断る「ことわる」、舞う「まう」、絡む「からむ」、切り出す「きりだす」、排卵「はいらん」、収まる「おさまる」、治する「じする」、狭める「せばめる」、覆す「くつがえす」、滅びる「ほろびる」、翻す「ひるがえす」、立て替える「たてかえる」、弾く「はじく」、養う「やしなう」、鈍る「にぶる」、唱える「となえる」、蓄える「たくわえる」、損なう「そこなう」、培う「つちかう」、見失う「みうしなう」、避ける「よける」、讃る「たたえる」、掘る「ほる」、怠る「おこたる」、敬う「うやまう」、臨む「のぞむ」、目論む「もくろむ」、偽る「いつわる」、了承「りょうしょう」、賑わう「にぎわう」、遮る「さえぎる」、取り消す「とりけす」、愛着「あいちゃく」、駆使「くし」、儲かる「もうかる」、縮まる「ちぢまる」、怯える「おびえる」、逸らす「そらす」、癒す「いやす」、差し引く「さしひく」、項垂れる「うなだれる」、拒む「こばむ」、担う「になう」、催す「もよおす」、引き返す「ひきかえす」、解ける「ほどける」、妨げる「さまたげる」、築く「きずく」、弾む「はずむ」、商う「あきなう」、食い止める「くいとめる」、訴える「うったえる」、辿る「たどる」、打ち切る「うちきる」、潤う「うるおう」、究明「きゅうめい」、立ち直る「たちなおる」、倒す「たおす」、削る「けずる」、言い張る「いいはる」、劣る「おとる」、偏る「かたよる」、阻む「はばむ」、遡る「さかのぼる」、冷え込む「ひえこむ」、取り払う「とりはらう」、収拾「しゅうしゅう」、出揃う「でそろう」、洗う「あらう」、仕込む「しこむ」、囃す「はやす」、見惚れる「みとれる」、馴染む「なじむ」、見落とす「みおとす」、仕入れる「しいれる」、扱う「あつかう」、搾る「しぼる」、見通す「みとおす」、費やす「ついやす」、座が白ける「ざがしらける」、讃える「たたえる」、持て余す「もてあます」、補う「おぎなう」、煉る「ねる」、清澄「せいちょう」、訪れる「おとずれる」、眺める「ながめる」、見積もる「みつもる」</p><h2 id="2-名詞"><a href="#2-名詞" class="headerlink" title="2. 名詞"></a>2. 名詞</h2><p>物語「ものがたり」、非難「ひなん」、靄「もや」、競技「きょうぎ」、過労「かろう」、振る舞い「ふるまい」、倹約「けんやく」、氏神「うじがみ」、大木「たいぼく」、復興「ふっこう」、亭主関白「ていしゅかんぱく」、畑「はたけ」、役割「やくわり」、脇「わき」、残酷「ざんこく」、稼業「かぎょう」、木立「きだち」、愛想「あいそ」、苦情「くじょう」、良し悪し「よしあし」、苛め「いじめ」、腰「こし」、当選「とうせん」、目論見「もくろみ」、冒頭「ぼうとう」、羽目「はめ」、下駄「げた」、屋敷「やしき」、一昨年「おととし」、照明「しょうめい」、虚ろ「うつろ」、合否「ごうひ」、私邸「してい」、扱い「あつかい」、神秘「しんぴ」、琴「こと」、里「さと」、猥褻「わいせつ」、暮れ「くれ」、醍醐味「だいごみ」、蓄積「ちくせき」、臥床「がしょう」、山懐「やまふところ」、生涯「しょうがい」、跡地「あとち」、味方「みかた」、取材「しゅざい」、発祥地「はっしょうち」、出入り「でいり」、達者「たっしゃ」、原動力「げんどうりょく」、拘束「こうそく」、融通「ゆうずう」、手際「てぎわ」、立食「りっしょく」、善悪「ぜんあく」、境地「きょうち」、人並み「人なみ」、裸足「はだし」、身内「みうち」、無礼「ぶれい」、懇談「こんだん」、試し「ためし」、公平「こうへい」、魅了「みりょう」、霧「きり」、合間「あいま」、顎「あご」、野生「やせい」、険悪「けんあく」、垢「あか」、庵「いおり」、吟味「ぎんみ」、修復「しゅうふく」、迫真「はくしん」、証「あかし」、話題「わだい」、転がし「ころがし」、干物「ひもの」、過誤「かご」、有頂天「うちょうてん」、懲戒「ちょうかい」、規制「きせい」、文献「ぶんけん」、猿「さる」、霞「かすみ」、叡智「えいち」、神話「しんわ」、賃金「ちんぎん」、密輸入「みつゆにゅう」、賭ける「かける」、育ち「そだち」、割れ目「われめ」、大人「おとな」、ありのまま、細菌「さいきん」、応募「おうぼ」、煮物「にもの」、潮流「ちょうりゅう」、焦る「あせる」、取り上げる「とりあげる」、昨年「さくねん」、贅沢「ぜいたく」、真骨頂「しんこっちょう」、争い「あらそい」、女房「にょうぼう」、足場「あしば」、要請「ようせい」、無難「ぶなん」、水着「みずぎ」、車窓「しゃそう」、合致「がっち」、外見「がいけん」、獣「けもの」、代物「しろもの」、田舎者「いなかもの」、趣「おもむき」、束縛「そくばく」、いらいら、緩和「かんわ」、芽「め」、幾分「いくぶん」、最善「さいぜん」、軽蔑「けいべつ」、日取り「ひどり」、無事「ぶじ」、糧「かて」、厄介「やっかい」、手渡し「てわたし」、一見「いっけん」、マスコミ、気の毒「きのどく」、埋立地「うめたてち」、窮屈「きゅうくつ」、勢い良く「いきおいよく」、触れ合い「ふれあい」、青二才「あおにさい」、怪我「けが」、辺鄙「へんぴ」、発端「ほったん」、跋扈「ばっこ」、ゆとり、最期「さいご」、作風「さくふう」、証拠「しょうこ」、生垣「いけがき」、用心棒「ようじんぼう」、安らぐ「やすらぐ」、折節「おりふし」、言及「げんきゅう」、風見鶏「かざみどり」、居眠り「いぬむり」、崖「がけ」、臆病「おくびょう」、一斉「いっせい」、断言「だんげん」、稲光「いなびかり」、勘定「かんじょう」、気前「きまえ」、気立「きだて」、箇条書き「かじょうがき」、編集「へんしゅう」、皆無「かいむ」、当たり「あたり」、漬物「つけもの」、拍手「はくしゅ」、節約「せつやく」、妄想「もうそう」、割合「わりあい」、壁際「かべぎわ」、出鱈目「でたらめ」、納期「のうき」、重体「じゅうたい」、理不尽「りふじん」、弁解「べんかい」、心構え「こころがまえ」、気配「きはい」、変遷「へんせん」、敏捷「びんしょう」、発足「はっそく」、加味「かみ」、内訳「うちわけ」、無造作「むぞうさ」、伴奏「ばんそう」、本筋「ほんすじ」、拠点「きょてん」、需要「じゅよう」、重複「ちょうふく」、積立金「つみたてきん」、軌道「きどう」、群衆「ぐんしゅう」、巧妙「こうみょう」、大筋「おおすじ」、主催「しゅさい」、督促「とくそく」、印「しるし」、配布「はいふ」、枠「わく」、決意「けつい」、質素「しっそ」、憤り「いきどおり」、統合「とうごう」、意気込み「いきごみ」、粘り「ねばり」、中枢「ちゅうすう」、厳正「げんせい」、優勝「ゆうしょう」、陳列「ちんれつ」、樹木「じゅもく」、照合「しょうごう」、証「あかし」、繁盛「はんじょう」、網羅「もうら」、念頭「ねんとう」、安堵「あんど」、由緒「ゆいしょ」、添付「てんぷ」、巡り「めぐり」、憩い「いこい」、廃れる「すたれる」、緊密「きんみつ」、強制「きょうせい」、役名「やくめい」、利子「りし」、難点「なんてん」、満喫「まんきつ」、合意「ごうい」、格段「かくだん」、把握「はあく」、競り合い「せりあい」、煩雑「はんざつ」、利潤「りじゅん」、趣旨「しゅし」、仰天「ぎょうてん」、裏腹「うらはら」、閲覧「えつらん」、兆し「きざし」、該当「がいとう」、先方「せんぽう」、目先「めさき」、改革「かいかく」、打診「だしん」、破損「はそん」、素ぶり「そぶり」、多岐「たき」、手間「てま」、緩和「かんわ」、貧富「ひんぷ」、合併「がっぺい」、概略「がいりゃく」、予断「よだん」、真っ先「まっさき」、人手「ひとで」、抜粋「ばっすい」、嫌味「いやみ」、朦朧「もうろう」、携わる「たずさわる」、食い違い「くいちがい」、怒り「いかり」、提起「ていき」、重宝「ちょうほう」、入念「にゅうねん」、工面「くめん」、推理「すいり」、淵「ふち」、遂行「すいこう」、鑑定「かんてい」、仕組み「しくみ」、口出し「くちだし」、腕前「うでまえ」、ゆとり、抱負「ほうふ」、人脈「じんみゃく」、手分け「てわけ」、逸材「いつざい」、踏襲「とうしゅう」、仕業「しわざ」、雑踏「ざっとう」、契約「けいやく」、相場「そうば」、異色「いしょく」、言い訳「いいわけ」、凝縮「ぎょうしゅく」、逸れる「それる」、収支「しゅうし」、有数「ゆうすう」、興奮「こうふん」、指図「さしず」、日夜「にちや」、逸脱「いつだつ」、処置「しょち」、概ね「おおむね」、拍子「ひょうし」、探り「さぐり」、可決「かけつ」、合致「がっち」、何れ「いずれ」、考慮「こうりょ」、経歴「けいれき」、傾斜「けいしゃ」、圧迫「あっぱく」、張り合う「はりあう」、利息「りそく」、起伏「きふく」、根拠「こんきょ」、ノルマ、手がかり「てがかり」、ウエイト、皮肉「ひにく」、固執「こしゅう」、お手上げ「おてあげ」、辞任「じにん」、躍進「やくしん」、裏付け「うらずけ」、帰結「きけつ」、名誉「めいよ」、互角「ごかく」、合弁「ごうべん」、釈明「しゃくめい」、溝「みぞ」、宿命「しゅくめい」、区々「まちまち」、暴露「ばくろ」、開拓「かいたく」、日差し「ひざし」、慣習「かんしゅう」、殺菌「さっきん」、落胆「らくたん」、会心「かいしん」、寄与「きよ」、承諾「しょうだく」、拠り所「よりどころ」、忍耐「にんたい」、大義「だいぎ」、贖罪「しょくざい」、倦怠「けんたい」、戒律「かいりつ」、途方「とほう」、土台「どだい」、分離「ぶんり」、卑怯「ひきょう」、下着「したぎ」、由緒「ゆいしょ」、珍重「ちんちょう」、奉公「ほうこう」、挙式「きょしき」、戦争「せんそう」、基「もとい」、乱発「らんぱつ」、零落「れいらく」、上映「じょうえい」、カオス、座敷「ざしき」、領域「りょういき」、碌「ろく」、内向「ないこう」、一命「いちめい」、贔屓「ひいき」、処分「しょぶん」、潤沢「じゅんたく」、流行「りゅうこう」、息吹「いぶき」、獲物「えもの」、妙「みょう」、幕府「ばくふ」、重荷「おもに」、道連れ「みちずれ」、高潔「こうけつ」、厳正「げんせい」、薬酒「やくしゅ」、気晴らし「きばらし」、報知「ほうち」、悪ふざけ「わるふざけ」、恍惚「こうこつ」、妥協「だきょう」、不思議「ふしぎ」、節目「ふしめ」、ニュアンス、</p><h2 id="3-形容詞"><a href="#3-形容詞" class="headerlink" title="3. 形容詞"></a>3. 形容詞</h2><p>鋭い「するどい」、甚だしい「はなはだしい」、朗らか「ほがらか」、等しい「ひとしい」、素っ気無い「そっけない」、雄大「ゆうだい」、騒がしい「さわがしい」、ぶかぶか「ぶかぶか」、逞しい「たくましい」、所謂「いわゆる」、緩やか「ゆるやか」、惨め「みじめ」、煌々「こうこう」、滑らか「なめらか」、無茶苦茶「むちゃくちゃ」、微か「かすか」、きまぐれ「きまぐれ」、目覚ましい「めざましい」、物足りない「ものたりない」、つれない、申し分ない「もうしぶんない」、べたべた、忌まわしい「いまわしい」、煩わしい「わずらわしい」、頼もしい「たのもしい」、気障「きざ」、切ない「せつない」、密接「みっせつ」、冥冥「めいめい」、見苦しい「みぐるしい」、あっかない、飛び飛び「とびとび」、達観「たっかん」、うざい、閑静「かんせい」、台無し「だいなし」、望ましい「のぞましい」、細やか「ささやか」、淑やか「しとやか」、真面「まとも」、煌々「こうこう」、淡々「たんたん」、厳密「げんみつ」、出しゃばり「でしゃばり」、刺々しい「とげとげしい」、厳か「おごそか」、乏しい「とぼしい」、疎ら「まばら」、慌ただしい「あわただしい」、待ち遠しい「まちどおしい」、疎か「疎か」、和やか「なごやか」、漠然「ばくぜん」、もどかしい、腹立たしい「はらだたしい」、怪しい「あやしい」、呆気ない「あっけない」、仄か「ほのか」、華やか「はなやか」、特異「とくい」、喧しい「やかましい」、無闇「むやみ」、鬱陶しい「うっとうしい」、おっちょこちょい、卑しい「いやしい」、速やか「すみやか」、浅ましい「あさましい」、勇ましい「いさましい」、穏やか「おだやか」、風情「ふぜい」、あくどい、虚しい「むなしい」、潔い「いさぎよい」、健やか「すこやか」、歴然「れきぜん」、悩ましい「なやましい」、画一的「かくいつてき」、広大「こうだい」、紛らわしい「まぎらわしい」、図々しい「ずうずうしい」、夥しい「おびただしい」、呆然「ぼうぜん」、しなやか、在り来り「ありきたり」、頑な「かたくな」、手薄「てうす」、目まぐるしい「めまぐるしい」、素直「すなお」、粘り強い「ねばりずよい」、容易い「たやすい」、爽やか「さわやか」、清々しい「すがすがしい」、柔い「やわい」、不備「ふび」、強か「したたか」、心地よい「ここちよい」、凄まじい「すさまじい」、紛れる「まぎれる」、弱い「よわい」、幅広い「はばひろい」、克明「こくめい」、重厚「じゅうこう」、端的「たんてき」、顕著「けんちょ」、分厚い「ぶあつい」、淡い「あわい」、密か「ひそか」、閑静「かんせい」、肝心「かんじん」、あり得ない「ありえない」、愕然「がくぜん」、口惜しい「くちおしい」、手ごろ「てごろ」、朗らか「ほがらか」、あやふや、立派「りっぱ」、だらしない、</p><h2 id="4-副詞"><a href="#4-副詞" class="headerlink" title="4. 副詞"></a>4. 副詞</h2><p>ぶらぶら、こそこそ、じろじろ、たっぷり、はらはら、がさがさ、がっしり、がやがや、さっぱり、しみじみ、のんびり、ゆったり、すやすや、ぎょうぎょう、めらめら、そっと、益々「ますます」、すらすら、尚更「なおさら」、ちらほら、いよいよ、めちゃくちゃ、ひんやり、ドキドキ、伸び伸び「のびのび」、にこにこ、ぞろぞろ、もやもや、ひっそり、そわそわ、ひょっとして、のっそり、とにかく、わくわく、うっかり、ごろごろ、めそめそ、ぞっと、僅か「わずか」、どっしり、ぐったり、嘸「さぞ」、いやいや、ちょいちょい、如何「いかん」、しっかり、ひたすら、予め「あらかじめ」、差し当たって、からから、ヘラヘラ、ぐっすり、ぐるぐる、のんびり、ひらひら、如何にも「いかにも」、ぼんやり、がっかり、ズルズル、偶々「たまたま」、きっちり、しっとり、元来「がんらい」、あっさり、びっくり、うっとり、丸ごと「まるごと」、すっかり、直に「じかに」、頻りに「しきりに」、バッチリ、ぎっしり、あたかも、すかすか、せっかく、きっかり、最早「もはや」、因みに「ちなみに」、こっそり、悠々「ゆうゆう」、ぼろぼろ、ハキハキ、ぺこぺこ、ふっくら、さっさと、にっこり、ギリギリ、すくすく、じめじめ、果たして「はたして」、至って「いたって」、敢えて「あえて」、からっと、いっそ、ぬるぬる、せめて、隈なく「くまなく」、とっくに、ぎっしり、くよくよ、悉く「ことごとく」、いとも、自ずと「おのずと」、ぐらぐら、ぶらぶら、猛然「もうぜん」、ぼうっと、てきぱき、俄かに「にわかに」、正しく「まさしく」、予々「かねがね」、ふんわり、どうやら、うんざり、不意に「ふいに」、改めて「あらためて」、辛うじて「かろうじて」、急遽「きゅうきょ」、丸で「まるで」、めきめき、随時「ずいじ」、即刻「そっこく」、へとへと、ざっと、しんなり、若干「じゃっかん」、一先ず「ひとまず」、すんなり、無性に「むしょうに」、さらさら、ちらっと、強いて「しいて」、何となく「なんとなく」、取り分け「とりわけ」、且つ「かつ」、はっきり、逐一「ちくいち」、言わば「いわば」、少しずつ「すこしずつ」、どんどん、ちやほや、全く「まったく」、些か「いささか」</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年8月东大情理CS算法题解读</title>
    <link href="/2024/09/15/UTO-DSA-2021-8/"/>
    <url>/2024/09/15/UTO-DSA-2021-8/</url>
    
    <content type="html"><![CDATA[<h1 id="Author-偷偷"><a href="#Author-偷偷" class="headerlink" title="Author: 偷偷  "></a><center>Author: 偷偷  </center></h1><h1 id="尊重原创，偷偷wx-LifeGoesOn-Rio"><a href="#尊重原创，偷偷wx-LifeGoesOn-Rio" class="headerlink" title="尊重原创，偷偷wx:LifeGoesOn_Rio  "></a><center>尊重原创，偷偷wx:LifeGoesOn_Rio  </center></h1><div class="note note-success">            <p>这道题的场景是实现一个排序算法，目的是优化时间复杂度。题目的策略是使用分治递归(Divide &amp; Conquer),在深度理解题目的场景下可以解决这道题目。</p>          </div><p>Firstly, read the pseudocode.</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// return the least value that is >= kl/m</span><span class="token keyword">int</span> <span class="token function">multfrac</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// *q &lt;= *p</span><span class="token keyword">void</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">></span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>        <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>        <span class="token operator">*</span>q <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// sort in ascending order</span><span class="token keyword">void</span> <span class="token function">mysort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>  <span class="token comment">// number of elements</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">/** fill in the  blanks **/</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>(1) 当k &lt; 4, 即元素个数小于4时做升序排序，分类讨论即可。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>   <span class="token comment">// 元素个数不多于1时，不做任何处理</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 比较交换一次</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">compare_swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token comment">// 依次比较三次</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>算法详细过程如下：<br><img src="/img/DSA/swap_compare.jpg" alt="交换流程演示" style="max-width: 100%; height: auto;" /></p><p>(2) </p><p>$$<br>T(n)&#x3D;<br>\begin{cases}<br>1,\quad n\leq 3 \\<br>n^{\log_{4&#x2F;3}{3}}, \quad n&gt;3<br>\end{cases}<br>$$</p><p>这里也是分类讨论：</p><p>当n &lt;&#x3D; 3时，比较次数不随输入规模变化，因此为1；</p><p>当n &gt; 3时，代入分析：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> x<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort后3/4规模的数组</span><span class="token function">mysort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token function">multfrac</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> z<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// sort前3/4规模的数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><img src="/img/DSA/swap_compare2.jpg" alt="递归树演示" style="max-width: 100%; height: auto;" /><p>根据递归树可以写出主定理公式(Master theorem):<br>$$T(n) &#x3D; 3T(3n&#x2F;4) + O(n) $$<br>根据套路：这里b &#x3D; 4&#x2F;3, a &#x3D; 3.<br>$$O(n ^{\log_{b}{a}}) &#x3D; O(n^{log_{4&#x2F;3}{3}}) &gt; O(n) $$<br>所以有<br>$$T(n) &#x3D; O(n^{\log_{4&#x2F;3}{3}})$$</p><p>(3) (4, 2, 3, 3), (4, 3, 2, 3), (4, 3, 3, 2) can always work properly. (4, 2, 3, 2) can’t always work properly.</p><blockquote><p>可以看下图演示：前两次的sort调用的交集部分是排好数组最大的部分，第三次sort调用要覆盖剩余没有排好的部分；对于(4, 2, 3, 2), 前两次调用排好了数组最大的1&#x2F;4部分，所以第三次调用至少要覆盖数组前3&#x2F;4的大小，而第三次调用只覆盖了前1&#x2F;2，所以这个组合不行。</p></blockquote><img src="/img/DSA/swap_compare3.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>(4)<br>$$<br>\begin{cases}<br>    x + y &gt; w \\<br>    x + y + z &gt;&#x3D; 2w<br>\end{cases}<br>$$</p><blockquote><p>在解决第三题后，第四题就非常容易了。</p></blockquote><img src="/img/DSA/swap_compare4.jpg" alt="排序演示" style="max-width: 100%; height: auto;" /><p>视数组的大小为1，第一次调用排好前x&#x2F;w部分的元素，第二次大小排好后y&#x2F;w部分的元素。所以排序需满足：</p><ol><li>前两次调用的范围必须要有交集</li><li>第三次调用必须要覆盖完前两次调用的没有排好的部分。因此有：<br>$$ x&#x2F; w + y &#x2F; w &gt; 1$$<br>$$ z &#x2F; w &gt;&#x3D;  1 - (x + y - w) &#x2F; w $$</li></ol>]]></content>
    
    
    <categories>
      
      <category>日本修考答案</category>
      
      <category>数据结构与算法</category>
      
      <category>东京大学情报理工</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
      <tag>东京大学</tag>
      
      <tag>修考答案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Structure &amp; Algorithms</title>
    <link href="/2024/09/10/DSA/"/>
    <url>/2024/09/10/DSA/</url>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure-Algorithms"><a href="#Data-Structure-Algorithms" class="headerlink" title="Data Structure &amp; Algorithms"></a>Data Structure &amp; Algorithms</h1><p>This is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(<strong>偷偷</strong>).The main language is in Chinese but you can see some concepts in English &amp; Japanese. And the pseudocode is in the style of <strong>C++</strong>. Let’s quickly review this subject!</p><p>这是偷偷刷了很多修考题之后总结出来的修考秘籍，全文都是考点，彻底高能。</p><h2 id="1-Introduction-to-Algorithms"><a href="#1-Introduction-to-Algorithms" class="headerlink" title="1. Introduction to Algorithms"></a>1. Introduction to Algorithms</h2><p>这一章主要计划复习<strong>时间复杂度(Time Complexity)</strong> 和 <strong>空间复杂度(Space Complexity)</strong> 两个概念，然后再仔细回顾 <strong>分治递归(DIvide &amp; Conquer)</strong> 这一重要的概念。最后再给出解决时间复杂度常用的分析方法和万能的<strong>主定理公式（Master Theorem）</strong></p><h3 id="1-1-时间复杂度与空间复杂度"><a href="#1-1-时间复杂度与空间复杂度" class="headerlink" title="1.1 时间复杂度与空间复杂度"></a>1.1 时间复杂度与空间复杂度</h3><div class="note note-success">            <p><strong>Space Complexity</strong>: 空间复杂度描述的是算法运行时所需的额外内存空间。通俗解释就是算法在运行的时候需要开辟多少空间的大小。O(1)指一个点集；O(n)就是开辟一个一维空间；O(n^2)开辟二维空间；O(n^3)开辟三维空间。在第二章讲解排序算法的时候，也会用到本章非常多的前置知识。</p>          </div><p>O(1): 常数空间复杂度，表示算法所需的额外空间是固定的，不随输入规模变化。例如，一个固定大小的变量。</p><p>O(n): 线性空间复杂度，表示算法所需的额外空间与输入规模成正比。例如，一个长度为 n 的数组。</p><p>O(n^2): 平方空间复杂度，表示算法所需的额外空间与输入规模的平方成正比。例如，一个 n x n 的二维数组。</p><p>O(n^3): 立方空间复杂度，表示算法所需的额外空间与输入规模的立方成正比。例如，一个 n x n x n 的三维数组。</p><p>一些常见的数据结构的空间复杂度：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> nums <span class="token comment">// 三维数组：O(n^3)</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> nums <span class="token comment">// 二维数组：O(n^2)</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>      <span class="token comment">// 栈：O(n)</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token comment">// 双端队列：O(n)</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> linkedList<span class="token punctuation">;</span>   <span class="token comment">// 链表：O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p><strong>Time complexity</strong>: 时间复杂度是衡量算法效率的重要指标之一，它描述了算法执行所需时间随输入规模增长的变化情况。这是修考中必考的一个地方：（1）如分析给出的代码的时间复杂度（Hint：关注for，while循环）（2）根据源代码优化时间复杂度设计新的算法（Hint：空间换时间）</p>          </div><p>常见的时间复杂度有以下几种：</p><p>O(1): <strong>常数时间复杂度</strong>，算法的执行时间不随输入规模变化。例如，访问数组中的某个元素。</p><p><code>int a = nums[10]  // 给a赋值数组下标为10的元素</code></p><p>O(n): <strong>线性时间复杂度</strong>，算法的执行时间与输入规模成正比。例如，遍历一个长度为 n 的数组。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; /* 操作 */ &#125;</code></p><p>O(log n): 对数时间复杂度，算法的执行时间随输入规模的对数增长。例如，二分查找(Binary Search)算法。</p><p><code>int binarySearch(int[] arr, int target) &#123; /* 二分查找逻辑 */ &#125;</code></p><p> O(n^2) : <strong>平方时间复杂度</strong>，算法的执行时间与输入规模的平方成正比。例如，冒泡排序(Bubble Sort)算法。</p><p><code>for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; /* 冒泡排序逻辑 */ &#125; &#125;</code></p><p>O(2^n): <strong>指数时间复杂度</strong>，算法的执行时间随输入规模的指数增长。例如，解决所有子集问题的递归算法。</p><p><code>void subsets(int[] nums) &#123; /* 递归逻辑 */ &#125;</code></p><p>在描述使劲复杂度的时候，有三种表示需要注意一下：</p><p>$O$: 表示渐进上界； $\Omega$: 表示渐进下界； $\Theta$: 渐进紧确界</p><h3 id="1-2-分治递归-Divide-Conquer"><a href="#1-2-分治递归-Divide-Conquer" class="headerlink" title="1.2 分治递归(Divide &amp; Conquer)"></a>1.2 分治递归(Divide &amp; Conquer)</h3><div class="note note-success">            <p>分治递归(Divide &amp; conquer)的思想是将原问题分割成更小的子问题，自顶向下地解决每个子问题，并最终自底向上合并它们的解来解决主问题。</p>          </div><p>常见的分治递归有：二分查找(Binary Search) 和归并排序(Merge Sort).</p><h4 id="1-2-1-二分查找-Binary-Search"><a href="#1-2-1-二分查找-Binary-Search" class="headerlink" title="1.2.1 二分查找(Binary Search)"></a>1.2.1 二分查找(Binary Search)</h4><img src="/img/DSA/binary_search.svg" alt="二分查找演示" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 前提nums是有序数组</span><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// (避免left + right) / 2 的溢出</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>   <span class="token comment">// 找到目标，返回索引</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 目标在左半部分</span>        <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 目标在右半部分</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>根据上图我们得出递归表达式：<br>$T(n) &#x3D; T(n &#x2F; 2) + O(1)$， 得出$T(n) &#x3D; O(log_{2}{n})$</p><h4 id="1-2-2-归并排序-Merge-Sort"><a href="#1-2-2-归并排序-Merge-Sort" class="headerlink" title="1.2.2 归并排序(Merge Sort)"></a>1.2.2 归并排序(Merge Sort)</h4><img src="/img/DSA/merge_sort.svg" alt="归并排序演示" style="max-width: 100%; height: auto;" />这个图像有效地展示了归并排序的"分而治之"策略： 1.将大问题（排序整个数组）分解成小问题（排序子数组） 2.解决小问题（对小数组排序） 3.将小问题的解合并成大问题的解（合并有序子数组）<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 合并两个有序的子数组</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子数组的长度</span>    <span class="token keyword">int</span> n2 <span class="token operator">=</span> right <span class="token operator">-</span> mid<span class="token punctuation">;</span>     <span class="token comment">// 右子数组的长度</span>    <span class="token comment">// 创建临时数组存储左右子数组</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftArr</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rightArr</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 复制数据到临时数组</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> rightArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token comment">// i是左子数组指针，j是右子数组指针，k是合并后数组的指针</span>    <span class="token comment">// 合并左右子数组</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的左子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将剩余的右子数组元素加入nums</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        j<span class="token operator">++</span><span class="token punctuation">;</span>        k<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 递归实现归并排序</span><span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 递归排序左右两部分</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 合并已排序的部分</span>        <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>递归式：$T(n) &#x3D; 2T(n &#x2F; 2) + O(n)$, 所以$T(n) &#x3D; O(nlog_{2}{n})$</p><h3 id="1-3-主定理-Master-Theorem"><a href="#1-3-主定理-Master-Theorem" class="headerlink" title="1.3 主定理(Master Theorem)"></a>1.3 主定理(Master Theorem)</h3><p>递归方程形式如：<br>$$T(n) &#x3D; aT(n &#x2F; b) + O(n^d)$$</p><div class="note note-success">            <p>其中，$a$表示子问题的数量，b表示每个子问题是原问题规模的$1&#x2F;b$, $O(n^d)$ 表示在每一层分治过程之外，解决问题所需的额外代价，通常是合并或分割的代价。</p>          </div><p><strong>情况 1：</strong><br>如果$log_{b}{a} &gt; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(\log_{b}{a}) $$</p><p><strong>解释：</strong> 在这种情况下，分治产生的子问题数量增长得更快，主导时间复杂度的是递归中的分治部分。</p><p><strong>情况 2：</strong><br>如果$log_{b}{a} &#x3D; d$，则递归式的解为：</p><p>$$ T(n) &#x3D; O(n^d\log{n}) $$</p><p><strong>解释：</strong> 在这种情况下，分治和额外开销的增长速度相同，因此总的时间复杂度是 $n^d\log{n}$。</p><p><strong>情况 3：</strong><br>如果 $log_{b}{a} &lt; d$，则递归式的解为：<br>$$T(n) &#x3D; O(n^d)$$<br><strong>解释：</strong> 在这种情况下，额外的开销主导时间复杂度，因此复杂度主要由 $n^d$决定。</p><p><strong>斯特林近似公式（Stirling’s Formula）:</strong> $n! \approx \sqrt{2 \pi n} \left( \frac{n}{e} \right)^n$</p><h2 id="2-Sorting-Algorithm"><a href="#2-Sorting-Algorithm" class="headerlink" title="2.Sorting Algorithm"></a>2.Sorting Algorithm</h2><p>再时间复杂度和空间复杂度的概念后，并引入了分治递归和归并排序算法；接下来这一章就主要回顾常见的一些排序算法，然后分析他们的时间复杂度和空间复杂度。</p><h3 id="2-1-插入排序-Insertion-Sort"><a href="#2-1-插入排序-Insertion-Sort" class="headerlink" title="2.1 插入排序(Insertion Sort)"></a>2.1 <strong>插入排序(Insertion Sort)</strong></h3><p>这个算法的过程也很直观：插入排序的核心思想是将一个新元素插入到已经排好序的子序列中的适当位置。<br><img src="/img/DSA/insertation_sort.svg" alt="插入排序演示" style="max-width: 100%; height: auto;" /><br>最好的情况下是：原数组规模小或者大部分数据有序，那么我们一次遍历就可以完成好排序。 最坏的情况下是：原数组是降序排列的，意思是每一次插入新元素的时候，都要遍历一遍已排好序的子数组。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 从第二个元素开始</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 回溯检查并交换</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>最坏情况：$T(n) &#x3D; T(n - 1) + O(n)$,  $T(n) &#x3D; O(n^2)$</p><p>最好情况：$T(n) &#x3D; T(n - 1) + O(1)$,  $T(n) &#x3D; O(n)$</p><h3 id="2-2冒泡排序-Bubble-Sort"><a href="#2-2冒泡排序-Bubble-Sort" class="headerlink" title="2.2冒泡排序(Bubble Sort)"></a>2.2冒泡排序(Bubble Sort)</h3><p>冒泡排序是一个直观的算法，通过重复地遍历数组来工作。在每次遍历中，它比较相邻的元素并在需要时交换它们，这样每次迭代都会将当前未排序部分中的最大元素’冒泡’到数组的末尾正确位置。这个过程从左到右重复进行，直到整个数组排序完成。一句话概括就是：不断的进行两两比较。<br><img src="/img/DSA/bubble_sort.svg" alt="冒泡排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 控制循环的轮数</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 内层循环，相邻比较</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 交换元素</span>                std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>冒泡排序平均时间复杂度</strong>：$T(n) &#x3D; O(n^2)$</p><h3 id="2-3选择排序-Selection-Sort"><a href="#2-3选择排序-Selection-Sort" class="headerlink" title="2.3选择排序(Selection Sort)"></a>2.3选择排序(Selection Sort)</h3><p>选择排序的基本思想是分阶段地将数组划分为两部分：已排序部分和未排序部分。每一轮从未排序部分中找到最小（或最大）的元素，放到已排序部分的末尾，直到整个数组排序完成。<br><img src="/img/DSA/selection_sort.svg" alt="选择排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 已排序数组末尾</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">// 找未排序数组中的最小元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIdx <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>选择排序时间复杂度：</strong> $T(n) &#x3D; O(n^2)$</p><h3 id="2-4快速排序-Quick-Sort"><a href="#2-4快速排序-Quick-Sort" class="headerlink" title="2.4快速排序(Quick Sort)"></a>2.4快速排序(Quick Sort)</h3><p>快速排序的本质是分治法。它通过选择一个基准元素，将原数组划分为小于基准元素和大于基准元素的两个子数组，然后对这两个子数组进行递归排序。<br><img src="/img/DSA/quick_sort.svg" alt="快速排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分区函数</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 选择最后一个元素作为基准</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 小于基准的元素的索引</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果当前元素小于或等于基准</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 增加小于基准的元素索引</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 快速排序函数</span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// pi是分区索引，arr[pi]现在在正确的位置</span>        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 分别对左右子数组进行递归排序</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在最坏情况下，基准元素可能是最大或最小值，这会导致一个子数组为空，另一个子数组的大小为 $n-1$，此时的时间复杂度为 $T(n) &#x3D; T(n-1) + O(n) &#x3D;O(n^2)$。而在平均情况下，基准元素能够较好地划分数组，时间复杂度为 $T(n) &#x3D; 2T(n&#x2F;2) + O(n)&#x3D;O(n\log{n})$ 。</p><h3 id="2-5堆排序-Heap-Sort"><a href="#2-5堆排序-Heap-Sort" class="headerlink" title="2.5堆排序(Heap Sort)"></a>2.5堆排序(Heap Sort)</h3><p>这个考点应该是修考最爱考的一个了！（敲重点）堆排序的基本思想是不断维护一个最大堆。在每次排序过程中，首先将最大堆的根节点（最大值）与堆的最后一个元素交换，然后缩小堆的范围（排除最后一个元素），并对新的根节点进行下沉操作，以恢复最大堆的性质。重复这一过程，直到所有元素都被排序。<br><img src="/img/DSA/heap_sort.svg" alt="堆排序演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 堆化函数，用于维护最大堆性质</span><span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 初始化最大值为根</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子节点</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 右子节点</span>    <span class="token comment">// 如果左子节点大于根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token comment">// 如果右子节点大于当前最大值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token comment">// 如果最大值不是根</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 递归地堆化受影响的子树</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 堆排序函数</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 构建最大堆（从最后一个非叶子节点开始）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 一个个从堆顶取出元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 将当前根移到末尾</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 在减小的堆上调用 max heapify</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>建堆的时间复杂度为$O(n)$,每个节点的调整最多为$O(\log{n})$次。在排序的过程中需要建堆$O(n)$次，并且每次需要$O(logn)$来维护堆(heapify),因此对排序总的时间复杂度为$O(n\log{n})$</p><h2 id="3-Data-Structure"><a href="#3-Data-Structure" class="headerlink" title="3.Data Structure"></a>3.Data Structure</h2><p>这一章主要讲解常见的数据结构,如栈(stack),队列(queue),链表(linked list),哈希表(hash map),以及字符串(string)。二叉树考点众多我会单独做成一章并且和图算法一块复习。</p><h3 id="3-1-Stack-Queue"><a href="#3-1-Stack-Queue" class="headerlink" title="3.1 Stack &amp; Queue"></a>3.1 Stack &amp; Queue</h3><p><strong>栈(stack)</strong> :后进先出(LIFO), <strong>队列</strong> :先进先出(FIFO)。另外，栈和队列是可以相互实现的，了解到这个程度，我认为就掌握到栈和队列的基本性质了。</p><p><em>Q1: 如何用栈实现队列？</em></p><div class="note note-success">            <p>A: 开两个栈，一个负责栈负责放入元素，另一个栈负责弹出元素</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个栈负责放入元素，一个栈负责弹出元素</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>      <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟入队过程</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 模拟弹出队首元素过程</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取队首元素的值</span>    <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 获取队首元素的值</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 放回</span>        out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><em>Q2：如何用队列实现栈？</em></p><div class="note note-success">            <p>A：开两个队列，一个模拟入栈，一个模拟出栈。更优化的方式是直接开一个队列即可,不断的出队入队就可以实现栈的性质。</p>          </div><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 一个队列负责入栈，一个负责出栈</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 把in队列的元素不断出队只剩一个，即时栈顶</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶的元素</span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取弹出后的值</span>        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 再放入队列</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>优化后的实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 放入元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 弹出栈顶元素</span>    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      n<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 把对位元素调整到队首</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取栈顶元素  </span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> ans<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">// 判断队列是否为空</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="3-2-Linked-List"><a href="#3-2-Linked-List" class="headerlink" title="3.2 Linked List"></a>3.2 Linked List</h3><p>常见的链表有单链表和双链表。<em>单链表</em>：每个节点只包含一个指向下一个节点的指针，访问节点时只能从头节点开始向后遍历。<em>双链表</em>：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。这使得可以在链表中向前和向后遍历。<br><img src="/img/DSA/linkedlist.svg" alt="链表演示" style="max-width: 100%; height: auto;" /></p><p><strong>链表的优缺点</strong></p><p><em>优点</em>：1)动态大小：链表的大小可以动态调整，不像数组那样需要预先定义大小。2)方便插入和删除：在链表中插入或删除节点的时间复杂度为 O(1)，只需调整指针，而数组则可能需要移动大量元素。</p><p><em>缺点</em>：1)内存占用：每个节点需要额外的存储空间来存储指针，导致比数组更高的内存开销。2)随机访问困难：链表不支持快速随机访问，查找元素的时间复杂度为 O(n)。</p><h3 id="3-3-Hash-Map"><a href="#3-3-Hash-Map" class="headerlink" title="3.3 Hash Map"></a>3.3 Hash Map</h3><p><strong>哈希映射（Hash Map）</strong> 是一种数据结构，用于以键值对（key-value pairs）形式存储数据。它通过一个哈希函数将键映射到数组中的索引，从而实现快速的数据访问。主要特点有：</p><p>1）快速查找：平均情况下，哈希映射可以在 O(1) 时间内进行查找、插入和删除操作。</p><p>2）键值对存储：每个元素都由一个唯一的键和与之关联的值组成，可以通过键快速访问对应的值。</p><p>3）哈希函数：将键转换为数组索引的函数，好的哈希函数可以减少冲突（不同键映射到相同索引）。</p><p>4）处理冲突：常用的方法包括<strong>链式法(chaining)<strong>和</strong>开放寻址法（open addressing）</strong>。<br><img src="/img/DSA/hash.svg" alt="哈希表处理冲突演示" style="max-width: 100%; height: auto;" /></p><p>为了减少哈希冲突，哈希映射的函数要尽量将不同的输入键均匀地映射到哈希表的不同索引，以减少冲突（即不同键映射到相同索引的情况）。</p><h3 id="3-4-String"><a href="#3-4-String" class="headerlink" title="3.4 String"></a>3.4 String</h3><p>字符串这个数据结构直观易懂，主要涉及到的考点有KMP算法和sequence alignment算法。这里主要回顾一下KMP算法，关于string类型的其他考点：最长子序列问题和序列比对(Sequence Alignment)，会在后面动态规划章节中仔细讲解。</p><h4 id="3-4-1-KMP算法"><a href="#3-4-1-KMP算法" class="headerlink" title="3.4.1 KMP算法"></a>3.4.1 KMP算法</h4><p>KMP算法可以说是学一次忘一次……建议考前一定要临时报佛脚记一下。这个算法的美妙之处就是在于优化了暴力匹配，用前缀表来跳过重复的匹配过程。前缀表就是模式串中每个位置的最长相等前缀和后缀的长度。在发生不匹配的情况下，将子串移动前一个字符串的前缀表的具体值。（感觉京大最喜欢考KMP算法了）<br><img src="/img/DSA/KMP.svg" alt="KMP算法演示" style="max-width: 100%; height: auto;" /></p><p><strong>🔹1. 什么是 <code>next</code> 数组？</strong></p><p>对于一个模式串 <code>pattern</code>，<code>next[i]</code> 表示：<strong>当 <code>pattern[i]</code> 失配时，下一步应该跳转到的位置</strong>（也就是前缀和后缀最长相等的长度）。</p><p>更具体地说：<code>next[i]</code> 是 <code>pattern[0:i]</code>（不包括 <code>pattern[i]</code>）的<strong>最长相等前后缀的长度</strong>。</p><p><strong>🔹2. 示例：构建 <code>next</code> 数组</strong></p><p>以字符串 <code>pattern = &quot;ababaca&quot;</code> 为例，构建 <code>next</code> 数组如下：</p><table><thead><tr><th>i（位置）</th><th>pattern[i]</th><th>next[i]</th><th>前缀-后缀说明</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>0</td><td>没有前缀和后缀</td></tr><tr><td>1</td><td>b</td><td>0</td><td>“a” 没有前后缀相等</td></tr><tr><td>2</td><td>a</td><td>1</td><td>“ab” 前缀 a，后缀 a，相等</td></tr><tr><td>3</td><td>b</td><td>2</td><td>“aba” 前缀 ab，后缀 ab，相等</td></tr><tr><td>4</td><td>a</td><td>3</td><td>“abab” 前缀 aba，后缀 aba，相等</td></tr><tr><td>5</td><td>c</td><td>0</td><td>“ababa” 前后缀都不同</td></tr><tr><td>6</td><td>a</td><td>1</td><td>“ababac” 前缀 a，后缀 a，相等</td></tr></tbody></table><p>所以最终的 <code>next</code> 数组为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">next = [0, 0, 1, 2, 3, 0, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p><strong>🔹3. 如何计算 next 数组？（Python 伪代码）</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_next</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token builtin">next</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n    j <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 前缀末尾指针</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 回退</span>        <span class="token keyword">if</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token builtin">next</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j    <span class="token keyword">return</span> <span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>🔹4. 小结</strong></p><ul><li><code>next[i]</code> 表示：在第 i 位字符匹配失败后，模式串应跳转的位置。</li><li>它避免了主串的重复回溯，使得 KMP 算法的时间复杂度为：<figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">O(n + m)  # n 是主串长度，m 是模式串长度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul><p>KMP（Knuth-Morris-Pratt）算法其核心思想是：当出现不匹配时，<strong>利用已经匹配的信息来避免重复匹配</strong>，通过 <code>next</code> 数组（也称为部分匹配表）加快匹配速度。</p><p>📌 已知条件</p><ul><li>文本串 <code>text</code>，长度为 <code>n</code></li><li>模式串 <code>pattern</code>，长度为 <code>m</code></li><li>已知 <code>next</code> 数组为 <code>next[0..m-1]</code></li></ul><p>🔁 主循环匹配逻辑</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># text 指针</span>j <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># pattern 指针</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>    <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">or</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>        i <span class="token operator">+=</span> <span class="token number">1</span>        j <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        j <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>🔍 匹配过程说明</p><ul><li><p><strong>初始设置</strong>：</p><ul><li><code>i = 0</code>, <code>j = 0</code>（或者 <code>j = -1</code>，视 <code>next</code> 数组实现方式）</li></ul></li><li><p><strong>匹配成功</strong>：</p><ul><li>如果 <code>text[i] == pattern[j]</code>，则：<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">+=</span> <span class="token number">1</span>j <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li></ul></li><li><p><strong>匹配失败</strong>：</p><ul><li>如果 <code>text[i] != pattern[j]</code>，则：<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">j <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token comment"># 不回退 i</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul></li><li><p><strong>匹配完成</strong>：</p><ul><li>如果 <code>j == m</code>，说明匹配成功，匹配位置为：<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">-</span> m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li></ul></li></ul><p>✅ 示例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">text    <span class="token operator">=</span> <span class="token string">"ababcabcacbab"</span>pattern <span class="token operator">=</span> <span class="token string">"abcac"</span><span class="token builtin">next</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>匹配过程如下：</p><table><thead><tr><th>i (text)</th><th>j (pattern)</th><th>text[i]</th><th>pattern[j]</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>a</td><td>a</td><td>匹配，i++, j++</td></tr><tr><td>1</td><td>1</td><td>b</td><td>b</td><td>匹配，i++, j++</td></tr><tr><td>2</td><td>2</td><td>a</td><td>c</td><td>不匹配，j &#x3D; 0</td></tr><tr><td>2</td><td>0</td><td>a</td><td>a</td><td>匹配，i++, j++</td></tr><tr><td>3</td><td>1</td><td>b</td><td>b</td><td>匹配，i++, j++</td></tr><tr><td>4</td><td>2</td><td>c</td><td>c</td><td>匹配，i++, j++</td></tr><tr><td>5</td><td>3</td><td>a</td><td>a</td><td>匹配，i++, j++</td></tr><tr><td>6</td><td>4</td><td>b</td><td>c</td><td>不匹配，j &#x3D; 2</td></tr><tr><td>6</td><td>2</td><td>b</td><td>c</td><td>不匹配，j &#x3D; 0</td></tr><tr><td>6</td><td>0</td><td>b</td><td>a</td><td>不匹配，j &#x3D; -1</td></tr><tr><td>6</td><td>-1</td><td>b</td><td>-</td><td>i++, j &#x3D; 0</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>继续匹配</td></tr></tbody></table><p>当 <code>j == 5</code> 时，表示匹配成功。</p><p>✅ 总结</p><ul><li>利用 next 数组可以避免暴力回溯，提高效率。</li></ul><p>⏱️ 时间复杂度</p><ul><li>构造 next 数组：O(m)</li><li>匹配过程：O(n)</li><li>总体时间复杂度：O(n + m)</li></ul><h2 id="4-Binary-Tree"><a href="#4-Binary-Tree" class="headerlink" title="4.Binary Tree"></a>4.Binary Tree</h2><p>关于二叉树的考点有许多，像是考二叉树的遍历，二叉搜索树（Binary Search Tree），最小生成树（MST），以及AVL树。首先需要了解二叉树的一些基本性质，例如每个节点的下标，以及二叉树的多种遍历方式。</p><h3 id="4-1-Concepts-of-Binary-Tree"><a href="#4-1-Concepts-of-Binary-Tree" class="headerlink" title="4.1 Concepts of Binary Tree"></a>4.1 Concepts of Binary Tree</h3><img src="/img/DSA/binary_tree.svg" alt="常见的二叉树" style="max-width: 100%; height: auto;" /><p><strong>完全二叉树（complete binary tree）</strong>：是一种二叉树，其中每一层都是满的，除了可能是最后一层，且最后一层的节点从左到右排列。在完全二叉树中，所有的节点都尽可能地靠左排列，这种结构使得它在存储和操作上更为高效。与全二叉树不同，完全二叉树允许最后一层不满，但仍需保持左侧填充。</p><p>对于一个完全二叉树，如果节点的索引为$i$,节点数为$n$那么：</p><ol><li>左孩子节点索引: $2i$</li><li>右孩子节点索引: $2i + 1$</li><li>父亲节点索引: $[i&#x2F;2]$  </li><li>二叉树高度: $ceil(log_{2}{(n+1)})$ 或 $floor(log_{2}{n}) + 1$</li></ol><p><strong>全二叉树（full binary tree）</strong>：是指每个节点要么没有子节点，要么恰好有两个子节点的二叉树。在这种树中，除了叶子节点外，所有节点都有两个子节点。这样的结构确保了树的每一层都被完全填满，只有最后一层可能不满。</p><p><strong>二叉搜索树（Binary Search Tree, BST）</strong>: 是一种二叉树，其中每个节点都包含一个键值，左子树的所有节点键值小于该节点，右子树的所有节点键值大于该节点。这种结构使得查找、插入和删除操作的平均时间复杂度为 O(log n)。其主要性质包括：每个节点最多有两个子节点，左子树和右子树都是二叉搜索树，且没有重复的键值。</p><p>二叉搜索树的搜索迭代实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">></span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="4-2-Tree-Traversal"><a href="#4-2-Tree-Traversal" class="headerlink" title="4.2 Tree Traversal"></a>4.2 Tree Traversal</h3><p><strong>层序遍历（Level Order Traversal）：</strong> 开一个队列处理一层的节点并放入下一层的节点。这个遍历也属于<strong>广度优先遍历（BFS）</strong>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">auto</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>二叉树的<strong>深度优先遍历（DFS）</strong> 可以分为三种：前序遍历，中序遍历和后序遍历。</p><p><strong>前序遍历（Preorder Traversal）：</strong>  <em>根-&gt;左-&gt;右</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然也可以开一个栈来实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>后序遍历（Postorder Traversal）：</strong>  <em>左-&gt;右-&gt;根</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>后序遍历同样可以开一个栈来实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                cur<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    cur<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>中序遍历（Inorder Traversal）：</strong>  <em>左-&gt;根-&gt;右</em>，递归实现</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>当然也可以开一个栈来实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            root <span class="token operator">=</span> root<span class="token operator">-></span> right<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>二叉树的中序遍历还有一个重要的考点是<em>逆波兰表达式</em>,这个曾经在京大的过去问中出现过。<strong>逆波兰表达式（Reverse Polish Notation, RPN）</strong> 是一种后缀表示法，用于表示算术表达式。在这种表示法中，运算符跟在操作数之后，而不是在它们之间。这种形式的好处是消除了括号的需要，因为操作的顺序总是由操作符的位置决定。具体的实现方法可以开一个栈轻松解决。<br><img src="/img/DSA/rpn.svg" alt="逆波兰表达式" style="max-width: 70%; height: auto;" /></p><h3 id="4-3-AVL-Tree"><a href="#4-3-AVL-Tree" class="headerlink" title="4.3 AVL Tree"></a>4.3 AVL Tree</h3><p><strong>AVL树</strong>是一种自平衡的二叉搜索树，确保每个节点的左右子树高度差（平衡因子）最多为1。这样可以保证树的高度在 $O(log{n})$ 范围内，确保高效的插入、删除和查找操作。AVL树通过旋转操作来维持平衡，从而优化性能，特别是在频繁修改的场景中。东工有一年考到了这个点，但我认为了解到AVL树的工作原理就ok了,主要聚焦在节点的添加和删除以及树的旋转。<br><img src="/img/DSA/avl_tree_insert.svg" alt="AVL树增加节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_delete.svg" alt="AVL树删除节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_rotate.svg" alt="AVL树左旋和右旋" style="max-width: 100%; height: auto;" /></p><h2 id="5-Graph-Theory"><a href="#5-Graph-Theory" class="headerlink" title="5.Graph Theory"></a>5.Graph Theory</h2><p>本章主要讲解图的基本算法，最小生成树，单源最短路径算法，单源最短路径算法和多源最短路径算法，以及最大流问题。修考题的图算法都是套的模版，因此了解算法的核心思想非常关键。</p><h3 id="5-1图的基本算法"><a href="#5-1图的基本算法" class="headerlink" title="5.1图的基本算法"></a>5.1图的基本算法</h3><p>对于图的表示，我们需要建立一个<strong>邻接矩阵(adjacency matrix)</strong>,简单图的邻接矩阵是(0,1)矩阵并且对角线元素都为0。无向图的邻接矩阵是对称矩阵。<br><img src="/img/DSA/adjacency_matrix.svg" alt="邻接矩阵" style="max-width: 100%; height: auto;" /></p><h4 id="5-1-1-BFS"><a href="#5-1-1-BFS" class="headerlink" title="5.1.1 BFS"></a>5.1.1 BFS</h4><p>在二叉树章节中讲解了树的深度遍历算法，在图中，我们可以同样的利用邻接链表（也就是建一个数组）来获取当前遍历的节点的邻接节点，开一个数组记录已访问的节点，最后利用队列实现层序遍历。<br><img src="/img/DSA/bfs.svg" alt="广度优先算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// BFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Create a queue for BFS</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> queue<span class="token punctuation">;</span>        <span class="token comment">// Mark the source node as visited and enqueue it</span>        visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// Dequeue a vertex from queue and print it</span>            s <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>            queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Get all adjacent vertices of the dequeued vertex s</span>            <span class="token comment">// If an adjacent has not been visited, then mark it visited</span>            <span class="token comment">// and enqueue it</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-1-2-DFS"><a href="#5-1-2-DFS" class="headerlink" title="5.1.2 DFS"></a>5.1.2 DFS</h4><p>DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索图形或树数据结构的算法。它尽可能深地访问节点，然后回溯，寻找未访问过的节点。</p><p><strong>基本原理：</strong></p><ol><li>初始化：从起始节点出发，将其标记为访问过。之后开始递归或使用栈</li><li><em>递归</em>：对每个未访问的邻接节点，递归调用DFS。（递归的实现方式就是利用栈来记录每一次函数调用的状态）<br><em>栈</em>：将节点压入栈中，访问节点时将其出栈，继续访问其未访问的邻接节点，并将这些邻接节点压入栈。</li><li><em>回溯</em>：如果当前节点的所有邻接节点都访问过，则回溯到上一个节点，继续这个过程，直到所有节点都访问完。<img src="/img/DSA/dfs.svg" alt="深度优先算法" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">&amp;</span>visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark the current node as visited and print it</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token comment">// Recur for all the vertices adjacent to this vertex</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// Function to add an edge to the graph</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// DFS traversal starting from given source vertex</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Mark all the vertices as not visited</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Call the recursive helper function to print DFS traversal</span>        <span class="token function">DFS</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><div class="note note-success">            <p>BFS和DFS对比非常鲜明。BFS的性格是保守，害怕风险，尽量做到“广撒网，细收鱼”；而DFS则是奔放，秉持着一颗“不撞南墙不回头”，“不到黄河不死心”的感觉。</p>          </div></li></ol><h4 id="5-1-3-Topological-Sort"><a href="#5-1-3-Topological-Sort" class="headerlink" title="5.1.3 Topological Sort"></a>5.1.3 Topological Sort</h4><p><strong>拓扑排序（Topological Sorting）</strong>是图论中的一种线性排序方法，主要用于对<strong>有向无环图（Directed Acyclic Graph, DAG</strong> 中的顶点进行排序，使得对于图中的每一条有向边 (u → v)，顶点 u 在排序中都出现在顶点 v 的前面。<br><img src="/img/DSA/topo_sort.svg" alt="拓扑排序算法" style="max-width: 100%; height: auto;" /><br><strong>拓扑排序算法步骤：</strong></p><ol><li>计算每个顶点的入度：统计每个顶点被其他顶点指向的次数（即入度, inDegree）。</li><li>将所有入度为 0 的顶点加入队列：这些顶点没有任何前置依赖。</li><li>重复以下步骤直到队列为空：（1）从队列中取出一个顶点 u，将其加入拓扑排序结果中。（2）遍历 u 的所有邻接顶点 v，将 v 的入度减 1；如果 v 的入度变为 0，则将 v 加入队列。</li><li>检查结果：如果所有顶点都被处理过，则返回拓扑排序；否则，图中有环，无法进行拓扑排序。</li></ol><p>在初始化时，需要遍历所有顶点计算入度，耗时$O(V)$；然后遍历所有边来更新入度并处理顶点，耗时$O(E)$。因此总的时间复杂度是$O(V + E)$。最终的排序顺序是: $1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7$。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span>  <span class="token comment">// 顶点数</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span>  <span class="token comment">// 邻接表</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inDegree<span class="token punctuation">;</span>  <span class="token comment">// 入度数组</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inDegree</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        <span class="token comment">// 将所有入度为0的顶点加入队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 对于所有相邻的顶点，将其入度减1</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 检查是否存在环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"图中存在环，无法进行拓扑排序"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-1-4-Union-Find"><a href="#5-1-4-Union-Find" class="headerlink" title="5.1.4 Union Find"></a>5.1.4 Union Find</h4><p><strong>并查集（Union-Find）</strong> 算法，又称为不相交集数据结构，是一种用于处理元素分组及查询元素所属组的高效数据结构。它广泛应用于图论（如判断图的连通性、<em>Kruskal算法</em>求最小生成树）并查集主要支持<strong>两种操作</strong>：</p><ol><li>查找（Find）：确定某个元素属于哪个集合（即找到该元素所在集合的代表元素或根节点）。</li><li>合并（Union）：将两个不同的集合合并为一个集合。</li></ol><p>为了提高并查集的效率，通常结合以下两种优化策略：</p><ol><li>路径压缩（Path Compression）：在 Find 操作中，将访问过的所有节点直接连接到根节点，从而降低树的高度。</li><li>按秩合并（Union by Rank）或按大小合并（Union by Size）：在 Union 操作中，总是将较小的树挂到较大的树下，保持树的平衡。</li></ol><p>结合这两种优化后，并查集的时间复杂度几乎接近于常数时间，具体为 反阿克曼函数 的时间复杂度，几乎可以认为是 $O(1)$。<br><img src="/img/DSA/union_find.svg" alt="并查集算法" style="max-width: 100%; height: auto;" /><br>以下是一个使用路径压缩和按秩合并优化的并查集实现：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 存储每个节点的父节点</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rank<span class="token punctuation">;</span>    <span class="token comment">// 存储每个节点的秩（树的高度）</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数：初始化每个节点的父节点为自身，秩为1</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        rank<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作：查找元素x所在集合的根节点，并进行路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 路径压缩</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作：将元素x和元素y所在的集合合并</span>    <span class="token keyword">void</span> <span class="token function">unionSets</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 已经在同一个集合中</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 按秩合并：将秩较小的树挂到秩较大的树下</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-2-Minimum-Spanning-Tree"><a href="#5-2-Minimum-Spanning-Tree" class="headerlink" title="5.2 Minimum Spanning Tree"></a>5.2 Minimum Spanning Tree</h3><p><strong>最小生成树（Minimum Spanning Tree, MST）</strong> 是指在一个带权无向图中，连接所有顶点的一个子图，使得：</p><ol><li>这个子图是一个树（即没有环，并且连通所有顶点）。</li><li>这个树的总边权和最小。</li></ol><p><strong>特点</strong>：</p><ol><li>最小生成树包含图中所有的顶点，但只包含连接这些顶点的最少数量的边（即 $V - 1$条边，$V$为顶点数）。</li><li>它保证生成的树的边权总和最小。</li></ol><p>常见的MST生成算法有2种：<em>Kruskal算法</em>和<em>Prim算法</em>。简单来说，Kruskal是基于边的选择，而Prim算法是从某个顶点开始构建最小生成树的，逐步扩展树的边界。</p><h4 id="5-2-1-Kruskal"><a href="#5-2-1-Kruskal" class="headerlink" title="5.2.1 Kruskal"></a>5.2.1 Kruskal</h4><p>具体步骤为：</p><ol><li>首先对所有边按权重从小到大排序。</li><li>然后依次利用<strong>并查集（Union Find）</strong>检查每条边的两个顶点是否属于不同的集合，如果是，则将它们合并，并将该边加入最小生成树。</li><li>重复这个过程，直到最小生成树中包含了$V−1$条边。</li></ol><p><strong>时间复杂度：</strong> 边排序耗时$O(ElogE)$，并查集操作近似为$O(1)$，因此总时间复杂度为$O(ElogE)$。<br><img src="/img/DSA/kruskal.svg" alt="Kruskal算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含起点、终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 比较函数，按照权重升序排序</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> weight <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 并查集（Union-Find）结构体</span><span class="token keyword">struct</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">,</span> rank<span class="token punctuation">;</span>    <span class="token comment">// 初始化并查集，所有节点的父节点初始化为自己，秩(rank)初始化为0</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找操作，使用路径压缩</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并操作，按秩合并</span>    <span class="token keyword">void</span> <span class="token function">unite</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> rootU <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rootV <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootU <span class="token operator">!=</span> rootV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">=</span> rootV<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>                rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Kruskal算法实现</span><span class="token keyword">int</span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 按权重升序排序所有边(至关重要的一环)</span>    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edges<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UnionFind <span class="token function">uf</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> edgesUsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已经加入生成树的边数</span>    <span class="token comment">// 遍历所有边</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 查找两个顶点是否属于不同的集合（不同的连通分量）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">)</span> <span class="token operator">!=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">,</span> edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将它们合并到同一个集合</span>            mstWeight <span class="token operator">+=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span> <span class="token comment">// 将这条边的权重加入总权重</span>            edgesUsed<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 如果已经加入V-1条边，生成树构建完毕</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>edgesUsed <span class="token operator">==</span> numVertices <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-2-2-Prim算法"><a href="#5-2-2-Prim算法" class="headerlink" title="5.2.2 Prim算法"></a>5.2.2 Prim算法</h4><p>Prim算法的基本思想是从一个顶点开始，逐步将与当前生成树相连的最小边加入到树中，直到包含图中所有顶点为止。不同于Kruskal算法选择的是边，Prim算法在每一步选择的是<em>与已连接的顶点相连的最小权重边</em>。</p><p>算法步骤：</p><ol><li>初始化：选择一个起始顶点，标记为生成树的一部分。<br>使用一个数组&#x2F;优先队列来记录所有尚未加入生成树的顶点到当前生成树的最小边的权重。</li><li>选择最小边：<br>在每一步中，从所有与生成树相连的边中选择权重最小的边（维护一个优先队列），确保这个边不会形成环。</li><li>更新距离：将选择的边的顶点加入生成树<u>并更新尚未加入树的顶点到新生成树的最小边的权重。</u></li><li>重复上述步骤，直到所有顶点都被加入生成树。</li></ol><p>对每条边的操作（插入、删除、更新最小边权重）是$O(logV)$的，因此总的时间复杂度为$O(ElogV)$，其中$E$是边的数量，$V$是顶点的数量。<br><img src="/img/DSA/prim.svg" alt="Prim算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含终点和权重</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// Prim算法的实现</span><span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 最小生成树的总权重</span>    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 标记每个顶点是否在生成树中</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">inMST</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 记录最小权重的边的权重，初始化为无穷大(敲重点)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">minEdgeWeight</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 优先队列（最小堆），存储&#123;边的权重，顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    <span class="token comment">// 从第0号顶点开始</span>    minEdgeWeight<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 取出权重最小的边</span>        <span class="token keyword">int</span> weight <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果顶点u已经在MST中，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 将顶点u加入MST</span>        inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        mstWeight <span class="token operator">+=</span> weight<span class="token punctuation">;</span>        <span class="token comment">// 更新与顶点u相连的其他顶点的最小边权重</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inMST<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">&lt;</span> minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>w<span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-3-单源最短路径算法"><a href="#5-3-单源最短路径算法" class="headerlink" title="5.3 单源最短路径算法"></a>5.3 单源最短路径算法</h3><p>单源最短路径算法（Single-Source Shortest Path, SSSP）用于从图中的一个指定起点（源点）出发，找到该点到图中所有其他顶点的最短路径。常用的单源路径算法为<strong>Dijkstra算法</strong>和<strong>Bellman-Ford算法</strong>。Dijkstra算法只能用于无负权边的图。如果图中存在负权边，Dijkstra算法的结果可能不正确。Bellman-Ford算法可以处理带负权边的图，且能够检测负权环（如果存在负权环，则说明不存在最短路径）。</p><h4 id="5-3-1-Dijkstra’s-algorithm"><a href="#5-3-1-Dijkstra’s-algorithm" class="headerlink" title="5.3.1 Dijkstra’s algorithm"></a>5.3.1 Dijkstra’s algorithm</h4><p><strong>Dijkstra算法</strong>的基本思想是：每次贪心地从当前未处理的顶点中选择一个距离源点最近的顶点，标记其最短路径为确定，然后通过该顶点更新其邻接点的最短路径。过反复选择距离最小的顶点，并更新邻接点的路径长度，最终能确定所有顶点的最短路</p><p><strong>时间复杂度</strong>：在使用优先队列（最小堆）的情况下，Dijkstra算法的时间复杂度为$O(ElogV)$，其中E是图中边的数量，V是顶点的数量。取出当前最小距离顶点的操作需要$O(logV)$时间。每条边被检查一次，更新时需要$O(logV)$的时间来调整优先队列。在稠密图中，算法的效率略低，因为每次更新都需要重新维护优先队列，但在稀疏图中性能良好。<br><img src="/img/DSA/dijkstra.svg" alt="Dijkstra算法" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 存储从源点到每个顶点的最短距离</span>    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 源点到自身的距离为0</span>        <span class="token comment">// 优先队列：最小堆，存储的是&#123;距离, 顶点编号&#125;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> source<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>  <span class="token comment">// 取出距离源点最近的顶点</span>        <span class="token keyword">int</span> d <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>   <span class="token comment">// 当前顶点的最短距离</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 如果当前距离已经不是最优解，跳过</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment">// 更新顶点 u 的邻接点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>            <span class="token keyword">int</span> weight <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>            <span class="token comment">// 如果通过 u 到 v 的路径更短，更新路径</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 v 插入优先队列</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h4 id="5-3-2-Bellman-Ford-Algorithm"><a href="#5-3-2-Bellman-Ford-Algorithm" class="headerlink" title="5.3.2 Bellman-Ford Algorithm"></a>5.3.2 Bellman-Ford Algorithm</h4><p><strong>Bellman-Ford算法</strong>是一种经典的算法，用于解决单源最短路径问题（Single Source Shortest Path, SSSP），即从图中的某个源点到其他所有顶点的最短路径。它与Dijkstra算法的不同之处在于，Bellman-Ford可以处理权值为负数的边，并且能够检测出图中是否存在负权环（negative-weight cycle）。</p><p>Bellman-Ford算法的核心思想是通过<strong>松弛（relaxation）</strong> 操作逐步更新每个顶点的最短路径估计值。松弛操作的含义是，如果从某条边可以得到比当前已知更短的路径，则更新路径长度。算法通过多次迭代更新路径，确保找到全局的最短路径。</p><p><strong>算法步骤：</strong></p><ol><li>初始化：将源点到源点的距离设为0（即$dist[source] &#x3D; 0$），其他所有顶点到源点的距离初始设为正无穷大（$dist[v] &#x3D; ∞$）。设定前驱节点为None或相应的初始值。</li><li>松弛所有边：对于图中的所有边$(u,v)$，检查是否可以通过$u$达到$v$的更短路径，即$dist[v] &gt; dist[u] + weight(u, v)$。如果是，则更新$dist[v] &#x3D; dist[u] + weight(u, v)$。重复这个过程最多$n−1$次，其中$n$是顶点的数量。因为最短路径最多包含$n−1$条边。</li><li>检测负权环（可选步骤）：在完成$n−1$次松弛操作后，再对所有边执行一次松弛操作。如果此时还能继续更新某个顶点的最短路径值，则说明图中存在负权环，因为在无负权环的情况下，经过$n−1$次松弛操作后，所有最短路径应该已经收敛。</li></ol><p>边的松弛操作需要对每条边执行，图中一共有𝑚条边。算法需要对所有边重复𝑛−1次（因为最短路径最多包含𝑛−1条边），因此时间复杂度为𝑂(𝑛⋅𝑚)</p><img src="/img/DSA/bellman_ford.svg" alt="松弛操作" style="max-width: 100%; height: auto;" /><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> Bellmanford算法伪代码function BellmanFord<span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> Step <span class="token number">1</span><span class="token punctuation">:</span> Initialize distances    <span class="token keyword">for</span> each vertex v <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> ∞  <span class="token operator">//</span> Set <span class="token builtin">all</span> distances to infinity        predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> null  <span class="token operator">//</span> No predecessors initially    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token operator">//</span> The distance <span class="token keyword">from</span> the source to itself <span class="token keyword">is</span> zero    <span class="token operator">//</span> Step <span class="token number">2</span><span class="token punctuation">:</span> Relax <span class="token builtin">all</span> edges n<span class="token operator">-</span><span class="token number">1</span> times    <span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">1</span> to <span class="token operator">|</span>V<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>            <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>                predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u    <span class="token operator">//</span> Step <span class="token number">3</span><span class="token punctuation">:</span> Check <span class="token keyword">for</span> negative<span class="token operator">-</span>weight cycles    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>        <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>            error <span class="token string">"Graph contains a negative-weight cycle"</span>        <span class="token keyword">return</span> dist<span class="token punctuation">,</span> predecessor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-4-多源最短路径算法"><a href="#5-4-多源最短路径算法" class="headerlink" title="5.4 多源最短路径算法"></a>5.4 多源最短路径算法</h3><h4 id="5-4-1-Floyd-Wallshall’s-Algorithm"><a href="#5-4-1-Floyd-Wallshall’s-Algorithm" class="headerlink" title="5.4.1 Floyd-Wallshall’s Algorithm"></a>5.4.1 Floyd-Wallshall’s Algorithm</h4><p><strong>Floyd-Warshall算法</strong> 是一种经典的动态规划算法，用于解决所有点对最短路径问题。它可以在加权图中找出每一对顶点之间的最短路径，<em>即使图中包含负权重边</em>，只要没有负权重环路（即从某个顶点出发经过一些边又回到该顶点且路径总权重为负）。<u>京大知能</u>的一年过去问就考了这道题的手动迭代推理，在复习这个题的时候建议和京大的过去问配合看。</p><p><strong>算法步骤：</strong></p><ol><li><p>初始化：将距离矩阵$dist[][]$初始化为图的邻接矩阵。如果$i &#x3D;&#x3D; j$，则$dist[i][j] &#x3D; 0$，表示从节点$i$到节点$j$的路径距离为$0$。如果$i ≠ j$且两点之间有边，则$dist[i][j] &#x3D; weight(i, j)$，否则$dist[i][j]设为∞$（表示两点不直接相连）。</p></li><li><p>动态规划：通过三重循环逐步更新每对顶点之间的最短距离。外层循环选取一个中间顶点$k$，中间两层循环更新每一对顶点$i$和$j$之间的最短路径，判断是否通过$k$可以得到更短的路径。如果$dist[i][k] + dist[k][j] &lt; dist[i][j]$，则更新$dist[i][j]$。公式为：</p><div style="text-align: center;">$$dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])$$</div></li></ol><p><strong>时间复杂度：</strong><br>Floyd-Warshall算法的时间复杂度为$O(V³)$，其中$V$是图中顶点的数量。三重嵌套循环的每一层都依赖于顶点的数量，因此该算法适合顶点较少的图。对于边多（稠密图）且顶点数量不多的情况，它是一个有效的算法。<br><img src="/img/DSA/floyd.svg" alt="Floyd算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">floydWarshall</span><span class="token punctuation">(</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储最短路径</span>    <span class="token comment">// 初始化距离矩阵，将其设为输入图的邻接矩阵</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 三重循环：i是起点，j是终点，k是中间节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 如果从i通过k到j的路径更短，则更新dist[i][j]</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span>                     dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-5-Maximum-FLow-Problem"><a href="#5-5-Maximum-FLow-Problem" class="headerlink" title="5.5 Maximum FLow Problem"></a>5.5 Maximum FLow Problem</h3><p><strong>最大流问题</strong>是网络流理论中的一个经典问题，旨在寻找在一个流网络（或称为容量网络）中，从源点到汇点的最大可能流量。这个问题可以应用于很多实际场景，比如交通网络、物流系统、通信网络等。</p><p><strong>最大流问题</strong>的定义：</p><ol><li><p>流网络：由顶点集和边集组成的有向图，其中每条边都有一个非负的容量，表示能通过该边的最大流量。这个网络中有一个特定的顶点被称为源点（source），另一个顶点称为汇点（sink）。</p></li><li><p>流量：从源点到汇点传输的流称为流量。流量需要遵守以下两个条件：</p></li><li><p>容量限制：每条边上的流量不能超过该边的容量。</p></li><li><p>流量守恒：除了源点和汇点，其他顶点的流入流量与流出流量相等。</p></li></ol><p>本章只讲解Ford-Fulkerson算法，有余力可以再了解一下Edmonds-Karp算法和Push-Relabel算法。</p><h4 id="5-5-1-Ford-Fulkerson-Algorithm"><a href="#5-5-1-Ford-Fulkerson-Algorithm" class="headerlink" title="5.5.1 Ford-Fulkerson Algorithm"></a>5.5.1 Ford-Fulkerson Algorithm</h4><p>福特-福尔克森算法的核心思想是利用增广路径（Augmenting Path）来增加网络中的流量。增广路径是指在残余网络（Residual Network）中，从源点到汇点的一条路径，且路径上的每条边都有剩余容量（Residual Capacity）大于零。算法通过反复寻找这样的路径，并沿路径增加流量，直到没有增广路径为止。<br><img src="/img/DSA/ford.svg" alt="Ford-Fulkerson算法演示" style="max-width: 100%; height: auto;" /><br><strong>初始状态：</strong></p><p>如图所示，所有边的初始流量都为 0。我们的目标是找到从源点 S 到汇点 T 的最大流。</p><p><strong>第一次迭代：</strong></p><ul><li><strong>a.</strong> 找一条增广路径，例如：S -&gt; A -&gt; C -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 5（A 到 C 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 0&#x2F;10 \rightarrow 5&#x2F;10 \\<br>A \to C: &amp;\ 0&#x2F;5 \rightarrow 5&#x2F;5 \\<br>C \to T: &amp;\ 0&#x2F;9 \rightarrow 5&#x2F;9<br>\end{aligned}<br>$$</li></ul><p><strong>第二次迭代：</strong></p><ul><li><strong>a.</strong> 找另一条增广路径，例如：S -&gt; B -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 6（D 到 T 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to B: &amp;\ 0&#x2F;8 \rightarrow 6&#x2F;8 \\<br>B \to D: &amp;\ 0&#x2F;7 \rightarrow 6&#x2F;7 \\<br>D \to T: &amp;\ 0&#x2F;6 \rightarrow 6&#x2F;6<br>\end{aligned}<br>$$</li></ul><p><strong>第三次迭代：</strong></p><ul><li><strong>a.</strong> 找下一条增广路径，例如：S -&gt; A -&gt; D -&gt; T</li><li><strong>b.</strong> 这条路径的瓶颈容量是 3（A 到 D 的边）</li><li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 5&#x2F;10 \rightarrow 8&#x2F;10 \\<br>A \to D: &amp;\ 0&#x2F;3 \rightarrow 3&#x2F;3 \\<br>D \to T: &amp;\ 6&#x2F;6 \text{（已满，无法增加）}<br>\end{aligned}<br>$$</li></ul><p><strong>算法终止：</strong><br>此时，我们无法找到从 S 到 T 的更多增广路径。所有通向 T 的边都已经满了：</p><ul><li>$C \to T: 5&#x2F;9$</li><li>$D \to T: 6&#x2F;6$</li></ul><p><strong>计算最大流：</strong><br>最大流等于从源点出发的所有流量之和：<br>$$<br>8\ (\text{S} \to \text{A}) + 6\ (\text{S} \to \text{B}) &#x3D; 14<br>$$<br>也等于进入汇点的所有流量之和：<br>$$<br>5\ (\text{C} \to \text{T}) + 6\ (\text{D} \to \text{T}) &#x3D; 11<br>$$</p><p><strong>最终结果：</strong></p><ul><li>最大流值为 14</li><li>S -&gt; A -&gt; C -&gt; T 路径上流量为 5</li><li>S -&gt; B -&gt; D -&gt; T 路径上流量为 6</li><li>S -&gt; A -&gt; D -&gt; T 路径上流量为 3</li></ul><p>Ford-Fulkerson 算法的核心思想是不断寻找增广路径并增加流量，直到无法找到更多的增广路径为止。每次找到增广路径后，我们都会更新网络中的流量，直到达到最大流。</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">function FordFulkerson<span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 初始化残余图    ResidualGraph Gf <span class="token operator">=</span> CreateResidualGraph<span class="token punctuation">(</span>G<span class="token punctuation">)</span>        <span class="token operator">//</span> 初始化最大流为<span class="token number">0</span>    maxFlow <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> true<span class="token punctuation">:</span>        <span class="token operator">//</span> 在残余图中寻找增广路径        Path augmentingPath <span class="token operator">=</span> FindAugmentingPath<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>                <span class="token operator">//</span> 如果没有找到增广路径，算法终止        <span class="token keyword">if</span> augmentingPath <span class="token keyword">is</span> empty<span class="token punctuation">:</span>            <span class="token keyword">break</span>                <span class="token operator">//</span> 找到增广路径上的最小残余容量        minResidualCapacity <span class="token operator">=</span> FindMinResidualCapacity<span class="token punctuation">(</span>augmentingPath<span class="token punctuation">)</span>                <span class="token operator">//</span> 更新残余图        UpdateResidualGraph<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> augmentingPath<span class="token punctuation">,</span> minResidualCapacity<span class="token punctuation">)</span>                <span class="token operator">//</span> 增加最大流        maxFlow <span class="token operator">=</span> maxFlow <span class="token operator">+</span> minResidualCapacity        <span class="token keyword">return</span> maxFlowfunction FindAugmentingPath<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 使用DFS或BFS寻找从source到sink的路径    <span class="token operator">//</span> 返回找到的路径，如果没有路径则返回空function FindMinResidualCapacity<span class="token punctuation">(</span>Path augmentingPath<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 遍历路径，找到最小的残余容量    <span class="token operator">//</span> 返回最小残余容量function UpdateResidualGraph<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Path augmentingPath<span class="token punctuation">,</span> <span class="token builtin">int</span> minResidualCapacity<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> augmentingPath<span class="token punctuation">:</span>        <span class="token operator">//</span> 减少正向边的残余容量        Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-</span> minResidualCapacity        <span class="token operator">//</span> 增加反向边的残余容量        Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> minResidualCapacityfunction CreateResidualGraph<span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token operator">//</span> 创建一个与原图结构相同的残余图    <span class="token operator">//</span> 初始化残余容量等于原图的容量    <span class="token operator">//</span> 为每条边添加一条初始容量为<span class="token number">0</span>的反向边    <span class="token operator">//</span> 返回创建的残余图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="5-6-Bipartite-Graph（双分图）"><a href="#5-6-Bipartite-Graph（双分图）" class="headerlink" title="5.6 Bipartite Graph（双分图）"></a>5.6 Bipartite Graph（双分图）</h3><p>在图论中，<strong>Bipartite Graph（双分图）</strong> 是一种特殊的无向图，其顶点集可以被划分为两个<strong>不相交的子集</strong> $U$ 和 $V$，使得图中<strong>每一条边都连接一个来自 $U$ 的顶点和一个来自 $V$ 的顶点</strong>，也就是说<strong>不存在同一子集中两个顶点之间的边</strong>。</p><p><strong>定义</strong></p><p>设图 $G &#x3D; (V, E)$，如果可以将顶点集 $V$ 分为两个集合 $U$ 和 $V$，满足：</p><ul><li>$U \cap V &#x3D; \emptyset$（两集合无交集）</li><li>$U \cup V &#x3D; V(G)$（合起来构成整个顶点集）</li><li>对所有边 $(x, y) \in E$，必有 $x \in U$ 且 $y \in V$，或者相反</li></ul><p>那么图 $G$ 是一个<strong>Bipartite Graph（双分图）</strong>。</p><p><strong>等价定义</strong></p><p>一个图是二分图 ⇔ 该图可以进行<strong>二染色</strong>，即能用两种颜色为图的每个顶点染色，使得<strong>任意一条边连接的两个端点颜色不同</strong>。</p><p><strong>举例</strong></p><ol><li>二分图：</li></ol><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">U: A, BV: 1, 2边：A–1, A–2, B–1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>这是一个典型的二分图：所有边都从 U 到 V。</p><ol start="2"><li>不是二分图：</li></ol><p>三角形图（3 个节点构成一个环）不是二分图，因为你无法用两种颜色染色而不让一条边连接两个同色的顶点。</p><p><strong>判断是否是二分图的算法</strong></p><p><strong>BFS&#x2F;DFS 染色法</strong>：</p><ul><li>从一个点出发，将其染成颜色 0；</li><li>相邻的点染成颜色 1；</li><li>再往下继续染色；</li><li>若发现相邻节点有相同颜色，说明不是二分图。</li></ul><p><strong>应用</strong></p><ul><li><strong>匹配问题</strong>：如最大匹配、婚姻匹配问题；</li><li><strong>网络流建模</strong>；</li><li><strong>任务分配</strong>：将任务和工人建模为两个集合；</li><li><strong>推荐系统</strong>：用户–物品的图可建模为二分图。</li></ul><p><strong>数学性质</strong></p><ul><li><strong>一个图是二分图 ⇔ 这个图不含奇数长度的环</strong>。</li><li>完全二分图：若 $|U| &#x3D; m$, $|V| &#x3D; n$，且 $U$ 中每个点都与 $V$ 中每个点相连，记作 $K_{m,n}$。</li></ul><h3 id="5-7-匈牙利算法（Hungarian-Algorithm）"><a href="#5-7-匈牙利算法（Hungarian-Algorithm）" class="headerlink" title="5.7 匈牙利算法（Hungarian Algorithm）"></a>5.7 匈牙利算法（Hungarian Algorithm）</h3><p>匈牙利算法用于解决<strong>二分图最大匹配</strong>问题。它常被用于如下问题：</p><ul><li>最佳任务分配（如工人分配到任务）</li><li>最大权匹配（扩展版本）</li><li>图的匹配问题</li></ul><p>一个<strong>二分图</strong>是指图的顶点可以被划分为两个不交的集合 $U$ 和 $V$，其中每条边只连接 $U$ 中的点与 $V$ 中的点。</p><p><strong>🧠 匈牙利算法思想</strong></p><p>对于一个二分图 $G &#x3D; (U, V, E)$，设当前匹配为 $M$。</p><ol><li><p>初始时，$M &#x3D; \emptyset$。</p></li><li><p>对于 $U$ 中的每个未匹配点 $u$：</p><ul><li>尝试从 $u$ 出发进行一条<strong>增广路径</strong>（alternating path）搜索。</li><li>若找到一条增广路径，则更新匹配。</li></ul></li><li><p>最终无法继续增广时，$M$ 即为最大匹配。</p></li></ol><p><strong>🔁 增广路径的定义</strong></p><ul><li><strong>交替路径</strong>：指匹配边与非匹配边交替出现的路径；</li><li><strong>增广路径</strong>：起点和终点都是未匹配的点，交替路径，从未匹配点开始和结束；</li><li>找到增广路径后，通过“翻转路径上的边”（将匹配边变成非匹配边，反之亦然）来增加匹配数。</li></ul><p><strong>🧾 匈牙利算法伪代码（DFS版）</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hungarian</span><span class="token punctuation">(</span>U<span class="token punctuation">,</span> V<span class="token punctuation">,</span> graph<span class="token punctuation">)</span><span class="token punctuation">:</span>    match_to_V <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment"># V -> U 的匹配结果</span>    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> v <span class="token keyword">in</span> visited<span class="token punctuation">:</span>                <span class="token keyword">continue</span>            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>v<span class="token punctuation">)</span>            <span class="token keyword">if</span> v <span class="token keyword">not</span> <span class="token keyword">in</span> match_to_V <span class="token keyword">or</span> dfs<span class="token punctuation">(</span>match_to_V<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>                match_to_V<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> u <span class="token keyword">in</span> U<span class="token punctuation">:</span>        visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>u<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>            result <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> result<span class="token punctuation">,</span> match_to_V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>📘 示例图</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">U &#x3D; &#123;u1, u2, u3&#125;V &#x3D; &#123;v1, v2, v3&#125;Edges:u1 - v1u1 - v2u2 - v2u3 - v3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><ul><li><p>初始：匹配为空。</p></li><li><p>尝试从 $u_1$ 找路径 → 匹配 $u_1$ 与 $v_1$</p></li><li><p>再尝试 $u_2$ → 匹配 $u_2$ 与 $v_2$</p></li><li><p>再尝试 $u_3$ → 匹配 $u_3$ 与 $v_3$</p></li><li><p>最终得到最大匹配为 3</p></li><li><p><strong>时间复杂度</strong>：$O(n \cdot m)$，其中 $n$ 是顶点数，$m$ 是边数。</p><ul><li>对于每个点尝试一次 DFS，最坏每次都遍历所有边。</li></ul></li></ul><img src="/img/DSA/bha.svg" alt="匈牙利算法" style="max-width: 100%; height: auto;" /><hr><h3 id="5-9-欧拉路径-Eulerian-Path"><a href="#5-9-欧拉路径-Eulerian-Path" class="headerlink" title="5.9 欧拉路径(Eulerian Path)"></a>5.9 欧拉路径(Eulerian Path)</h3><p>欧拉路径是图中的一条路径，它经过图中每一条边恰好一次。可以重复经过顶点，但不能重复经过边。如果这条路径是一个回路（即起点和终点是同一个顶点），那么它叫做欧拉回路（Eulerian Circuit 或 Cycle）。</p><p>欧拉路径算法适用于：</p><ul><li><p><strong>无向图</strong>或<strong>有向图</strong></p></li><li><p>使用以下常见数据结构表示图：</p><ul><li>邻接表（推荐）</li><li>邻接矩阵（适合稠密图）</li></ul></li></ul><p><strong>Python中的邻接表：</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>欧拉路径判定条件（算法判断步骤）</strong></p><p>🎯 对于<strong>无向图</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">has_eulerian_path_undirected</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>    odd_degree_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            odd_degree_count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> odd_degree_count <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> odd_degree_count <span class="token operator">==</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p>若有0个或2个奇数度顶点 → 存在欧拉路径。</p></blockquote><p><strong>🎯 对于有向图</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">has_eulerian_path_directed</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>    in_deg <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    out_deg <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> u <span class="token keyword">in</span> graph<span class="token punctuation">:</span>        out_deg<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>            in_deg<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> in_deg<span class="token punctuation">.</span>get<span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>            in_deg<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>u<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>            out_deg<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        start_nodes <span class="token operator">=</span> end_nodes <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">:</span>        out_d <span class="token operator">=</span> out_deg<span class="token punctuation">.</span>get<span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        in_d <span class="token operator">=</span> in_deg<span class="token punctuation">.</span>get<span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> out_d <span class="token operator">-</span> in_d <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            start_nodes <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> in_d <span class="token operator">-</span> out_d <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            end_nodes <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">elif</span> in_d <span class="token operator">!=</span> out_d<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>start_nodes <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> end_nodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>start_nodes <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> end_nodes <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong>欧拉路径构造算法（Hierholzer’s Algorithm）</strong></p><blockquote><p>更高效于 Fleury 算法，时间复杂度为 $O(E)$，适合稀疏图。</p></blockquote><p><strong>💡 算法思路（无向图为例）</strong></p><ol><li>从一个合法的起点出发（若有奇数度，则从奇数度顶点开始）</li><li>用<strong>栈</strong>模拟 DFS 深度优先遍历路径</li><li>每次走一条边，就把它“删掉”</li><li>如果当前节点没有边了，把它弹出，加入结果路径</li><li>最终路径反转后即为欧拉路径</li></ol><p><strong>🚀 Python实现（无向图）</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict<span class="token keyword">def</span> <span class="token function">find_eulerian_path</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>    graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span>u<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token keyword">for</span> u<span class="token punctuation">,</span> vs <span class="token keyword">in</span> graph<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>    stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 选择起点：奇数度点，如果没有就任选一个</span>    start <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u <span class="token keyword">for</span> u <span class="token keyword">in</span> graph <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>    <span class="token keyword">while</span> stack<span class="token punctuation">:</span>        u <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>            v <span class="token operator">=</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>u<span class="token punctuation">)</span>  <span class="token comment"># 对于无向图，要从两边删除</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 反转得到正向路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>🌟 示例输入</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token number">3</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>path <span class="token operator">=</span> find_eulerian_path<span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Eulerian Path:"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>输出可能为：</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Eulerian Path: [0, 1, 3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>🏁 总结：欧拉路径判定与构造流程</p><table><thead><tr><th>步骤</th><th>无向图</th><th>有向图</th></tr></thead><tbody><tr><td>判定是否存在欧拉路径</td><td>奇度点数是0或2</td><td>至多1个出度多1和1个入度多1</td></tr><tr><td>起点选择</td><td>若有奇度，从奇度点；否则任意</td><td>出度多1的点；否则任意</td></tr><tr><td>构造路径</td><td>Hierholzer 算法</td><td>同样可以用 Hierholzer，但注意方向</td></tr></tbody></table><hr><h4 id="5-9-1-欧拉路径相关命题证明"><a href="#5-9-1-欧拉路径相关命题证明" class="headerlink" title="5.9.1 欧拉路径相关命题证明"></a>5.9.1 欧拉路径相关命题证明</h4><p><strong>命题1</strong>：一个<strong>连通</strong>的无向图存在欧拉路径的充要条件是：<br>图中<strong>奇数度顶点的个数是 0 或 2</strong>。</p><p>✏️ 证明（无向图）</p><p>记图为 $G &#x3D; (V, E)$。</p><p>我们需要证明两个方向：</p><p>✅ 正向：存在欧拉路径 ⟹ 奇数度点数为 0 或 2</p><p>设图存在一条欧拉路径 $P$，从 $s$ 到 $t$，路径中每条边仅出现一次。</p><p>观察路径中每个点的度数：</p><ul><li>对于路径中<strong>中间的每个顶点</strong>（即既非起点 $s$ 也非终点 $t$），每次到达它后都必须离开它，所以它们的度数一定是<strong>偶数</strong>。</li><li>如果路径首尾 $s \neq t$，那么 $s$ 只有“出”而没有“入”，$t$ 只有“入”而没有“出”，所以它们的度数都是奇数。</li><li>如果路径是一个回路（$s &#x3D; t$），那么所有点的度数都是偶数。</li></ul><p>因此，图中奇数度顶点最多只能有两个（$s$ 和 $t$），否则不能形成欧拉路径。</p><p>✅ 所以：<strong>奇数度点数为 0（回路）或 2（非回路）</strong>。</p><hr><p>✅ 反向：奇数度点数为 0 或 2 ⟹ 存在欧拉路径</p><p>我们考虑两种情况：</p><ol><li><p><strong>若所有顶点的度数都是偶数</strong>（即奇度点数 &#x3D; 0）：</p><p>欧拉回路存在（Hierholzer 算法可构造）。回路是一种特殊的路径，因此欧拉路径也存在。</p></li><li><p><strong>若恰好两个奇数度顶点</strong>：</p><p>假设这两个点为 $u$ 和 $v$。我们构造一个新图 $G’$，在 $u$ 和 $v$ 之间加一条边 $(u, v)$。</p><ul><li>由于 $u$ 和 $v$ 原本为奇度，加上一条边后变为偶度，其余点度数不变。</li><li>所以 $G’$ 所有顶点都是偶数度 ⇒ $G’$ 有欧拉<strong>回路</strong>。</li><li>在 $G’$ 的欧拉回路中，必定会经过 $(u, v)$。我们从 $u$ 出发，走完整个回路，第一次遇到 $(u, v)$ 时就把它“切开”，只留下从 $u$ 到 $v$ 的路径 ⇒ $G$ 的欧拉路径。</li></ul></li></ol><p>✅ 所以：<strong>奇数度点数为 0 或 2 ⇒ 存在欧拉路径</strong>。</p><hr><p><strong>📌 命题二（有向图）</strong></p><p><strong>命题</strong>：一个<strong>连通</strong>的有向图存在欧拉路径的充要条件是：</p><ul><li>所有顶点满足 $in(v) &#x3D; out(v)$，或者</li><li>恰有一个顶点 $s$ 满足 $out(s) &#x3D; in(s) + 1$，一个顶点 $t$ 满足 $in(t) &#x3D; out(t) + 1$，其余点 $in &#x3D; out$</li></ul><p><strong>✅ 正向：存在欧拉路径 ⟹ 满足上述条件</strong></p><p>假设存在欧拉路径，从顶点 $s$ 到 $t$。</p><p>观察每个顶点的入度 $in(v)$ 与出度 $out(v)$：</p><ul><li>对于中间点（既非 $s$ 也非 $t$）：每进一次就必须出一次 ⇒ $in &#x3D; out$</li><li>起点 $s$：出度比入度多1 ⇒ $out(s) &#x3D; in(s) + 1$</li><li>终点 $t$：入度比出度多1 ⇒ $in(t) &#x3D; out(t) + 1$</li></ul><p>所以图中必须恰好有：</p><ul><li>一个顶点出度多1（起点）</li><li>一个顶点入度多1（终点）</li><li>其他点 $in &#x3D; out$</li></ul><p>或如果是回路情况，则所有点 $in &#x3D; out$</p><p><strong>✅ 反向：满足上述度数条件 ⟹ 存在欧拉路径</strong></p><p>和无向图类似：</p><ul><li><p>如果所有点 $in &#x3D; out$，我们可以从任意点出发，构造一个欧拉<strong>回路</strong>。</p></li><li><p>如果恰有 $s, t$ 满足上述不等度条件：</p><ul><li>我们向图中加入一条边 $(t \to s)$，使得所有点满足 $in &#x3D; out$。</li><li>在新图中存在欧拉回路。</li><li>在这个回路中，$(t \to s)$ 是某一段，我们将其“切断”，得到从 $s$ 到 $t$ 的欧拉路径。</li></ul></li></ul><p><strong>✅ 结论总结</strong></p><table><thead><tr><th>图类型</th><th>欧拉路径存在条件</th></tr></thead><tbody><tr><td>无向图</td><td>图连通且奇度点数为 0 或 2</td></tr><tr><td>有向图</td><td>图连通且：<br>① 所有点 $in &#x3D; out$（回路）<br>② 或存在 $s, t$，满足 $out(s) &#x3D; in(s)+1$，$in(t) &#x3D; out(t)+1$，其余点 $in &#x3D; out$（路径）</td></tr></tbody></table><h2 id="6-Greedy-Algorithm"><a href="#6-Greedy-Algorithm" class="headerlink" title="6. Greedy Algorithm"></a>6. Greedy Algorithm</h2><p><strong>贪心算法</strong>是一种算法设计范式，其核心思想是：在解决问题时，总是做出在当前状态下看起来最优的选择，即局部最优解，希望通过一系列这样的选择能够最终得到全局最优解。这个算法理解起来非常直观，但是合理性证明的话需要严格的数学证明。本章着重讲解最经典的<strong>最大子序和问题（Maximum Subarray）</strong> 和<strong>合并区间问题（Merge Intervals）</strong></p><h3 id="6-1-Maximum-Subarray"><a href="#6-1-Maximum-Subarray" class="headerlink" title="6.1 Maximum Subarray"></a>6.1 Maximum Subarray</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/maximum-subarray/description/">Leetcode 53题</a>练习。</p><blockquote><p>问题描述是：Given an integer array nums, find the subarray with the largest sum, and return its sum.</p></blockquote><p><strong>Example 1:</strong></p><ul><li><p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p></li><li><p>Output: 6</p></li><li><p>Explanation: The subarray [4,-1,2,1] has the largest sum 6.</p></li></ul><p>解决这个问题的贪心算法也叫Kadane算法：算法从左到右遍历一次数组，在每一步，它都计算当前位置结束的子数组的最大和（Current Sum）同时，它保持追踪全局的最大和（Max Sum）。最终，Max Sum的最后一个值就是整个问题的解。<br><img src="/img/DSA/kadane.svg" alt="kadane算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>        <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            curSum <span class="token operator">+=</span> x<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> curSum <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 贪心地取子数组最大值</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> maxSum <span class="token operator">=</span> curSum<span class="token punctuation">;</span> <span class="token comment">// 不断更新结果</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="6-2-Merge-Intervals"><a href="#6-2-Merge-Intervals" class="headerlink" title="6.2 Merge Intervals"></a>6.2 Merge Intervals</h3><p>这道问题可以直接上<a href="https://leetcode.com/problems/merge-intervals/description/">Leetcode 56题</a>练习。</p><blockquote><p>题目描述：Given an array of intervals where $\text{intervals}[i] &#x3D; [\text{start}_i, \text{end}_i]$, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p></blockquote><p><strong>Example 1:</strong></p><p>Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</p><p>Output: [[1,6],[8,10],[15,18]]</p><p>Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</p><p>解决这道题的思路是：先排序让所有相邻的区间尽可能重合在一起(以开端最小优先，其次结尾最小次之)，然后一次遍历贪心地选择局部最优解。<br><img src="/img/DSA/merge.svg" alt="合并区间算法演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 重载cmp函数，让区间的排列以开端最小优先，其次结尾最小优先</span>    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 贪心地选择是否合并区间</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">// 若不重合，则加入结果数组</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 若重合，则合并区间并贪心的选择区间结尾</span>            <span class="token keyword">else</span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="7-Dynamic-Programming"><a href="#7-Dynamic-Programming" class="headerlink" title="7. Dynamic Programming"></a>7. Dynamic Programming</h2><p><strong>动态规划（Dynamic Programming, DP）</strong> 是一种用于解决最优化问题的算法设计技巧。它通过将问题分解为更小的子问题，并记录其解来<u>避免重复计算</u>，从而提高算法的效率。本章主要讲解5个经典DP问题：<em>斐波那契数列</em>，<em>背包问题</em>，<em>股票问题</em>，<em>最长公共子序列</em>，以及<em>序列比对问题</em>。</p><h3 id="7-1-Fibonacci-Sequence"><a href="#7-1-Fibonacci-Sequence" class="headerlink" title="7.1 Fibonacci Sequence"></a>7.1 Fibonacci Sequence</h3><p>形如：$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ….$的数列称之为斐波那契数，我们可以很轻易地得到递归式：$dp[n] &#x3D; dp[n-1] + dp[n-2]$,然后我们再对递归式子进行初始化：$dp[0] &#x3D; 1, dp[1] &#x3D; 1$, 我们就可以利用递归式求得所有的斐波那契数。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-2-Knapsack-Problem"><a href="#7-2-Knapsack-Problem" class="headerlink" title="7.2 Knapsack Problem"></a>7.2 Knapsack Problem</h3><p>关于背包问题有三种：0-1背包，完全背包，多重背包。应对修考我认为掌握0-1背包问题就足够了。关于0-1背包的问题描述是：</p><ol><li>一组物品，每个物品都有一个重量和一个价值。</li><li>一个背包，具有固定的容量。</li></ol><p>给定$n$个物品，每个物品$i$具有重量$w[i]$和价值$v[i]$，还有一个背包的最大容量$W$。目标是选择物品的组合，使得在不超过背包容量的情况下，背包中的物品总价值最大。</p><p><strong>1.定义状态：</strong> $dp[i][j]$表示在考虑前$i$个物品，且背包容量为$j$时的最大价值。</p><p><strong>2.状态转移方程：</strong> 对于每个物品$i$，有两个选择：</p><ul><li>不放入背包：此时最大价值为$dp[i-1][j]$。</li><li>放入背包：此时最大价值为$dp[i-1][j - w[i]] + v[i]$，前提是当前物品的重量不超过背包容量 $j &gt;&#x3D; w[i]$。</li></ul><p>因此，状态转移方程为：<br>$$<br>dp[i][j] &#x3D; \begin{cases}<br>dp[i-1][j] &amp; \text{if } j &lt; w[i] \\<br>\max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]) &amp; \text{if } j \geq w[i]<br>\end{cases}<br>$$</p><p><strong>3.边界条件：</strong></p><ul><li>当没有物品可选时，最大价值为$0$，即 $(dp[0][j] &#x3D; 0)$。</li><li>当背包容量为$0$时，最大价值也为$0$，即 $(dp[i][0] &#x3D; 0)$。</li></ul><p><strong>4.计算顺序：</strong></p><p>先遍历物品再遍历背包更容易理解，从 $(i &#x3D; 1)$到 $(n)$，对于每个物品，再从 $(j &#x3D; 0)$到$(W)$计算。当然也可以先遍历背包再遍历物品，这里不过多赘述。</p><p><strong>5.返回结果：</strong> 最终的最大价值为 $(dp[n][W])$。</p><p>假设有以下物品和背包容量：</p><ul><li>物品 1：重量 &#x3D; 2，价值 &#x3D; 3</li><li>物品 2：重量 &#x3D; 3，价值 &#x3D; 4</li><li>物品 3：重量 &#x3D; 4，价值 &#x3D; 5</li><li>物品 4：重量 &#x3D; 5，价值 &#x3D; 6</li></ul><p>背包容量为 5。<br><img src="/img/DSA/01knapsnack.svg" alt="01背包遍历演示" style="max-width: 100%; height: auto;" /></p><p>遍历的核心代码：</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> W<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 装不下的情况</span>            <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装下的情况</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-3-Stock-Problem"><a href="#7-3-Stock-Problem" class="headerlink" title="7.3 Stock Problem"></a>7.3 Stock Problem</h3><p>股票问题有很多种，这里介绍一种，参考<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">Leetcode 122题</a>。题目描述是：</p><blockquote><p>You are given an integer array $prices$ where $prices[i]$ is the price of a given stock on the ith day. On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold <u>at most one share </u> of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: prices &#x3D; [7,1,5,3,6,4]</li><li>Output: 7</li><li>Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.<br>Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.<br>Total profit is 4 + 3 &#x3D; 7.<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// have the stock on the day 0;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token comment">// no stock on the day 0;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// no stock on the day n - 1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li></ul><p><strong>初始状态：</strong></p><p><code>dp[0][0] = -prices[0]</code>：表示在第$0$天买入股票后的利润，利润为负的股票价格。<br><code>dp[0][1] = 0</code>：表示在第$0$天没有持有股票，利润为$0$。</p><p><strong>状态转移：</strong></p><blockquote><p><strong>对于第$i$天，持有股票的状态 <code>dp[i][0]</code>，有两种可能：</strong></p></blockquote><ul><li>前一天已经持有股票，保持不动：<code>dp[i-1][0]</code>。  </li><li>前一天没有持有股票，但今天买入：<code>dp[i-1][1] - prices[i]</code>（买入股票，减去当天股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])</code>。</p><blockquote><p><strong>对于第$i$天，不持有股票的状态 <code>dp[i][1]</code>，也有两种可能：</strong></p></blockquote><ul><li>前一天已经不持有股票，保持不动：<code>dp[i-1][1]</code>。  </li><li>前一天持有股票，但今天卖出：<code>dp[i-1][0] + prices[i]</code>（卖出股票，得到当前股票的价格）。</li></ul><p>取两者的最大值：<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</code>。</p><p><strong>最终结果：</strong> 返回 <code>dp[n-1][1]</code>，表示最后一天不持有股票的最大利润。</p><h3 id="7-4-Longest-Common-Subsequence"><a href="#7-4-Longest-Common-Subsequence" class="headerlink" title="7.4 Longest Common Subsequence"></a>7.4 Longest Common Subsequence</h3><p><strong>最长公共子序列（LCS）</strong> 也是修考的一个常考点，具体参考：<a href="https://leetcode.com/problems/longest-common-subsequence/description/">Leetcode 1143</a></p><blockquote><p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”. A common subsequence of two strings is a subsequence that is common to both strings.</p></blockquote><p><strong>Example 1:</strong></p><ul><li>Input: text1 &#x3D; “abcde”, text2 &#x3D; “ace” </li><li>Output: 3  </li><li>Explanation: The longest common subsequence is “ace” and its length is 3.</li></ul><p><strong>定义状态：</strong></p><p>$$<br>dp[i][j] \text{ 表示在考虑前 } i \text{ 个字符的 } \text{text1} \text{ 和前 } j \text{ 个字符的 } \text{text2} \text{ 时的最长公共子序列的长度。}<br>$$</p><p><strong>状态转移方程：</strong></p><p>对于每个字符对<code>text1[i-1] </code> 和<code>text2[j-1]</code>，有两种情况：</p><ul><li>如果 <code>&#39;text1[i-1] == text2[j-1]&#39;</code>，说明这两个字符相同，最长公共子序列可以延长 1，此时 <code>&#39;dp[i][j] = dp[i-1][j-1] + 1&#39;</code>。</li><li>如果 <code>&#39;text1[i-1] != text2[j-1]&#39;</code>，则取决于之前的子问题结果，最长公共子序列为：<ul><li>不包括当前字符：<code>&#39;dp[i][j] = max(dp[i][j-1], dp[i-1][j])&#39;</code>。</li></ul></li></ul><p><strong>边界条件：</strong></p><ul><li>当 <code>&#39;i = 0&#39;</code> 或 <code>&#39;j = 0&#39;</code> 时，即有一个字符串为空，最长公共子序列长度为 0，所以初始化时 <code>&#39;dp[0][j] = 0&#39;</code> 和 <code>&#39;dp[i][0] = 0&#39;</code>。</li></ul><p><strong>计算顺序：</strong></p><p>从 <code>&#39;i = 1&#39;</code> 到 <code>&#39;n&#39;</code>，对于每个字符，再从 <code>&#39;j = 1&#39;</code> 到 <code>&#39;m&#39;</code> 计算 <code>&#39;dp[i][j]&#39;</code>，逐步构建整个表。</p><p><strong>返回结果：</strong></p><p>最终结果为 <code>&#39;dp[n][m]&#39;</code>，即考虑所有字符的最长公共子序列的长度。<br><img src="/img/DSA/lcs.svg" alt="LCS遍历演示" style="max-width: 100%; height: auto;" /></p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="7-5-Sequence-Alignment"><a href="#7-5-Sequence-Alignment" class="headerlink" title="7.5 Sequence Alignment"></a>7.5 Sequence Alignment</h3><p><strong>序列比对（Sequence Alignment）</strong> 是生物信息学中的一个核心问题，用于比较两个或多个生物序列（如DNA、RNA或蛋白质）的相似性。其目的是通过对比序列中的元素（碱基或氨基酸）找出它们之间的最优匹配方式，进而揭示它们的进化关系、功能相似性或结构上的保守性。</p><h4 id="7-5-1-Needleman–Wunsch-algorithm"><a href="#7-5-1-Needleman–Wunsch-algorithm" class="headerlink" title="7.5.1 Needleman–Wunsch algorithm"></a>7.5.1 Needleman–Wunsch algorithm</h4><p>Needleman-Wunsch算法是用于进行全局序列比对的经典算法，特别适用于对比两个生物序列（如DNA、RNA或蛋白质）时，将它们的整个序列进行对齐。它采用动态规划的思想来寻找两个序列的最优对齐方式。<br><img src="/img/DSA/needle.svg" alt="序列比对算法演示" style="max-width: 100%; height: auto;" /></p><p><strong>Needleman-Wunsch算法步骤：</strong></p><p><strong>定义状态：</strong></p><p>设有两个序列 <code>A</code> 和 <code>B</code>，长度分别为 <code>n</code> 和 <code>m</code>。<br>创建一个大小为 <code>(n+1) x (m+1)</code> 的二维矩阵 <code>dp</code>，其中 <code>dp[i][j]</code> 表示序列 <code>A</code> 的前 <code>i</code> 个字符与序列 <code>B</code> 的前 <code>j</code> 个字符的最优对齐得分。</p><p><strong>罚分机制：</strong></p><ul><li><strong>匹配</strong>：当 <code>A[i-1] == B[j-1]</code> 时，表示两个字符相同，得分为 <code>match score</code>。</li><li><strong>不匹配</strong>：当 <code>A[i-1] != B[j-1]</code> 时，表示两个字符不同，得分为 <code>mismatch penalty</code>。</li><li><strong>Gap</strong>：当在序列 <code>A</code> 或 <code>B</code> 中插入一个字符时，得分为 <code>gap penalty</code>。</li></ul><p><strong>初始化：</strong></p><ul><li>第一行和第一列表示序列与空序列的比对。比对空序列时，每个字符都需要插入或删除，因此使用缺口罚分（gap penalty）。</li><li>初始化 <code>dp[0][0] = 0</code>，代表两个空序列的得分为 0。</li><li>初始化第一行：<code>dp[0][j] = j * gap penalty</code>，表示序列 <code>B</code> 的前 <code>j</code> 个字符与空序列的比对得分。</li><li>初始化第一列：<code>dp[i][0] = i * gap penalty</code>，表示序列 <code>A</code> 的前 <code>i</code> 个字符与空序列的比对得分。</li></ul><p><strong>状态转移方程：</strong>对于矩阵中的每个 <code>dp[i][j]</code>，有三种可能的情况：</p><ol><li><strong>匹配</strong>：如果 <code>A[i-1] == B[j-1]</code>，即两个字符相同，则可以匹配，得分为 <code>dp[i-1][j-1] + match score</code>。</li><li><strong>不匹配</strong>：如果 <code>A[i-1] != B[j-1]</code>，则可以进行替换，得分为 <code>dp[i-1][j-1] + mismatch penalty</code>。</li><li><strong>插入&#x2F;删除（Gap）</strong>：在序列 <code>A</code> 或 <code>B</code> 中插入一个字符，得分为 <code>dp[i][j-1] + gap penalty</code> 或 <code>dp[i-1][j] + gap penalty</code>。</li></ol><p>取这三种操作中的最大值更新 <code>dp[i][j]</code>，即：</p><p>$$<br>dp[i][j] &#x3D; \max\left(dp[i-1][j-1] + \text{(match&#x2F;mismatch score)}, dp[i-1][j] + \text{gap penalty}, dp[i][j-1] + \text{gap penalty}\right)<br>$$</p><p><strong>回溯：</strong>填完矩阵后，从右下角 <code>dp[n][m]</code> 开始回溯，找出最优路径，从而得到序列 <code>A</code> 和 <code>B</code> 的最优全局对齐方案。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化：处理空序列的情况</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一列，表示A的前i个字符和空序列的比对</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一行，表示B的前j个字符和空序列的比对</span><span class="token comment">// 填充 dp 表</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 1. 匹配或不匹配的情况</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符相等，则进行匹配，加上 match_score</span>            <span class="token keyword">int</span> match <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> match_score<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果当前字符不相等，则进行替换，加上 mismatch_penalty</span>            <span class="token keyword">int</span> mismatch <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> mismatch_penalty<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">// 2. 插入的情况</span>        <span class="token keyword">int</span> insert <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 在序列 A 中插入 gap</span>        <span class="token comment">// 3. 删除的情况</span>        <span class="token keyword">int</span> del <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>     <span class="token comment">// 在序列 B 中插入 gap</span>                <span class="token comment">// 取三种操作的最大值来更新 dp[i][j]</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> match_score <span class="token operator">:</span> mismatch_penalty<span class="token punctuation">)</span><span class="token punctuation">,</span> insert<span class="token punctuation">,</span> del<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 最终结果是 dp[n][m]，表示A和B的最优全局比对得分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="8-P-NP-problem"><a href="#8-P-NP-problem" class="headerlink" title="8. P&#x2F;NP problem"></a>8. P&#x2F;NP problem</h2><p><strong>P&#x2F;NP问题</strong> 是计算机科学中的一个核心难题，涉及确定哪些问题可以在合理的时间内（多项式时间）被解决，和哪些问题的解可以在合理的时间内被验证。它是理论计算机科学和数学中最著名、最重要的未解决问题之一。</p><p><strong>P类问题</strong></p><p>P类问题（Polynomial time）指的是那些可以在多项式时间内被解决的问题。也就是说，给定一个问题实例，使用某种算法可以在输入规模为 $n$ 时，用 $n^k$（其中 $k$ 是一个常数）次运算步骤就可以得到结果。</p><ul><li><p>例如，常见的排序算法（如快速排序）和图论中的最短路径算法（如Dijkstra算法）都是 <strong>P类问题</strong>。它们的时间复杂度是多项式级别的。</p></li><li><p><strong>直观理解</strong>：如果一个问题属于P类，那么它是“容易”解决的，因为我们可以用有效的算法在合理的时间内求解。</p></li></ul><p><strong>NP类问题</strong></p><p>NP类问题（Nondeterministic Polynomial time）是指那些解可以在多项式时间内被验证的问题，尽管可能没有已知的多项式时间算法来找到这个解。</p><ul><li><p>也就是说，如果我们猜测出一个解，可以在多项式时间内检查这个解是否正确。但是，要找到这个解可能会很难，甚至没有已知的多项式时间算法来求解。</p></li><li><p><strong>经典的NP问题</strong> 包括旅行商问题（TSP）、背包问题和布尔可满足性问题（SAT）。这些问题的特点是验证解很容易，但找到最优解可能非常耗时。</p></li></ul><p><strong>P与NP的关系</strong></p><ul><li><p><strong>P是否属于NP？</strong></p><ul><li><p>P类问题显然也是NP类问题。如果我们能够在多项式时间内求解一个问题，那我们一定也能在多项式时间内验证这个解。</p></li><li><p>因此可以得出结论：<strong>P是NP的一个子集</strong>，即 $P \subseteq NP$。</p></li></ul></li><li><p><strong>P与NP的区别</strong></p><ul><li>关键在于我们还不确定 <strong>P类问题</strong> 和 <strong>NP类问题</strong> 是否是同一个集合。这就是 <strong>P vs NP</strong> 问题的核心所在：<ul><li>如果 $P &#x3D; NP$，那么所有能在多项式时间内验证的解也可以在多项式时间内求解。</li><li>如果 $P \neq NP$，那么有一些问题能在多项式时间内验证解，但没有已知的多项式时间算法来求解它们。</li></ul></li></ul></li></ul><p><strong>NP完全问题（NP-Complete）</strong></p><p>NP完全问题（NP-Complete, NPC）是NP类问题中的一个特殊子集，它们有两个重要的特性：</p><ol><li>它们本身是NP类问题。</li><li>任何一个NP类问题都可以通过多项式时间的归约（转换）转换为这个NP完全问题。</li></ol><ul><li><p><strong>重要性</strong>：如果你能找到一个NP完全问题的多项式时间解法，那么所有的NP问题都可以在多项式时间内解决。因此，NP完全问题是NP类问题中的“最难问题”。</p></li><li><p><strong>典型的NP完全问题</strong>：</p><ul><li>旅行商问题（TSP）：寻找一条经过每个城市恰好一次且路径最短的旅行路线。</li><li>3-SAT问题：判断一个布尔公式是否有解。</li><li>顶点覆盖问题：在一个图中找到最小的顶点集合，使得每条边至少有一个顶点被覆盖。</li></ul></li></ul><p><strong>P vs NP问题</strong></p><p>P vs NP问题是指：<strong>P是否等于NP？</strong></p><ul><li><p>如果 <strong>P &#x3D; NP</strong>，意味着所有NP问题都有多项式时间的求解算法。这将意味着大量的难问题（如密码学中的问题）可以被快速解决。</p></li><li><p>如果 <strong>P ≠ NP</strong>，那么一些问题的解可以快速验证，但无法快速求解。</p></li></ul><p>目前，这个问题尚未解决，它是 <strong>“千禧年大奖问题”</strong> 之一，美国克雷数学研究所为解决这个问题悬赏 <strong>100万美元</strong>。</p><p><strong>总结</strong></p><ul><li><strong>P类问题</strong>：可以在多项式时间内求解。</li><li><strong>NP类问题</strong>：可以在多项式时间内验证解，但不一定能在多项式时间内求解。</li><li><strong>P vs NP问题</strong>：我们不知道所有可以快速验证的解是否也可以快速求解，即是否 $P &#x3D; NP$。</li></ul><h2 id="9-偷偷说"><a href="#9-偷偷说" class="headerlink" title="9.偷偷说"></a>9.偷偷说</h2><p>本文应该囊括了修考绝大部分的考点了，当然还有双指针和滑动窗口，哈希之类的算法技巧我觉得就不用大费周章地写下来了。做修考题我认为最重要的是阅读伪代码的能力！希望这篇文章可以帮助到修考受验生们。完结撒花🎉</p><div class="note note-success">            <p>偷偷目前兼任私塾班主任，如果需要1对1辅导，请联系：LifeGoesOn_Rio</p>          </div>]]></content>
    
    
    <categories>
      
      <category>专业科目笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修考</tag>
      
      <tag>DSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本語勉強</title>
    <link href="/2024/09/10/JPN/"/>
    <url>/2024/09/10/JPN/</url>
    
    <content type="html"><![CDATA[<h3 id="1-〜あっての"><a href="#1-〜あっての" class="headerlink" title="1.〜あっての"></a>1.〜あっての</h3><div class="note note-success">            <p>説明：あるものが存在するのは他のもののおかげであることを強調する表現です。名詞 + あっての + 名詞</p>          </div><p>健康あっての人生なんだから、体調管理には十分気をつけなさい。</p><p>家族の支えがあったからこそ成功できた。</p><h3 id="2-以外の何ものでもない。"><a href="#2-以外の何ものでもない。" class="headerlink" title="2.~以外の何ものでもない。"></a>2.~以外の何ものでもない。</h3><div class="note note-success">            <p>「Aが唯一の理由・原因である」という意味になります。</p>          </div><p>この結果は偶然以外の何ものでもない。</p><h3 id="3-〜いかんで-いかんでは"><a href="#3-〜いかんで-いかんでは" class="headerlink" title="3.〜いかんで&#x2F;いかんでは"></a>3.〜いかんで&#x2F;いかんでは</h3><div class="note note-success">            <p>どちらも「〜によって」「〜次第で」という意味を持ち、前の事柄によって後の結果が変わることを示す表現です。ただし、微妙なニュアンスの違いがあります。</p>          </div><p>天候いかんでは、収穫は全てできないこともある。</p><h3 id="4-～いかんに関わらず・いかんによらず・いかんをとわず"><a href="#4-～いかんに関わらず・いかんによらず・いかんをとわず" class="headerlink" title="4.～いかんに関わらず・いかんによらず・いかんをとわず"></a>4.～いかんに関わらず・いかんによらず・いかんをとわず</h3><div class="note note-success">            <p>「〜に関係なく」や「〜にかかわらず」と同じ意味で使われます。つまり、ある条件や状況に影響されずに、という意味です。</p>          </div><p>成績いかんに関わらず、全員が参加できます。</p><h3 id="5-いざ〜となると・いざ〜となれば・いざ〜となったら"><a href="#5-いざ〜となると・いざ〜となれば・いざ〜となったら" class="headerlink" title="5.いざ〜となると・いざ〜となれば・いざ〜となったら"></a>5.いざ〜となると・いざ〜となれば・いざ〜となったら</h3><div class="note note-success">            <p>いずれも「実際にその状況になったら」という意味で使われます。これらの表現は、ある状況が現実になったときにどうなるか、ということを強調するために使われます。</p>          </div><p>いざ出発となれば、準備が整っていないことに気づく。</p><h3 id="6-〜言わずもがな"><a href="#6-〜言わずもがな" class="headerlink" title="6.〜言わずもがな"></a>6.〜言わずもがな</h3><div class="note note-success">            <p>「〜言わずもがな」という表現は、「言うまでもなく」や「言わなくてもわかる」という意味で使われます。つまり、あることが非常に明白であるため、わざわざ言う必要がないということを強調する表現です。</p>          </div><p>彼の才能は言わずもがな、誰もが認めるところだ。</p><h3 id="7-限りだ"><a href="#7-限りだ" class="headerlink" title="7. ~限りだ"></a>7. ~限りだ</h3><div class="note note-success">            <p>「〜限りだ」という表現は、感情や感覚を強調するために使われます。特に、感動や驚き、悲しみなどの強い感情を表現する際に用いられます。</p>          </div><p>嬉しい限りだ。</p><h3 id="8-かたがた"><a href="#8-かたがた" class="headerlink" title="8.~かたがた"></a>8.~かたがた</h3><div class="note note-success">            <p>「〜しながら」「〜と同時に」という意味：<br>ある行動をしながら、同時に別の目的も果たすことを表します。<br>例：</p>          </div><p>散歩かたがた買い物に行く。<br>(散歩をしながら買い物もする)</p><div class="note note-success">            <p>「〜のついでに」「〜を機会に」という意味：<br>ある行動や状況を利用して、ついでに別のことも行うことを表します。</p>          </div><p>東京出張かたがた友人に会ってきた。<br>(東京への出張を機会に友人にも会った)</p><h3 id="9-かたわら"><a href="#9-かたわら" class="headerlink" title="9. ~かたわら"></a>9. ~かたわら</h3><div class="note note-success">            <p>主な活動や仕事をしながら、同時に別の活動も行うことを表します。</p>          </div><p>教師のかたわら、小説を執筆している。</p><h3 id="10-がてら"><a href="#10-がてら" class="headerlink" title="10.~がてら"></a>10.~がてら</h3><div class="note note-success">            <p>「〜のついでに」「〜と同時に」<br>ある行動をする際に、ついでに別の行動も同時に行うことを表します。主な目的とは別の、副次的な行動を示すのに使われます。</p>          </div><p>散歩がてら、近所の様子を見て回りました。</p><h3 id="11-からある・からする・からの"><a href="#11-からある・からする・からの" class="headerlink" title="11.~からある・からする・からの"></a>11.~からある・からする・からの</h3><div class="note note-success">            <p>强调大，多，重，长等。<br>「からある」前面表示数量，长度，大小，高矮等数量名词；[からする]前面多用表示金额的量词；[からの]前面多表示人物的数量词。</p>          </div><p>１００キロからある荷物を三階まで運ぶには、足腰の強い人が三人は必要だ。</p><p>彼女は４０億からする遺産を相続したそうだ。</p><p>今日のスピーチ大会は５００人からの人が集まった。</p><h3 id="12-始末だ"><a href="#12-始末だ" class="headerlink" title="12.~始末だ"></a>12.~始末だ</h3><div class="note note-success">            <p>「ひどい状態だ」「困った事態だ」「始末に負えない」といった否定的な状況を表現します。<br>話者の失望、困惑、あるいは軽蔑の気持ちを含むことが多いです。</p>          </div><p>彼は借金を重ね、今では家も売らなければならない始末だ。</p><h3 id="13-～ずくめ"><a href="#13-～ずくめ" class="headerlink" title="13.～ずくめ"></a>13.～ずくめ</h3><div class="note note-success">            <p>「～ずくめ」は日本語の文法表現で、「全て～ばかりである」という意味を表します。この表現は、ある特定の性質や状態が全体的に存在することを強調するために使われます。</p>          </div><p>この本は難しい言葉ずくめで、読むのが大変だ。</p><p>彼女の服装は黒ずくめだった。</p><h3 id="14-〜ずじまいだ"><a href="#14-〜ずじまいだ" class="headerlink" title="14.〜ずじまいだ"></a>14.〜ずじまいだ</h3><div class="note note-success">            <p>「〜ずじまいだ」は「〜ずじまい」という表現の丁寧な形です。この表現は、ある行動や状態が最後まで続いて終わることを意味します。主に否定的なニュアンスで使われることが多いです。</p>          </div><p>忙しいくて、結局休暇を取る図じまいだった。</p><p>締め切りに追われて、計画を見直すずじまいだった。</p><h3 id="15-ずにはおかない"><a href="#15-ずにはおかない" class="headerlink" title="15.~ずにはおかない"></a>15.~ずにはおかない</h3><div class="note note-success">            <p>「必ず〜する」「〜せずにはいられない」という強い意志や必然性を表します。</p>          </div><p>この素晴らしい景色を見たら、誰も感動せずにはおかない。</p><p>彼女の熱意は、周りの人々に影響を与えずにはおかないだろう。</p><h3 id="16-術がない"><a href="#16-術がない" class="headerlink" title="16.~術がない"></a>16.~術がない</h3><div class="note note-success">            <p>意味:<br>「〜する方法がない」「〜する手段がない」「〜するすべがない」</p>          </div><p>締め切りに間に合わせる術がなく、締めるしかなっかた。</p><p>彼女を説得する術がないので、このまま計画を進めるしかない。</p><h3 id="17-そびれる"><a href="#17-そびれる" class="headerlink" title="17.~そびれる"></a>17.~そびれる</h3><div class="note note-success">            <p>意味:<br>「〜するチャンスを逃す」「〜し損ねる」「うっかり〜し忘れる」</p>          </div><p>興味深い展覧会があったのに、行きそびれてしまった。</p><p>大切な約束を確認しそびれて、すっかり忘れてしまった。</p><h3 id="18-たところで"><a href="#18-たところで" class="headerlink" title="18.~たところで"></a>18.~たところで</h3><div class="note note-success">            <p>意味:「〜たところで」は「〜しても、結局」や「〜したとしても、それでも」という意味を表します。</p>          </div><p>急いだところで、もう間に合わないだろう。</p><p>お金をたくさん持っているところで、幸せになれるとは限らない。</p><h3 id="19-てしかるべきだ"><a href="#19-てしかるべきだ" class="headerlink" title="19.~てしかるべきだ"></a>19.~てしかるべきだ</h3><div class="note note-success">            <p>意味：「〜するのが当然だ」「〜するのが適切だ」という意味を表します。話者の強い意見や判断を示す表現です。</p>          </div><p>法律を守ってしかるべきだ。</p><p>その問題については、専門家に相談してしかるべきだ。</p><h3 id="20-て憚らない"><a href="#20-て憚らない" class="headerlink" title="20.~て憚らない"></a>20.~て憚らない</h3><div class="note note-success">            <p>意味：遠慮せずに～する」「ためらわずに～する」「大胆に～する」</p>          </div><p>意見を述べて憚らない。</p><p>新しいアイデアを提案して憚らない。</p><h3 id="21-てはかなわない"><a href="#21-てはかなわない" class="headerlink" title="21.~てはかなわない"></a>21.~てはかなわない</h3><div class="note note-success">            <p>「〜するのは困る」や「〜するのは耐えられない」という意味を表す表現です。「かなわない」は「対抗できない」「負ける」「耐えられない」といったニュアンスを持ちます。</p>          </div><p>この騒音では寝てはかなわない。</p><p>彼女は泣かれてはかなわない。</p><h3 id="22-ても差し支えない"><a href="#22-ても差し支えない" class="headerlink" title="22.~ても差し支えない"></a>22.~ても差し支えない</h3><div class="note note-success">            <p>「問題ない」や「大丈夫」といった意味を表します。</p>          </div><p>書類は明日提出しても差し支えありません。</p><p>会議中に退席しても差し支えないでしょうか。</p><h3 id="23-てもともとだ"><a href="#23-てもともとだ" class="headerlink" title="23.~てもともとだ"></a>23.~てもともとだ</h3><div class="note note-success">            <p>「~てもともとだ」は、ある状況や条件が変わっても、結果は変わらないことを強調するときに使われます。つまり、何かが起こったとしても、本質的には何も変わらないという意味合いを持ちます。</p>          </div><p>彼が来なくてもともとだ。</p><p>だめでもともとだから、思い切って彼女に告白してみた。</p><h3 id="24-ても始まらない"><a href="#24-ても始まらない" class="headerlink" title="24.~ても始まらない"></a>24.~ても始まらない</h3><div class="note note-success">            <p>「たとえ〜をしても、何も良い結果は生まれない」「〜をしても意味がない」</p>          </div><p>今から後悔しても始まらない。</p><p>言い訳をしても始まらないよ。</p><h3 id="25-～てやまない"><a href="#25-～てやまない" class="headerlink" title="25.～てやまない"></a>25.～てやまない</h3><div class="note note-success">            <p>ある行動や状態が継続的に行われていることを強調する表現です。</p>          </div><p>結婚する二人の今後の幸せを願ってやまない。</p><p>真実を追求してやまない。</p><h3 id="26-か-と思いきや"><a href="#26-か-と思いきや" class="headerlink" title="26.~(か)と思いきや"></a>26.~(か)と思いきや</h3><div class="note note-success">            <p>「予想や期待とは異なり、意外な結果になって」</p>          </div><p>晴れると思いきや、突然雨が降り出した。</p><p>彼女は怒ると思いきや、意外にも笑顔で許してくれた。</p><h3 id="27-〜ともなく"><a href="#27-〜ともなく" class="headerlink" title="27.〜ともなく"></a>27.〜ともなく</h3><div class="note note-success">            <p>「〜ともなく」という表現は、意識せずに行動をしている様子や、特定の対象や理由がないことを表す日本語の文法表現です。</p>          </div><p>聞くともなく隣の会話が耳に入った。</p><p>電車の窓から外を見るともなく、高校時代の同級生の姿が目に入った。</p><h3 id="28-〜ならいざしらず"><a href="#28-〜ならいざしらず" class="headerlink" title="28.〜ならいざしらず"></a>28.〜ならいざしらず</h3><div class="note note-success">            <p>「〜なら問題ないが、そうでないなら問題だ」「〜なら仕方がないが、そうでないなら受け入れられない」といった意味で使います。</p>          </div><p>小学生ならいざしらず、大学生はこの漢字を知らないのは問題だ。</p><p>新入社員ならいざしらず、入社8年にもなる君がこんなミスをするとは信じられない。</p><h3 id="29-にはあたらない"><a href="#29-にはあたらない" class="headerlink" title="29.~にはあたらない"></a>29.~にはあたらない</h3><div class="note note-success">            <p>意味: 「〜する必要はない」「〜するほどのことではない」といった意味で使われ、感情的な反応や評価を避けるときに用います。</p>          </div><p>彼なりにできるだけの努力をしたのだから、いい結果を出せなかったとしても、非難するには当たらない。</p><p>優秀な田中君のことだから、論文を１週間で仕上げたと聞いても驚くにはあたらない。</p><h3 id="30-におかれましては"><a href="#30-におかれましては" class="headerlink" title="30.~におかれましては"></a>30.~におかれましては</h3><div class="note note-success">            <p>意味: 「〜に関しては」「〜については」の丁寧な形で、相手を非常に敬った形で、その人の状況や状態を指す。</p>          </div><p>社長におかれましては、お元気でご活躍のことと存じます。</p><p>最近のご状況におかれましては、いかがでしょうか。お忙しいことと存じますが、くれぐれもご自愛ください。</p><h3 id="31-にかこつけて"><a href="#31-にかこつけて" class="headerlink" title="31.~にかこつけて"></a>31.~にかこつけて</h3><div class="note note-success">            <p>意味: 「〜を口実にして」「〜を理由にして」といった意味で、表向きの理由を使って、実際は別の意図や目的があることを示します。</p>          </div><p>彼は仕事にかこつけて、頻繁に出張し、観光地を回っている。</p><p>天気にかこつけて、今日の会議は延期されたが、実は準備が間に合わなかったらしい。</p><h3 id="32-にかまけて"><a href="#32-にかまけて" class="headerlink" title="32.~にかまけて"></a>32.~にかまけて</h3><div class="note note-success">            <p>「〜に気を取られて他のことができない」「〜に夢中になって他のことを疎かにする」といった意味で、何かに集中しすぎて、他のことをやる余裕がなくなる状況を表します。</p>          </div><p>彼は仕事にかまけて、家族との時間を全然取っていない。</p><p>スマホにかまけて、勉強が疎かになっている。</p><h3 id="33-にかたくない"><a href="#33-にかたくない" class="headerlink" title="33.~にかたくない"></a>33.~にかたくない</h3><div class="note note-success">            <p>意味: 「〜するのは難しくない」「〜を簡単に理解できる」「〜を容易に想像できる」といった意味を表します。</p>          </div><p>長年に努力してきたことが報われた時の彼の喜びは、想像に難くない。</p><p>異国の地で生活する彼女の苦労は、理解にかたくない。</p><h3 id="34-にしくはない"><a href="#34-にしくはない" class="headerlink" title="34.~にしくはない"></a>34.~にしくはない</h3><div class="note note-success">            <p>意味としては、「〜が一番よい」、「〜が最善である」、「〜するに越したことはない」という考えを表現するものです。</p>          </div><p>安全な道を選ぶにしくはない。</p><p>事前に準備しておくにしくはない。</p><h3 id="35-に忍びない"><a href="#35-に忍びない" class="headerlink" title="35.~に忍びない"></a>35.~に忍びない</h3><div class="note note-success">            <p>「〜に忍びない」という表現は、感情的に耐えられず、ある行為をするのがつらい、または心苦しいと感じるときに使います。</p>          </div><p>彼の写真を捨てるに忍びない。</p><p>その小説の最後の場面はあまりに悲しくて、読むに忍びない。</p><h3 id="36-にたえる"><a href="#36-にたえる" class="headerlink" title="36.~にたえる"></a>36.~にたえる</h3><div class="note note-success">            <p>「〜にたえる（〜に堪える）」は、「〜する価値がある」「〜に耐えられる」という意味を持つ日本語の表現です。主に二つの使い方があります。</p>          </div><p>この映画は見るにたえる作品だ。</p><p>この痛みは堪えるに堪えない。</p><h3 id="37-にとどまらず"><a href="#37-にとどまらず" class="headerlink" title="37.~にとどまらず"></a>37.~にとどまらず</h3><div class="note note-success">            <p>「〜にとどまらず」という表現は、何かが特定の範囲や状況に「とどまる（留まる）」ことなく、さらに広がっている、または影響を及ぼしていることを示す表現です。つまり、「〜だけではなく、さらに」という意味を持ちます。</p>          </div><p>彼の影響は国内にとどまらず、海外にも広がっている。</p><p>この技術は企業内にとどまらず、一般家庭にも普及している。</p><h3 id="38-にひきかえ"><a href="#38-にひきかえ" class="headerlink" title="38.~にひきかえ"></a>38.~にひきかえ</h3><div class="note note-success">            <p>意味：「〜に対して」、「〜と比べて」</p>          </div><p>彼の努力しているにひきかえ、結果が出ていない。</p><p>新製品の売上が好調なにひきかえ、旧製品は苦戦している。</p><h3 id="39-にも増して"><a href="#39-にも増して" class="headerlink" title="39.~にも増して"></a>39.~にも増して</h3><div class="note note-success">            <p>「〜にも増して」は、「〜以上に」と同じ意味で、ある状況や程度がより強く、またはより重要であることを表します。</p>          </div><p>今年の夏は、去年にも増して暑い。</p><p>いつにも増して彼は元気そうだ。</p><h3 id="40-の至りだ"><a href="#40-の至りだ" class="headerlink" title="40.~の至りだ"></a>40.~の至りだ</h3><div class="note note-success">            <p>「非常に〜だ」「極めて〜だ」</p>          </div><p>このような賞をいただき、光栄の至りです。</p><p>皆様の温かいご支援に対し、感激の至りです。</p><h3 id="41-にさておいて・はさておき"><a href="#41-にさておいて・はさておき" class="headerlink" title="41.~にさておいて・はさておき"></a>41.~にさておいて・はさておき</h3><div class="note note-success">            <p>「〜はさておいて」は、何かを一旦脇に置いて、別のことに話題や焦点を移す際に使われる表現です。話の流れの中で、前に述べた内容や問題を一時的に保留して、別の重要なことについて言及したい場合に使います。</p>          </div><p>実現できるかとうかはさておき、まずは新商品のアイディアをみんなで出してみよう。</p><p>社員旅行の件ですが、費用のことはさておいて、まず日程について検討してみましょう。</p><h3 id="42-はそっちのけで・をそっちのけで"><a href="#42-はそっちのけで・をそっちのけで" class="headerlink" title="42.~はそっちのけで・をそっちのけで"></a>42.~はそっちのけで・をそっちのけで</h3><div class="note note-success">            <p>「そっちのけ」とは「そのことを無視する」「放っておく」という意味で、主に否定的なニュアンスで使われます。</p>          </div><p>宿題はそっちのけで、ゲームばかりしている。</p><p>大学4年生の弟は就職のことはそっちのけで、毎日パソコンゲームに没頭している。</p><h3 id="43-羽目になる・羽目に陥る"><a href="#43-羽目になる・羽目に陥る" class="headerlink" title="43.~羽目になる・羽目に陥る"></a>43.~羽目になる・羽目に陥る</h3><div class="note note-success">            <p>「〜羽目になる」や「〜羽目に陥る」は、意図しない結果や不幸な状況に陥ることを表す表現です。</p>          </div><p>遅刻してしまい、会議に出られない羽目になった。</p><p>お金を借りたことが原因で、返済のプレッシャーに陥る羽目になった。</p><h3 id="44-べからず"><a href="#44-べからず" class="headerlink" title="44.~べからず"></a>44.~べからず</h3><div class="note note-success">            <p>意味としては「〜してはならない」「〜すべきではない」という禁止や戒めを表します。形式は動詞の辞書形に「べからず」を付けて作られます。</p>          </div><p>企業から多額のお金を受け取るなんて、政治家としてゆるすべからざる行為だ。</p><p>彼はうちの会社にとって欠くべからざる人材だ。</p><h3 id="45-まじき"><a href="#45-まじき" class="headerlink" title="45.~まじき"></a>45.~まじき</h3><div class="note note-success">            <p>主に道徳的・社会的に「〜してはならない」「〜ふさわしくない」という意味を表します。具体的には、「あるべきではない」「許されない行為や態度」を強調する際に使われます。</p>          </div><p>彼の言動は社会人としてあるまじきもので、とうてい許すことはできない。</p><p>彼のやったことは、人としてあるまじき残酷な行為だ。</p><h3 id="46-めく・めいて・めいた"><a href="#46-めく・めいて・めいた" class="headerlink" title="46.~めく・めいて・めいた"></a>46.~めく・めいて・めいた</h3><div class="note note-success">            <p>「〜めく」「〜めいて」「〜めいた」は、物事や人の様子、性質を表現する際に使われる言葉です。</p>          </div><p>そんな皮肉めいた言い方をしないでください。</p><p>雪が溶けて、野の花が咲き始め、日差しも春めいてきた。</p><h3 id="47-もさることながら"><a href="#47-もさることながら" class="headerlink" title="47.~もさることながら"></a>47.~もさることながら</h3><div class="note note-success">            <p>「〜もさることながら」は、ある事柄を強調しつつ、その上で別の事柄も重要であることを示す表現です。通常、前半に言及したことが重要であると認めつつ、後半でそれに劣らず重要なことを追加します。</p>          </div><p>彼の実力もさることながら、努力も評価されるべきだ。</p><p>両親は、息子に病院の跡を継いで医者になって欲しいと思っているようだ。だが、親の希望もさることながら、やはり本人の気持ちが第一だろう。</p><h3 id="48-を皮切りに"><a href="#48-を皮切りに" class="headerlink" title="48.~を皮切りに"></a>48.~を皮切りに</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>このプロジェクトは、会議を皮切りに始まりました。</p><p>旅行を皮切りに、さまざまな国を訪れました。</p><h3 id="49-を蔑ろにする"><a href="#49-を蔑ろにする" class="headerlink" title="49.~を蔑ろにする"></a>49.~を蔑ろにする</h3><div class="note note-success">            <p>「~をきっかけに」という意味で、何かの始まりや出発点を示す表現です。この文法は、ある出来事や行動を契機として、次に続く事柄が起こることを強調します。</p>          </div><p>彼はチームの意見を蔑ろにして、自分の考えだけを押し通した。</p><p>友人の気持ちを蔑ろにするような行動は避けるべきだ。</p><h3 id="50-をなおざりにして"><a href="#50-をなおざりにして" class="headerlink" title="50.~をなおざりにして"></a>50.~をなおざりにして</h3><div class="note note-success">            <p>何かをいい加減に扱ったり、手を抜いたりすることを意味する表現です。このフレーズは、重要な事柄を怠ったり、十分に注意を払わないことを示します。</p>          </div><p>どんなことがあっても、仕事をなおざりにしてはいけない。</p><p>彼は仕事をなおざりにして、結果的にトラブルを引き起こした。</p><h3 id="51-を控え"><a href="#51-を控え" class="headerlink" title="51.~を控え"></a>51.~を控え</h3><div class="note note-success">            <p>「~を控えて」は、特定の行動や状況を踏まえて、それに関連する行動や注意を促す際に使われる表現です。</p>          </div><p>試験を控えて、しっかり勉強する必要があります。</p><p>引越しを控えて、整理整頓を始めました。</p><h3 id="52-を振り出しに"><a href="#52-を振り出しに" class="headerlink" title="52.~を振り出しに"></a>52.~を振り出しに</h3><div class="note note-success">            <p>ある出来事や行動をきっかけとして、その後の展開や進展が始まることを示す表現です。</p>          </div><p>彼女は転職を振り出しに、キャリアは一新しました。</p><p>彼は小学校の教師を振り出しに社会に出た。</p>]]></content>
    
    
    <categories>
      
      <category>N1学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日本語</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学公式用法整理</title>
    <link href="/2024/09/08/Math-formula/"/>
    <url>/2024/09/08/Math-formula/</url>
    
    <content type="html"><![CDATA[<h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><blockquote><p>升级后的插件需要双反斜杠“\\\\”，网页才能正确渲染下来</p></blockquote><p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x\leq 0 \\<br>x, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p><h1 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h1><blockquote><p>array和aligned都不适配当前需求，直接用cases环境</p></blockquote><p>$$<br>\begin{cases}<br>    a_1x + b_1y + c_1z &#x3D; d_1 \\<br>    a_2x + b_2y + c_2z &#x3D; d_2 \\<br>    a_3x + b_3y + c_3z &#x3D; d_3<br>\end{cases}<br>$$</p><h1 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h1><p>$$<br>J(\theta) &#x3D; \frac{1}{2m}\sum_{i &#x3D; 0} ^m(y^i - h_\theta (x^i))^2<br>$$</p><h1 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h1><p>$$<br>\frac{\partial J(\theta)}{\partial\theta_j}&#x3D;-\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>$$</p><h1 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h1><p>$$<br>\begin{aligned}<br>\frac{\partial J(\theta)}{\partial\theta_j}<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i)) \frac{\partial}{\partial\theta_j}(\sum_{j&#x3D;0}^n\theta_jx_j^i-y^i) \\<br>&amp; &#x3D; -\frac1m\sum_{i&#x3D;0}^m(y^i-h_\theta(x^i))x^i_j<br>\end{aligned}<br>$$</p><h1 id="case环境的使用"><a href="#case环境的使用" class="headerlink" title="case环境的使用"></a>case环境的使用</h1><p>$$<br>a &#x3D;<br>   \begin{cases}<br>     \int x, \mathrm{d} x\\<br>     b^2<br>   \end{cases}<br>$$</p><h1 id="带方框的等式"><a href="#带方框的等式" class="headerlink" title="带方框的等式"></a>带方框的等式</h1><p>$$<br>\begin{aligned}<br> \boxed{x^2+y^2 &#x3D; z^2}<br>\end{aligned}<br>$$</p><h1 id="最大（最小）操作符"><a href="#最大（最小）操作符" class="headerlink" title="最大（最小）操作符"></a>最大（最小）操作符</h1><p>$$<br>\begin{gathered}<br>\operatorname{arg,max}_a f(a)<br> &#x3D; \operatorname*{arg,max}_b f(b) \\<br> \operatorname{arg,min}_c f(c)<br> &#x3D; \operatorname*{arg,min}_d f(d)<br>\end{gathered}<br>$$</p><h1 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h1><p>$$<br>\begin{aligned}<br>  \lim_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \lim\nolimits_{a\to \infty} \tfrac{1}{a}<br>\end{aligned}<br>$$</p><h1 id="求积分"><a href="#求积分" class="headerlink" title="求积分"></a>求积分</h1><p>$$<br>\begin{aligned}<br>   \int_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>   \int\limits_a^b x^2  \mathrm{d} x<br>\end{aligned}<br>$$</p><h1 id="多行表达公式"><a href="#多行表达公式" class="headerlink" title="多行表达公式"></a>多行表达公式</h1><p>$$<br>\begin{aligned}<br>J(\mathbf{w})&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m(f(\mathbf{x_i})-y_i)^2\\<br>&amp;&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m [f(\mathbf{x_i})]^2-2f(\mathbf{x_i)}y_i+y_i^2<br>\end{aligned}<br>$$</p><h1 id="小括号矩阵"><a href="#小括号矩阵" class="headerlink" title="小括号矩阵"></a>小括号矩阵</h1><p>$$\left(<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right)<br>\tag{2}<br>$$</p><h1 id="中括号矩阵"><a href="#中括号矩阵" class="headerlink" title="中括号矩阵"></a>中括号矩阵</h1><p>$$\left[<br>\begin{matrix}<br>1 &amp; 2 &amp; 3\\<br>4 &amp; 5 &amp; 6 \\<br>7 &amp; 8 &amp; 9<br>\end{matrix}<br>\right]<br>\tag{3}<br>$$</p><h1 id="带省略号的矩阵"><a href="#带省略号的矩阵" class="headerlink" title="带省略号的矩阵"></a>带省略号的矩阵</h1><p>$$<br>\left[<br>\begin{matrix}<br>a &amp; b &amp; \cdots &amp; a\\<br>b &amp; b &amp; \cdots &amp; b\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>c &amp; c &amp; \cdots &amp; c<br>\end{matrix}<br>\right]<br>\tag{5}<br>$$</p><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><p>$\sin^2\alpha+\cos^2\alpha&#x3D;1$</p><p>$\cfrac{\sin\alpha}{\cos\alpha}&#x3D;\tan\alpha$</p><p>$\sin(2k\pi+\alpha)&#x3D;\sin\alpha(k\in Z)$</p><p>$\cos(2k\pi+\alpha)&#x3D;\cos\alpha(k\in Z)$</p><p>$\tan(2k\pi+\alpha)&#x3D;\tan\alpha(k\in Z)$</p><p>$\cot(2k\pi+\alpha)&#x3D;\cot\alpha(k\in Z)$</p><p>$\sin(\pi+\alpha)&#x3D;-\sin\alpha$</p><p>$\cos(\pi+\alpha)&#x3D;-\cos\alpha$</p><p>$\tan(\pi+\alpha)&#x3D;\tan\alpha$</p><p>$\cot(\pi+\alpha)&#x3D;\cot\alpha$</p><p>$\sin(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\sin\alpha(n为偶数)\\<br>(-1)^{\cfrac{n-1}{2}}\cos\alpha(n为奇数)\end{cases}$</p><p>$\cos(\cfrac{n\pi}{2}+\alpha) &#x3D; \begin{cases} (-1)^{\cfrac{n}{2}}\cos\alpha(n为偶数)\\(-1)^{\cfrac{n+1}{2}}\sin\alpha(n为奇数)\end{cases}$</p><p>$$<br>\left[<br>    \begin{array}{c|cc}<br>    1 &amp; 2 &amp; 3 \\ \hline<br>    4 &amp; 5 &amp; 6 \\<br>    7 &amp; 8 &amp; 9<br>    \end{array}<br>\right]<br>\tag{7}<br>$$</p><p>$$x&#x3D;a_0 + \frac{1^2}{a_ 1+\frac{2^2}{a_2+\frac{3^2}{a_3+ \frac{4^2}{a_4+…}}}}$$</p><p>$a \equiv b \pmod n$</p><h1 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h1><p>$$<br>e^{i\pi} + 1 &#x3D; 0<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/08/hello-world/"/>
    <url>/2024/09/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
