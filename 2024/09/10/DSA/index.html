

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="toutou">
  <meta name="keywords" content="">
  
    <meta name="description" content="Data Structure &amp; AlgorithmsThis is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(偷偷).The main language is in Chinese but y">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structure &amp; Algorithms">
<meta property="og:url" content="http://toutou.zeabur.app/2024/09/10/DSA/index.html">
<meta property="og:site_name" content="偷偷星球">
<meta property="og:description" content="Data Structure &amp; AlgorithmsThis is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(偷偷).The main language is in Chinese but y">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/binary_search.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/merge_sort.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/insertation_sort.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/bubble_sort.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/selection_sort.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/quick_sort.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/heap_sort.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/linkedlist.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/hash.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/KMP.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/binary_tree.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/rpn.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/avl_tree_insert.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/avl_tree_delete.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/avl_tree_rotate.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/adjacency_matrix.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/bfs.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/dfs.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/topo_sort.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/union_find.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/kruskal.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/prim.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/dijkstra.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/bellman_ford.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/floyd.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/ford.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/bha.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/kadane.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/merge.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/01knapsnack.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/lcs.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DSA/needle.svg">
<meta property="article:published_time" content="2024-09-10T14:51:46.000Z">
<meta property="article:modified_time" content="2025-09-14T13:22:09.514Z">
<meta property="article:author" content="toutou">
<meta property="article:tag" content="修考">
<meta property="article:tag" content="DSA">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://toutou.zeabur.app/img/DSA/binary_search.svg">
  
  
  
  <title>Data Structure &amp; Algorithms - 偷偷星球</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"toutou.zeabur.app","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>偷偷星球</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/wall.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Data Structure &amp; Algorithms"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-10 23:51" pubdate>
          September 10, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          158 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Data Structure &amp; Algorithms</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Data-Structure-Algorithms"><a href="#Data-Structure-Algorithms" class="headerlink" title="Data Structure &amp; Algorithms"></a>Data Structure &amp; Algorithms</h1><p>This is for test takers to quickly review the basics and key points of DSA. Moreover, this is the masterpiece written by toutou(<strong>偷偷</strong>).The main language is in Chinese but you can see some concepts in English &amp; Japanese. And the pseudocode is in the style of <strong>C++</strong>. Let’s quickly review this subject!</p>
<p>这是偷偷刷了很多修考题之后总结出来的修考秘籍，全文都是考点，彻底高能。</p>
<h2 id="1-Introduction-to-Algorithms"><a href="#1-Introduction-to-Algorithms" class="headerlink" title="1. Introduction to Algorithms"></a>1. Introduction to Algorithms</h2><p>这一章主要计划复习<strong>时间复杂度(Time Complexity)</strong> 和 <strong>空间复杂度(Space Complexity)</strong> 两个概念，然后再仔细回顾 <strong>分治递归(DIvide &amp; Conquer)</strong> 这一重要的概念。最后再给出解决时间复杂度常用的分析方法和万能的<strong>主定理公式（Master Theorem）</strong></p>
<h3 id="1-1-时间复杂度与空间复杂度"><a href="#1-1-时间复杂度与空间复杂度" class="headerlink" title="1.1 时间复杂度与空间复杂度"></a>1.1 时间复杂度与空间复杂度</h3><div class="note note-success">
            <p><strong>Space Complexity</strong>: 空间复杂度描述的是算法运行时所需的额外内存空间。通俗解释就是算法在运行的时候需要开辟多少空间的大小。O(1)指一个点集；O(n)就是开辟一个一维空间；O(n^2)开辟二维空间；O(n^3)开辟三维空间。在第二章讲解排序算法的时候，也会用到本章非常多的前置知识。</p>
          </div>

<p>O(1): 常数空间复杂度，表示算法所需的额外空间是固定的，不随输入规模变化。例如，一个固定大小的变量。</p>
<p>O(n): 线性空间复杂度，表示算法所需的额外空间与输入规模成正比。例如，一个长度为 n 的数组。</p>
<p>O(n^2): 平方空间复杂度，表示算法所需的额外空间与输入规模的平方成正比。例如，一个 n x n 的二维数组。</p>
<p>O(n^3): 立方空间复杂度，表示算法所需的额外空间与输入规模的立方成正比。例如，一个 n x n x n 的三维数组。</p>
<p>一些常见的数据结构的空间复杂度：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> nums <span class="token comment">// 三维数组：O(n^3)</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> nums <span class="token comment">// 二维数组：O(n^2)</span>
stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>      <span class="token comment">// 栈：O(n)</span>
deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token comment">// 双端队列：O(n)</span>
list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> linkedList<span class="token punctuation">;</span>   <span class="token comment">// 链表：O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<div class="note note-success">
            <p><strong>Time complexity</strong>: 时间复杂度是衡量算法效率的重要指标之一，它描述了算法执行所需时间随输入规模增长的变化情况。这是修考中必考的一个地方：（1）如分析给出的代码的时间复杂度（Hint：关注for，while循环）（2）根据源代码优化时间复杂度设计新的算法（Hint：空间换时间）</p>
          </div>
<p>常见的时间复杂度有以下几种：</p>
<p>O(1): <strong>常数时间复杂度</strong>，算法的执行时间不随输入规模变化。例如，访问数组中的某个元素。</p>
<p><code>int a = nums[10]  // 给a赋值数组下标为10的元素</code></p>
<p>O(n): <strong>线性时间复杂度</strong>，算法的执行时间与输入规模成正比。例如，遍历一个长度为 n 的数组。</p>
<p><code>for (int i = 0; i &lt; n; i++) &#123; /* 操作 */ &#125;</code></p>
<p>O(log n): 对数时间复杂度，算法的执行时间随输入规模的对数增长。例如，二分查找(Binary Search)算法。</p>
<p><code>int binarySearch(int[] arr, int target) &#123; /* 二分查找逻辑 */ &#125;</code></p>
<p> O(n^2) : <strong>平方时间复杂度</strong>，算法的执行时间与输入规模的平方成正比。例如，冒泡排序(Bubble Sort)算法。</p>
<p><code>for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; /* 冒泡排序逻辑 */ &#125; &#125;</code></p>
<p>O(2^n): <strong>指数时间复杂度</strong>，算法的执行时间随输入规模的指数增长。例如，解决所有子集问题的递归算法。</p>
<p><code>void subsets(int[] nums) &#123; /* 递归逻辑 */ &#125;</code></p>
<p>在描述使劲复杂度的时候，有三种表示需要注意一下：</p>
<p>$O$: 表示渐进上界； $\Omega$: 表示渐进下界； $\Theta$: 渐进紧确界</p>
<h3 id="1-2-分治递归-Divide-Conquer"><a href="#1-2-分治递归-Divide-Conquer" class="headerlink" title="1.2 分治递归(Divide &amp; Conquer)"></a>1.2 分治递归(Divide &amp; Conquer)</h3><div class="note note-success">
            <p>分治递归(Divide &amp; conquer)的思想是将原问题分割成更小的子问题，自顶向下地解决每个子问题，并最终自底向上合并它们的解来解决主问题。</p>
          </div>

<p>常见的分治递归有：二分查找(Binary Search) 和归并排序(Merge Sort).</p>
<h4 id="1-2-1-二分查找-Binary-Search"><a href="#1-2-1-二分查找-Binary-Search" class="headerlink" title="1.2.1 二分查找(Binary Search)"></a>1.2.1 二分查找(Binary Search)</h4><img src="/img/DSA/binary_search.svg" srcset="/img/loading.gif" lazyload alt="二分查找演示" style="max-width: 100%; height: auto;" />

<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 前提nums是有序数组</span>
<span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// (避免left + right) / 2 的溢出</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>   <span class="token comment">// 找到目标，返回索引</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 目标在左半部分</span>
        <span class="token keyword">else</span> left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 目标在右半部分</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>根据上图我们得出递归表达式：<br>$T(n) &#x3D; T(n &#x2F; 2) + O(1)$， 得出$T(n) &#x3D; O(log_{2}{n})$</p>
<h4 id="1-2-2-归并排序-Merge-Sort"><a href="#1-2-2-归并排序-Merge-Sort" class="headerlink" title="1.2.2 归并排序(Merge Sort)"></a>1.2.2 归并排序(Merge Sort)</h4><img src="/img/DSA/merge_sort.svg" srcset="/img/loading.gif" lazyload alt="归并排序演示" style="max-width: 100%; height: auto;" />
这个图像有效地展示了归并排序的"分而治之"策略：
 1.将大问题（排序整个数组）分解成小问题（排序子数组）
 2.解决小问题（对小数组排序）
 3.将小问题的解合并成大问题的解（合并有序子数组）

<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 合并两个有序的子数组</span>
<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子数组的长度</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> right <span class="token operator">-</span> mid<span class="token punctuation">;</span>     <span class="token comment">// 右子数组的长度</span>

    <span class="token comment">// 创建临时数组存储左右子数组</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftArr</span><span class="token punctuation">(</span>n1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rightArr</span><span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 复制数据到临时数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> rightArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span>  <span class="token comment">// i是左子数组指针，j是右子数组指针，k是合并后数组的指针</span>

    <span class="token comment">// 合并左右子数组</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 将剩余的左子数组元素加入nums</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> leftArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 将剩余的右子数组元素加入nums</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> rightArr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 递归实现归并排序</span>
<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token comment">// 递归排序左右两部分</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 合并已排序的部分</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>递归式：$T(n) &#x3D; 2T(n &#x2F; 2) + O(n)$, 所以$T(n) &#x3D; O(nlog_{2}{n})$</p>
<h3 id="1-3-主定理-Master-Theorem"><a href="#1-3-主定理-Master-Theorem" class="headerlink" title="1.3 主定理(Master Theorem)"></a>1.3 主定理(Master Theorem)</h3><p>递归方程形式如：<br>$$T(n) &#x3D; aT(n &#x2F; b) + O(n^d)$$</p>
<div class="note note-success">
            <p>其中，$a$表示子问题的数量，b表示每个子问题是原问题规模的$1&#x2F;b$, $O(n^d)$ 表示在每一层分治过程之外，解决问题所需的额外代价，通常是合并或分割的代价。</p>
          </div>



<p><strong>情况 1：</strong><br>如果$log_{b}{a} &gt; d$，则递归式的解为：</p>
<p>$$ T(n) &#x3D; O(n^{log_{b}{a}}) $$</p>
<p><strong>解释：</strong> 在这种情况下，分治产生的子问题数量增长得更快，主导时间复杂度的是递归中的分治部分。</p>
<p><strong>情况 2：</strong><br>如果$log_{b}{a} &#x3D; d$，则递归式的解为：</p>
<p>$$ T(n) &#x3D; O(n^d\log{n}) $$</p>
<p><strong>解释：</strong> 在这种情况下，分治和额外开销的增长速度相同，因此总的时间复杂度是 $n^d\log{n}$。</p>
<p><strong>情况 3：</strong><br>如果 $log_{b}{a} &lt; d$，则递归式的解为：<br>$$T(n) &#x3D; O(n^d)$$<br><strong>解释：</strong> 在这种情况下，额外的开销主导时间复杂度，因此复杂度主要由 $n^d$决定。</p>
<p><strong>斯特林近似公式（Stirling’s Formula）:</strong> $n! \approx \sqrt{2 \pi n} \left( \frac{n}{e} \right)^n$</p>
<h2 id="2-Sorting-Algorithm"><a href="#2-Sorting-Algorithm" class="headerlink" title="2.Sorting Algorithm"></a>2.Sorting Algorithm</h2><p>再时间复杂度和空间复杂度的概念后，并引入了分治递归和归并排序算法；接下来这一章就主要回顾常见的一些排序算法，然后分析他们的时间复杂度和空间复杂度。</p>
<h3 id="2-1-插入排序-Insertion-Sort"><a href="#2-1-插入排序-Insertion-Sort" class="headerlink" title="2.1 插入排序(Insertion Sort)"></a>2.1 <strong>插入排序(Insertion Sort)</strong></h3><p>这个算法的过程也很直观：插入排序的核心思想是将一个新元素插入到已经排好序的子序列中的适当位置。<br><img src="/img/DSA/insertation_sort.svg" srcset="/img/loading.gif" lazyload alt="插入排序演示" style="max-width: 100%; height: auto;" /><br>最好的情况下是：原数组规模小或者大部分数据有序，那么我们一次遍历就可以完成好排序。 最坏的情况下是：原数组是降序排列的，意思是每一次插入新元素的时候，都要遍历一遍已排好序的子数组。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 从第二个元素开始</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token comment">// 回溯检查并交换</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>最坏情况：$T(n) &#x3D; T(n - 1) + O(n)$,  $T(n) &#x3D; O(n^2)$</p>
<p>最好情况：$T(n) &#x3D; T(n - 1) + O(1)$,  $T(n) &#x3D; O(n)$</p>
<h3 id="2-2冒泡排序-Bubble-Sort"><a href="#2-2冒泡排序-Bubble-Sort" class="headerlink" title="2.2冒泡排序(Bubble Sort)"></a>2.2冒泡排序(Bubble Sort)</h3><p>冒泡排序是一个直观的算法，通过重复地遍历数组来工作。在每次遍历中，它比较相邻的元素并在需要时交换它们，这样每次迭代都会将当前未排序部分中的最大元素’冒泡’到数组的末尾正确位置。这个过程从左到右重复进行，直到整个数组排序完成。一句话概括就是：不断的进行两两比较。<br><img src="/img/DSA/bubble_sort.svg" srcset="/img/loading.gif" lazyload alt="冒泡排序演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 控制循环的轮数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 内层循环，相邻比较</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 交换元素</span>
                std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>冒泡排序平均时间复杂度</strong>：$T(n) &#x3D; O(n^2)$</p>
<h3 id="2-3选择排序-Selection-Sort"><a href="#2-3选择排序-Selection-Sort" class="headerlink" title="2.3选择排序(Selection Sort)"></a>2.3选择排序(Selection Sort)</h3><p>选择排序的基本思想是分阶段地将数组划分为两部分：已排序部分和未排序部分。每一轮从未排序部分中找到最小（或最大）的元素，放到已排序部分的末尾，直到整个数组排序完成。<br><img src="/img/DSA/selection_sort.svg" srcset="/img/loading.gif" lazyload alt="选择排序演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 已排序数组末尾</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token comment">// 找未排序数组中的最小元素</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIdx <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>选择排序时间复杂度：</strong> $T(n) &#x3D; O(n^2)$</p>
<h3 id="2-4快速排序-Quick-Sort"><a href="#2-4快速排序-Quick-Sort" class="headerlink" title="2.4快速排序(Quick Sort)"></a>2.4快速排序(Quick Sort)</h3><p>快速排序的本质是分治法。它通过选择一个基准元素，将原数组划分为小于基准元素和大于基准元素的两个子数组，然后对这两个子数组进行递归排序。<br><img src="/img/DSA/quick_sort.svg" srcset="/img/loading.gif" lazyload alt="快速排序演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 分区函数</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 选择最后一个元素作为基准</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 小于基准的元素的索引</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果当前元素小于或等于基准</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// 增加小于基准的元素索引</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 快速排序函数</span>
<span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// pi是分区索引，arr[pi]现在在正确的位置</span>
        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 分别对左右子数组进行递归排序</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>在最坏情况下，基准元素可能是最大或最小值，这会导致一个子数组为空，另一个子数组的大小为 $n-1$，此时的时间复杂度为 $T(n) &#x3D; T(n-1) + O(n) &#x3D;O(n^2)$。而在平均情况下，基准元素能够较好地划分数组，时间复杂度为 $T(n) &#x3D; 2T(n&#x2F;2) + O(n)&#x3D;O(n\log{n})$ 。</p>
<h3 id="2-5堆排序-Heap-Sort"><a href="#2-5堆排序-Heap-Sort" class="headerlink" title="2.5堆排序(Heap Sort)"></a>2.5堆排序(Heap Sort)</h3><p>这个考点应该是修考最爱考的一个了！（敲重点）堆排序的基本思想是不断维护一个最大堆。在每次排序过程中，首先将最大堆的根节点（最大值）与堆的最后一个元素交换，然后缩小堆的范围（排除最后一个元素），并对新的根节点进行下沉操作，以恢复最大堆的性质。重复这一过程，直到所有元素都被排序。<br><img src="/img/DSA/heap_sort.svg" srcset="/img/loading.gif" lazyload alt="堆排序演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 堆化函数，用于维护最大堆性质</span>
<span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment">// 初始化最大值为根</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 左子节点</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 右子节点</span>

    <span class="token comment">// 如果左子节点大于根</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>
        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>

    <span class="token comment">// 如果右子节点大于当前最大值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>
        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>

    <span class="token comment">// 如果最大值不是根</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 递归地堆化受影响的子树</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 堆排序函数</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 构建最大堆（从最后一个非叶子节点开始）</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 一个个从堆顶取出元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 将当前根移到末尾</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 在减小的堆上调用 max heapify</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>建堆的时间复杂度为$O(n)$,每个节点的调整最多为$O(\log{n})$次。在排序的过程中需要建堆$O(n)$次，并且每次需要$O(logn)$来维护堆(heapify),因此对排序总的时间复杂度为$O(n\log{n})$</p>
<h2 id="3-Data-Structure"><a href="#3-Data-Structure" class="headerlink" title="3.Data Structure"></a>3.Data Structure</h2><p>这一章主要讲解常见的数据结构,如栈(stack),队列(queue),链表(linked list),哈希表(hash map),以及字符串(string)。二叉树考点众多我会单独做成一章并且和图算法一块复习。</p>
<h3 id="3-1-Stack-Queue"><a href="#3-1-Stack-Queue" class="headerlink" title="3.1 Stack &amp; Queue"></a>3.1 Stack &amp; Queue</h3><p><strong>栈(stack)</strong> :后进先出(LIFO), <strong>队列</strong> :先进先出(FIFO)。另外，栈和队列是可以相互实现的，了解到这个程度，我认为就掌握到栈和队列的基本性质了。</p>
<p><em>Q1: 如何用栈实现队列？</em></p>
<div class="note note-success">
            <p>A: 开两个栈，一个负责栈负责放入元素，另一个栈负责弹出元素</p>
          </div>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 一个栈负责放入元素，一个栈负责弹出元素</span>
    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>  
    <span class="token function">MyQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// 模拟入队过程</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 模拟弹出队首元素过程</span>
    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        out<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 获取队首元素的值</span>
    <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 获取队首元素的值</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 放回</span>
        out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><em>Q2：如何用队列实现栈？</em></p>
<div class="note note-success">
            <p>A：开两个队列，一个模拟入栈，一个模拟出栈。更优化的方式是直接开一个队列即可,不断的出队入队就可以实现栈的性质。</p>
          </div>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 一个队列负责入栈，一个负责出栈</span>
    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> in<span class="token punctuation">,</span> out<span class="token punctuation">;</span>
    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    
    <span class="token comment">// 放入元素</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 把in队列的元素不断出队只剩一个，即时栈顶</span>
    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        in<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换两个队列</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 获取栈顶的元素</span>
    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取弹出后的值</span>
        in<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 再放入队列</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> in<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>优化后的实现：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>
    <span class="token function">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// 放入元素</span>
    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 弹出栈顶元素</span>
    <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      n<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 把对位元素调整到队首</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token keyword">int</span> ans <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>  
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 获取栈顶元素  </span>
    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> ans<span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="3-2-Linked-List"><a href="#3-2-Linked-List" class="headerlink" title="3.2 Linked List"></a>3.2 Linked List</h3><p>常见的链表有单链表和双链表。<em>单链表</em>：每个节点只包含一个指向下一个节点的指针，访问节点时只能从头节点开始向后遍历。<em>双链表</em>：每个节点包含两个指针，一个指向下一个节点，另一个指向前一个节点。这使得可以在链表中向前和向后遍历。<br><img src="/img/DSA/linkedlist.svg" srcset="/img/loading.gif" lazyload alt="链表演示" style="max-width: 100%; height: auto;" /></p>
<p><strong>链表的优缺点</strong></p>
<p><em>优点</em>：1)动态大小：链表的大小可以动态调整，不像数组那样需要预先定义大小。2)方便插入和删除：在链表中插入或删除节点的时间复杂度为 O(1)，只需调整指针，而数组则可能需要移动大量元素。</p>
<p><em>缺点</em>：1)内存占用：每个节点需要额外的存储空间来存储指针，导致比数组更高的内存开销。2)随机访问困难：链表不支持快速随机访问，查找元素的时间复杂度为 O(n)。</p>
<h3 id="3-3-Hash-Map"><a href="#3-3-Hash-Map" class="headerlink" title="3.3 Hash Map"></a>3.3 Hash Map</h3><p><strong>哈希映射（Hash Map）</strong> 是一种数据结构，用于以键值对（key-value pairs）形式存储数据。它通过一个哈希函数将键映射到数组中的索引，从而实现快速的数据访问。主要特点有：</p>
<p>1）快速查找：平均情况下，哈希映射可以在 O(1) 时间内进行查找、插入和删除操作。</p>
<p>2）键值对存储：每个元素都由一个唯一的键和与之关联的值组成，可以通过键快速访问对应的值。</p>
<p>3）哈希函数：将键转换为数组索引的函数，好的哈希函数可以减少冲突（不同键映射到相同索引）。</p>
<p>4）处理冲突：常用的方法包括<strong>链式法(chaining)<strong>和</strong>开放寻址法（open addressing）</strong>。<br><img src="/img/DSA/hash.svg" srcset="/img/loading.gif" lazyload alt="哈希表处理冲突演示" style="max-width: 100%; height: auto;" /></p>
<p>为了减少哈希冲突，哈希映射的函数要尽量将不同的输入键均匀地映射到哈希表的不同索引，以减少冲突（即不同键映射到相同索引的情况）。</p>
<h3 id="3-4-String"><a href="#3-4-String" class="headerlink" title="3.4 String"></a>3.4 String</h3><p>字符串这个数据结构直观易懂，主要涉及到的考点有KMP算法和sequence alignment算法。这里主要回顾一下KMP算法，关于string类型的其他考点：最长子序列问题和序列比对(Sequence Alignment)，会在后面动态规划章节中仔细讲解。</p>
<h4 id="3-4-1-KMP算法"><a href="#3-4-1-KMP算法" class="headerlink" title="3.4.1 KMP算法"></a>3.4.1 KMP算法</h4><p>KMP算法可以说是学一次忘一次……建议考前一定要临时报佛脚记一下。这个算法的美妙之处就是在于优化了暴力匹配，用前缀表来跳过重复的匹配过程。前缀表就是模式串中每个位置的最长相等前缀和后缀的长度。在发生不匹配的情况下，将子串移动前一个字符串的前缀表的具体值。（感觉京大最喜欢考KMP算法了）<br><img src="/img/DSA/KMP.svg" srcset="/img/loading.gif" lazyload alt="KMP算法演示" style="max-width: 100%; height: auto;" /></p>
<p><strong>🔹1. 什么是 <code>next</code> 数组？</strong></p>
<p>对于一个模式串 <code>pattern</code>，<code>next[i]</code> 表示：<strong>当 <code>pattern[i]</code> 失配时，下一步应该跳转到的位置</strong>（也就是前缀和后缀最长相等的长度）。</p>
<p>更具体地说：<code>next[i]</code> 是 <code>pattern[0:i]</code>（不包括 <code>pattern[i]</code>）的<strong>最长相等前后缀的长度</strong>。</p>
<p><strong>🔹2. 示例：构建 <code>next</code> 数组</strong></p>
<p>以字符串 <code>pattern = &quot;ababaca&quot;</code> 为例，构建 <code>next</code> 数组如下：</p>
<table>
<thead>
<tr>
<th>i（位置）</th>
<th>pattern[i]</th>
<th>next[i]</th>
<th>前缀-后缀说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>a</td>
<td>0</td>
<td>没有前缀和后缀</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>0</td>
<td>“a” 没有前后缀相等</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>1</td>
<td>“ab” 前缀 a，后缀 a，相等</td>
</tr>
<tr>
<td>3</td>
<td>b</td>
<td>2</td>
<td>“aba” 前缀 ab，后缀 ab，相等</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3</td>
<td>“abab” 前缀 aba，后缀 aba，相等</td>
</tr>
<tr>
<td>5</td>
<td>c</td>
<td>0</td>
<td>“ababa” 前后缀都不同</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>1</td>
<td>“ababac” 前缀 a，后缀 a，相等</td>
</tr>
</tbody></table>
<p>所以最终的 <code>next</code> 数组为：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">next = [0, 0, 1, 2, 3, 0, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p><strong>🔹3. 如何计算 next 数组？（Python 伪代码）</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_next</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>
    <span class="token builtin">next</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
    j <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 前缀末尾指针</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            j <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 回退</span>

        <span class="token keyword">if</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>

        <span class="token builtin">next</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j
    <span class="token keyword">return</span> <span class="token builtin">next</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>🔹4. 小结</strong></p>
<ul>
<li><code>next[i]</code> 表示：在第 i 位字符匹配失败后，模式串应跳转的位置。</li>
<li>它避免了主串的重复回溯，使得 KMP 算法的时间复杂度为：<figure><div class="code-wrapper"><pre class="line-numbers language-text" data-language="text"><code class="language-text">O(n + m)  # n 是主串长度，m 是模式串长度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li>
</ul>
<p>KMP（Knuth-Morris-Pratt）算法其核心思想是：当出现不匹配时，<strong>利用已经匹配的信息来避免重复匹配</strong>，通过 <code>next</code> 数组（也称为部分匹配表）加快匹配速度。</p>
<p>📌 已知条件</p>
<ul>
<li>文本串 <code>text</code>，长度为 <code>n</code></li>
<li>模式串 <code>pattern</code>，长度为 <code>m</code></li>
<li>已知 <code>next</code> 数组为 <code>next[0..m-1]</code></li>
</ul>
<p>🔁 主循环匹配逻辑</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># text 指针</span>
j <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># pattern 指针</span>

<span class="token keyword">while</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
    <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">or</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
        j <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        j <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>🔍 匹配过程说明</p>
<ul>
<li><p><strong>初始设置</strong>：</p>
<ul>
<li><code>i = 0</code>, <code>j = 0</code>（或者 <code>j = -1</code>，视 <code>next</code> 数组实现方式）</li>
</ul>
</li>
<li><p><strong>匹配成功</strong>：</p>
<ul>
<li>如果 <code>text[i] == pattern[j]</code>，则：<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">+=</span> <span class="token number">1</span>
j <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li>
</ul>
</li>
<li><p><strong>匹配失败</strong>：</p>
<ul>
<li>如果 <code>text[i] != pattern[j]</code>，则：<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">j <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token comment"># 不回退 i</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li>
</ul>
</li>
<li><p><strong>匹配完成</strong>：</p>
<ul>
<li>如果 <code>j == m</code>，说明匹配成功，匹配位置为：<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">i <span class="token operator">-</span> m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure></li>
</ul>
</li>
</ul>
<p>✅ 示例</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">text    <span class="token operator">=</span> <span class="token string">"ababcabcacbab"</span>
pattern <span class="token operator">=</span> <span class="token string">"abcac"</span>
<span class="token builtin">next</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>
<p>匹配过程如下：</p>
<table>
<thead>
<tr>
<th>i (text)</th>
<th>j (pattern)</th>
<th>text[i]</th>
<th>pattern[j]</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>a</td>
<td>a</td>
<td>匹配，i++, j++</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>b</td>
<td>b</td>
<td>匹配，i++, j++</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>a</td>
<td>c</td>
<td>不匹配，j &#x3D; 0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>a</td>
<td>a</td>
<td>匹配，i++, j++</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>b</td>
<td>b</td>
<td>匹配，i++, j++</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>c</td>
<td>c</td>
<td>匹配，i++, j++</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>a</td>
<td>a</td>
<td>匹配，i++, j++</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
<td>b</td>
<td>c</td>
<td>不匹配，j &#x3D; 2</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>b</td>
<td>c</td>
<td>不匹配，j &#x3D; 0</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>b</td>
<td>a</td>
<td>不匹配，j &#x3D; -1</td>
</tr>
<tr>
<td>6</td>
<td>-1</td>
<td>b</td>
<td>-</td>
<td>i++, j &#x3D; 0</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>继续匹配</td>
</tr>
</tbody></table>
<p>当 <code>j == 5</code> 时，表示匹配成功。</p>
<p>✅ 总结</p>
<ul>
<li>利用 next 数组可以避免暴力回溯，提高效率。</li>
</ul>
<p>⏱️ 时间复杂度</p>
<ul>
<li>构造 next 数组：O(m)</li>
<li>匹配过程：O(n)</li>
<li>总体时间复杂度：O(n + m)</li>
</ul>
<h2 id="4-Binary-Tree"><a href="#4-Binary-Tree" class="headerlink" title="4.Binary Tree"></a>4.Binary Tree</h2><p>关于二叉树的考点有许多，像是考二叉树的遍历，二叉搜索树（Binary Search Tree），最小生成树（MST），以及AVL树。首先需要了解二叉树的一些基本性质，例如每个节点的下标，以及二叉树的多种遍历方式。</p>
<h3 id="4-1-Concepts-of-Binary-Tree"><a href="#4-1-Concepts-of-Binary-Tree" class="headerlink" title="4.1 Concepts of Binary Tree"></a>4.1 Concepts of Binary Tree</h3><img src="/img/DSA/binary_tree.svg" srcset="/img/loading.gif" lazyload alt="常见的二叉树" style="max-width: 100%; height: auto;" />

<p><strong>完全二叉树（complete binary tree）</strong>：是一种二叉树，其中每一层都是满的，除了可能是最后一层，且最后一层的节点从左到右排列。在完全二叉树中，所有的节点都尽可能地靠左排列，这种结构使得它在存储和操作上更为高效。与全二叉树不同，完全二叉树允许最后一层不满，但仍需保持左侧填充。</p>
<p>对于一个完全二叉树，如果节点的索引为$i$,节点数为$n$那么：</p>
<ol>
<li>左孩子节点索引: $2i$</li>
<li>右孩子节点索引: $2i + 1$</li>
<li>父亲节点索引: $[i&#x2F;2]$  </li>
<li>二叉树高度: $ceil(log_{2}{(n+1)})$ 或 $floor(log_{2}{n}) + 1$</li>
</ol>
<p><strong>全二叉树（full binary tree）</strong>：是指每个节点要么没有子节点，要么恰好有两个子节点的二叉树。在这种树中，除了叶子节点外，所有节点都有两个子节点。这样的结构确保了树的每一层都被完全填满，只有最后一层可能不满。</p>
<p><strong>二叉搜索树（Binary Search Tree, BST）</strong>: 是一种二叉树，其中每个节点都包含一个键值，左子树的所有节点键值小于该节点，右子树的所有节点键值大于该节点。这种结构使得查找、插入和删除操作的平均时间复杂度为 O(log n)。其主要性质包括：每个节点最多有两个子节点，左子树和右子树都是二叉搜索树，且没有重复的键值。</p>
<p>二叉搜索树的搜索迭代实现：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">searchBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">></span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>val <span class="token operator">&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">)</span> root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h3 id="4-2-Tree-Traversal"><a href="#4-2-Tree-Traversal" class="headerlink" title="4.2 Tree Traversal"></a>4.2 Tree Traversal</h3><p><strong>层序遍历（Level Order Traversal）：</strong> 开一个队列处理一层的节点并放入下一层的节点。这个遍历也属于<strong>广度优先遍历（BFS）</strong>。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>
        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>
            <span class="token keyword">int</span> n <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">auto</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>二叉树的<strong>深度优先遍历（DFS）</strong> 可以分为三种：前序遍历，中序遍历和后序遍历。</p>
<p><strong>前序遍历（Preorder Traversal）：</strong>  <em>根-&gt;左-&gt;右</em>，递归实现</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>当然也可以开一个栈来实现</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>
        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>后序遍历（Postorder Traversal）：</strong>  <em>左-&gt;右-&gt;根</em>，递归实现</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>后序遍历同样可以开一个栈来实现</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>
        st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cur<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cur<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>中序遍历（Inorder Traversal）：</strong>  <em>左-&gt;根-&gt;右</em>，递归实现</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>当然也可以开一个栈来实现：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>
        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> st<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root <span class="token operator">||</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
                root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            root <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token operator">-></span> right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>二叉树的中序遍历还有一个重要的考点是<em>逆波兰表达式</em>,这个曾经在京大的过去问中出现过。<strong>逆波兰表达式（Reverse Polish Notation, RPN）</strong> 是一种后缀表示法，用于表示算术表达式。在这种表示法中，运算符跟在操作数之后，而不是在它们之间。这种形式的好处是消除了括号的需要，因为操作的顺序总是由操作符的位置决定。具体的实现方法可以开一个栈轻松解决。<br><img src="/img/DSA/rpn.svg" srcset="/img/loading.gif" lazyload alt="逆波兰表达式" style="max-width: 70%; height: auto;" /></p>
<h3 id="4-3-AVL-Tree"><a href="#4-3-AVL-Tree" class="headerlink" title="4.3 AVL Tree"></a>4.3 AVL Tree</h3><p><strong>AVL树</strong>是一种自平衡的二叉搜索树，确保每个节点的左右子树高度差（平衡因子）最多为1。这样可以保证树的高度在 $O(log{n})$ 范围内，确保高效的插入、删除和查找操作。AVL树通过旋转操作来维持平衡，从而优化性能，特别是在频繁修改的场景中。东工有一年考到了这个点，但我认为了解到AVL树的工作原理就ok了,主要聚焦在节点的添加和删除以及树的旋转。<br><img src="/img/DSA/avl_tree_insert.svg" srcset="/img/loading.gif" lazyload alt="AVL树增加节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_delete.svg" srcset="/img/loading.gif" lazyload alt="AVL树删除节点" style="max-width: 100%; height: auto;" /><br><img src="/img/DSA/avl_tree_rotate.svg" srcset="/img/loading.gif" lazyload alt="AVL树左旋和右旋" style="max-width: 100%; height: auto;" /></p>
<h2 id="5-Graph-Theory"><a href="#5-Graph-Theory" class="headerlink" title="5.Graph Theory"></a>5.Graph Theory</h2><p>本章主要讲解图的基本算法，最小生成树，单源最短路径算法，单源最短路径算法和多源最短路径算法，以及最大流问题。修考题的图算法都是套的模版，因此了解算法的核心思想非常关键。</p>
<h3 id="5-1图的基本算法"><a href="#5-1图的基本算法" class="headerlink" title="5.1图的基本算法"></a>5.1图的基本算法</h3><p>对于图的表示，我们需要建立一个<strong>邻接矩阵(adjacency matrix)</strong>,简单图的邻接矩阵是(0,1)矩阵并且对角线元素都为0。无向图的邻接矩阵是对称矩阵。<br><img src="/img/DSA/adjacency_matrix.svg" srcset="/img/loading.gif" lazyload alt="邻接矩阵" style="max-width: 100%; height: auto;" /></p>
<h4 id="5-1-1-BFS"><a href="#5-1-1-BFS" class="headerlink" title="5.1.1 BFS"></a>5.1.1 BFS</h4><p>在二叉树章节中讲解了树的深度遍历算法，在图中，我们可以同样的利用邻接链表（也就是建一个数组）来获取当前遍历的节点的邻接节点，开一个数组记录已访问的节点，最后利用队列实现层序遍历。<br><img src="/img/DSA/bfs.svg" srcset="/img/loading.gif" lazyload alt="广度优先算法" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">// Function to add an edge to the graph</span>
    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// BFS traversal starting from given source vertex</span>
    <span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Mark all vertices as not visited</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Create a queue for BFS</span>
        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> queue<span class="token punctuation">;</span>

        <span class="token comment">// Mark the source node as visited and enqueue it</span>
        visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// Dequeue a vertex from queue and print it</span>
            s <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Get all adjacent vertices of the dequeued vertex s</span>
            <span class="token comment">// If an adjacent has not been visited, then mark it visited</span>
            <span class="token comment">// and enqueue it</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h4 id="5-1-2-DFS"><a href="#5-1-2-DFS" class="headerlink" title="5.1.2 DFS"></a>5.1.2 DFS</h4><p>DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索图形或树数据结构的算法。它尽可能深地访问节点，然后回溯，寻找未访问过的节点。</p>
<p><strong>基本原理：</strong></p>
<ol>
<li>初始化：从起始节点出发，将其标记为访问过。之后开始递归或使用栈</li>
<li><em>递归</em>：对每个未访问的邻接节点，递归调用DFS。（递归的实现方式就是利用栈来记录每一次函数调用的状态）<br><em>栈</em>：将节点压入栈中，访问节点时将其出栈，继续访问其未访问的邻接节点，并将这些邻接节点压入栈。</li>
<li><em>回溯</em>：如果当前节点的所有邻接节点都访问过，则回溯到上一个节点，继续这个过程，直到所有节点都访问完。<img src="/img/DSA/dfs.svg" srcset="/img/loading.gif" lazyload alt="深度优先算法" style="max-width: 100%; height: auto;" />
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// Number of vertices</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// Adjacency list</span>

    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">&amp;</span>visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Mark the current node as visited and print it</span>
        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>

        <span class="token comment">// Recur for all the vertices adjacent to this vertex</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> adjacent <span class="token operator">:</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>adjacent<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">DFS</span><span class="token punctuation">(</span>adjacent<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token comment">// Function to add an edge to the graph</span>
    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// DFS traversal starting from given source vertex</span>
    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// Mark all the vertices as not visited</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Call the recursive helper function to print DFS traversal</span>
        <span class="token function">DFS</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<div class="note note-success">
            <p>BFS和DFS对比非常鲜明。BFS的性格是保守，害怕风险，尽量做到“广撒网，细收鱼”；而DFS则是奔放，秉持着一颗“不撞南墙不回头”，“不到黄河不死心”的感觉。</p>
          </div></li>
</ol>
<h4 id="5-1-3-Topological-Sort"><a href="#5-1-3-Topological-Sort" class="headerlink" title="5.1.3 Topological Sort"></a>5.1.3 Topological Sort</h4><p><strong>拓扑排序（Topological Sorting）</strong>是图论中的一种线性排序方法，主要用于对<strong>有向无环图（Directed Acyclic Graph, DAG</strong> 中的顶点进行排序，使得对于图中的每一条有向边 (u → v)，顶点 u 在排序中都出现在顶点 v 的前面。<br><img src="/img/DSA/topo_sort.svg" srcset="/img/loading.gif" lazyload alt="拓扑排序算法" style="max-width: 100%; height: auto;" /><br><strong>拓扑排序算法步骤：</strong></p>
<ol>
<li>计算每个顶点的入度：统计每个顶点被其他顶点指向的次数（即入度, inDegree）。</li>
<li>将所有入度为 0 的顶点加入队列：这些顶点没有任何前置依赖。</li>
<li>重复以下步骤直到队列为空：（1）从队列中取出一个顶点 u，将其加入拓扑排序结果中。（2）遍历 u 的所有邻接顶点 v，将 v 的入度减 1；如果 v 的入度变为 0，则将 v 加入队列。</li>
<li>检查结果：如果所有顶点都被处理过，则返回拓扑排序；否则，图中有环，无法进行拓扑排序。</li>
</ol>
<p>在初始化时，需要遍历所有顶点计算入度，耗时$O(V)$；然后遍历所有边来更新入度并处理顶点，耗时$O(E)$。因此总的时间复杂度是$O(V + E)$。最终的排序顺序是: $1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7$。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> V<span class="token punctuation">;</span>  <span class="token comment">// 顶点数</span>
    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span>  <span class="token comment">// 邻接表</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inDegree<span class="token punctuation">;</span>  <span class="token comment">// 入度数组</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">V</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">inDegree</span><span class="token punctuation">(</span>v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span>
        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>

        <span class="token comment">// 将所有入度为0的顶点加入队列</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>inDegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 对于所有相邻的顶点，将其入度减1</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>inDegree<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 检查是否存在环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> V<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"图中存在环，无法进行拓扑排序"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="5-1-4-Union-Find"><a href="#5-1-4-Union-Find" class="headerlink" title="5.1.4 Union Find"></a>5.1.4 Union Find</h4><p><strong>并查集（Union-Find）</strong> 算法，又称为不相交集数据结构，是一种用于处理元素分组及查询元素所属组的高效数据结构。它广泛应用于图论（如判断图的连通性、<em>Kruskal算法</em>求最小生成树）并查集主要支持<strong>两种操作</strong>：</p>
<ol>
<li>查找（Find）：确定某个元素属于哪个集合（即找到该元素所在集合的代表元素或根节点）。</li>
<li>合并（Union）：将两个不同的集合合并为一个集合。</li>
</ol>
<p>为了提高并查集的效率，通常结合以下两种优化策略：</p>
<ol>
<li>路径压缩（Path Compression）：在 Find 操作中，将访问过的所有节点直接连接到根节点，从而降低树的高度。</li>
<li>按秩合并（Union by Rank）或按大小合并（Union by Size）：在 Union 操作中，总是将较小的树挂到较大的树下，保持树的平衡。</li>
</ol>
<p>结合这两种优化后，并查集的时间复杂度几乎接近于常数时间，具体为 反阿克曼函数 的时间复杂度，几乎可以认为是 $O(1)$。<br><img src="/img/DSA/union_find.svg" srcset="/img/loading.gif" lazyload alt="并查集算法" style="max-width: 100%; height: auto;" /><br>以下是一个使用路径压缩和按秩合并优化的并查集实现：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment">// 存储每个节点的父节点</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rank<span class="token punctuation">;</span>    <span class="token comment">// 存储每个节点的秩（树的高度）</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 构造函数：初始化每个节点的父节点为自身，秩为1</span>
    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        rank<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 查找操作：查找元素x所在集合的根节点，并进行路径压缩</span>
    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 路径压缩</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 合并操作：将元素x和元素y所在的集合合并</span>
    <span class="token keyword">void</span> <span class="token function">unionSets</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> rootX <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rootY <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>rootX <span class="token operator">==</span> rootY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 已经在同一个集合中</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 按秩合并：将秩较小的树挂到秩较大的树下</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            parent<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">=</span> rootY<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            parent<span class="token punctuation">[</span>rootY<span class="token punctuation">]</span> <span class="token operator">=</span> rootX<span class="token punctuation">;</span>
            rank<span class="token punctuation">[</span>rootX<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="5-2-Minimum-Spanning-Tree"><a href="#5-2-Minimum-Spanning-Tree" class="headerlink" title="5.2 Minimum Spanning Tree"></a>5.2 Minimum Spanning Tree</h3><p><strong>最小生成树（Minimum Spanning Tree, MST）</strong> 是指在一个带权无向图中，连接所有顶点的一个子图，使得：</p>
<ol>
<li>这个子图是一个树（即没有环，并且连通所有顶点）。</li>
<li>这个树的总边权和最小。</li>
</ol>
<p><strong>特点</strong>：</p>
<ol>
<li>最小生成树包含图中所有的顶点，但只包含连接这些顶点的最少数量的边（即 $V - 1$条边，$V$为顶点数）。</li>
<li>它保证生成的树的边权总和最小。</li>
</ol>
<p>常见的MST生成算法有2种：<em>Kruskal算法</em>和<em>Prim算法</em>。简单来说，Kruskal是基于边的选择，而Prim算法是从某个顶点开始构建最小生成树的，逐步扩展树的边界。</p>
<h4 id="5-2-1-Kruskal"><a href="#5-2-1-Kruskal" class="headerlink" title="5.2.1 Kruskal"></a>5.2.1 Kruskal</h4><p>具体步骤为：</p>
<ol>
<li>首先对所有边按权重从小到大排序。</li>
<li>然后依次利用<strong>并查集（Union Find）</strong>检查每条边的两个顶点是否属于不同的集合，如果是，则将它们合并，并将该边加入最小生成树。</li>
<li>重复这个过程，直到最小生成树中包含了$V−1$条边。</li>
</ol>
<p><strong>时间复杂度：</strong> 边排序耗时$O(ElogE)$，并查集操作近似为$O(1)$，因此总时间复杂度为$O(ElogE)$。<br><img src="/img/DSA/kruskal.svg" srcset="/img/loading.gif" lazyload alt="Kruskal算法" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含起点、终点和权重</span>
<span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>
    
    <span class="token comment">// 比较函数，按照权重升序排序</span>
    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> weight <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 并查集（Union-Find）结构体</span>
<span class="token keyword">struct</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">,</span> rank<span class="token punctuation">;</span>

    <span class="token comment">// 初始化并查集，所有节点的父节点初始化为自己，秩(rank)初始化为0</span>
    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">parent</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 查找操作，使用路径压缩</span>
    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 合并操作，按秩合并</span>
    <span class="token keyword">void</span> <span class="token function">unite</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> rootU <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rootV <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rootU <span class="token operator">!=</span> rootV<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">></span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                parent<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span> <span class="token operator">=</span> rootV<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                parent<span class="token punctuation">[</span>rootV<span class="token punctuation">]</span> <span class="token operator">=</span> rootU<span class="token punctuation">;</span>
                rank<span class="token punctuation">[</span>rootU<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// Kruskal算法实现</span>
<span class="token keyword">int</span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span><span class="token operator">&amp;</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 按权重升序排序所有边(至关重要的一环)</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edges<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    UnionFind <span class="token function">uf</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最小生成树的总权重</span>
    <span class="token keyword">int</span> edgesUsed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已经加入生成树的边数</span>
    <span class="token comment">// 遍历所有边</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 查找两个顶点是否属于不同的集合（不同的连通分量）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">)</span> <span class="token operator">!=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            uf<span class="token punctuation">.</span><span class="token function">unite</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">,</span> edge<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将它们合并到同一个集合</span>
            mstWeight <span class="token operator">+=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span> <span class="token comment">// 将这条边的权重加入总权重</span>
            edgesUsed<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">// 如果已经加入V-1条边，生成树构建完毕</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>edgesUsed <span class="token operator">==</span> numVertices <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="5-2-2-Prim算法"><a href="#5-2-2-Prim算法" class="headerlink" title="5.2.2 Prim算法"></a>5.2.2 Prim算法</h4><p>Prim算法的基本思想是从一个顶点开始，逐步将与当前生成树相连的最小边加入到树中，直到包含图中所有顶点为止。不同于Kruskal算法选择的是边，Prim算法在每一步选择的是<em>与已连接的顶点相连的最小权重边</em>。</p>
<p>算法步骤：</p>
<ol>
<li>初始化：选择一个起始顶点，标记为生成树的一部分。<br>使用一个数组&#x2F;优先队列来记录所有尚未加入生成树的顶点到当前生成树的最小边的权重。</li>
<li>选择最小边：<br>在每一步中，从所有与生成树相连的边中选择权重最小的边（维护一个优先队列），确保这个边不会形成环。</li>
<li>更新距离：将选择的边的顶点加入生成树<u>并更新尚未加入树的顶点到新生成树的最小边的权重。</u></li>
<li>重复上述步骤，直到所有顶点都被加入生成树。</li>
</ol>
<p>对每条边的操作（插入、删除、更新最小边权重）是$O(logV)$的，因此总的时间复杂度为$O(ElogV)$，其中$E$是边的数量，$V$是顶点的数量。<br><img src="/img/DSA/prim.svg" srcset="/img/loading.gif" lazyload alt="Prim算法" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 边的结构体，包含终点和权重</span>
<span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>
    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// Prim算法的实现</span>
<span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 最小生成树的总权重</span>
    <span class="token keyword">int</span> mstWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 标记每个顶点是否在生成树中</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">inMST</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 记录最小权重的边的权重，初始化为无穷大(敲重点)</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">minEdgeWeight</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 优先队列（最小堆），存储&#123;边的权重，顶点编号&#125;</span>
    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>

    <span class="token comment">// 从第0号顶点开始</span>
    minEdgeWeight<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 取出权重最小的边</span>
        <span class="token keyword">int</span> weight <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 如果顶点u已经在MST中，跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// 将顶点u加入MST</span>
        inMST<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        mstWeight <span class="token operator">+=</span> weight<span class="token punctuation">;</span>

        <span class="token comment">// 更新与顶点u相连的其他顶点的最小边权重</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>
            <span class="token keyword">int</span> w <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>inMST<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">&lt;</span> minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                minEdgeWeight<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>
                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>w<span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> mstWeight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="5-3-单源最短路径算法"><a href="#5-3-单源最短路径算法" class="headerlink" title="5.3 单源最短路径算法"></a>5.3 单源最短路径算法</h3><p>单源最短路径算法（Single-Source Shortest Path, SSSP）用于从图中的一个指定起点（源点）出发，找到该点到图中所有其他顶点的最短路径。常用的单源路径算法为<strong>Dijkstra算法</strong>和<strong>Bellman-Ford算法</strong>。Dijkstra算法只能用于无负权边的图。如果图中存在负权边，Dijkstra算法的结果可能不正确。Bellman-Ford算法可以处理带负权边的图，且能够检测负权环（如果存在负权环，则说明不存在最短路径）。</p>
<h4 id="5-3-1-Dijkstra’s-algorithm"><a href="#5-3-1-Dijkstra’s-algorithm" class="headerlink" title="5.3.1 Dijkstra’s algorithm"></a>5.3.1 Dijkstra’s algorithm</h4><p><strong>Dijkstra算法</strong>的基本思想是：每次贪心地从当前未处理的顶点中选择一个距离源点最近的顶点，标记其最短路径为确定，然后通过该顶点更新其邻接点的最短路径。过反复选择距离最小的顶点，并更新邻接点的路径长度，最终能确定所有顶点的最短路</p>
<p><strong>时间复杂度</strong>：在使用优先队列（最小堆）的情况下，Dijkstra算法的时间复杂度为$O(ElogV)$，其中E是图中边的数量，V是顶点的数量。取出当前最小距离顶点的操作需要$O(logV)$时间。每条边被检查一次，更新时需要$O(logV)$的时间来调整优先队列。在稠密图中，算法的效率略低，因为每次更新都需要重新维护优先队列，但在稀疏图中性能良好。<br><img src="/img/DSA/dijkstra.svg" srcset="/img/loading.gif" lazyload alt="Dijkstra算法" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>
    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> numVertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> source<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>numVertices<span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 存储从源点到每个顶点的最短距离</span>
    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 源点到自身的距离为0</span>
    
    <span class="token comment">// 优先队列：最小堆，存储的是&#123;距离, 顶点编号&#125;</span>
    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> pq<span class="token punctuation">;</span>
    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> source<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>  <span class="token comment">// 取出距离源点最近的顶点</span>
        <span class="token keyword">int</span> d <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>   <span class="token comment">// 当前顶点的最短距离</span>
        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 如果当前距离已经不是最优解，跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>d <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token comment">// 更新顶点 u 的邻接点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Edge<span class="token operator">&amp;</span> edge <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to<span class="token punctuation">;</span>
            <span class="token keyword">int</span> weight <span class="token operator">=</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
            <span class="token comment">// 如果通过 u 到 v 的路径更短，更新路径</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">;</span>
                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> v<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将 v 插入优先队列</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> dist<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="5-3-2-Bellman-Ford-Algorithm"><a href="#5-3-2-Bellman-Ford-Algorithm" class="headerlink" title="5.3.2 Bellman-Ford Algorithm"></a>5.3.2 Bellman-Ford Algorithm</h4><p><strong>Bellman-Ford算法</strong>是一种经典的算法，用于解决单源最短路径问题（Single Source Shortest Path, SSSP），即从图中的某个源点到其他所有顶点的最短路径。它与Dijkstra算法的不同之处在于，Bellman-Ford可以处理权值为负数的边，并且能够检测出图中是否存在负权环（negative-weight cycle）。</p>
<p>Bellman-Ford算法的核心思想是通过<strong>松弛（relaxation）</strong> 操作逐步更新每个顶点的最短路径估计值。松弛操作的含义是，如果从某条边可以得到比当前已知更短的路径，则更新路径长度。算法通过多次迭代更新路径，确保找到全局的最短路径。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>初始化：将源点到源点的距离设为0（即$dist[source] &#x3D; 0$），其他所有顶点到源点的距离初始设为正无穷大（$dist[v] &#x3D; ∞$）。设定前驱节点为None或相应的初始值。</li>
<li>松弛所有边：对于图中的所有边$(u,v)$，检查是否可以通过$u$达到$v$的更短路径，即$dist[v] &gt; dist[u] + weight(u, v)$。如果是，则更新$dist[v] &#x3D; dist[u] + weight(u, v)$。重复这个过程最多$n−1$次，其中$n$是顶点的数量。因为最短路径最多包含$n−1$条边。</li>
<li>检测负权环（可选步骤）：在完成$n−1$次松弛操作后，再对所有边执行一次松弛操作。如果此时还能继续更新某个顶点的最短路径值，则说明图中存在负权环，因为在无负权环的情况下，经过$n−1$次松弛操作后，所有最短路径应该已经收敛。</li>
</ol>
<p>边的松弛操作需要对每条边执行，图中一共有𝑚条边。算法需要对所有边重复𝑛−1次（因为最短路径最多包含𝑛−1条边），因此时间复杂度为𝑂(𝑛⋅𝑚)</p>
<img src="/img/DSA/bellman_ford.svg" srcset="/img/loading.gif" lazyload alt="松弛操作" style="max-width: 100%; height: auto;" />

<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">//</span> Bellmanford算法伪代码
function BellmanFord<span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">//</span> Step <span class="token number">1</span><span class="token punctuation">:</span> Initialize distances
    <span class="token keyword">for</span> each vertex v <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>
        dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> ∞  <span class="token operator">//</span> Set <span class="token builtin">all</span> distances to infinity
        predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> null  <span class="token operator">//</span> No predecessors initially
    dist<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token operator">//</span> The distance <span class="token keyword">from</span> the source to itself <span class="token keyword">is</span> zero

    <span class="token operator">//</span> Step <span class="token number">2</span><span class="token punctuation">:</span> Relax <span class="token builtin">all</span> edges n<span class="token operator">-</span><span class="token number">1</span> times
    <span class="token keyword">for</span> i <span class="token keyword">from</span> <span class="token number">1</span> to <span class="token operator">|</span>V<span class="token operator">|</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>
            <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>
                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
                predecessor<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u

    <span class="token operator">//</span> Step <span class="token number">3</span><span class="token punctuation">:</span> Check <span class="token keyword">for</span> negative<span class="token operator">-</span>weight cycles
    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> Graph<span class="token punctuation">:</span>
        <span class="token keyword">if</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> weight<span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>
            error <span class="token string">"Graph contains a negative-weight cycle"</span>
    
    <span class="token keyword">return</span> dist<span class="token punctuation">,</span> predecessor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h3 id="5-4-多源最短路径算法"><a href="#5-4-多源最短路径算法" class="headerlink" title="5.4 多源最短路径算法"></a>5.4 多源最短路径算法</h3><h4 id="5-4-1-Floyd-Wallshall’s-Algorithm"><a href="#5-4-1-Floyd-Wallshall’s-Algorithm" class="headerlink" title="5.4.1 Floyd-Wallshall’s Algorithm"></a>5.4.1 Floyd-Wallshall’s Algorithm</h4><p><strong>Floyd-Warshall算法</strong> 是一种经典的动态规划算法，用于解决所有点对最短路径问题。它可以在加权图中找出每一对顶点之间的最短路径，<em>即使图中包含负权重边</em>，只要没有负权重环路（即从某个顶点出发经过一些边又回到该顶点且路径总权重为负）。<u>京大知能</u>的一年过去问就考了这道题的手动迭代推理，在复习这个题的时候建议和京大的过去问配合看。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p>初始化：将距离矩阵$dist[][]$初始化为图的邻接矩阵。如果$i &#x3D;&#x3D; j$，则$dist[i][j] &#x3D; 0$，表示从节点$i$到节点$j$的路径距离为$0$。如果$i ≠ j$且两点之间有边，则$dist[i][j] &#x3D; weight(i, j)$，否则$dist[i][j]设为∞$（表示两点不直接相连）。</p>
</li>
<li><p>动态规划：通过三重循环逐步更新每对顶点之间的最短距离。外层循环选取一个中间顶点$k$，中间两层循环更新每一对顶点$i$和$j$之间的最短路径，判断是否通过$k$可以得到更短的路径。如果$dist[i][k] + dist[k][j] &lt; dist[i][j]$，则更新$dist[i][j]$。公式为：</p>
<div style="text-align: center;">
$$
dist[i][j] = \min(dist[i][j], dist[i][k] + dist[k][j])
$$
</div></li>
</ol>
<p><strong>时间复杂度：</strong><br>Floyd-Warshall算法的时间复杂度为$O(V³)$，其中$V$是图中顶点的数量。三重嵌套循环的每一层都依赖于顶点的数量，因此该算法适合顶点较少的图。对于边多（稠密图）且顶点数量不多的情况，它是一个有效的算法。<br><img src="/img/DSA/floyd.svg" srcset="/img/loading.gif" lazyload alt="Floyd算法演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">floydWarshall</span><span class="token punctuation">(</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储最短路径</span>

    <span class="token comment">// 初始化距离矩阵，将其设为输入图的邻接矩阵</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 三重循环：i是起点，j是终点，k是中间节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 如果从i通过k到j的路径更短，则更新dist[i][j]</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">&amp;&amp;</span> 
                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="5-5-Maximum-FLow-Problem"><a href="#5-5-Maximum-FLow-Problem" class="headerlink" title="5.5 Maximum FLow Problem"></a>5.5 Maximum FLow Problem</h3><p><strong>最大流问题</strong>是网络流理论中的一个经典问题，旨在寻找在一个流网络（或称为容量网络）中，从源点到汇点的最大可能流量。这个问题可以应用于很多实际场景，比如交通网络、物流系统、通信网络等。</p>
<p><strong>最大流问题</strong>的定义：</p>
<ol>
<li><p>流网络：由顶点集和边集组成的有向图，其中每条边都有一个非负的容量，表示能通过该边的最大流量。这个网络中有一个特定的顶点被称为源点（source），另一个顶点称为汇点（sink）。</p>
</li>
<li><p>流量：从源点到汇点传输的流称为流量。流量需要遵守以下两个条件：</p>
</li>
<li><p>容量限制：每条边上的流量不能超过该边的容量。</p>
</li>
<li><p>流量守恒：除了源点和汇点，其他顶点的流入流量与流出流量相等。</p>
</li>
</ol>
<p>本章只讲解Ford-Fulkerson算法，有余力可以再了解一下Edmonds-Karp算法和Push-Relabel算法。</p>
<h4 id="5-5-1-Ford-Fulkerson-Algorithm"><a href="#5-5-1-Ford-Fulkerson-Algorithm" class="headerlink" title="5.5.1 Ford-Fulkerson Algorithm"></a>5.5.1 Ford-Fulkerson Algorithm</h4><p>福特-福尔克森算法的核心思想是利用增广路径（Augmenting Path）来增加网络中的流量。增广路径是指在残余网络（Residual Network）中，从源点到汇点的一条路径，且路径上的每条边都有剩余容量（Residual Capacity）大于零。算法通过反复寻找这样的路径，并沿路径增加流量，直到没有增广路径为止。<br><img src="/img/DSA/ford.svg" srcset="/img/loading.gif" lazyload alt="Ford-Fulkerson算法演示" style="max-width: 100%; height: auto;" /><br><strong>初始状态：</strong></p>
<p>如图所示，所有边的初始流量都为 0。我们的目标是找到从源点 S 到汇点 T 的最大流。</p>
<p><strong>第一次迭代：</strong></p>
<ul>
<li><strong>a.</strong> 找一条增广路径，例如：S -&gt; A -&gt; C -&gt; T</li>
<li><strong>b.</strong> 这条路径的瓶颈容量是 5（A 到 C 的边）</li>
<li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 0&#x2F;10 \rightarrow 5&#x2F;10 \\<br>A \to C: &amp;\ 0&#x2F;5 \rightarrow 5&#x2F;5 \\<br>C \to T: &amp;\ 0&#x2F;9 \rightarrow 5&#x2F;9<br>\end{aligned}<br>$$</li>
</ul>
<p><strong>第二次迭代：</strong></p>
<ul>
<li><strong>a.</strong> 找另一条增广路径，例如：S -&gt; B -&gt; D -&gt; T</li>
<li><strong>b.</strong> 这条路径的瓶颈容量是 6（D 到 T 的边）</li>
<li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to B: &amp;\ 0&#x2F;8 \rightarrow 6&#x2F;8 \\<br>B \to D: &amp;\ 0&#x2F;7 \rightarrow 6&#x2F;7 \\<br>D \to T: &amp;\ 0&#x2F;6 \rightarrow 6&#x2F;6<br>\end{aligned}<br>$$</li>
</ul>
<p><strong>第三次迭代：</strong></p>
<ul>
<li><strong>a.</strong> 找下一条增广路径，例如：S -&gt; A -&gt; D -&gt; T</li>
<li><strong>b.</strong> 这条路径的瓶颈容量是 3（A 到 D 的边）</li>
<li><strong>c.</strong> 更新流量：<br>$$<br>\begin{aligned}<br>S \to A: &amp;\ 5&#x2F;10 \rightarrow 8&#x2F;10 \\<br>A \to D: &amp;\ 0&#x2F;3 \rightarrow 3&#x2F;3 \\<br>D \to T: &amp;\ 6&#x2F;6 \text{（已满，无法增加）}<br>\end{aligned}<br>$$</li>
</ul>
<p><strong>算法终止：</strong><br>此时，我们无法找到从 S 到 T 的更多增广路径。所有通向 T 的边都已经满了：</p>
<ul>
<li>$C \to T: 5&#x2F;9$</li>
<li>$D \to T: 6&#x2F;6$</li>
</ul>
<p><strong>计算最大流：</strong><br>最大流等于从源点出发的所有流量之和：<br>$$<br>8\ (\text{S} \to \text{A}) + 6\ (\text{S} \to \text{B}) &#x3D; 14<br>$$<br>也等于进入汇点的所有流量之和：<br>$$<br>5\ (\text{C} \to \text{T}) + 6\ (\text{D} \to \text{T}) &#x3D; 11<br>$$</p>
<p><strong>最终结果：</strong></p>
<ul>
<li>最大流值为 14</li>
<li>S -&gt; A -&gt; C -&gt; T 路径上流量为 5</li>
<li>S -&gt; B -&gt; D -&gt; T 路径上流量为 6</li>
<li>S -&gt; A -&gt; D -&gt; T 路径上流量为 3</li>
</ul>
<p>Ford-Fulkerson 算法的核心思想是不断寻找增广路径并增加流量，直到无法找到更多的增广路径为止。每次找到增广路径后，我们都会更新网络中的流量，直到达到最大流。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">function FordFulkerson<span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">//</span> 初始化残余图
    ResidualGraph Gf <span class="token operator">=</span> CreateResidualGraph<span class="token punctuation">(</span>G<span class="token punctuation">)</span>
    
    <span class="token operator">//</span> 初始化最大流为<span class="token number">0</span>
    maxFlow <span class="token operator">=</span> <span class="token number">0</span>
    
    <span class="token keyword">while</span> true<span class="token punctuation">:</span>
        <span class="token operator">//</span> 在残余图中寻找增广路径
        Path augmentingPath <span class="token operator">=</span> FindAugmentingPath<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> source<span class="token punctuation">,</span> sink<span class="token punctuation">)</span>
        
        <span class="token operator">//</span> 如果没有找到增广路径，算法终止
        <span class="token keyword">if</span> augmentingPath <span class="token keyword">is</span> empty<span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        
        <span class="token operator">//</span> 找到增广路径上的最小残余容量
        minResidualCapacity <span class="token operator">=</span> FindMinResidualCapacity<span class="token punctuation">(</span>augmentingPath<span class="token punctuation">)</span>
        
        <span class="token operator">//</span> 更新残余图
        UpdateResidualGraph<span class="token punctuation">(</span>Gf<span class="token punctuation">,</span> augmentingPath<span class="token punctuation">,</span> minResidualCapacity<span class="token punctuation">)</span>
        
        <span class="token operator">//</span> 增加最大流
        maxFlow <span class="token operator">=</span> maxFlow <span class="token operator">+</span> minResidualCapacity
    
    <span class="token keyword">return</span> maxFlow

function FindAugmentingPath<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Node source<span class="token punctuation">,</span> Node sink<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">//</span> 使用DFS或BFS寻找从source到sink的路径
    <span class="token operator">//</span> 返回找到的路径，如果没有路径则返回空

function FindMinResidualCapacity<span class="token punctuation">(</span>Path augmentingPath<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">//</span> 遍历路径，找到最小的残余容量
    <span class="token operator">//</span> 返回最小残余容量

function UpdateResidualGraph<span class="token punctuation">(</span>ResidualGraph Gf<span class="token punctuation">,</span> Path augmentingPath<span class="token punctuation">,</span> <span class="token builtin">int</span> minResidualCapacity<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> each edge <span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">in</span> augmentingPath<span class="token punctuation">:</span>
        <span class="token operator">//</span> 减少正向边的残余容量
        Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-</span> minResidualCapacity
        <span class="token operator">//</span> 增加反向边的残余容量
        Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> Gf<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> minResidualCapacity

function CreateResidualGraph<span class="token punctuation">(</span>Graph G<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token operator">//</span> 创建一个与原图结构相同的残余图
    <span class="token operator">//</span> 初始化残余容量等于原图的容量
    <span class="token operator">//</span> 为每条边添加一条初始容量为<span class="token number">0</span>的反向边
    <span class="token operator">//</span> 返回创建的残余图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h3 id="5-6-Bipartite-Graph（双分图）"><a href="#5-6-Bipartite-Graph（双分图）" class="headerlink" title="5.6 Bipartite Graph（双分图）"></a>5.6 Bipartite Graph（双分图）</h3><p>在图论中，<strong>Bipartite Graph（双分图）</strong> 是一种特殊的无向图，其顶点集可以被划分为两个<strong>不相交的子集</strong> $U$ 和 $V$，使得图中<strong>每一条边都连接一个来自 $U$ 的顶点和一个来自 $V$ 的顶点</strong>，也就是说<strong>不存在同一子集中两个顶点之间的边</strong>。</p>
<p><strong>定义</strong></p>
<p>设图 $G &#x3D; (V, E)$，如果可以将顶点集 $V$ 分为两个集合 $U$ 和 $V$，满足：</p>
<ul>
<li>$U \cap V &#x3D; \emptyset$（两集合无交集）</li>
<li>$U \cup V &#x3D; V(G)$（合起来构成整个顶点集）</li>
<li>对所有边 $(x, y) \in E$，必有 $x \in U$ 且 $y \in V$，或者相反</li>
</ul>
<p>那么图 $G$ 是一个<strong>Bipartite Graph（双分图）</strong>。</p>
<p><strong>等价定义</strong></p>
<p>一个图是二分图 ⇔ 该图可以进行<strong>二染色</strong>，即能用两种颜色为图的每个顶点染色，使得<strong>任意一条边连接的两个端点颜色不同</strong>。</p>
<p><strong>举例</strong></p>
<ol>
<li>二分图：</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">U: A, B
V: 1, 2

边：A–1, A–2, B–1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>这是一个典型的二分图：所有边都从 U 到 V。</p>
<ol start="2">
<li>不是二分图：</li>
</ol>
<p>三角形图（3 个节点构成一个环）不是二分图，因为你无法用两种颜色染色而不让一条边连接两个同色的顶点。</p>
<p><strong>判断是否是二分图的算法</strong></p>
<p><strong>BFS&#x2F;DFS 染色法</strong>：</p>
<ul>
<li>从一个点出发，将其染成颜色 0；</li>
<li>相邻的点染成颜色 1；</li>
<li>再往下继续染色；</li>
<li>若发现相邻节点有相同颜色，说明不是二分图。</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li><strong>匹配问题</strong>：如最大匹配、婚姻匹配问题；</li>
<li><strong>网络流建模</strong>；</li>
<li><strong>任务分配</strong>：将任务和工人建模为两个集合；</li>
<li><strong>推荐系统</strong>：用户–物品的图可建模为二分图。</li>
</ul>
<p><strong>数学性质</strong></p>
<ul>
<li><strong>一个图是二分图 ⇔ 这个图不含奇数长度的环</strong>。</li>
<li>完全二分图：若 $|U| &#x3D; m$, $|V| &#x3D; n$，且 $U$ 中每个点都与 $V$ 中每个点相连，记作 $K_{m,n}$。</li>
</ul>
<h3 id="5-7-匈牙利算法（Hungarian-Algorithm）"><a href="#5-7-匈牙利算法（Hungarian-Algorithm）" class="headerlink" title="5.7 匈牙利算法（Hungarian Algorithm）"></a>5.7 匈牙利算法（Hungarian Algorithm）</h3><p>匈牙利算法用于解决<strong>二分图最大匹配</strong>问题。它常被用于如下问题：</p>
<ul>
<li>最佳任务分配（如工人分配到任务）</li>
<li>最大权匹配（扩展版本）</li>
<li>图的匹配问题</li>
</ul>
<p>一个<strong>二分图</strong>是指图的顶点可以被划分为两个不交的集合 $U$ 和 $V$，其中每条边只连接 $U$ 中的点与 $V$ 中的点。</p>
<p><strong>🧠 匈牙利算法思想</strong></p>
<p>对于一个二分图 $G &#x3D; (U, V, E)$，设当前匹配为 $M$。</p>
<ol>
<li><p>初始时，$M &#x3D; \emptyset$。</p>
</li>
<li><p>对于 $U$ 中的每个未匹配点 $u$：</p>
<ul>
<li>尝试从 $u$ 出发进行一条<strong>增广路径</strong>（alternating path）搜索。</li>
<li>若找到一条增广路径，则更新匹配。</li>
</ul>
</li>
<li><p>最终无法继续增广时，$M$ 即为最大匹配。</p>
</li>
</ol>
<p><strong>🔁 增广路径的定义</strong></p>
<ul>
<li><strong>交替路径</strong>：指匹配边与非匹配边交替出现的路径；</li>
<li><strong>增广路径</strong>：起点和终点都是未匹配的点，交替路径，从未匹配点开始和结束；</li>
<li>找到增广路径后，通过“翻转路径上的边”（将匹配边变成非匹配边，反之亦然）来增加匹配数。</li>
</ul>
<p><strong>🧾 匈牙利算法伪代码（DFS版）</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hungarian</span><span class="token punctuation">(</span>U<span class="token punctuation">,</span> V<span class="token punctuation">,</span> graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    match_to_V <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment"># V -> U 的匹配结果</span>
    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> v <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token keyword">if</span> v <span class="token keyword">not</span> <span class="token keyword">in</span> match_to_V <span class="token keyword">or</span> dfs<span class="token punctuation">(</span>match_to_V<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>
                match_to_V<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u
                <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    result <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> u <span class="token keyword">in</span> U<span class="token punctuation">:</span>
        visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> dfs<span class="token punctuation">(</span>u<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>
            result <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> result<span class="token punctuation">,</span> match_to_V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>📘 示例图</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">U &#x3D; &#123;u1, u2, u3&#125;
V &#x3D; &#123;v1, v2, v3&#125;
Edges:
u1 - v1
u1 - v2
u2 - v2
u3 - v3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<ul>
<li><p>初始：匹配为空。</p>
</li>
<li><p>尝试从 $u_1$ 找路径 → 匹配 $u_1$ 与 $v_1$</p>
</li>
<li><p>再尝试 $u_2$ → 匹配 $u_2$ 与 $v_2$</p>
</li>
<li><p>再尝试 $u_3$ → 匹配 $u_3$ 与 $v_3$</p>
</li>
<li><p>最终得到最大匹配为 3</p>
</li>
<li><p><strong>时间复杂度</strong>：$O(n \cdot m)$，其中 $n$ 是顶点数，$m$ 是边数。</p>
<ul>
<li>对于每个点尝试一次 DFS，最坏每次都遍历所有边。</li>
</ul>
</li>
</ul>
<img src="/img/DSA/bha.svg" srcset="/img/loading.gif" lazyload alt="匈牙利算法" style="max-width: 100%; height: auto;" />


<hr>
<h3 id="5-9-欧拉路径-Eulerian-Path"><a href="#5-9-欧拉路径-Eulerian-Path" class="headerlink" title="5.9 欧拉路径(Eulerian Path)"></a>5.9 欧拉路径(Eulerian Path)</h3><p>欧拉路径是图中的一条路径，它经过图中每一条边恰好一次。可以重复经过顶点，但不能重复经过边。如果这条路径是一个回路（即起点和终点是同一个顶点），那么它叫做欧拉回路（Eulerian Circuit 或 Cycle）。</p>
<p>欧拉路径算法适用于：</p>
<ul>
<li><p><strong>无向图</strong>或<strong>有向图</strong></p>
</li>
<li><p>使用以下常见数据结构表示图：</p>
<ul>
<li>邻接表（推荐）</li>
<li>邻接矩阵（适合稠密图）</li>
</ul>
</li>
</ul>
<p><strong>Python中的邻接表：</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token number">2</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>欧拉路径判定条件（算法判断步骤）</strong></p>
<p>🎯 对于<strong>无向图</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">has_eulerian_path_undirected</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    odd_degree_count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
            odd_degree_count <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> odd_degree_count <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> odd_degree_count <span class="token operator">==</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<blockquote>
<p>若有0个或2个奇数度顶点 → 存在欧拉路径。</p>
</blockquote>
<p><strong>🎯 对于有向图</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">has_eulerian_path_directed</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    in_deg <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    out_deg <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    
    <span class="token keyword">for</span> u <span class="token keyword">in</span> graph<span class="token punctuation">:</span>
        out_deg<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> v <span class="token keyword">in</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>
            in_deg<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> in_deg<span class="token punctuation">.</span>get<span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            in_deg<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>u<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
            out_deg<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    
    start_nodes <span class="token operator">=</span> end_nodes <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> node <span class="token keyword">in</span> graph<span class="token punctuation">:</span>
        out_d <span class="token operator">=</span> out_deg<span class="token punctuation">.</span>get<span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        in_d <span class="token operator">=</span> in_deg<span class="token punctuation">.</span>get<span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> out_d <span class="token operator">-</span> in_d <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
            start_nodes <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> in_d <span class="token operator">-</span> out_d <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
            end_nodes <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> in_d <span class="token operator">!=</span> out_d<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>start_nodes <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> end_nodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>start_nodes <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">and</span> end_nodes <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>欧拉路径构造算法（Hierholzer’s Algorithm）</strong></p>
<blockquote>
<p>更高效于 Fleury 算法，时间复杂度为 $O(E)$，适合稀疏图。</p>
</blockquote>
<p><strong>💡 算法思路（无向图为例）</strong></p>
<ol>
<li>从一个合法的起点出发（若有奇数度，则从奇数度顶点开始）</li>
<li>用<strong>栈</strong>模拟 DFS 深度优先遍历路径</li>
<li>每次走一条边，就把它“删掉”</li>
<li>如果当前节点没有边了，把它弹出，加入结果路径</li>
<li>最终路径反转后即为欧拉路径</li>
</ol>
<p><strong>🚀 Python实现（无向图）</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict

<span class="token keyword">def</span> <span class="token function">find_eulerian_path</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span>u<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">(</span>vs<span class="token punctuation">)</span> <span class="token keyword">for</span> u<span class="token punctuation">,</span> vs <span class="token keyword">in</span> graph<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
    stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token comment"># 选择起点：奇数度点，如果没有就任选一个</span>
    start <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">(</span>u <span class="token keyword">for</span> u <span class="token keyword">in</span> graph <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">next</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start<span class="token punctuation">)</span>

    <span class="token keyword">while</span> stack<span class="token punctuation">:</span>
        u <span class="token operator">=</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">:</span>
            v <span class="token operator">=</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
            graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>u<span class="token punctuation">)</span>  <span class="token comment"># 对于无向图，要从两边删除</span>
            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 反转得到正向路径</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>🌟 示例输入</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token number">0</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token number">2</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token number">3</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>

path <span class="token operator">=</span> find_eulerian_path<span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Eulerian Path:"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>输出可能为：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Eulerian Path: [0, 1, 3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>🏁 总结：欧拉路径判定与构造流程</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>无向图</th>
<th>有向图</th>
</tr>
</thead>
<tbody><tr>
<td>判定是否存在欧拉路径</td>
<td>奇度点数是0或2</td>
<td>至多1个出度多1和1个入度多1</td>
</tr>
<tr>
<td>起点选择</td>
<td>若有奇度，从奇度点；否则任意</td>
<td>出度多1的点；否则任意</td>
</tr>
<tr>
<td>构造路径</td>
<td>Hierholzer 算法</td>
<td>同样可以用 Hierholzer，但注意方向</td>
</tr>
</tbody></table>
<hr>
<h4 id="5-9-1-欧拉路径相关命题证明"><a href="#5-9-1-欧拉路径相关命题证明" class="headerlink" title="5.9.1 欧拉路径相关命题证明"></a>5.9.1 欧拉路径相关命题证明</h4><p><strong>命题1</strong>：一个<strong>连通</strong>的无向图存在欧拉路径的充要条件是：<br>图中<strong>奇数度顶点的个数是 0 或 2</strong>。</p>
<p>✏️ 证明（无向图）</p>
<p>记图为 $G &#x3D; (V, E)$。</p>
<p>我们需要证明两个方向：</p>
<p>✅ 正向：存在欧拉路径 ⟹ 奇数度点数为 0 或 2</p>
<p>设图存在一条欧拉路径 $P$，从 $s$ 到 $t$，路径中每条边仅出现一次。</p>
<p>观察路径中每个点的度数：</p>
<ul>
<li>对于路径中<strong>中间的每个顶点</strong>（即既非起点 $s$ 也非终点 $t$），每次到达它后都必须离开它，所以它们的度数一定是<strong>偶数</strong>。</li>
<li>如果路径首尾 $s \neq t$，那么 $s$ 只有“出”而没有“入”，$t$ 只有“入”而没有“出”，所以它们的度数都是奇数。</li>
<li>如果路径是一个回路（$s &#x3D; t$），那么所有点的度数都是偶数。</li>
</ul>
<p>因此，图中奇数度顶点最多只能有两个（$s$ 和 $t$），否则不能形成欧拉路径。</p>
<p>✅ 所以：<strong>奇数度点数为 0（回路）或 2（非回路）</strong>。</p>
<hr>
<p>✅ 反向：奇数度点数为 0 或 2 ⟹ 存在欧拉路径</p>
<p>我们考虑两种情况：</p>
<ol>
<li><p><strong>若所有顶点的度数都是偶数</strong>（即奇度点数 &#x3D; 0）：</p>
<p>欧拉回路存在（Hierholzer 算法可构造）。回路是一种特殊的路径，因此欧拉路径也存在。</p>
</li>
<li><p><strong>若恰好两个奇数度顶点</strong>：</p>
<p>假设这两个点为 $u$ 和 $v$。我们构造一个新图 $G’$，在 $u$ 和 $v$ 之间加一条边 $(u, v)$。</p>
<ul>
<li>由于 $u$ 和 $v$ 原本为奇度，加上一条边后变为偶度，其余点度数不变。</li>
<li>所以 $G’$ 所有顶点都是偶数度 ⇒ $G’$ 有欧拉<strong>回路</strong>。</li>
<li>在 $G’$ 的欧拉回路中，必定会经过 $(u, v)$。我们从 $u$ 出发，走完整个回路，第一次遇到 $(u, v)$ 时就把它“切开”，只留下从 $u$ 到 $v$ 的路径 ⇒ $G$ 的欧拉路径。</li>
</ul>
</li>
</ol>
<p>✅ 所以：<strong>奇数度点数为 0 或 2 ⇒ 存在欧拉路径</strong>。</p>
<hr>
<p><strong>📌 命题二（有向图）</strong></p>
<p><strong>命题</strong>：一个<strong>连通</strong>的有向图存在欧拉路径的充要条件是：</p>
<ul>
<li>所有顶点满足 $in(v) &#x3D; out(v)$，或者</li>
<li>恰有一个顶点 $s$ 满足 $out(s) &#x3D; in(s) + 1$，一个顶点 $t$ 满足 $in(t) &#x3D; out(t) + 1$，其余点 $in &#x3D; out$</li>
</ul>
<p><strong>✅ 正向：存在欧拉路径 ⟹ 满足上述条件</strong></p>
<p>假设存在欧拉路径，从顶点 $s$ 到 $t$。</p>
<p>观察每个顶点的入度 $in(v)$ 与出度 $out(v)$：</p>
<ul>
<li>对于中间点（既非 $s$ 也非 $t$）：每进一次就必须出一次 ⇒ $in &#x3D; out$</li>
<li>起点 $s$：出度比入度多1 ⇒ $out(s) &#x3D; in(s) + 1$</li>
<li>终点 $t$：入度比出度多1 ⇒ $in(t) &#x3D; out(t) + 1$</li>
</ul>
<p>所以图中必须恰好有：</p>
<ul>
<li>一个顶点出度多1（起点）</li>
<li>一个顶点入度多1（终点）</li>
<li>其他点 $in &#x3D; out$</li>
</ul>
<p>或如果是回路情况，则所有点 $in &#x3D; out$</p>
<p><strong>✅ 反向：满足上述度数条件 ⟹ 存在欧拉路径</strong></p>
<p>和无向图类似：</p>
<ul>
<li><p>如果所有点 $in &#x3D; out$，我们可以从任意点出发，构造一个欧拉<strong>回路</strong>。</p>
</li>
<li><p>如果恰有 $s, t$ 满足上述不等度条件：</p>
<ul>
<li>我们向图中加入一条边 $(t \to s)$，使得所有点满足 $in &#x3D; out$。</li>
<li>在新图中存在欧拉回路。</li>
<li>在这个回路中，$(t \to s)$ 是某一段，我们将其“切断”，得到从 $s$ 到 $t$ 的欧拉路径。</li>
</ul>
</li>
</ul>
<p><strong>✅ 结论总结</strong></p>
<table>
<thead>
<tr>
<th>图类型</th>
<th>欧拉路径存在条件</th>
</tr>
</thead>
<tbody><tr>
<td>无向图</td>
<td>图连通且奇度点数为 0 或 2</td>
</tr>
<tr>
<td>有向图</td>
<td>图连通且：<br>① 所有点 $in &#x3D; out$（回路）<br>② 或存在 $s, t$，满足 $out(s) &#x3D; in(s)+1$，$in(t) &#x3D; out(t)+1$，其余点 $in &#x3D; out$（路径）</td>
</tr>
</tbody></table>
<h2 id="6-Greedy-Algorithm"><a href="#6-Greedy-Algorithm" class="headerlink" title="6. Greedy Algorithm"></a>6. Greedy Algorithm</h2><p><strong>贪心算法</strong>是一种算法设计范式，其核心思想是：在解决问题时，总是做出在当前状态下看起来最优的选择，即局部最优解，希望通过一系列这样的选择能够最终得到全局最优解。这个算法理解起来非常直观，但是合理性证明的话需要严格的数学证明。本章着重讲解最经典的<strong>最大子序和问题（Maximum Subarray）</strong> 和<strong>合并区间问题（Merge Intervals）</strong></p>
<h3 id="6-1-Maximum-Subarray"><a href="#6-1-Maximum-Subarray" class="headerlink" title="6.1 Maximum Subarray"></a>6.1 Maximum Subarray</h3><p>这道问题可以直接上<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/description/">Leetcode 53题</a>练习。</p>
<blockquote>
<p>问题描述是：Given an integer array nums, find the subarray with the largest sum, and return its sum.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<ul>
<li><p>Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p>
</li>
<li><p>Output: 6</p>
</li>
<li><p>Explanation: The subarray [4,-1,2,1] has the largest sum 6.</p>
</li>
</ul>
<p>解决这个问题的贪心算法也叫Kadane算法：算法从左到右遍历一次数组，在每一步，它都计算当前位置结束的子数组的最大和（Current Sum）同时，它保持追踪全局的最大和（Max Sum）。最终，Max Sum的最后一个值就是整个问题的解。<br><img src="/img/DSA/kadane.svg" srcset="/img/loading.gif" lazyload alt="kadane算法演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> maxSum <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>
        <span class="token keyword">int</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x <span class="token operator">:</span> nums<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            curSum <span class="token operator">+=</span> x<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> curSum <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 贪心地取子数组最大值</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>curSum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> maxSum <span class="token operator">=</span> curSum<span class="token punctuation">;</span> <span class="token comment">// 不断更新结果</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="6-2-Merge-Intervals"><a href="#6-2-Merge-Intervals" class="headerlink" title="6.2 Merge Intervals"></a>6.2 Merge Intervals</h3><p>这道问题可以直接上<a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/description/">Leetcode 56题</a>练习。</p>
<blockquote>
<p>题目描述：Given an array of intervals where $\text{intervals}[i] &#x3D; [\text{start}_i, \text{end}_i]$, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<p>Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</p>
<p>Output: [[1,6],[8,10],[15,18]]</p>
<p>Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</p>
<p>解决这道题的思路是：先排序让所有相邻的区间尽可能重合在一起(以开端最小优先，其次结尾最小次之)，然后一次遍历贪心地选择局部最优解。<br><img src="/img/DSA/merge.svg" srcset="/img/loading.gif" lazyload alt="合并区间算法演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 重载cmp函数，让区间的排列以开端最小优先，其次结尾最小优先</span>
    <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> result<span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 贪心地选择是否合并区间</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 若不重合，则加入结果数组</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 若重合，则合并区间并贪心的选择区间结尾</span>
            <span class="token keyword">else</span> result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h2 id="7-Dynamic-Programming"><a href="#7-Dynamic-Programming" class="headerlink" title="7. Dynamic Programming"></a>7. Dynamic Programming</h2><p><strong>动态规划（Dynamic Programming, DP）</strong> 是一种用于解决最优化问题的算法设计技巧。它通过将问题分解为更小的子问题，并记录其解来<u>避免重复计算</u>，从而提高算法的效率。本章主要讲解5个经典DP问题：<em>斐波那契数列</em>，<em>背包问题</em>，<em>股票问题</em>，<em>最长公共子序列</em>，以及<em>序列比对问题</em>。</p>
<h3 id="7-1-Fibonacci-Sequence"><a href="#7-1-Fibonacci-Sequence" class="headerlink" title="7.1 Fibonacci Sequence"></a>7.1 Fibonacci Sequence</h3><p>形如：$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ….$的数列称之为斐波那契数，我们可以很轻易地得到递归式：$dp[n] &#x3D; dp[n-1] + dp[n-2]$,然后我们再对递归式子进行初始化：$dp[0] &#x3D; 1, dp[1] &#x3D; 1$, 我们就可以利用递归式求得所有的斐波那契数。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> N<span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="7-2-Knapsack-Problem"><a href="#7-2-Knapsack-Problem" class="headerlink" title="7.2 Knapsack Problem"></a>7.2 Knapsack Problem</h3><p>关于背包问题有三种：0-1背包，完全背包，多重背包。应对修考我认为掌握0-1背包问题就足够了。关于0-1背包的问题描述是：</p>
<ol>
<li>一组物品，每个物品都有一个重量和一个价值。</li>
<li>一个背包，具有固定的容量。</li>
</ol>
<p>给定$n$个物品，每个物品$i$具有重量$w[i]$和价值$v[i]$，还有一个背包的最大容量$W$。目标是选择物品的组合，使得在不超过背包容量的情况下，背包中的物品总价值最大。</p>
<p><strong>1.定义状态：</strong> $dp[i][j]$表示在考虑前$i$个物品，且背包容量为$j$时的最大价值。</p>
<p><strong>2.状态转移方程：</strong> 对于每个物品$i$，有两个选择：</p>
<ul>
<li>不放入背包：此时最大价值为$dp[i-1][j]$。</li>
<li>放入背包：此时最大价值为$dp[i-1][j - w[i]] + v[i]$，前提是当前物品的重量不超过背包容量 $j &gt;&#x3D; w[i]$。</li>
</ul>
<p>因此，状态转移方程为：<br>$$<br>dp[i][j] &#x3D; \begin{cases}<br>dp[i-1][j] &amp; \text{if } j &lt; w[i] \\<br>\max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]) &amp; \text{if } j \geq w[i]<br>\end{cases}<br>$$</p>
<p><strong>3.边界条件：</strong></p>
<ul>
<li>当没有物品可选时，最大价值为$0$，即 $(dp[0][j] &#x3D; 0)$。</li>
<li>当背包容量为$0$时，最大价值也为$0$，即 $(dp[i][0] &#x3D; 0)$。</li>
</ul>
<p><strong>4.计算顺序：</strong></p>
<p>先遍历物品再遍历背包更容易理解，从 $(i &#x3D; 1)$到 $(n)$，对于每个物品，再从 $(j &#x3D; 0)$到$(W)$计算。当然也可以先遍历背包再遍历物品，这里不过多赘述。</p>
<p><strong>5.返回结果：</strong> 最终的最大价值为 $(dp[n][W])$。</p>
<p>假设有以下物品和背包容量：</p>
<ul>
<li>物品 1：重量 &#x3D; 2，价值 &#x3D; 3</li>
<li>物品 2：重量 &#x3D; 3，价值 &#x3D; 4</li>
<li>物品 3：重量 &#x3D; 4，价值 &#x3D; 5</li>
<li>物品 4：重量 &#x3D; 5，价值 &#x3D; 6</li>
</ul>
<p>背包容量为 5。<br><img src="/img/DSA/01knapsnack.svg" srcset="/img/loading.gif" lazyload alt="01背包遍历演示" style="max-width: 100%; height: auto;" /></p>
<p>遍历的核心代码：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历物品</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> W<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历背包容量</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 装不下的情况</span>
            <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 装下的情况</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="7-3-Stock-Problem"><a href="#7-3-Stock-Problem" class="headerlink" title="7.3 Stock Problem"></a>7.3 Stock Problem</h3><p>股票问题有很多种，这里介绍一种，参考<a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">Leetcode 122题</a>。题目描述是：</p>
<blockquote>
<p>You are given an integer array $prices$ where $prices[i]$ is the price of a given stock on the ith day. On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold <u>at most one share </u> of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<ul>
<li>Input: prices &#x3D; [7,1,5,3,6,4]</li>
<li>Output: 7</li>
<li>Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.<br>Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.<br>Total profit is 4 + 3 &#x3D; 7.<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// have the stock on the day 0;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token comment">// no stock on the day 0;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// no stock on the day n - 1</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></li>
</ul>
<p><strong>初始状态：</strong></p>
<p><code>dp[0][0] = -prices[0]</code>：表示在第$0$天买入股票后的利润，利润为负的股票价格。<br><code>dp[0][1] = 0</code>：表示在第$0$天没有持有股票，利润为$0$。</p>
<p><strong>状态转移：</strong></p>
<blockquote>
<p><strong>对于第$i$天，持有股票的状态 <code>dp[i][0]</code>，有两种可能：</strong></p>
</blockquote>
<ul>
<li>前一天已经持有股票，保持不动：<code>dp[i-1][0]</code>。  </li>
<li>前一天没有持有股票，但今天买入：<code>dp[i-1][1] - prices[i]</code>（买入股票，减去当天股票的价格）。</li>
</ul>
<p>取两者的最大值：<code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])</code>。</p>
<blockquote>
<p><strong>对于第$i$天，不持有股票的状态 <code>dp[i][1]</code>，也有两种可能：</strong></p>
</blockquote>
<ul>
<li>前一天已经不持有股票，保持不动：<code>dp[i-1][1]</code>。  </li>
<li>前一天持有股票，但今天卖出：<code>dp[i-1][0] + prices[i]</code>（卖出股票，得到当前股票的价格）。</li>
</ul>
<p>取两者的最大值：<code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</code>。</p>
<p><strong>最终结果：</strong> 返回 <code>dp[n-1][1]</code>，表示最后一天不持有股票的最大利润。</p>
<h3 id="7-4-Longest-Common-Subsequence"><a href="#7-4-Longest-Common-Subsequence" class="headerlink" title="7.4 Longest Common Subsequence"></a>7.4 Longest Common Subsequence</h3><p><strong>最长公共子序列（LCS）</strong> 也是修考的一个常考点，具体参考：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-subsequence/description/">Leetcode 1143</a></p>
<blockquote>
<p>Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”. A common subsequence of two strings is a subsequence that is common to both strings.</p>
</blockquote>
<p><strong>Example 1:</strong></p>
<ul>
<li>Input: text1 &#x3D; “abcde”, text2 &#x3D; “ace” </li>
<li>Output: 3  </li>
<li>Explanation: The longest common subsequence is “ace” and its length is 3.</li>
</ul>
<p><strong>定义状态：</strong></p>
<p>$$<br>dp[i][j] \text{ 表示在考虑前 } i \text{ 个字符的 } \text{text1} \text{ 和前 } j \text{ 个字符的 } \text{text2} \text{ 时的最长公共子序列的长度。}<br>$$</p>
<p><strong>状态转移方程：</strong></p>
<p>对于每个字符对<code>text1[i-1] </code> 和<code>text2[j-1]</code>，有两种情况：</p>
<ul>
<li>如果 <code>&#39;text1[i-1] == text2[j-1]&#39;</code>，说明这两个字符相同，最长公共子序列可以延长 1，此时 <code>&#39;dp[i][j] = dp[i-1][j-1] + 1&#39;</code>。</li>
<li>如果 <code>&#39;text1[i-1] != text2[j-1]&#39;</code>，则取决于之前的子问题结果，最长公共子序列为：<ul>
<li>不包括当前字符：<code>&#39;dp[i][j] = max(dp[i][j-1], dp[i-1][j])&#39;</code>。</li>
</ul>
</li>
</ul>
<p><strong>边界条件：</strong></p>
<ul>
<li>当 <code>&#39;i = 0&#39;</code> 或 <code>&#39;j = 0&#39;</code> 时，即有一个字符串为空，最长公共子序列长度为 0，所以初始化时 <code>&#39;dp[0][j] = 0&#39;</code> 和 <code>&#39;dp[i][0] = 0&#39;</code>。</li>
</ul>
<p><strong>计算顺序：</strong></p>
<p>从 <code>&#39;i = 1&#39;</code> 到 <code>&#39;n&#39;</code>，对于每个字符，再从 <code>&#39;j = 1&#39;</code> 到 <code>&#39;m&#39;</code> 计算 <code>&#39;dp[i][j]&#39;</code>，逐步构建整个表。</p>
<p><strong>返回结果：</strong></p>
<p>最终结果为 <code>&#39;dp[n][m]&#39;</code>，即考虑所有字符的最长公共子序列的长度。<br><img src="/img/DSA/lcs.svg" srcset="/img/loading.gif" lazyload alt="LCS遍历演示" style="max-width: 100%; height: auto;" /></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="7-5-Sequence-Alignment"><a href="#7-5-Sequence-Alignment" class="headerlink" title="7.5 Sequence Alignment"></a>7.5 Sequence Alignment</h3><p><strong>序列比对（Sequence Alignment）</strong> 是生物信息学中的一个核心问题，用于比较两个或多个生物序列（如DNA、RNA或蛋白质）的相似性。其目的是通过对比序列中的元素（碱基或氨基酸）找出它们之间的最优匹配方式，进而揭示它们的进化关系、功能相似性或结构上的保守性。</p>
<h4 id="7-5-1-Needleman–Wunsch-algorithm"><a href="#7-5-1-Needleman–Wunsch-algorithm" class="headerlink" title="7.5.1 Needleman–Wunsch algorithm"></a>7.5.1 Needleman–Wunsch algorithm</h4><p>Needleman-Wunsch算法是用于进行全局序列比对的经典算法，特别适用于对比两个生物序列（如DNA、RNA或蛋白质）时，将它们的整个序列进行对齐。它采用动态规划的思想来寻找两个序列的最优对齐方式。<br><img src="/img/DSA/needle.svg" srcset="/img/loading.gif" lazyload alt="序列比对算法演示" style="max-width: 100%; height: auto;" /></p>
<p><strong>Needleman-Wunsch算法步骤：</strong></p>
<p><strong>定义状态：</strong></p>
<p>设有两个序列 <code>A</code> 和 <code>B</code>，长度分别为 <code>n</code> 和 <code>m</code>。<br>创建一个大小为 <code>(n+1) x (m+1)</code> 的二维矩阵 <code>dp</code>，其中 <code>dp[i][j]</code> 表示序列 <code>A</code> 的前 <code>i</code> 个字符与序列 <code>B</code> 的前 <code>j</code> 个字符的最优对齐得分。</p>
<p><strong>罚分机制：</strong></p>
<ul>
<li><strong>匹配</strong>：当 <code>A[i-1] == B[j-1]</code> 时，表示两个字符相同，得分为 <code>match score</code>。</li>
<li><strong>不匹配</strong>：当 <code>A[i-1] != B[j-1]</code> 时，表示两个字符不同，得分为 <code>mismatch penalty</code>。</li>
<li><strong>Gap</strong>：当在序列 <code>A</code> 或 <code>B</code> 中插入一个字符时，得分为 <code>gap penalty</code>。</li>
</ul>
<p><strong>初始化：</strong></p>
<ul>
<li>第一行和第一列表示序列与空序列的比对。比对空序列时，每个字符都需要插入或删除，因此使用缺口罚分（gap penalty）。</li>
<li>初始化 <code>dp[0][0] = 0</code>，代表两个空序列的得分为 0。</li>
<li>初始化第一行：<code>dp[0][j] = j * gap penalty</code>，表示序列 <code>B</code> 的前 <code>j</code> 个字符与空序列的比对得分。</li>
<li>初始化第一列：<code>dp[i][0] = i * gap penalty</code>，表示序列 <code>A</code> 的前 <code>i</code> 个字符与空序列的比对得分。</li>
</ul>
<p><strong>状态转移方程：</strong>对于矩阵中的每个 <code>dp[i][j]</code>，有三种可能的情况：</p>
<ol>
<li><strong>匹配</strong>：如果 <code>A[i-1] == B[j-1]</code>，即两个字符相同，则可以匹配，得分为 <code>dp[i-1][j-1] + match score</code>。</li>
<li><strong>不匹配</strong>：如果 <code>A[i-1] != B[j-1]</code>，则可以进行替换，得分为 <code>dp[i-1][j-1] + mismatch penalty</code>。</li>
<li><strong>插入&#x2F;删除（Gap）</strong>：在序列 <code>A</code> 或 <code>B</code> 中插入一个字符，得分为 <code>dp[i][j-1] + gap penalty</code> 或 <code>dp[i-1][j] + gap penalty</code>。</li>
</ol>
<p>取这三种操作中的最大值更新 <code>dp[i][j]</code>，即：</p>
<p>$$<br>dp[i][j] &#x3D; \max\left(dp[i-1][j-1] + \text{(match&#x2F;mismatch score)}, dp[i-1][j] + \text{gap penalty}, dp[i][j-1] + \text{gap penalty}\right)<br>$$</p>
<p><strong>回溯：</strong>填完矩阵后，从右下角 <code>dp[n][m]</code> 开始回溯，找出最优路径，从而得到序列 <code>A</code> 和 <code>B</code> 的最优全局对齐方案。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> m <span class="token operator">=</span> B<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化：处理空序列的情况</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一列，表示A的前i个字符和空序列的比对</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j <span class="token operator">*</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 第一行，表示B的前j个字符和空序列的比对</span>

<span class="token comment">// 填充 dp 表</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 1. 匹配或不匹配的情况</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 如果当前字符相等，则进行匹配，加上 match_score</span>
            <span class="token keyword">int</span> match <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> match_score<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 如果当前字符不相等，则进行替换，加上 mismatch_penalty</span>
            <span class="token keyword">int</span> mismatch <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> mismatch_penalty<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
        <span class="token comment">// 2. 插入的情况</span>
        <span class="token keyword">int</span> insert <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>  <span class="token comment">// 在序列 A 中插入 gap</span>

        <span class="token comment">// 3. 删除的情况</span>
        <span class="token keyword">int</span> del <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> gap_penalty<span class="token punctuation">;</span>     <span class="token comment">// 在序列 B 中插入 gap</span>
        
        <span class="token comment">// 取三种操作的最大值来更新 dp[i][j]</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> B<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> match_score <span class="token operator">:</span> mismatch_penalty<span class="token punctuation">)</span><span class="token punctuation">,</span> insert<span class="token punctuation">,</span> del<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 最终结果是 dp[n][m]，表示A和B的最优全局比对得分</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h2 id="8-P-NP-problem"><a href="#8-P-NP-problem" class="headerlink" title="8. P&#x2F;NP problem"></a>8. P&#x2F;NP problem</h2><p><strong>P&#x2F;NP问题</strong> 是计算机科学中的一个核心难题，涉及确定哪些问题可以在合理的时间内（多项式时间）被解决，和哪些问题的解可以在合理的时间内被验证。它是理论计算机科学和数学中最著名、最重要的未解决问题之一。</p>
<p><strong>P类问题</strong></p>
<p>P类问题（Polynomial time）指的是那些可以在多项式时间内被解决的问题。也就是说，给定一个问题实例，使用某种算法可以在输入规模为 $n$ 时，用 $n^k$（其中 $k$ 是一个常数）次运算步骤就可以得到结果。</p>
<ul>
<li><p>例如，常见的排序算法（如快速排序）和图论中的最短路径算法（如Dijkstra算法）都是 <strong>P类问题</strong>。它们的时间复杂度是多项式级别的。</p>
</li>
<li><p><strong>直观理解</strong>：如果一个问题属于P类，那么它是“容易”解决的，因为我们可以用有效的算法在合理的时间内求解。</p>
</li>
</ul>
<p><strong>NP类问题</strong></p>
<p>NP类问题（Nondeterministic Polynomial time）是指那些解可以在多项式时间内被验证的问题，尽管可能没有已知的多项式时间算法来找到这个解。</p>
<ul>
<li><p>也就是说，如果我们猜测出一个解，可以在多项式时间内检查这个解是否正确。但是，要找到这个解可能会很难，甚至没有已知的多项式时间算法来求解。</p>
</li>
<li><p><strong>经典的NP问题</strong> 包括旅行商问题（TSP）、背包问题和布尔可满足性问题（SAT）。这些问题的特点是验证解很容易，但找到最优解可能非常耗时。</p>
</li>
</ul>
<p><strong>P与NP的关系</strong></p>
<ul>
<li><p><strong>P是否属于NP？</strong></p>
<ul>
<li><p>P类问题显然也是NP类问题。如果我们能够在多项式时间内求解一个问题，那我们一定也能在多项式时间内验证这个解。</p>
</li>
<li><p>因此可以得出结论：<strong>P是NP的一个子集</strong>，即 $P \subseteq NP$。</p>
</li>
</ul>
</li>
<li><p><strong>P与NP的区别</strong></p>
<ul>
<li>关键在于我们还不确定 <strong>P类问题</strong> 和 <strong>NP类问题</strong> 是否是同一个集合。这就是 <strong>P vs NP</strong> 问题的核心所在：<ul>
<li>如果 $P &#x3D; NP$，那么所有能在多项式时间内验证的解也可以在多项式时间内求解。</li>
<li>如果 $P \neq NP$，那么有一些问题能在多项式时间内验证解，但没有已知的多项式时间算法来求解它们。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>NP完全问题（NP-Complete）</strong></p>
<p>NP完全问题（NP-Complete, NPC）是NP类问题中的一个特殊子集，它们有两个重要的特性：</p>
<ol>
<li>它们本身是NP类问题。</li>
<li>任何一个NP类问题都可以通过多项式时间的归约（转换）转换为这个NP完全问题。</li>
</ol>
<ul>
<li><p><strong>重要性</strong>：如果你能找到一个NP完全问题的多项式时间解法，那么所有的NP问题都可以在多项式时间内解决。因此，NP完全问题是NP类问题中的“最难问题”。</p>
</li>
<li><p><strong>典型的NP完全问题</strong>：</p>
<ul>
<li>旅行商问题（TSP）：寻找一条经过每个城市恰好一次且路径最短的旅行路线。</li>
<li>3-SAT问题：判断一个布尔公式是否有解。</li>
<li>顶点覆盖问题：在一个图中找到最小的顶点集合，使得每条边至少有一个顶点被覆盖。</li>
</ul>
</li>
</ul>
<p><strong>P vs NP问题</strong></p>
<p>P vs NP问题是指：<strong>P是否等于NP？</strong></p>
<ul>
<li><p>如果 <strong>P &#x3D; NP</strong>，意味着所有NP问题都有多项式时间的求解算法。这将意味着大量的难问题（如密码学中的问题）可以被快速解决。</p>
</li>
<li><p>如果 <strong>P ≠ NP</strong>，那么一些问题的解可以快速验证，但无法快速求解。</p>
</li>
</ul>
<p>目前，这个问题尚未解决，它是 <strong>“千禧年大奖问题”</strong> 之一，美国克雷数学研究所为解决这个问题悬赏 <strong>100万美元</strong>。</p>
<p><strong>总结</strong></p>
<ul>
<li><strong>P类问题</strong>：可以在多项式时间内求解。</li>
<li><strong>NP类问题</strong>：可以在多项式时间内验证解，但不一定能在多项式时间内求解。</li>
<li><strong>P vs NP问题</strong>：我们不知道所有可以快速验证的解是否也可以快速求解，即是否 $P &#x3D; NP$。</li>
</ul>
<h2 id="9-偷偷说"><a href="#9-偷偷说" class="headerlink" title="9.偷偷说"></a>9.偷偷说</h2><p>本文应该囊括了修考绝大部分的考点了，当然还有双指针和滑动窗口，哈希之类的算法技巧我觉得就不用大费周章地写下来了。做修考题我认为最重要的是阅读伪代码的能力！希望这篇文章可以帮助到修考受验生们。完结撒花🎉</p>
<div class="note note-success">
            <p>偷偷目前兼任私塾班主任，如果需要1对1辅导，请联系：LifeGoesOn_Rio</p>
          </div>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%A7%91%E7%9B%AE%E7%AC%94%E8%AE%B0/" class="category-chain-item">专业科目笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%BF%AE%E8%80%83/" class="print-no-link">#修考</a>
      
        <a href="/tags/DSA/" class="print-no-link">#DSA</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Data Structure &amp; Algorithms</div>
      <div>http://toutou.zeabur.app/2024/09/10/DSA/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>toutou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>September 10, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/09/15/UTO-DSA-2021-8/" title="2021年8月东大情理CS算法题解读">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2021年8月东大情理CS算法题解读</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/10/JPN/" title="日本語勉強">
                        <span class="hidden-mobile">日本語勉強</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://www.instagram.com/hanni_rio/" target="_blank" rel="nofollow noopener"><span>Hanni Rio</span></a> <i class="iconfont icon-copyright"></i> <a href="https://toutou.pro/" target="_blank" rel="nofollow noopener"><span>toutou</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
