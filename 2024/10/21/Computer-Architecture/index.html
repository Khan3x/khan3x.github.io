

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="toutou">
  <meta name="keywords" content="">
  
    <meta name="description" content="Computer ArchitectureThis is for test takers to quickly review Computer Architecture. The whole notes contain 5 parts and I try to make it clear and simple. Credit to《Computer Organization and Design">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer Architecture">
<meta property="og:url" content="http://toutou.zeabur.app/2024/10/21/Computer-Architecture/index.html">
<meta property="og:site_name" content="偷偷星球">
<meta property="og:description" content="Computer ArchitectureThis is for test takers to quickly review Computer Architecture. The whole notes contain 5 parts and I try to make it clear and simple. Credit to《Computer Organization and Design">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/von.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/endianness.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/float.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/pipeline.png">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/memory.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/cache_map.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/map_miss.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/map_strategy.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/CA/address.svg">
<meta property="article:published_time" content="2024-10-21T15:50:31.000Z">
<meta property="article:modified_time" content="2025-07-31T07:30:30.138Z">
<meta property="article:author" content="toutou">
<meta property="article:tag" content="修考">
<meta property="article:tag" content="Computer Architecture">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://toutou.zeabur.app/img/CA/von.svg">
  
  
  
  <title>Computer Architecture - 偷偷星球</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"toutou.zeabur.app","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>偷偷星球</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/wall.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Computer Architecture"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-21 23:50" pubdate>
          October 21, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          112 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Computer Architecture</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Computer-Architecture"><a href="#Computer-Architecture" class="headerlink" title="Computer Architecture"></a>Computer Architecture</h1><p>This is for test takers to quickly review Computer Architecture. The whole notes contain 5 parts and I try to make it clear and simple. Credit to《Computer Organization and Design : The Hardware&#x2F;Software Interface, 5th Edition》</p>
<blockquote>
<p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>
</blockquote>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>在本章中，主要引入一下计算机组成的概念然后讲解衡量计算机的性能指标，并着重讲解涉及到的计量单位和公式。</p>
<h3 id="1-1-常用单位"><a href="#1-1-常用单位" class="headerlink" title="1.1 常用单位"></a>1.1 常用单位</h3><p>容量单位常用<strong>字节(Byte)</strong> ,衡量单位是<em>2进制(Binary)</em> ,容量之间的数量级关系是：$2^{10}$; 常见的有$K$,$M$,$G$,$T$。</p>
<blockquote>
<p>例如： $1TB&#x3D;2^{10} GB&#x3D; 1024GB$; $1GB&#x3D;2^{10}MB&#x3D;1024MB$</p>
</blockquote>
<p>衡量传输速度常用<strong>位每秒(bps,bit per secod)</strong> ,衡量单位是<em>10进制(Decimal)</em> ,传输速度之间的数量级关系是：$10^3$; 常见的有$K$,$M$,$G$,$T$。</p>
<blockquote>
<p>例如：$1kbit&#x2F;s&#x3D;1000bit&#x2F;s$, $1mbit&#x2F;s&#x3D;1000kbit&#x2F;s$</p>
</blockquote>
<p>另外需要注意的单位换算是：</p>
<ul>
<li>$bit&#x2F;s$记作$bps$</li>
<li>$1 Byte &#x3D; 8 bit$</li>
<li>$1 Bps &#x3D; 1 Byte&#x2F;second &#x3D; 8 bit&#x2F;second &#x3D; 8 bps$</li>
</ul>
<h3 id="1-2-计算机结构中的8个伟大思想"><a href="#1-2-计算机结构中的8个伟大思想" class="headerlink" title="1.2 计算机结构中的8个伟大思想"></a>1.2 计算机结构中的8个伟大思想</h3><ul>
<li>Moore’s Law: 芯片上的集成度每18～24个月翻一番</li>
<li>Abstraction：使用抽象来表示不同设计层次，化繁为简</li>
<li>Common Case Fast: 加速大概率事件远比优化小概率事件更能提高性能，即抓住主要矛盾</li>
<li>Parallel Performance: 并行操作来提高性能，说白了就是<del>打工人能做多少做多少</del></li>
<li>Pipeline: 这是一个并行场景的具体实现，后面章节会详细讲解🔎</li>
<li>Prediction：通过猜测的方式提前启动某些操作，提高性能，投资人讲究一个增收降本的策略。</li>
<li>Hierachy of memory: 用存储器层次来解决容量，速度，成本之间的相互矛盾需求。小而精则贵，大而糙则贱</li>
<li>Dependable：任何一个物理器件都有可能失效，使用冗余部件的方式来提高系统的可靠性，即备胎🛞</li>
</ul>
<p>在加速大概率事件中有一个定量分析的<strong>Amdahl定律</strong>：</p>
<center>$改进后的执行时间 = 改进影响的执行时间 / 加速比 + 改进不影响的执行时间$</center>
<center>$t_{\text{改进}} = t_{\text{相关}} / S + t_{\text{无关}}$</center>

<h3 id="1-3-计算机语言"><a href="#1-3-计算机语言" class="headerlink" title="1.3 计算机语言"></a>1.3 计算机语言</h3><p>计算机语言主要分为三类：<strong>高级语言</strong>、<strong>汇编语言</strong>和<strong>机器语言</strong>。程序执行的过程是先将高级语言编译为汇编语言，然后通过汇编，将汇编语言转化为相应的机器语言。</p>
<h4 id="1-3-1-高级语言-High-level-programming-language"><a href="#1-3-1-高级语言-High-level-programming-language" class="headerlink" title="1.3.1 高级语言(High-level programming language)"></a>1.3.1 高级语言(High-level programming language)</h4><p>最接近人类自然语言的编程语言。常见的高级语言包括C++, Java, Python, 和JavaScript。</p>
<h4 id="1-3-2-汇编语言-Assembly-language"><a href="#1-3-2-汇编语言-Assembly-language" class="headerlink" title="1.3.2 汇编语言(Assembly language)"></a>1.3.2 汇编语言(Assembly language)</h4><p>汇编语言是一种低级编程语言，它直接对应于机器语言，但使用人类更易理解的符号和短语来表示。每条汇编指令通常都对应一条机器语言指令，因此汇编语言被认为是机器语言的符号表示。汇编语言需要使用汇编器（Assembler）将代码转换为机器语言。这种语言通常用于编写需要精确控制硬件的程序，如操作系统内核和驱动程序。汇编语言的分类一般有两种主要类型：<strong>RISC指令集（Reduced Instruction Set Computing）</strong> 和 <strong>CISC指令集（Complex Instruction Set Computing）</strong>。</p>
<ul>
<li><strong>RISC指令集：</strong> 即简化指令集计算（Reduced Instruction Set Computing）：这种类型的指令集特点是<em>指令集较为简单，每条指令执行时间固定而短，通常在一个时钟周期内完成</em>。这使得RISC处理器能够更快速地执行大量简单的指令。代表性的RISC架构包括<u>ARM、MIPS和SPARC。</u></li>
<li><strong>CISC指令集：</strong>即复杂指令集计算（Complex Instruction Set Computing），这种类型的指令集特点是指令集复杂，每条指令可能<em>需要多个时钟周期</em>才能完成执行。CISC处理器通过一个复杂的指令集试图降低编程的复杂性，使得某些复杂操作能通过一条指令完成。典型的CISC架构包括<u>x86和VAX。</u></li>
</ul>
<div class="note note-success">
            <p>在修考中，出现的汇编语言是RISC指令集，因此在后序章节只讲解RISC指令</p>
          </div>

<h4 id="1-3-3-机器语言-Machine-language"><a href="#1-3-3-机器语言-Machine-language" class="headerlink" title="1.3.3 机器语言(Machine language)"></a>1.3.3 机器语言(Machine language)</h4><p>机器语言是计算机能够直接执行的最底层编程语言。它由二进制代码组成，每条指令由一串0和1表示（eg. 00000111111010001），直接控制计算机的硬件操作。由于其复杂性和难以阅读，人类很少直接编写机器语言程序。</p>
<blockquote>
<p>总结：高级语言编译为汇编语言，然后汇编语言通过汇编转化为由01串组成的机器语言</p>
</blockquote>
<h3 id="1-4-冯·诺伊曼结构-Von-Neumann-architecture"><a href="#1-4-冯·诺伊曼结构-Von-Neumann-architecture" class="headerlink" title="1.4 冯·诺伊曼结构(Von Neumann architecture)"></a>1.4 冯·诺伊曼结构(Von Neumann architecture)</h3><img src="/img/CA/von.svg" srcset="/img/loading.gif" lazyload alt="冯诺伊曼结构" style="max-width: 100%; height: auto;" />

<p><strong>输入设备(Input Devices)</strong> 是用于向计算机输入数据和指令的硬件。例如，键盘（Keyboard）、鼠标（Mouse）、扫描仪（Scanner）、话筒（Microphone）等。它们将用户的操作转化为计算机能够理解的信号。</p>
<p><strong>输出设备(Output Devices)</strong> 是用于从计算机输出数据和结果的硬件。例如，显示器（Monitor）、打印机（Printer）、扬声器（Speakers）等。它们将计算机处理后的数据转化为用户可以理解的信息。</p>
<p><strong>控制器(Control Unit, CU)</strong> 是负责从存储器读取指令，并解释和执行指令的计算机部件。它管理和协调计算机的各个部分，以确保指令被按顺序执行。</p>
<p><strong>运算器(Arithmetic Logic Unit, ALU)</strong> 是执行算术运算和逻辑运算的核心部件。它能处理整数和浮点数的加、减、乘、除等运算，也能进行与、或、非等逻辑运算。</p>
<p><strong>存储器(Memory)</strong> 是存储数据和指令的地方。分为主存储器（Main Memory）和辅助存储器（Secondary Storage）。主存储器（如RAM，随机存取存储器，Random Access Memory）用于存储当前正在使用的数据和指令；辅助存储器（如硬盘，Hard Disk Drive）用于长期存储数据。</p>
<p><strong>中央处理器(Central Processing Unit, CPU)</strong> 是计算机的“大脑”，负责解释和执行指令。它由控制器（Control Unit, CU）和运算器（Arithmetic Logic Unit, ALU）组成，管理并处理所有的计算任务。</p>
<h3 id="1-5-计算机性能指标"><a href="#1-5-计算机性能指标" class="headerlink" title="1.5 计算机性能指标"></a>1.5 计算机性能指标</h3><p><strong>响应时间（Response Time）：</strong> 响应时间，又称执行时间，是指系统从接收到请求到开始产生输出结果所经过的时间。</p>
<p><strong>吞吐率（Throughput）：</strong> 吞吐率是指在单位时间内系统能够处理的请求数量。它衡量的是系统的处理能力。高吞吐率意味着在同样的时间内，系统能够处理更多的请求或完成更多的工作。</p>
<p><strong>CPU性能公式(Performance)：</strong></p>
<center>$CPU性能 = 1 / 执行时间$</center>

<p>A的性能比B的性能高$X$倍计算：  $X&#x3D;t_{B执行时间}&#x2F;t_{A执行时间}$</p>
<p><strong>时钟周期长度(Clock Cycle Length):</strong><br>是指计算机时钟信号中相邻两个相同状态（如两个上升沿）之间的时间间隔。CPU做的任何动作所消耗的时间都是一个时钟周期的整数倍。通常以纳秒（ns）为单位,记作 $T$</p>
<p><strong>时钟周期频率(Clock Cycle Frequency):</strong><br>则是时钟信号每秒钟振荡的次数，通常以赫兹（Hz）为单位。它是时钟周期长度的倒数。例如，如果时钟周期长度是2纳秒，那么时钟频率就是0.5 GHz,记作 $f$</p>
<p>两者之间的关系是：</p>
<ul>
<li><p>时钟周期长度 &#x3D; 1 &#x2F; 时钟周期频率, 即 $T &#x3D; 1 &#x2F; f$</p>
</li>
<li><p>时钟周期频率 &#x3D; 1 &#x2F; 时钟周期长度, 即 $f &#x3D; 1 &#x2F; T$</p>
</li>
</ul>
<p><strong>CPI(Cycles Per Instruction):</strong><br>是计算机性能指标，用于衡量每条指令所需的平均时钟周期数。它反映了CPU执行指令的效率。CPI的计算公式是：</p>
<center>$ \text{CPI} = \frac{\text{总时钟周期数}}{\text{指令数}} $</center>


<p><strong>时钟周期数计算公式(Clock Cycle):</strong></p>
<center>$Clock Cycle=指令数\times平均每条指令所需周期数 = IC \times CPI$</center>

<blockquote>
<p>注：指令数(Instruction Count, IC)是指CPU在执行一个程序时，需要执行的指令总数。</p>
</blockquote>
<p><strong>CPU执行时间：</strong></p>
<center>$ \text{CPU Time} = \text{指令数} \times \text{CPI} \times \text{时钟周期长度} = IC \times CPI \times T = IC \times CPI / f$</center>

<p>还有一个衡量指标<strong>是MIPS(million instructions per second)</strong>:</p>
<center>$ MIPS = IC / (\text{CPU Time} \times 10^{6}) = f / (CPI \times 10^{6})$</center>

<p><strong>功耗计算公式：</strong> 记住就行</p>
<center> $P = \frac{1}{2} \times U^2 \times f$</center>

<blockquote>
<p>注： $P$ 是功耗，$C$ 是负载电容， $U$ 是电压， $f$ 是开关频率</p>
</blockquote>
<h2 id="2-Instructions-The-Language-of-Computers"><a href="#2-Instructions-The-Language-of-Computers" class="headerlink" title="2. Instructions: The Language of Computers"></a>2. Instructions: The Language of Computers</h2><p>这一章非常重要，因为修考题目中经常出现理解汇编语言的题目。本章主要讲解RISC-V指令集架构还有五种寻址方式</p>
<h3 id="2-1-Instrcucton"><a href="#2-1-Instrcucton" class="headerlink" title="2.1 Instrcucton"></a>2.1 Instrcucton</h3><p>计算机在底层执行程序时，通过读取由0和1组成的机器指令来执行命令。在RISC-V指令集中，所有的机器指令都是32位长，也就是32位的二进制串。这些32位的机器指令对应的汇编语言指令通常由操作码和两个地址码组成（形式：操作码 + 地址码 + 地址码）。规定：</p>
<ul>
<li>程序中的变量存放在保存寄存器（store reg）中：$s0~$s7共8个</li>
<li>临时变量，中间变量存放在临时寄存器（temp reg）中：$t0~$t7共8个</li>
<li>零寄存器，永远存放32位的0，记作$zero</li>
</ul>
<h3 id="2-2-RISC-V-Instruction-Set"><a href="#2-2-RISC-V-Instruction-Set" class="headerlink" title="2.2 RISC-V Instruction Set"></a>2.2 RISC-V Instruction Set</h3><h4 id="2-2-1-基本指令"><a href="#2-2-1-基本指令" class="headerlink" title="2.2.1 基本指令"></a>2.2.1 基本指令</h4><p><strong>加法，减法指令(add, sub):</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; c &#x3D; a + b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; b
add $s2, $s0, $s1  
&#x2F;&#x2F; c &#x3D; a - b; $s2 &#x3D; c, $s0 &#x3D; a, $s1 &#x3D; b
sub $s2, $s0, $s1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>加立即数指令(addi):</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; i &#x3D; i + 1, i存放在$s0寄存器中
addi $s0, $s0, 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>
<p><strong>逻辑运算指令:</strong> and(与)，or(或)，nor（或非）</p>
<p><strong>逻辑左移(shift left logic, sll)和右移(shift right logic, srl):</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sll $to, $s2, 2 &#x2F;&#x2F; 将$s2寄存器的值左移2位，即变为4倍，存放在$t0中
srl $to, $s2, 1 &#x2F;&#x2F; 将$s2寄存器的值右移1位，即变为1&#x2F;2倍，存放在$t0中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>
<p><strong>取字指令(load word, lw)和存字指令(save word, sw):</strong><br>因为寄存器是按字(Word)存储，而内存是按字节(Byte)编址,在RISC-V指令集中，约定：1 Word &#x3D; 32 bit &#x3D; 4 Byte。</p>
<blockquote>
<p>举个例子：已知a[0]的地址存放在寄存器s0中，现在需要取a[2]的值存放在寄存器t0中；a[2]和a[0]之间的字节偏移有 2 * 4 &#x3D; 8 Byte。RISC-V指令可写为：</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lw $t0, 8($s0)  &#x2F;&#x2F; 取出$s0偏移8字节的位置的值，存放在$t0寄存器中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>
<blockquote>
<p>同理，如果我们要把t0寄存器的值存到a[4]中去，可以知道a[4]与a[0]的字节偏移有 4 * 4 &#x3D; 16 Byte。RISC-V指令可写为：</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">sw $t0, 16($s0) &#x2F;&#x2F; 注意操作的方向和lw相反<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<h4 id="2-2-2-装载32位立即数到寄存器"><a href="#2-2-2-装载32位立即数到寄存器" class="headerlink" title="2.2.2 装载32位立即数到寄存器"></a>2.2.2 装载32位立即数到寄存器</h4><p>因为装载的32位立即数不能完全放进32位的机器指令中，因此寄存器可以通过两条指令来完成：LUI (Load Upper Immediate) 和 ORI (OR Immediate)。比如将立即数 0xF7EE57AD 装载到寄存器中这个两个指令需要完成的动作是：</p>
<blockquote>
<p>0xF7EE57AD 对应的 32 位二进制数是：1111 0111 1110 1110 0101 0111 1010 1101</p>
</blockquote>
<ul>
<li><p>LUI 指令：取0xF7EE57AD的高16位数（1111 0111 1110 1110) 放入寄存器的高16位</p>
</li>
<li><p>ORI 指令：将寄存器和剩下的低16位数做立即与的动作(0101 0111 1010 1101)</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $s1, 63470 &#x2F;&#x2F; 1111 0111 1110 1110 对应的十进制数是 63470
ori $s1, 22957 &#x2F;&#x2F; 0101 0111 1010 1101 对应的十进制数是 22957
&#x2F;* 整个动作如下：
step1: 取到高16位数，$s1的值为 1111 0111 1110 1110 0000 0000 0000 0000
step2: $s1的值与低16位数立即与 0000 0000 0000 0000 0101 0111 1010 1101
最终$s1的值为 1111 0111 1110 1110 0101 0111 1010 1101
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>当然还有其他写法：比如lui和addi。例如，要将立即数 0x12345678 装载到寄存器 t0 中</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">lui $t0, 0x12345 &#x2F;&#x2F; 将高20位0x12345装载到t0
addi $t0, $t0, 0x678 &#x2F;&#x2F; 将剩余的12位0x678添加到t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure></li>
</ul>
<h4 id="2-2-3-判断和决策指令"><a href="#2-2-3-判断和决策指令" class="headerlink" title="2.2.3 判断和决策指令"></a>2.2.3 判断和决策指令</h4><p><strong>BEQ（Branch if Equal） 指令：</strong></p>
<ul>
<li><strong>功能</strong>：比较两个寄存器的值，如果它们相等，则跳转到指定的目标地址。</li>
<li><strong>格式</strong>：<code>beq rs1, rs2, offset</code><ul>
<li><code>rs1</code>：第一个源寄存器</li>
<li><code>rs2</code>：第二个源寄存器</li>
<li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">beq $t0, $t1, label &#x2F;&#x2F; 如果t0和t1相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>
<strong>BNE（Branch if Not Equal） 指令：</strong></li>
</ul>
</li>
<li><strong>功能</strong>：比较两个寄存器的值，如果它们不相等，则跳转到指定的目标地址。</li>
<li><strong>格式</strong>：<code>bne rs1, rs2, offset</code><ul>
<li><code>rs1</code>：第一个源寄存器</li>
<li><code>rs2</code>：第二个源寄存器</li>
<li><code>offset</code>：相对跳转的偏移量<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">bne $t0, $t1, label &#x2F;&#x2F; 如果t0和t1不相等，则跳转到label<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>
<strong>小于则置位(set less than, slt)：</strong></li>
</ul>
</li>
</ul>
<p><strong>功能</strong>：将两个寄存器中的值进行比较，如果第一个寄存器的值小于第二个寄存器的值，则将目标寄存器设为1，否则设为0。</p>
<ul>
<li><strong>格式</strong>：<code>slt rd, rs1, rs2</code><ul>
<li><code>rd</code>：目标寄存器</li>
<li><code>rs1</code>：第一个源寄存器</li>
<li><code>rs2</code>：第二个源寄存器</li>
</ul>
</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">slt $t0, $t1, $t2 &#x2F;&#x2F; 如果t1 &lt; t2，则将t0设为1；否则设为0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>
<p><strong>J指令(JUMP)</strong></p>
<ul>
<li><strong>功能</strong>：无条件跳转到指定的目标地址。这个指令改变了程序的执行流程，立即将控制转移到指定的地址。</li>
<li><strong>格式</strong>：<code>j offset</code><ul>
<li><code>offset</code>：相对当前地址的跳转偏移量</li>
</ul>
</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">j label &#x2F;&#x2F; 无条件跳转到label标记的位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>
<h3 id="2-3-Assembly-language-and-High-level-programming-language"><a href="#2-3-Assembly-language-and-High-level-programming-language" class="headerlink" title="2.3 Assembly language and High-level programming language"></a>2.3 Assembly language and High-level programming language</h3><p>举个例子，有C++代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> value1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> value2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> value3 <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> t0 <span class="token operator">=</span> value1<span class="token punctuation">;</span>
    <span class="token keyword">int</span> t1 <span class="token operator">=</span> value2<span class="token punctuation">;</span>

    <span class="token keyword">int</span> t2 <span class="token operator">=</span> t0 <span class="token operator">+</span> t1<span class="token punctuation">;</span> <span class="token comment">// t2 = t0 + t1</span>
    <span class="token keyword">int</span> t3 <span class="token operator">=</span> t1 <span class="token operator">-</span> t0<span class="token punctuation">;</span> <span class="token comment">// t3 = t1 - t0</span>
    <span class="token keyword">int</span> t4 <span class="token operator">=</span> t0 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>  <span class="token comment">// t4 = t0 + 4</span>

    <span class="token keyword">int</span> t5 <span class="token operator">=</span> t0 <span class="token operator">&amp;</span> t1<span class="token punctuation">;</span> <span class="token comment">// t5 = t0 AND t1</span>
    <span class="token keyword">int</span> t6 <span class="token operator">=</span> t0 <span class="token operator">|</span> t1<span class="token punctuation">;</span> <span class="token comment">// t6 = t0 OR t1</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>t0 <span class="token operator">==</span> t1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">goto</span> ELSE<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">goto</span> main<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

ELSE<span class="token operator">:</span>
    <span class="token comment">// Do nothing (类似于 nop)</span>
    <span class="token keyword">goto</span> EXIT<span class="token punctuation">;</span>

main<span class="token operator">:</span>
    <span class="token comment">// Do nothing (类似于循环到 main)</span>

EXIT<span class="token operator">:</span>
    <span class="token comment">// Do nothing (类似于结束)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>其对应的汇编语言是</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.data
value1: .word 5
value2: .word 10
value3: .word 15

.text
main:
    lw $t0, value1      # 将value1的值加载到$t0
    lw $t1, value2      # 将value2的值加载到$t1

    add $t2, $t0, $t1     # $t2 &#x3D; $t0 + $t1
    sub $t3, $t1, $t0     # $t3 &#x3D; $t1 - $t0
    addi $t4, $t0, 4     # $t4 &#x3D; $t0 + 4

    and $t5, $t0, $t1     # $t5 &#x3D; $t0 AND $t1
    or $t6, $t0, $t1      # $t6 &#x3D; $t0 OR $t1

    beq $t0, $t1, ELSE   # 如果$t0 &#x3D;&#x3D; $t1，则跳转到ELSE
    bne $t0, $t1, main   # 如果$t0 !&#x3D; $t1，则跳转到main

ELSE:
    j EXIT             # 无条件跳转到EXIT

EXIT:
    nop                # 无操作（用于占位）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="2-4-Three-Instruction-Formats"><a href="#2-4-Three-Instruction-Formats" class="headerlink" title="2.4 Three Instruction Formats"></a>2.4 Three Instruction Formats</h3><p>在汇编语言中，主要有三种指令格式：R型指令、I型指令和J型指令。每种格式有特定的结构，用于不同类型的操作。</p>
<h4 id="2-4-1-R-type-Register-Instructions"><a href="#2-4-1-R-type-Register-Instructions" class="headerlink" title="2.4.1 R-type (Register) Instructions"></a>2.4.1 R-type (Register) Instructions</h4><ul>
<li><strong>目的</strong>：用于需要三个寄存器的算术和逻辑操作。</li>
<li><strong>格式</strong>：<ul>
<li><code>opcode</code>：指定指令类型的操作码。</li>
<li><code>rs1</code>：第一个源寄存器。</li>
<li><code>rs2</code>：第二个源寄存器。</li>
<li><code>rd</code>：目标寄存器。</li>
<li><code>funct3</code> 和 <code>funct7</code>：附加功能代码，用于指定具体操作。</li>
</ul>
</li>
<li><strong>例子</strong>：<code>add rd, rs1, rs2</code> <ul>
<li>将 <code>rs1</code> 和 <code>rs2</code> 中的内容相加，并将结果存储在 <code>rd</code> 中。</li>
</ul>
</li>
</ul>
<h4 id="2-4-2-I-type-Immediate-Instructions"><a href="#2-4-2-I-type-Immediate-Instructions" class="headerlink" title="2.4.2 I-type (Immediate) Instructions"></a>2.4.2 I-type (Immediate) Instructions</h4><ul>
<li><strong>目的</strong>：用于带有立即数（嵌入指令中的常数）的操作。</li>
<li><strong>格式</strong>：<ul>
<li><code>opcode</code>：指定指令类型的操作码。</li>
<li><code>rs1</code>：源寄存器。</li>
<li><code>rd</code>：目标寄存器。</li>
<li><code>imm</code>：立即数（常数）。</li>
<li><code>funct3</code>：附加功能代码。</li>
</ul>
</li>
<li><strong>例子</strong>：<code>addi rd, rs1, imm</code><ul>
<li>将 <code>rs1</code> 和 <code>imm</code> 的内容相加，并将结果存储在 <code>rd</code></li>
</ul>
</li>
</ul>
<h4 id="2-4-3-J-type-Jump-Instructions"><a href="#2-4-3-J-type-Jump-Instructions" class="headerlink" title="2.4.3 J-type (Jump) Instructions"></a>2.4.3 J-type (Jump) Instructions</h4><ul>
<li><strong>目的</strong>：用于修改程序控制流的跳转操作。</li>
<li><strong>格式</strong>：<ul>
<li><code>opcode</code>：指定指令类型的操作码。</li>
<li><code>offset</code>：跳转偏移量。</li>
</ul>
</li>
<li><strong>例子</strong>：<code>j offset</code><ul>
<li>跳转到通过将 <code>offset</code> 添加到当前程序计数器（PC）计算出的地址。</li>
</ul>
</li>
</ul>
<h3 id="2-5-Five-Addressing-Modes"><a href="#2-5-Five-Addressing-Modes" class="headerlink" title="2.5 Five Addressing Modes"></a>2.5 Five Addressing Modes</h3><h4 id="2-5-1-立即寻址（Immediate-Addressing）"><a href="#2-5-1-立即寻址（Immediate-Addressing）" class="headerlink" title="2.5.1 立即寻址（Immediate Addressing）"></a>2.5.1 立即寻址（Immediate Addressing）</h4><ul>
<li><strong>定义</strong>：操作数直接在指令中给出。</li>
<li><strong>例子</strong>：<code>MOV AL, 5</code><ul>
<li>这里，数值 <code>5</code> 直接被移动到寄存器 <code>AL</code> 中。</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-直接寻址（Direct-Addressing）"><a href="#2-5-2-直接寻址（Direct-Addressing）" class="headerlink" title="2.5.2 直接寻址（Direct Addressing）"></a>2.5.2 直接寻址（Direct Addressing）</h4><ul>
<li><strong>定义</strong>：操作数的地址在指令中明确给出。</li>
<li><strong>例子</strong>：<code>MOV AX, [1234H]</code><ul>
<li>该指令将内存地址 <code>1234H</code> 的值移动到寄存器 <code>AX</code> 中。</li>
</ul>
</li>
</ul>
<h4 id="2-5-3-间接寻址（Indirect-Addressing）"><a href="#2-5-3-间接寻址（Indirect-Addressing）" class="headerlink" title="2.5.3 间接寻址（Indirect Addressing）"></a>2.5.3 间接寻址（Indirect Addressing）</h4><ul>
<li><strong>定义</strong>：操作数的地址存储在寄存器或内存位置中。</li>
<li><strong>例子</strong>：<code>MOV AX, [BX]</code><ul>
<li>内存位置 <code>[BX]</code> 中的值被移动到 <code>AX</code> 中。</li>
</ul>
</li>
</ul>
<h4 id="2-5-4-索引寻址（Indexed-Addressing）"><a href="#2-5-4-索引寻址（Indexed-Addressing）" class="headerlink" title="2.5.4 索引寻址（Indexed Addressing）"></a>2.5.4 索引寻址（Indexed Addressing）</h4><ul>
<li><strong>定义</strong>：操作数的最终地址由寄存器内容与常数相加生成。</li>
<li><strong>例子</strong>：<code>MOV AX, [SI+20H]</code><ul>
<li>内存位置 <code>[SI + 20H]</code> 中的值被移动到 <code>AX</code> 中。</li>
</ul>
</li>
</ul>
<h4 id="2-5-5-寄存器寻址（Register-Addressing）"><a href="#2-5-5-寄存器寻址（Register-Addressing）" class="headerlink" title="2.5.5 寄存器寻址（Register Addressing）"></a>2.5.5 寄存器寻址（Register Addressing）</h4><ul>
<li><strong>定义</strong>：操作数位于寄存器中，寄存器在指令中直接指定。</li>
<li><strong>例子</strong>：<code>MOV AX, BX</code><ul>
<li><code>BX</code> 中的值被移动到 <code>AX</code></li>
</ul>
</li>
</ul>
<div class="note note-primary">
            <p>程序计数器PC在取指令时会自增4（每条指令是4字节），因此，下一条指令的地址是PC + 4。若当前指令需要进行跳转或分支，字地址偏移量则用于计算目标地址。具体来说，如果你有一个偏移量offset，在跳转指令中，你通常会将其左移2位（因为地址是字节为单位的），然后加到PC + 4上来获得目标地址。</p>
          </div>

<h2 id="3-Arithmetic-Operations-in-Computers"><a href="#3-Arithmetic-Operations-in-Computers" class="headerlink" title="3. Arithmetic Operations in Computers"></a>3. Arithmetic Operations in Computers</h2><p>本章主要讲解的知识点有，计算机是如何表示整数和进行整数运算的，以及浮点数的表示规范。本章在修考的考察非常精细，一定要理清每种数的表示。下面的例子都用8bit来表示并且给出对应的表示范围。</p>
<h3 id="3-1-Integer-Representation"><a href="#3-1-Integer-Representation" class="headerlink" title="3.1 Integer Representation"></a>3.1 Integer Representation</h3><p>本小节介绍无符号整数、原码、反码和补码的表示方法。</p>
<h4 id="3-1-1-无符号整数（Unsigned-Integer）"><a href="#3-1-1-无符号整数（Unsigned-Integer）" class="headerlink" title="3.1.1 无符号整数（Unsigned Integer）"></a>3.1.1 无符号整数（Unsigned Integer）</h4><p><strong>表示方法</strong>：<br>无符号整数只表示<strong>非负数</strong>，使用所有位表示数值，不用负号。8位无符号整数的取值范围是从0到255。</p>
<p><strong>表示范围</strong>：</p>
<ul>
<li>最小值：$0$</li>
<li>最大值：$2^8 - 1 &#x3D; 255$</li>
</ul>
<p><strong>例子</strong>：</p>
<ul>
<li>十进制数5的无符号表示：<code>00000101</code></li>
<li>十进制数255的无符号表示：<code>11111111</code></li>
</ul>
<h4 id="3-1-2-原码（Sign-Magnitude）"><a href="#3-1-2-原码（Sign-Magnitude）" class="headerlink" title="3.1.2 原码（Sign-Magnitude）"></a>3.1.2 原码（Sign-Magnitude）</h4><p><strong>表示方法</strong>：<br>原码使用最高位作为符号位（0表示正数，1表示负数），其余位表示数值的绝对值。对于8位原码，正数的最高位是0，负数的最高位是1。因此原码有$+0$和$-0$两种表示方法，分别是$00000000$,$10000000$。</p>
<p><strong>表示范围</strong>：</p>
<ul>
<li>最小值：$-127$（<code>11111111</code>）</li>
<li>最大值：$127$（<code>01111111</code>）</li>
</ul>
<p><strong>例子</strong>：</p>
<ul>
<li>十进制数5的原码表示：<code>00000101</code></li>
<li>十进制数-5的原码表示：<code>10000101</code></li>
</ul>
<h4 id="3-1-3-反码（One’s-Complement）"><a href="#3-1-3-反码（One’s-Complement）" class="headerlink" title="3.1.3 反码（One’s Complement）"></a>3.1.3 反码（One’s Complement）</h4><p><strong>表示方法</strong>：<br>反码对正数和负数的表示方法稍有不同。正数的反码与原码相同，负数的反码是将其绝对值的原码的每一位取反（0变1，1变0）。因此反码有也有$+0$和$-0$两种表示方法，分别是$00000000$和$11111111$。</p>
<p><strong>表示范围</strong>：</p>
<ul>
<li>最小值：$-127$（<code>10000000</code>）</li>
<li>最大值：$127$（<code>01111111</code>）</li>
</ul>
<p><strong>例子</strong>：</p>
<ul>
<li>十进制数5的反码表示：<code>00000101</code></li>
<li>十进制数-5的反码表示：<code>11111010</code>（原码<code>00000101</code>取反）</li>
</ul>
<h4 id="3-1-4-补码（Two’s-Complement）"><a href="#3-1-4-补码（Two’s-Complement）" class="headerlink" title="3.1.4 补码（Two’s Complement）"></a>3.1.4 补码（Two’s Complement）</h4><p><strong>表示方法</strong>：<br>补码是最常用的负数表示方法。正数的补码与原码相同，负数的补码是其绝对值的原码取反后加1。补码的意义是<em>消除原码和反码有2种零的表示方法</em>，可以用于直接计算。计算机都是用补码进行整数加减运算。因为补码只有一种$0$的表示方法，因此负数的表示范围会比整数多一个。</p>
<blockquote>
<p>补码非常爱考的一个点：$11111111$(-1), $10000000$(-128,因为超出8位范围), $00000000$(0)</p>
</blockquote>
<p><strong>表示范围</strong>：</p>
<ul>
<li>最小值：$-128$（<code>10000000</code>），🚨重中之重</li>
<li>最大值：$127$（<code>01111111</code>）</li>
</ul>
<p><strong>例子</strong>：</p>
<ul>
<li>十进制数5的补码表示：<code>00000101</code></li>
<li>十进制数-5的补码表示：<code>11111011</code>（原码<code>00000101</code>取反后加1）</li>
</ul>
<h4 id="3-1-5-表示方法总结"><a href="#3-1-5-表示方法总结" class="headerlink" title="3.1.5 表示方法总结"></a>3.1.5 表示方法总结</h4><table>
<thead>
<tr>
<th>表示法</th>
<th>最小值</th>
<th>最大值</th>
<th>示例 - 正数</th>
<th>示例 - 负数</th>
<th>0的表示个数</th>
</tr>
</thead>
<tbody><tr>
<td>无符号整数</td>
<td>0</td>
<td>255</td>
<td><code>00000101</code> (5)</td>
<td>N&#x2F;A</td>
<td>1</td>
</tr>
<tr>
<td>原码</td>
<td>-127</td>
<td>127</td>
<td><code>00000101</code> (5)</td>
<td><code>10000101</code> (-5)</td>
<td>2</td>
</tr>
<tr>
<td>反码</td>
<td>-127</td>
<td>127</td>
<td><code>00000101</code> (5)</td>
<td><code>11111010</code> (-5)</td>
<td>2</td>
</tr>
<tr>
<td>补码</td>
<td>-128</td>
<td>127</td>
<td><code>00000101</code> (5)</td>
<td><code>11111011</code> (-5)</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="3-2-符号位扩展与大小端编址"><a href="#3-2-符号位扩展与大小端编址" class="headerlink" title="3.2 符号位扩展与大小端编址"></a>3.2 符号位扩展与大小端编址</h3><p>这几个考点经常出现在题目的开胃前菜，是很容易忽略的一个考点，切记切记。</p>
<h4 id="3-2-1-符号位扩展（sign-extension）"><a href="#3-2-1-符号位扩展（sign-extension）" class="headerlink" title="3.2.1 符号位扩展（sign extension）"></a>3.2.1 符号位扩展（sign extension）</h4><p><strong>符号位扩展（sign extension）</strong> 是指在将带符号的数从较小的位数扩展到较大位数时，保持其数值的正负性。这个过程通常在处理数值的运算或数据类型转换时使用。<br>填充高位：</p>
<ul>
<li>如果符号位为0，扩展时在左边填充0。</li>
<li>如果符号位为1，扩展时在左边填充1。<br>假设我们要将一个8位的补码数扩展到16位：</li>
</ul>
<p><strong>8位正数</strong></p>
<ul>
<li>原数：<code>00001010</code>（十进制10）</li>
<li>扩展后：<code>00000000 00001010</code>（仍然是十进制10）</li>
</ul>
<p><strong>8位负数</strong></p>
<ul>
<li>原数：<code>11111010</code>（十进制-6）</li>
<li>扩展后：<code>11111111 11111010</code>（仍然是十进制-6）</li>
</ul>
<h4 id="3-2-2-大端编址（Big-endian）和小端编址（Little-endian）"><a href="#3-2-2-大端编址（Big-endian）和小端编址（Little-endian）" class="headerlink" title="3.2.2 大端编址（Big-endian）和小端编址（Little-endian）"></a>3.2.2 大端编址（Big-endian）和小端编址（Little-endian）</h4><p>大端编址（Big-endian）和小端编址（Little-endian）是两种不同的数据存储方式，决定了多字节数据在内存中的排列顺序。</p>
<p><strong>大端编址（Big-endian）</strong></p>
<ul>
<li><strong>定义</strong>：在大端模式下，数据的高位字节存储在低地址，低位字节存储在高地址。</li>
<li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul>
<li>地址 <code>0x00</code>：<code>12</code></li>
<li>地址 <code>0x01</code>：<code>34</code></li>
<li>地址 <code>0x02</code>：<code>56</code></li>
<li>地址 <code>0x03</code>：<code>78</code></li>
</ul>
</li>
</ul>
<p><strong>小端编址（Little-endian）</strong></p>
<ul>
<li><strong>定义</strong>：在小端模式下，数据的低位字节存储在低地址，高位字节存储在高地址。</li>
<li><strong>示例</strong>：对于32位整数 <code>0x12345678</code>，其在内存中的存储顺序为：<ul>
<li>地址 <code>0x00</code>：<code>78</code></li>
<li>地址 <code>0x01</code>：<code>56</code></li>
<li>地址 <code>0x02</code>：<code>34</code></li>
<li>地址 <code>0x03</code>：<code>12</code></li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li><strong>大端</strong>：常用于网络协议（如TCP&#x2F;IP），因为网络字节顺序采用大端。</li>
<li><strong>小端</strong>：通常用于个人电脑（如x86架构的处理器）。</li>
</ul>
<img src="/img/CA/endianness.svg" srcset="/img/loading.gif" lazyload alt="大端和小端序" style="max-width: 100%; height: auto;" />

<h3 id="3-3-Arithmetic-Operations-Logic"><a href="#3-3-Arithmetic-Operations-Logic" class="headerlink" title="3.3 Arithmetic Operations Logic"></a>3.3 Arithmetic Operations Logic</h3><p>参照<a href="https://toutou.zeabur.app/2024/11/04/Digital-Circuit/">数字电路笔记</a>第二章的算术运算实现</p>
<h3 id="3-4-IEEE754-Float-Point-Number"><a href="#3-4-IEEE754-Float-Point-Number" class="headerlink" title="3.4 IEEE754 Float Point Number"></a>3.4 IEEE754 Float Point Number</h3><p><strong>IEEE 754 单精度浮点数</strong></p>
<p>IEEE 754 单精度浮点数总共32位：1位符号位（S），8位指数位（E），23位尾数位（F）。</p>
<ul>
<li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li>
<li><strong>指数位（E）</strong>：偏阶值(Bias)为127，即实际的指数值是存储的指数值减去127。<ul>
<li>例如，如果指数部分存储的是10000001（二进制的129），实际的指数就是129-127&#x3D;2。</li>
</ul>
</li>
<li><strong>尾数位（F）</strong>：23位，表示小数部分。注意尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li>
</ul>
<p><strong>计算公式</strong>：</p>
<center> $(-1)^S \times 2^{(E - 127)} \times 1.F$ </center>

<p><strong>IEEE 754 双精度浮点数</strong></p>
<p>IEEE 754 双精度浮点数总共64位：1位符号位（S），11位指数位（E），52位尾数位（F）。</p>
<ul>
<li><strong>符号位（S）</strong>：0表示正数，1表示负数。</li>
<li><strong>指数位（E）</strong>：偏阶值(Bias)为1023，即实际的指数值是存储的指数值减去1023。<ul>
<li>例如，如果指数部分存储的是10000000010（二进制的1026），实际的指数就是1026-1023&#x3D;3。</li>
</ul>
</li>
<li><strong>尾数位（F）</strong>：52位，表示小数部分。尾数部分隐含一个1，所以公式中写作<code>1.F</code>。</li>
</ul>
<p><strong>计算公式</strong>：</p>
<center> $(-1)^S \times 2^{(E - 1023)} \times 1.F$ </center>

<img src="/img/CA/float.svg" srcset="/img/loading.gif" lazyload alt="浮点数表示格式" style="max-width: 100%; height: auto;" />

<blockquote>
<p>思考：为什么需要偏阶值(Bias)的存在？</p>
</blockquote>
<p>偏阶（Bias）的存在主要是为了简化浮点数的比较和计算过程。以下是几个具体原因：</p>
<ol>
<li><p><strong>简化比较操作</strong>：<br>通过使用偏阶，所有可能的指数值都被映射到一个非负范围内，使得比较浮点数时可以简单地比较其指数部分的数值。例如，对于单精度浮点数，偏阶127确保了指数范围从 -127 到 128 被映射到 0 到 255。</p>
</li>
<li><p><strong>标准化表示</strong>：<br>使用偏阶可以确保指数部分总是一个非负数，从而使浮点数表示更为统一和标准化。这对于硬件电路设计和算法实现有很大的便利性。</p>
</li>
<li><p><strong>处理负指数</strong>：<br>偏阶允许使用非负整数来表示负指数，这对表示非常小的浮点数（接近于0）尤其有用。通过偏阶值，可以直接在指数部分进行加法和减法，而不需要额外处理负数。</p>
</li>
</ol>
<p>举个例子，对于单精度浮点数，偏阶是127。这意味着：</p>
<ul>
<li>实际指数为0时，存储的指数值是127。</li>
<li>实际指数为-1时，存储的指数值是126。</li>
<li>实际指数为+1时，存储的指数值是128。</li>
</ul>
<p>这种设计大大简化了计算和比较过程，让浮点运算变得高效和准确。</p>
<h2 id="4-Processor"><a href="#4-Processor" class="headerlink" title="4.  Processor"></a>4.  Processor</h2><p>MIPS是一种采取RISC的架构。MIPS 处理器的指令执行过程被分为<strong>五个主要阶段。</strong> 通过流水线的设计，MIPS 能够在每个时钟周期执行多个指令阶段，从而提升性能。以下是每个阶段的详细说明：</p>
<h3 id="4-1-指令周期分解"><a href="#4-1-指令周期分解" class="headerlink" title="4.1 指令周期分解"></a>4.1 指令周期分解</h3><ol>
<li><p><strong>取指令（IF，Instruction Fetch）</strong></p>
<ul>
<li>从指令存储器中读取当前指令，将其载入到指令寄存器（IR，Instruction Register）中。</li>
<li>将程序计数器（PC）更新为下一条指令的地址，一般为当前 PC 值加 4（因为每条指令长度固定为 4 字节）。</li>
<li>在这个阶段，通常也会将 PC 的值保存，以备后续的跳转或分支指令使用。</li>
</ul>
</li>
<li><p><strong>指令译码（ID，Instruction Decode）</strong></p>
<ul>
<li>解析指令的操作码（opcode），以确定指令类型和具体的操作。</li>
<li>从寄存器文件中读取操作数（源寄存器数据）。在 R 型指令中读取两个寄存器，而 I 型和 J 型指令则根据需求读取一个或不读取。</li>
<li>进行分支地址的计算（PC + 偏移量），以备可能的跳转或分支指令使用。</li>
<li>根据指令类型生成控制信号，控制信号会影响后续各个阶段的具体操作。</li>
</ul>
</li>
<li><p><strong>执行（EX，Execute）</strong></p>
<ul>
<li><strong>算术或逻辑操作</strong>：如果是算术或逻辑指令，ALU（算术逻辑单元）执行相应操作，例如加法、减法、与或非等。</li>
<li><strong>内存地址计算</strong>：若是加载或存储指令，ALU 计算内存访问的目标地址（基地址 + 偏移量）。</li>
<li><strong>分支判断</strong>：若是分支指令，在 ALU 进行判断后决定是否采用分支地址。</li>
<li>这一阶段的结果（例如运算结果或目标地址）将传递给下一阶段。</li>
</ul>
</li>
<li><p><strong>访存（MEM，Memory Access）</strong></p>
<ul>
<li><strong>加载指令</strong>：如果是加载指令（如 <code>lw</code>），从内存中读取数据，并将其存入一个临时寄存器。</li>
<li><strong>存储指令</strong>：如果是存储指令（如 <code>sw</code>），将寄存器中的数据写入指定的内存地址。</li>
<li>其他指令在这一阶段不做任何操作，直接进入下一个阶段。</li>
</ul>
</li>
<li><p><strong>写回（WB，Write Back）</strong></p>
<ul>
<li>将执行结果写回到寄存器文件中（如 <code>R</code> 型和 <code>I</code> 型指令）。</li>
<li>对于加载指令，将从内存读取的数据写入目标寄存器。</li>
<li>此阶段完成后，处理器准备进入下一条指令的执行。</li>
</ul>
</li>
</ol>
<h3 id="4-2-Pipeline-Basics"><a href="#4-2-Pipeline-Basics" class="headerlink" title="4.2 Pipeline Basics"></a>4.2 Pipeline Basics</h3><p>在指令周期的五个阶段，可以把数据通路分为5个阶段，形成流水线(pipeline)。<br><img src="/img/CA/pipeline.png" srcset="/img/loading.gif" lazyload alt="流水线" style="max-width: 100%; height: auto;" /><br>根据上图，可以很直观的给出流水线相关计算公式：</p>
<center>$时钟周期数 = 指令数 + 流水级级数 - 1 = IC + n - 1$</center>
<center>$理想加速比 = 流水线级数 = n$</center>

<blockquote>
<p>注意⚠️：时钟周期取5个阶段中最慢的阶段作为时钟周期（木桶效应）</p>
</blockquote>
<h3 id="4-3-Pipeline-Hazards"><a href="#4-3-Pipeline-Hazards" class="headerlink" title="4.3 Pipeline Hazards"></a>4.3 Pipeline Hazards</h3><p><strong>流水线冒险（Pipeline Hazards）</strong> 是在指令流水线中可能导致流水线停顿或性能下降的问题。主要有三种类型的流水线冒险：数据冒险、控制冒险和结构冒险。下面是对每种冒险的详细讲解：</p>
<h4 id="4-3-1-数据冒险-Data-Hazard"><a href="#4-3-1-数据冒险-Data-Hazard" class="headerlink" title="4.3.1 数据冒险 (Data Hazard)"></a>4.3.1 数据冒险 (Data Hazard)</h4><p>数据冒险是由于指令之间的数据依赖性导致的。例如，一条指令需要使用前一条指令的计算结果，如果在计算结果尚未写回寄存器时就使用该结果，流水线会因为缺少数据而停顿。常见的数据冒险有以下几种类型：</p>
<ul>
<li><p><strong>RAW（Read After Write，读后写）</strong>：最常见的数据冒险类型。假设有指令 A 和指令 B，A 先于 B 执行。如果 B 读取 A 的结果而 A 还未写回寄存器，则会产生数据冒险。例如：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">A: R1 &#x3D; R2 + R3
B: R4 &#x3D; R1 + R5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>
<p>指令 B 在 A 的结果写回之前读取了 R1，造成数据冒险。</p>
</li>
<li><p><strong>WAR（Write After Read，写后读）</strong>：较少见，发生在指令先读取了寄存器的值，而后续指令修改了该寄存器的值。这种冒险通常在特定的流水线架构中才会发生。</p>
</li>
<li><p><strong>WAW（Write After Write，写后写）</strong>：如果流水线支持多发射或指令乱序执行，就可能发生这种冒险。即先有一条指令写一个寄存器，后续指令也写相同寄存器，但乱序执行导致后面的指令先写完。</p>
</li>
</ul>
<p>解决方法：</p>
<ul>
<li>数据转发 (Data Forwarding)或旁路（bypass）：将未写回寄存器的数据直接转发给下一条指令的执行单元，从而避免等待写回寄存器的过程。</li>
<li>插入气泡 (Bubble)：让流水线停顿一个或多个周期，直到所需数据准备就绪。</li>
</ul>
<h4 id="4-3-2-控制冒险-Control-Hazard"><a href="#4-3-2-控制冒险-Control-Hazard" class="headerlink" title="4.3.2 控制冒险 (Control Hazard)"></a>4.3.2 控制冒险 (Control Hazard)</h4><p>控制冒险是因为分支指令或跳转指令的出现，使得流水线不能确定下一条要执行的指令，从而导致流水线停顿。分支指令可能改变程序执行的路径，而在确定跳转目标前，流水线并不知道应该继续取哪条指令。</p>
<p>例如，以下代码段中，当执行<code>if</code>判断时，可能会发生控制冒险：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span>
    <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    <span class="token function">do_something_else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>在判断 <code>a &gt; b</code> 之前，流水线不知道下一步应该执行 <code>do_something</code> 还是 <code>do_something_else</code>。</p>
<p>解决方法：</p>
<ul>
<li>分支预测 (Branch Prediction)：利用硬件预测分支指令的执行路径。现代处理器使用动态分支预测，根据历史执行情况预测下一步操作。</li>
<li>延迟槽 (Delay Slot)：将分支指令后的指令提前执行，即使分支结果不确定也先执行下一条指令，从而减少停顿，但这种方法需要编译器支持。</li>
<li>分支目标缓冲区 (Branch Target Buffer, BTB)：缓存分支指令的目标地址，减少分支跳转的停顿时间。</li>
</ul>
<h4 id="4-3-3-结构冒险-Structural-Hazard"><a href="#4-3-3-结构冒险-Structural-Hazard" class="headerlink" title="4.3.3 结构冒险 (Structural Hazard)"></a>4.3.3 结构冒险 (Structural Hazard)</h4><p>结构冒险是由于硬件资源的竞争导致的。在指令执行过程中，如果两个或多个指令同时需要访问同一硬件资源（例如，内存、寄存器或 ALU 单元），但硬件资源不能同时支持多个访问请求，则会产生结构冒险。</p>
<p>例如，如果处理器的内存访问和取指令共享相同的内存端口，且一个指令在内存中读取数据的同时，另一个指令需要从内存中取指令，就会产生结构冒险。</p>
<p>解决方法：</p>
<ul>
<li>增加硬件资源：在流水线设计时，增加必要的硬件资源。例如，为指令存储和数据存储提供独立的内存端口，避免资源竞争。</li>
<li>流水线停顿：当资源不可用时，让流水线停顿一个周期，以等待资源的释放。</li>
</ul>
<div class="note note-primary">
            <p>流水线在修考里面是非常非常重要的存在‼️我更希望用经典的例题讲解然后来帮助理解。</p>
          </div>
<p>经典流水线问题：<a href="https://toutou.zeabur.app/2024/12/07/%E4%B9%9D%E5%B7%9E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E5%A4%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">九州大学2022年夏季计算机组成过去问</a></p>
<h2 id="5-Memory"><a href="#5-Memory" class="headerlink" title="5. Memory"></a>5. Memory</h2><p>本章主要讲解存储器的层次和局部性原理。这一章和操作系统的重合度非常高，建议配合操作系统复习。本章的Cache映射和TLB映射在修考题中出现的频率非常高。</p>
<h3 id="5-1-Memory-Hierachy"><a href="#5-1-Memory-Hierachy" class="headerlink" title="5.1 Memory Hierachy"></a>5.1 Memory Hierachy</h3><p>如标题所见，这是计算机8大设计思想之一，采用层次结构将存储器主要分为4个层次，从顶层到底层依次是：寄存器，高速缓存，主存，外存。<br><img src="/img/CA/memory.svg" srcset="/img/loading.gif" lazyload alt="存储器层次" style="max-width: 100%; height: auto;" /></p>
<h4 id="5-1-1-Register"><a href="#5-1-1-Register" class="headerlink" title="5.1.1 Register"></a>5.1.1 Register</h4><p>寄存器是 CPU 中的高速存储单元，用于暂时存储指令和数据，帮助 CPU 进行快速计算。它们是 CPU 中访问速度最快的存储器，因为它们直接位于 CPU 内核中，靠近运算单元（如算术逻辑单元，ALU）。</p>
<p><strong>寄存器的特点</strong></p>
<ul>
<li><strong>速度快</strong>：寄存器的访问速度比 Cache 和主存（RAM）都要快，能满足 CPU 的即时需求。</li>
<li><strong>容量小</strong>：寄存器数量有限，通常每个寄存器只有几个字节或几十个字节的容量。</li>
<li><strong>功能明确</strong>：寄存器根据用途被分为不同类型，每种寄存器在特定的指令或运算中起特定的作用。</li>
</ul>
<p><strong>常见的寄存器类型</strong></p>
<ol>
<li><strong>通用寄存器</strong>：用于临时存储数据，支持基本的加、减、乘、除等运算。</li>
<li><strong>程序计数器 (PC)</strong> ：保存下一条要执行指令的地址，用于控制程序执行的顺序。</li>
<li><strong>状态寄存器&#x2F;标志寄存器</strong>：存储运算结果的状态信息，如是否为零、是否有溢出等，用于条件判断。</li>
<li><strong>堆栈指针 (SP)</strong> ：指向栈顶位置，用于函数调用和返回的管理。</li>
<li><strong>地址寄存器</strong>：存储内存地址，用于快速访问特定的内存位置。</li>
</ol>
<p><strong>寄存器的作用</strong><br>寄存器用于 CPU 执行指令时的临时数据存储，避免频繁访问较慢的内存单元。它们直接与 CPU 核心连接，确保计算快速、高效。</p>
<h4 id="5-1-2-Cache"><a href="#5-1-2-Cache" class="headerlink" title="5.1.2 Cache"></a>5.1.2 Cache</h4><p><strong>Cache</strong>（缓存）是位于 CPU 和主存（RAM）之间的高速存储器，用于缓解 CPU 与主存之间的速度差异。Cache 通过暂时存储常用的数据和指令，减少 CPU 访问主存的次数，从而提高整体运算速度。Cache 通常是由 <strong>SRAM（静态随机存取存储器）</strong> 组成的；SRAM是易失性存储器，尽管 SRAM 的数据不需要周期性刷新，但一旦电源关闭，存储在其中的数据就会丢失。这是因为 SRAM 的存储原理基于晶体管的电状态，当电源断开时，这些状态会消失。<strong>DRAM</strong>则有些许不同，需要定期刷新以维持数据，刷新操作会耗费一定时间和电力，但也是易失性存储器(volatile memory)。</p>
<p><strong>Cache 的特点</strong></p>
<ul>
<li><strong>访问速度快</strong>：Cache 的访问速度比主存快，仅次于寄存器，能快速提供数据。</li>
<li><strong>层级结构</strong>：Cache 通常分为多级，包括 L1、L2 和 L3 缓存，分别位于不同的 CPU 层次上，L1 速度最快但容量最小，L3 容量最大但速度相对较慢。</li>
<li><strong>自动管理</strong>：Cache 由硬件自动管理，CPU 根据访问数据的频率和规律自动将数据加载到 Cache 中，无需程序员手动干预。</li>
</ul>
<p><strong>Cache 的作用</strong><br>Cache 主要用于存储 CPU 经常访问的数据或指令，以减少访问主存的延迟，提升 CPU 的执行效率。现代处理器通常会采用多级缓存结构，以平衡容量与速度之间的需求。</p>
<h4 id="5-1-3-Main-Memory"><a href="#5-1-3-Main-Memory" class="headerlink" title="5.1.3 Main Memory"></a>5.1.3 Main Memory</h4><p><strong>内存</strong>（Memory）一般称为主存(Main Memory)，是计算机中用于临时存储数据和程序的部件，CPU 可以快速访问其中的数据。内存的主要作用是为 CPU 提供运行时的工作区，用于存放操作系统、应用程序和当前处理的数据。</p>
<p><strong>内存的特点</strong></p>
<ul>
<li><strong>速度适中</strong>：内存的访问速度介于 Cache 和硬盘之间。尽管比硬盘快很多，但比不上 CPU 内部的寄存器和缓存。</li>
<li><strong>容量较大</strong>：内存容量一般较大，能够存储多个程序和大量数据，以满足系统的多任务需求。</li>
<li><strong>易失性</strong>：内存（RAM）通常由 DRAM（动态随机存取存储器）组成。DRAM 由于容量大、成本相对较低，也是一种易失性存储器，断电后数据会丢失。</li>
</ul>
<p><strong>内存的作用</strong></p>
<p>内存用于临时存放正在执行的程序和正在处理的数据，起到了 CPU 与硬盘之间的缓冲作用，使得系统运行更加高效。计算机在开机后，将程序从硬盘加载到内存中，CPU 再从内存中读取指令执行。</p>
<h4 id="5-1-4-Secondary-Memory"><a href="#5-1-4-Secondary-Memory" class="headerlink" title="5.1.4 Secondary Memory"></a>5.1.4 Secondary Memory</h4><p><strong>Secondary Memory</strong>（二级存储器）是计算机的外部存储，用于长期存储数据和程序，断电后数据不会丢失。常见的二级存储器包括硬盘驱动器 (HDD)、固态硬盘 (SSD)、光盘、以及 USB 闪存等。</p>
<p><strong>辅助存储器的特点</strong></p>
<ul>
<li><strong>非易失性(nonvolatile)</strong> ：辅助存储器断电后仍能保留数据，适合长期存储文件、程序和系统数据。</li>
<li><strong>大容量</strong>：相比于主存，辅助存储器容量更大，能够存储大量的数据和文件。</li>
<li><strong>较慢的访问速度</strong>：辅助存储器的读写速度比内存慢，因此用于存储不需要频繁访问的数据。</li>
</ul>
<p><strong>辅助存储器的作用</strong></p>
<p>辅助存储器用于存储计算机的操作系统、应用程序、用户文件和其他数据，提供数据的长期保存。计算机在启动时会将操作系统和相关程序从辅助存储器加载到内存中，以便 CPU 处理。</p>
<h3 id="5-2-Principle-of-Locality"><a href="#5-2-Principle-of-Locality" class="headerlink" title="5.2 Principle of Locality"></a>5.2 Principle of Locality</h3><p>局部性原理(principle of locality)是计算机组成中的一个关键概念，用来描述程序在执行过程中，访问内存地址或存储单元的一种倾向。局部性原理主要分为以下两类：</p>
<p><strong>时间局部性（Temporal Locality）</strong></p>
<ul>
<li><strong>定义</strong>：如果一个数据被访问过，那么在不久的将来它很可能会再次被访问。</li>
<li><strong>例子</strong>：在循环中多次访问某个变量。比如循环计数器，每次迭代都会访问该变量。</li>
</ul>
<p><strong>空间局部性（Spatial Locality）</strong></p>
<ul>
<li><strong>定义</strong>：如果一个数据被访问过，那么它附近的数据也很可能会在不久的将来被访问。</li>
<li><strong>例子</strong>：遍历数组时，逐个访问数组中的元素。比如访问数组<code>arr[0]</code>后，很可能访问<code>arr[1]</code>。</li>
</ul>
<blockquote>
<p>局部性原理在设计计算机缓存（Cache）时尤为重要。因为缓存利用局部性原理，通过临时存储经常访问的数据或地址来减少访问主内存的次数，提高整体系统性能。</p>
</blockquote>
<h3 id="5-3-Cache’s-Performance"><a href="#5-3-Cache’s-Performance" class="headerlink" title="5.3 Cache’s Performance"></a>5.3 Cache’s Performance</h3><p>Cache的主要考点围绕在命中率和缺失率的计算；在Cache映射中也有非常多的改进策略。</p>
<h4 id="5-3-1-Cache-Hit-Miss"><a href="#5-3-1-Cache-Hit-Miss" class="headerlink" title="5.3.1 Cache Hit &amp; Miss"></a>5.3.1 Cache Hit &amp; Miss</h4><p><strong>Cache命中（Cache Hit）</strong></p>
<ul>
<li><strong>定义</strong>：当处理器需要的数据在缓存中找到时，就称为Cache命中。命中率（Hit Rate）是命中次数占总访问次数的百分比。</li>
<li><strong>示例</strong>：处理器需要读取一个数据块，如果它已经在缓存中，直接读取数据，避免了访问慢速的主内存，从而提高了整体性能。</li>
</ul>
<p><strong>Cache缺失（Cache Miss）</strong></p>
<ul>
<li><strong>定义</strong>：当处理器需要的数据不在缓存中，必须从主内存中读取时，就称为Cache缺失。缺失率（Miss Rate）是缺失次数占总访问次数的百分比。</li>
<li><strong>示例</strong>：处理器需要读取一个数据块，如果它不在缓存中，处理器需要从主内存中读取该数据块，并将其放入缓存中。这个过程比直接从缓存读取要慢得多。</li>
</ul>
<p>命中率(Hit Rate)和缺失率(Miss Rate)的计算方法非常直观，分别是命中&#x2F;缺失的次数占访存次数的比例。</p>
<h4 id="5-3-2-命中时间、缺失代价和访存阻塞周期"><a href="#5-3-2-命中时间、缺失代价和访存阻塞周期" class="headerlink" title="5.3.2 命中时间、缺失代价和访存阻塞周期"></a>5.3.2 命中时间、缺失代价和访存阻塞周期</h4><p><strong>命中时间（Hit Time）</strong></p>
<ul>
<li><strong>定义</strong>：命中时间是指CPU在缓存中找到数据所需的时间，包括地址翻译、缓存访问和数据返回给处理器的时间。通常只有1个时钟周期长度。</li>
<li><strong>计算</strong>：命中时间通常由缓存访问的硬件特性决定，具体时间取决于缓存的层级和设计。</li>
</ul>
<p><strong>缺失代价（Miss Penalty）</strong></p>
<ul>
<li><strong>定义</strong>：缺失代价是指当数据不在缓存中，需要从较低层级的缓存或主存中加载数据所需的时间。</li>
<li><strong>计算</strong>：缺失代价 &#x3D; 低层级缓存或主存的访问时间 + 将数据传送到缓存中的时间。</li>
</ul>
<p><strong>访存阻塞周期（Memory Stall Cycles）</strong></p>
<ul>
<li><strong>定义</strong>：访存阻塞周期是指由于缓存缺失导致处理器需要等待数据加载而停顿的周期数。</li>
<li><strong>计算</strong>：访存阻塞周期 &#x3D; 缺失率 × 缺失代价</li>
</ul>
<p>假设：</p>
<ul>
<li>命中时间为1个周期。</li>
<li>缺失代价为50个周期。</li>
<li>缺失率为5%。</li>
</ul>
<p>那么：访存阻塞周期 &#x3D; 5% × 50个周期 &#x3D; 2.5个周期。</p>
<p>普适性的衡量会给上一个缺失率(Miss Rate), 那么</p>
<center>$访存阻塞周期 = 访存次数 \times 缺失率 \times 缺失代价$</center>

<h3 id="5-4-Cache的三种映射方式"><a href="#5-4-Cache的三种映射方式" class="headerlink" title="5.4 Cache的三种映射方式"></a>5.4 Cache的三种映射方式</h3><p><strong>1. 直接映射（Direct Mapped Cache）</strong></p>
<ul>
<li><strong>定义</strong>：每个内存块都映射到缓存的一个特定位置。缓存中的每个位置可以存储多个内存块，但在任意时间只能存储一个。</li>
<li><strong>优点</strong>：实现简单且成本低。</li>
<li><strong>缺点</strong>：冲突较多，即不同内存块可能会映射到同一个缓存位置，导致频繁替换。</li>
</ul>
<p><strong>2. 全关联映射（Fully Associative Cache）</strong></p>
<ul>
<li><strong>定义</strong>：内存块可以映射到缓存的任何位置。缓存中的每个位置都可以存储任何内存块。</li>
<li><strong>优点</strong>：减少了冲突，因为任何内存块都可以放到任何缓存位置。</li>
<li><strong>缺点</strong>：实现复杂且成本高，需要比较所有缓存位置以找到匹配的块。</li>
</ul>
<p><strong>3. 组关联映射（Set Associative Cache）</strong></p>
<ul>
<li><strong>定义</strong>：缓存分成多个组，每个组包含若干个位置。内存块首先映射到某个组，然后可以存储在该组的任意位置。</li>
<li><strong>优点</strong>：在复杂度和性能之间取得平衡，减少了直接映射中的冲突，同时实现比全关联映射更简单。</li>
<li><strong>缺点</strong>：组的选择可能会导致一些复杂度，但总的来说，比全关联映射低。<img src="/img/CA/cache_map.svg" srcset="/img/loading.gif" lazyload alt="Cache三种映射方式" style="max-width: 100%; height: auto;" /></li>
</ul>
<h4 id="5-4-1-直接映射"><a href="#5-4-1-直接映射" class="headerlink" title="5.4.1 直接映射"></a>5.4.1 直接映射</h4><p>映射规则：Cache块号 &#x3D; 内存块号 % Cache块数</p>
<blockquote>
<p>比如，Cache共有8块，内存的十号块映射在Cache的块号是：10 % 8 &#x3D; 2</p>
</blockquote>
<p>直接映射缓存（Direct Mapped Cache）内存地址通常被分成三个字段：块内字节偏移、索引位和标记位。</p>
<p><strong>1. 块内字节偏移（Block Offset）</strong></p>
<ul>
<li><strong>定义</strong>：块内字节偏移用于定位一个块中的具体字节。</li>
<li><strong>计算</strong>：偏移位的数量取决于块的大小。例如，如果块大小为4个字节，则需要2位来表示块内字节偏移。<ul>
<li>例子：对于一个块大小为4个字节的缓存，偏移位可能是<code>00</code>、<code>01</code>、<code>10</code>、<code>11</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. 索引位（Index Bits）</strong></p>
<ul>
<li><strong>定义</strong>：索引位用于定位缓存中的具体行（块）。</li>
<li><strong>计算</strong>：索引位的数量取决于缓存的行数。例如，如果缓存有8行，需要3位索引位来标识具体的行。<ul>
<li>例子：对于一个有8行的缓存，索引位可能是<code>000</code>到<code>111</code>。</li>
</ul>
</li>
</ul>
<p><strong>3. 标记位（Tag Bits）</strong></p>
<ul>
<li><strong>定义</strong>：标记位用于区分不同内存块，它们映射到同一个缓存行。</li>
<li><strong>计算</strong>：标记位的数量 &#x3D; 内存地址总位数 - 索引位数量 - 块内字节偏移位数量。<ul>
<li>例子：假设内存地址总位数为16位，块大小为4字节（2位块内偏移），缓存有8行（3位索引），那么标记位数量为11（16-3-2&#x3D;11）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>示例</strong> ：假设有一个16位的内存地址，缓存有8行，每行块大小为4字节。</p>
</blockquote>
<p>内存地址：<code>1010110010101110</code></p>
<ul>
<li><strong>块内字节偏移</strong>：2位（最右边的2位），<code>10</code> 表示块内的某个字节。</li>
<li><strong>索引位</strong>：3位（次右边的3位），<code>110</code> 表示缓存的具体行。</li>
<li><strong>标记位</strong>：11位（剩余左边的位），<code>10101100101</code> 用于区分不同的内存块。</li>
</ul>
<p><strong>内存地址分解</strong>：</p>
<ul>
<li>标记位（Tag）：<code>10101100101</code></li>
<li>索引位（Index）：<code>110</code></li>
<li>块内字节偏移（Block Offset）：<code>10</code></li>
</ul>
<center>$Cache容量 = （标记位 + 数据位）\times 行数 $</center>
补充：如果题目强调了有效位的存在，那么Cache的每一行需要多1bit的有效位，则
<center>$Cache容量 = （1 + 标记位 + 数据位）\times 行数 $</center>

<p>有效位是缓存系统中的一个重要概念，用于指示缓存块中的数据是否有效。具体来说，有效位帮助确定当前缓存块是否包含可以被处理器使用的有效数据。</p>
<ol>
<li><strong>指示数据有效性</strong>：有效位为1表示缓存块中的数据有效且可用；为0表示缓存块中的数据无效，可能未被使用或需要更新。</li>
<li><strong>管理缓存块</strong>：当一个新的内存块被加载到缓存时，会设置有效位为1。当缓存块的数据被替换或失效时，有效位被设置为0。</li>
</ol>
<p><strong>实现原理</strong></p>
<ul>
<li><strong>检查有效位</strong>：每次缓存访问时，首先检查有效位。如果有效位为0，即使缓存地址匹配，数据也不被使用，因为它无效。</li>
<li><strong>缓存替换</strong>：在缓存替换时，新的数据块写入缓存，并将对应的有效位设置为1。被替换的数据块的有效位通常被设置为0，表示数据无效。</li>
</ul>
<p><strong>示例</strong><br>假设一个缓存系统有4个块，每个块都有一个有效位：</p>
<ul>
<li>块0：有效位&#x3D;1（数据有效）</li>
<li>块1：有效位&#x3D;0（数据无效）</li>
<li>块2：有效位&#x3D;1（数据有效）</li>
<li>块3：有效位&#x3D;0（数据无效）</li>
</ul>
<p>当处理器访问一个地址时，它首先检查缓存块的有效位。如果有效位为1，它会进一步检查地址是否匹配；如果有效位为0，则直接从主存获取数据。</p>
<h4 id="5-4-2-直接映射缺失的3C模型"><a href="#5-4-2-直接映射缺失的3C模型" class="headerlink" title="5.4.2 直接映射缺失的3C模型"></a>5.4.2 直接映射缺失的3C模型</h4><p><strong>1. 冷缺失（Cold Miss）</strong></p>
<ul>
<li><strong>定义</strong>：也称为强制缺失或首次缺失。这种情况发生在缓存首次加载数据块时，因为缓存中还没有存储该数据块。</li>
<li><strong>示例</strong>：程序第一次访问一个数据块时，缓存中还没有该数据块，导致冷缺失。</li>
</ul>
<p><strong>2. 容量缺失（Capacity Miss）</strong></p>
<ul>
<li><strong>定义</strong>：由于缓存容量有限，即使缓存中所有块都被充分利用，仍然无法容纳所有需要的数据块，从而导致缺失。</li>
<li><strong>示例</strong>：程序需要访问的数据块数量超过了缓存容量，导致一些较早访问的数据块被驱逐，再次访问时需要重新加载。</li>
</ul>
<p><strong>3. 冲突缺失（Conflict Miss）</strong></p>
<ul>
<li><strong>定义</strong>：也称为干扰缺失。这种情况发生在直接映射缓存中，不同的数据块映射到同一个缓存块位置，导致频繁替换，即使缓存容量足够也会出现缺失。</li>
<li><strong>示例</strong>：两个或多个数据块映射到同一个缓存位置，导致数据块被替换，从而产生冲突缺失。</li>
</ul>
<img src="/img/CA/map_miss.svg" srcset="/img/loading.gif" lazyload alt="3C模型" style="max-width: 100%; height: auto;" />
  
<p>直接映射在应对上面的Cache缺失的时候有三种处理方式：</p>
<p><strong>1.写直达（Write Through）：</strong></p>
<ul>
<li>CPU同时向Cache和主存写入数据</li>
<li>实现简单，但写入速度慢</li>
<li>保持了Cache和主存的一致性</li>
</ul>
<p><strong>写缓冲（Write Buffer）：</strong></p>
<ul>
<li>CPU先写入Cache</li>
<li>数据暂存在写缓冲区</li>
<li>后台异步写入主存</li>
<li>提高了写入效率</li>
</ul>
<p><strong>写回（Write Back）：</strong></p>
<ul>
<li>CPU只写入Cache</li>
<li>使用脏位(Dirty Bit)标记修改</li>
<li>仅在数据被替换时才写回主存</li>
<li>最高效但实现复杂</li>
</ul>
<img src="/img/CA/map_strategy.svg" srcset="/img/loading.gif" lazyload alt="Cache缺失策略" style="max-width: 100%; height: auto;" />

<h4 id="5-4-3-多级缓存机制"><a href="#5-4-3-多级缓存机制" class="headerlink" title="5.4.3 多级缓存机制"></a>5.4.3 多级缓存机制</h4><p>多级缓存（Multilevel Cache）是一种在计算机系统中提高处理器访问数据速度的技术，通常将缓存分为多个层次，如 L1、L2 和 L3 缓存。这些缓存层次的设置能够平衡存取速度、容量和成本，确保 CPU 能更快地获取需要的数据。</p>
<p><strong>多级缓存的主要特点</strong></p>
<ol>
<li><p><strong>L1缓存</strong>（一级缓存）：通常集成在 CPU 内核中，速度最快，容量较小（一般为几十KB）。L1缓存分为指令缓存（I-Cache）和数据缓存（D-Cache），分别用于存储指令和数据，帮助 CPU 快速访问常用数据。</p>
</li>
<li><p><strong>L2缓存</strong>（二级缓存）：相比 L1 缓存稍慢，但容量更大（几百KB到几MB），通常也集成在处理器中。L2 缓存为 L1 提供数据支援，命中率高，进一步减少了 CPU 对主存（RAM）的访问需求。</p>
</li>
<li><p><strong>L3缓存</strong>（三级缓存）：用于共享多个 CPU 内核的数据，容量较大（几MB到几十MB），但访问速度比 L2 缓慢。L3缓存作为所有内核的公共缓存，提升了多核处理器的并行性能。</p>
</li>
<li><p><strong>工作原理</strong>：CPU 会首先查找 L1 缓存，如果未命中则依次查找 L2 和 L3 缓存，直到最后访问主存。这样的分级缓存结构可以减少主存访问次数，从而提高系统性能。</p>
</li>
<li><p><strong>优点</strong>：多级缓存结构能显著降低数据访问延迟，提高处理器的执行效率；而且它能有效利用缓存的层级特性，合理分配存取速度和容量。</p>
</li>
</ol>
<p><strong>多级缓存背景下的平均 CPI 计算</strong></p>
<p>在多级缓存系统中，平均每条指令的周期数（CPI，Cycles Per Instruction）可以通过考虑每一级缓存的缺失率和缺失代价来计算。这里的缺失率指的是每一级缓存未命中（缺失）的概率，缺失代价则是缓存未命中时所需要的额外处理周期数。平均 CPI 的计算可以按以下步骤进行。</p>
<p>假设：</p>
<ul>
<li>$\text{CPI}_{\text{ideal}}$ 是理想情况下（没有缓存缺失）的 CPI，即不考虑缓存缺失时每条指令的周期数。</li>
<li>L1、L2、L3 分别是一级、二级和三级缓存。</li>
<li>$\text{MR}_n$ 表示第 $n$ 级缓存的缺失率（Miss Rate）。</li>
<li>$\text{MC}_n$ 表示第 $n$ 级缓存的缺失代价（Miss Penalty），即在第 $n$ 级缓存缺失时需要的额外周期数。</li>
</ul>
<p>平均 CPI 的计算可以分为以下步骤：</p>
<ol>
<li><p><strong>L1 缓存的贡献</strong>：L1 缓存缺失的情况下，需要访问 L2 缓存，因此 L1 缓存的平均贡献为：</p>
<center> $\text{CPI}_{\text{L1}} = \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}}$ </center>
</li>
<li><p><strong>L2 缓存的贡献</strong>：L1 缓存缺失时会访问 L2 缓存，如果 L2 缓存也缺失，则需要访问 L3 缓存。L2 缓存的平均贡献为：</p>
<center> $\text{CPI}_{\text{L2}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$ </center>
</li>
<li><p><strong>L3 缓存的贡献</strong>：当 L1 和 L2 都缺失时，才会访问 L3 缓存。如果 L3 缓存也缺失，就会访问主存，因此 L3 缓存的平均贡献为：</p>
<center> $\text{CPI}_{\text{L3}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}}$ </center>
</li>
<li><p><strong>主存的贡献</strong>：当 L1、L2 和 L3 缓存都缺失时，才会访问主存。因此主存的平均贡献为：</p>
<center> $\text{CPI}_{\text{memory}} = \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$ </center></li>
</ol>
<p>把各级缓存和主存的贡献相加，再加上理想情况下的 CPI，得到总的平均 CPI：</p>
<center> $\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{CPI}_{\text{L1}} + \text{CPI}_{\text{L2}} + \text{CPI}_{\text{L3}} + \text{CPI}_{\text{memory}}$ </center>

<p>展开后，即：</p>
<center> 
$\text{CPI}_{\text{avg}} = \text{CPI}_{\text{ideal}} + \text{MR}_{\text{L1}} \times \text{MC}_{\text{L1}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MC}_{\text{L2}}$
$+ \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{L3}} + \text{MR}_{\text{L1}} \times \text{MR}_{\text{L2}} \times \text{MR}_{\text{L3}} \times \text{MC}_{\text{memory}}$
</center>

<blockquote>
<ul>
<li>每一级缓存的贡献都是基于它前一级缓存的缺失率和自身的缺失代价递归计算的。</li>
<li>这个公式综合了各级缓存的缺失率和缺失代价，提供了一个较为准确的平均 CPI 估计。</li>
</ul>
</blockquote>
<h3 id="5-5-Virtual-Memory"><a href="#5-5-Virtual-Memory" class="headerlink" title="5.5 Virtual Memory"></a>5.5 Virtual Memory</h3><p>虚拟存储器通过地址映射机制，将操作系统使用的虚拟地址转换为不同的物理地址。这个过程涉及多层缓存和映射关系，例如：</p>
<ul>
<li>Cache 将处理器寄存器访问的地址映射到内存中的物理地址，以加速数据读取。</li>
<li>主存（内存）充当磁盘的缓存，从磁盘读取数据时，常用的数据会保存在内存中以加快访问速度。</li>
<li>TLB（快表）是页表的缓存，用于快速查找虚拟地址到物理地址的映射，减少页表查找的开销。</li>
</ul>
<p>将虚拟地址转换为物理地址的过程通常涉及几个关键步骤：</p>
<ol>
<li><p>地址生成：当程序访问某个内存位置时，它会生成一个虚拟地址。</p>
</li>
<li><p>页号和偏移量：虚拟地址被分为两个部分：页号和偏移量。页号用于识别该地址所属的页，而偏移量则指定了在该页内的具体位置。</p>
</li>
<li><p>快速表 (Translation Lookaside Buffer, TLB)：在检查页表之前，系统首先检查快速表 (TLB)，这是一个小而快速的缓存，存储最近的虚拟到物理地址的转换。如果在 TLB 中找到转换（TLB 命中），则可以快速检索物理地址。</p>
</li>
<li><p>页表查找：如果在 TLB 中未找到转换（TLB 未命中），系统将访问页表。页表包含条目，将每个虚拟页号映射到内存中相应的物理页框号。</p>
</li>
<li><p>物理地址形成：一旦访问了页表，就可以获得物理页框号。然后，物理地址通过将该页框号与原虚拟地址中的偏移量结合来形成。</p>
</li>
<li><p>访问内存：系统现在使用物理地址访问 RAM 中的数据。</p>
</li>
<li><p>页面缺失处理：如果所需的页面不在内存中（页面缺失），操作系统将从磁盘存储中检索该页面，并相应地更新页表。</p>
</li>
</ol>
<img src="/img/CA/address.svg" srcset="/img/loading.gif" lazyload alt="Address Translation" style="max-width: 100%; height: auto;" />

<p>关于虚拟地址和物理地址还有更多的考点内容，比如各种替换策略和写策略，这里的内容我更愿意放到操作系统的对应章节来讲解😈马不停蹄更新中🐎</p>
<div class="note note-primary">
            <p>完结撒花🎉<br>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>
          </div>


















                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%A7%91%E7%9B%AE%E7%AC%94%E8%AE%B0/" class="category-chain-item">专业科目笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%BF%AE%E8%80%83/" class="print-no-link">#修考</a>
      
        <a href="/tags/Computer-Architecture/" class="print-no-link">#Computer Architecture</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Computer Architecture</div>
      <div>http://toutou.zeabur.app/2024/10/21/Computer-Architecture/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>toutou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>October 21, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/11/04/Digital-Circuit/" title="Digital Circuit">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Digital Circuit</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/09/28/JPN-Words/" title="日本語語彙まとめ">
                        <span class="hidden-mobile">日本語語彙まとめ</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://www.instagram.com/hanni_rio/" target="_blank" rel="nofollow noopener"><span>Hanni Rio</span></a> <i class="iconfont icon-copyright"></i> <a href="https://toutou.pro/" target="_blank" rel="nofollow noopener"><span>toutou</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
