

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="toutou">
  <meta name="keywords" content="">
  
    <meta name="description" content="Digital CircuitCredit to《Digital Design and Computer Architecture, Second Edition》🤯 Let’s quickly review this subject. The diagram is powered by @drawio   催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio  1. Logic Gat">
<meta property="og:type" content="article">
<meta property="og:title" content="Digital Circuit">
<meta property="og:url" content="http://toutou.zeabur.app/2024/11/04/Digital-Circuit/index.html">
<meta property="og:site_name" content="偷偷星球">
<meta property="og:description" content="Digital CircuitCredit to《Digital Design and Computer Architecture, Second Edition》🤯 Let’s quickly review this subject. The diagram is powered by @drawio   催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio  1. Logic Gat">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/add.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/nand.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/buffer.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/half_adder.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/full_adder.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/fa1.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/fa2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/fa3.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/ripple.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/lookahead.jpeg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/half.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/sub2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/sub3.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/mux.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/mux2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/decoder.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/pd.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/glitch.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/glitch2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/sr.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/sr2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/dlatch.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/jklatch.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/srff.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/dff.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/dff2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/dff3.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/jkff.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/jkff2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/tff.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/tff2.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/DC/fsm.svg">
<meta property="article:published_time" content="2024-11-04T15:56:01.000Z">
<meta property="article:modified_time" content="2024-12-01T16:37:44.970Z">
<meta property="article:author" content="toutou">
<meta property="article:tag" content="修考">
<meta property="article:tag" content="Digital Circuit">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://toutou.zeabur.app/img/DC/add.svg">
  
  
  
  <title>Digital Circuit - 偷偷星球</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"toutou.zeabur.app","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>偷偷星球</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/wall.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Digital Circuit"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-11-04 23:56" pubdate>
          November 4, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Digital Circuit</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Digital-Circuit"><a href="#Digital-Circuit" class="headerlink" title="Digital Circuit"></a>Digital Circuit</h1><p>Credit to《Digital Design and Computer Architecture, Second Edition》🤯 Let’s quickly review this subject. The diagram is powered by <a target="_blank" rel="noopener" href="https://github.com/jgraph/drawio-desktop">@drawio</a></p>
<blockquote>
<p> 催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>
</blockquote>
<h2 id="1-Logic-Gates"><a href="#1-Logic-Gates" class="headerlink" title="1. Logic Gates"></a>1. Logic Gates</h2><p>第一章主要认识最基础的逻辑门元件，然后熟悉其对应的真值表(Truth Table),主要是为第二章的组合电路(combinational circuit)做铺垫。</p>
<p><strong>NOT 门（非门）:</strong> 输出是输入的逻辑反， $Y &#x3D; \neg A$</p>
<p><strong>BUF 门（缓冲器）:</strong> 输出与输入相同，用于信号强化。$Y &#x3D; A$</p>
<p><strong>AND 门（与门）:</strong> 所有输入均为1时，输出才为1。$Y &#x3D; A \cap B$</p>
<p><strong>OR 门（或门）:</strong> 任意输入为1时，输出为1。$Y &#x3D; A \cup B$</p>
<img src="/img/DC/add.svg" srcset="/img/loading.gif" lazyload alt="逻辑门1" style="max-width: 100%; height: auto;" />

<p><strong>NAND 门（与非门）:</strong> 与门输出取反。 $ Y &#x3D; \neg (A \cap B) $</p>
<p><strong>NOR 门（或非门）:</strong> 或门输出取反。 $ Y &#x3D; \neg (A \cup B) $</p>
<p><strong>XOR 门（异或门）:</strong> 相异为1，相同为0。 $ Y &#x3D; A \oplus B $</p>
<p><strong>XNOR 门（同或门）:</strong> 相同为0，相异为1。 $ Y &#x3D; \neg (A \oplus B) $</p>
<img src="/img/DC/nand.svg" srcset="/img/loading.gif" lazyload alt="逻辑门2" style="max-width: 100%; height: auto;" />

<p><strong>三态缓冲器（tristate buffer）</strong> 是一种数字电路元件，其输出可以处于三种状态之一：高电平（1）、低电平（0）或高阻态（Z）。高阻态表示输出像断开一样，不驱动任何电流，可以用于总线控制等应用。</p>
<p><strong>高水平有效（Active High）</strong></p>
<p>在高水平有效的三态缓冲器中，当控制信号为高电平（1）时，缓冲器输出有效，即输出输入信号的值。当控制信号为低电平（0）时，缓冲器输出高阻态（Z）。</p>
<ul>
<li>控制信号 &#x3D; 1：输出 &#x3D; 输入信号</li>
<li>控制信号 &#x3D; 0：输出 &#x3D; 高阻态（Z）</li>
</ul>
<p><strong>低水平有效（Active Low）</strong></p>
<p>在低水平有效的三态缓冲器中，当控制信号为低电平（0）时，缓冲器输出有效，即输出输入信号的值。当控制信号为高电平（1）时，缓冲器输出高阻态（Z）。</p>
<ul>
<li>控制信号 &#x3D; 0：输出 &#x3D; 输入信号</li>
<li>控制信号 &#x3D; 1：输出 &#x3D; 高阻态（Z）</li>
</ul>
<p align="center">
  <img src="/img/DC/buffer.svg" srcset="/img/loading.gif" lazyload alt="逻辑门3" style="max-width: 110%; height: auto;" />
</p>


<h2 id="2-Combinational-Logic-Circuit"><a href="#2-Combinational-Logic-Circuit" class="headerlink" title="2. Combinational Logic Circuit"></a>2. Combinational Logic Circuit</h2><p>组合逻辑电路（Combinational Logic Circuit）是一种数字电路，其中输出仅依赖于当前输入，而不依赖于之前的输入状态。这意味着组合电路没有存储元件，因此它没有记忆功能。其主要特性包括：</p>
<ul>
<li><p>无记忆功能：输出<strong>仅由当前输入决定</strong>，与之前的输入无关。</p>
</li>
<li><p>固定的逻辑功能：根据输入信号的组合，输出信号以确定的方式变化。</p>
</li>
<li><p>构建简单：组合电路通常由基本逻辑门（如AND、OR、NOT、NAND、NOR、XOR、XNOR）构建，可以用来实现任意逻辑功能。</p>
</li>
</ul>
<p>在有逻辑门的基础知识下，还需要有布尔表达式以及卡诺图的基础下才能完成组合电路的设计。</p>
<h3 id="2-1-Boolean-Equation"><a href="#2-1-Boolean-Equation" class="headerlink" title="2.1 Boolean Equation"></a>2.1 Boolean Equation</h3><p><strong>与或式（Sum of Products, SOP）</strong> 是一种布尔表达式形式，表示多个与项（积项）之间的或操作。每个积项由一个或多个变量通过与操作连接而成。与或式通常用于表达布尔函数的标准形式之一。例如：</p>
 <center>$ Y = A \cdot B + \overline{A}  \cdot C + B \cdot \overline{C} $</center>

<p><strong>或与式（Product of Sums, POS）</strong> 是布尔表达式的另一种形式，表示多个或项（和项）之间的与操作。每个和项由一个或多个变量通过或操作连接而成。或与式也常用于表达布尔函数的标准形式之一。例如：</p>
<center> $ Y = (A + B) \cdot (\overline {A} + C) \cdot (B + \overline{C}) $</center>


<p><strong>最小项 (Minterms)</strong> 是布尔函数的标准形式之一，其中每个最小项对应一个输出为1的输入组合。最小项由所有变量的与运算构成，每个变量可能是原变量或其补变量。通俗解释就是输出为1对应积项为1的累加。</p>
<p>示例：考虑一个布尔函数 ( F(A, B, C) )：</p>
<ul>
<li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最小项为 $ ( A \cdot \overline{B} \cdot C )$ </li>
<li>当 ( A &#x3D; 0 ), ( B &#x3D; 1 ), ( C &#x3D; 0 ) 时，最小项为 $ ( \overline{A} \cdot B \cdot \overline{C} )$</li>
</ul>
<p>假设布尔函数在以下输入组合下输出为1：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>相应的最小项表示为：</p>
<center>$ F(A, B, C) = \overline{A} \cdot \overline{B} \cdot C + \overline{A} \cdot B \cdot \overline{C} + A \cdot \overline{B} \cdot C $</center>

<p><strong>最大项 (Maxterms)</strong> 是布尔函数的另一种标准形式，其中每个最大项对应一个输出为0的输入组合。最大项由所有变量的或运算构成，每个变量可能是原变量或其补变量。通俗解释就是输入为0所对应的和项为0的累乘</p>
<p>示例：同样考虑布尔函数 ( F(A, B, C) )：</p>
<p>这两个组合对应的最大项为：</p>
<ul>
<li>当 ( A &#x3D; 0 ), ( B &#x3D; 0 ), ( C &#x3D; 0 ) 时，最大项为$ (A + B + C) $</li>
<li>当 ( A &#x3D; 1 ), ( B &#x3D; 0 ), ( C &#x3D; 1 ) 时，最大项为$ (\overline{A} + B + \overline{C} ) $</li>
</ul>
<p>假设布尔函数 ( F(A, B, C) ) 在以下输入组合下输出为0：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>因此，相应的最大项表达式为：</p>
<center> 
\[
F(A, B, C) = (A + B + C) \cdot (\overline{A} + \overline{B} + C)
\] 
</center>


<p><strong>总结</strong></p>
<ul>
<li><strong>最小项</strong>：布尔函数输出为1时，对应输入组合的与运算。</li>
<li><strong>最大项</strong>：布尔函数输出为0时，对应输入组合的或运算。</li>
</ul>
<blockquote>
<p>这些概念在布尔代数和数字电路设计中非常有用，也是这门课的高频考点</p>
</blockquote>
<h3 id="2-2-Boolean-Operation-Rules"><a href="#2-2-Boolean-Operation-Rules" class="headerlink" title="2.2 Boolean Operation Rules"></a>2.2 Boolean Operation Rules</h3><p>布尔运算的基本定律，和卡诺图一样，是逻辑电路化简的主要手段</p>
<h4 id="2-2-1-交换律（Commutative-Law）"><a href="#2-2-1-交换律（Commutative-Law）" class="headerlink" title="2.2.1 交换律（Commutative Law）"></a>2.2.1 交换律（Commutative Law）</h4><p>交换律表示在布尔运算中，操作数的位置可以互换。</p>
<ul>
<li><strong>与运算</strong>：$ A \cdot B &#x3D; B \cdot A $</li>
<li><strong>或运算</strong>：$ A + B &#x3D; B + A $</li>
</ul>
<h4 id="2-2-2-结合律（Associative-Law）"><a href="#2-2-2-结合律（Associative-Law）" class="headerlink" title="2.2.2 结合律（Associative Law）"></a>2.2.2 结合律（Associative Law）</h4><p>结合律表示在布尔运算中，操作数的组合方式不影响运算结果。</p>
<ul>
<li><strong>与运算</strong>：$ (A \cdot B) \cdot C &#x3D; A \cdot (B \cdot C) $</li>
<li><strong>或运算</strong>：$ (A + B) + C &#x3D; A + (B + C) $</li>
</ul>
<h4 id="2-2-3-分配律（Distributive-Law）"><a href="#2-2-3-分配律（Distributive-Law）" class="headerlink" title="2.2.3 分配律（Distributive Law）"></a>2.2.3 分配律（Distributive Law）</h4><p>分配律表示一种运算可以分配到另一种运算上。</p>
<ul>
<li><strong>与对或</strong>：$ A \cdot (B + C) &#x3D; (A \cdot B) + (A \cdot C) $</li>
<li><strong>或对与</strong>：$ A + (B \cdot C) &#x3D; (A + B) \cdot (A + C) $</li>
</ul>
<h4 id="2-2-4-吸收律（Absorption-Law）"><a href="#2-2-4-吸收律（Absorption-Law）" class="headerlink" title="2.2.4 吸收律（Absorption Law）"></a>2.2.4 吸收律（Absorption Law）</h4><p>吸收律表示通过某些布尔运算可以简化表达式。</p>
<ul>
<li>$ A + (A \cdot B) &#x3D; A $</li>
<li>$ A \cdot (A + B) &#x3D; A $</li>
</ul>
<h4 id="2-2-5-合并律（Combining-Law）"><a href="#2-2-5-合并律（Combining-Law）" class="headerlink" title="2.2.5 合并律（Combining Law）"></a>2.2.5 合并律（Combining Law）</h4><p>合并律表示布尔变量和其补变量的某些组合具有特定的结果。</p>
<ul>
<li>$ A + \overline{A} &#x3D; 1 $</li>
<li>$ A \cdot \overline{A} &#x3D; 0 $</li>
</ul>
<h4 id="2-2-6-一致律（Identity-Law）"><a href="#2-2-6-一致律（Identity-Law）" class="headerlink" title="2.2.6 一致律（Identity Law）"></a>2.2.6 一致律（Identity Law）</h4><p>一致律表示布尔变量与1和0的运算结果。</p>
<ul>
<li><strong>与1</strong>：$ A \cdot 1 &#x3D; A $</li>
<li><strong>与0</strong>：$ A \cdot 0 &#x3D; 0 $</li>
<li><strong>或1</strong>：$ A + 1 &#x3D; 1 $</li>
<li><strong>或0</strong>：$ A + 0 &#x3D; A $</li>
</ul>
<h4 id="2-2-7-德摩根律（De-Morgan’s-Laws）"><a href="#2-2-7-德摩根律（De-Morgan’s-Laws）" class="headerlink" title="2.2.7 德摩根律（De Morgan’s Laws）"></a>2.2.7 德摩根律（De Morgan’s Laws）</h4><p>德摩根律表示对布尔表达式取反的规则。</p>
<ul>
<li>$ \overline{A \cdot B} &#x3D; \overline{A} + \overline{B} $</li>
<li>$ \overline{A + B} &#x3D; \overline{A} \cdot \overline{B} $</li>
</ul>
<h4 id="2-2-8-部分二级公式推导"><a href="#2-2-8-部分二级公式推导" class="headerlink" title="2.2.8 部分二级公式推导"></a>2.2.8 部分二级公式推导</h4><ul>
<li>$ A + \overline{A}B &#x3D; A + B$</li>
</ul>
<p>证明: $A(1 + B) + {A}B &#x3D; A + AB + \overline{A}B &#x3D; A + B $ </p>
<ul>
<li>$ (A + B) \cdot (A + C) &#x3D; A + (B \cdot C) $</li>
</ul>
<p>证明: $ AA + AC + AB + BC &#x3D; A + AB + AC + BC &#x3D; A(1 + B + C) + BC &#x3D; A + BC $</p>
<ul>
<li>$A \cdot (A + B) &#x3D; A$</li>
</ul>
<p>证明: $AA + AB &#x3D; A + AB &#x3D; A(1 + B) &#x3D; A$</p>
<ul>
<li>$BC + B\overline{C} &#x3D; B$</li>
</ul>
<p>证明: $B \cdot (C + \overline{C}) &#x3D; B \cdot 1 &#x3D; B$</p>
<ul>
<li>$(A + B) \cdot (A + \overline{B}) &#x3D; A$</li>
</ul>
<p>证明: $AA + A\overline{B} + AB + B\overline{B} &#x3D; A + A(B + \overline{B}) &#x3D; A + A &#x3D; A$</p>
<ul>
<li>$AB + \overline{A}C + BC &#x3D; AB + \overline{A}C$</li>
</ul>
<p>证明关键：使用吸收律 $A + AB &#x3D; A$, 推广为$AB + ABC &#x3D; AB$</p>
<p>$$<br>\begin{aligned}<br>&amp;AB + \overline{A}C + BC \\<br>&amp;&#x3D; AB + \overline{A}C + (A + \overline{A})BC \\<br>&amp;&#x3D; AB + \overline{A}C + ABC + \overline{A}CB \\<br>&amp;&#x3D; AB + ABC + \overline{A}C + \overline{A}CB \text{(使用推广公式)} \\<br>&amp;&#x3D; AB + \overline{A}C<br>\end{aligned}<br>$$</p>
<p>根据吸收律可继续推广下去：<br>$$AB + \overline{A}C + BC\cdot(\text{其他任何项}) &#x3D; AB + \overline{A}C  $$ </p>
<p>在表达式中，无论包含 $B$ 和 $C$ 的项如何复杂（例如 $BCDEFGH$），它都不会改变整个表达式的最终结果。</p>
<div class="note note-primary">
            <p>渲染上述公式太折磨了！修考一般不考如此复杂的化简，一般掌握K-Map化简足够应付</p>
          </div>

<h3 id="2-3-K-Map"><a href="#2-3-K-Map" class="headerlink" title="2.3 K-Map"></a>2.3 K-Map</h3><p>在绘制卡诺图的时候需要用到格雷码的表格。首先引入一个格雷码的概念。</p>
<h4 id="2-3-1-Gray-Code"><a href="#2-3-1-Gray-Code" class="headerlink" title="2.3.1 Gray Code"></a>2.3.1 Gray Code</h4><p>格雷码（Gray Code）是一种<strong>特殊的二进制编码方式</strong>，其特点是<strong>相邻的两个数码之间仅有一位二进制数不同</strong>。格雷码的发明即是用来将误差之可能性缩减至最小，编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码，可以使装置做数字步进时只更动最少的位元数以提高稳定性。</p>
<p><strong>格雷码的特性</strong></p>
<ul>
<li><strong>相邻差一位</strong>：每个相邻编码仅一位不同，减少了转换时的误差风险。</li>
<li><strong>非权重编码</strong>：格雷码不按照传统二进制编码的权值（如 $1, 2, 4, 8, \dots$）累加。</li>
</ul>
<p><strong>2 位格雷码卡诺图</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>00</td>
<td>01</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>10</td>
</tr>
</tbody></table>
<p><strong>3 位格雷码卡诺图</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>00</th>
<th>01</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>000</td>
<td>001</td>
<td>011</td>
<td>010</td>
</tr>
<tr>
<td>1</td>
<td>110</td>
<td>111</td>
<td>101</td>
<td>100</td>
</tr>
</tbody></table>
<p><strong>4 位格雷码卡诺图</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>00</th>
<th>01</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>0000</td>
<td>0001</td>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>01</td>
<td>0110</td>
<td>0111</td>
<td>0101</td>
<td>0100</td>
</tr>
<tr>
<td>11</td>
<td>1110</td>
<td>1111</td>
<td>1101</td>
<td>1100</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
<td>1011</td>
<td>1001</td>
<td>1000</td>
</tr>
</tbody></table>
<blockquote>
<p>上述表格，无论是以x轴对称，或者y轴对称，或者中心对称，均只有1位的差异</p>
</blockquote>
<h4 id="2-3-2-卡诺图化简步骤"><a href="#2-3-2-卡诺图化简步骤" class="headerlink" title="2.3.2 卡诺图化简步骤"></a>2.3.2 卡诺图化简步骤</h4><ol>
<li><p>构建 K 图：根据布尔函数的输入变量数量，构建相应大小的 K 图：</p>
<ul>
<li>2 位变量：4 格（2×2）</li>
<li>3 位变量：8 格（2×4）</li>
<li>4 位变量：16 格（4×4）</li>
</ul>
</li>
</ol>
<p>横轴和纵轴的变量顺序需按照<strong>格雷码</strong>排列，以确保相邻格子之间只有一个变量不同。</p>
<ol start="2">
<li><p>填写真值表和无关项：</p>
<ul>
<li>根据逻辑函数或真值表，在 K 图中标记输出为 1 的位置。</li>
<li>将无关项标(Don’t Care Conditions)记为 X。无关项是那些对最终结果没有影响的输入组合，可以被自由选择为 1 或 0，以帮助扩大合并区域。</li>
</ul>
</li>
<li><p>寻找最大合并区域：</p>
<ul>
<li>在 K 图中，寻找可以合并的 1 和 X 区域。合并的目标是形成2 的幂次方大小的区域（例如 1、2、4、8 等格），并使每个 1 尽量包含在最大的区域中。</li>
<li>合并时遵循以下规则：<ul>
<li>只允许合并相邻的 1 和 X（上下、左右、包围环绕相邻）。</li>
<li>尽量优先选择包含更多无关项 X 的区域，以增加合并区域的大小。</li>
<li>合并区域可以是矩形、正方形，甚至是环绕 K 图的封闭区域。</li>
</ul>
</li>
</ul>
</li>
<li><p>合并相邻项：</p>
<ul>
<li>每个合并区域中的变量中，如果某个变量在区域内既有 0 又有 1，则忽略该变量（因为它在该区域中无关紧要）。</li>
<li>将每个合并区域的共同变量提取为一个积项。对于每个变量：<ul>
<li>如果变量在区域内始终为 1，则使用原变量（如 $A$）。</li>
<li>如果变量在区域内始终为 0，则使用其反码（如 $\overline{A}$）。</li>
</ul>
</li>
</ul>
</li>
<li><p>写出最简化表达式：</p>
<ul>
<li>将所有合并区域的积项求和，得到逻辑函数的最简化形式。</li>
<li>所有包含在化简表达式中的项应尽量少，以确保表达式是最简形式。</li>
</ul>
</li>
</ol>
<blockquote>
<p>多练多化简就行了，没什么难度</p>
</blockquote>
<h3 id="2-4-常见数字模块"><a href="#2-4-常见数字模块" class="headerlink" title="2.4 常见数字模块"></a>2.4 常见数字模块</h3><p>这一小节跟计算机组成中的算术运算关联度很高，数字电路就是来讲解计算机所呈现出来的算术运算在底层是如何用逻辑元器件实现的。</p>
<h4 id="2-4-1-Half-Adder"><a href="#2-4-1-Half-Adder" class="headerlink" title="2.4.1 Half Adder"></a>2.4.1 Half Adder</h4><p><strong>半加器 (Half Adder)</strong> 是一个基本的数字电路，用于计算两个单比特二进制数的和。它的功能是执行二进制加法，并且产生两个输出：</p>
<ul>
<li>Sum：表示两个输入二进制数加法的结果（不考虑进位）。这里用$S$来表示和。</li>
<li>Carry：表示加法结果中<strong>产生的进位</strong>。这里用$Cout$来表示产生的进位了。</li>
</ul>
<p>根据如下K-Map我们可以得出和与进位的表达式，分别为：$S &#x3D; A \oplus B$ , $Cout &#x3D; A\cdot B$，再把组合电路进行封装📦(encapsulation)可以得到半加器这个电路元件<br><img src="/img/DC/half_adder.svg" srcset="/img/loading.gif" lazyload alt="半加器" style="max-width: 100%; height: auto;" />  </p>
<h4 id="2-4-2-Full-Adder"><a href="#2-4-2-Full-Adder" class="headerlink" title="2.4.2 Full Adder"></a>2.4.2 Full Adder</h4><p><strong>全加器 (Full Adder)</strong> 是数字电路中的一种基本元件，用于对二进制数进行加法运算。与半加器（Half Adder）相比，全加器可以对两个二进制数和一个进位位进行加法运算，并输出结果和新的进位位。</p>
<p>全加器的输入包括三个位：</p>
<ul>
<li><p>A（第一个加数位）</p>
</li>
<li><p>B（第二个加数位）</p>
</li>
<li><p>Cin（输入进位位）</p>
</li>
</ul>
<p>全加器的输出包括两个位：</p>
<ul>
<li><p>S（和位）：表示加法结果的当前位。</p>
</li>
<li><p>Cout（输出进位位）：表示加法结果的进位位。</p>
</li>
</ul>
<img src="/img/DC/full_adder.svg" srcset="/img/loading.gif" lazyload alt="全加器" style="max-width: 100%; height: auto;" />  

<p>首先分析真值表写出最小项表达式，对于$S$有：</p>
<p>$$<br>\begin{aligned}<br>S &amp;&#x3D; \overline{A} \cdot B \cdot \overline{C_{in}} + A \cdot\overline{B} \cdot \overline{C_{in}} + \overline{A} \cdot \overline{B} \cdot C_{in} + A \cdot B \cdot C_{in} \\<br>&amp;&#x3D; \overline{C_{in}}(A \oplus B) + C_{in} \overline{(A \oplus B)} \\<br>&amp;&#x3D; A \oplus B \oplus C_{in}<br>\end{aligned}<br>$$</p>
<p>对于$C_{out}$有：</p>
<p>$$<br>\begin{aligned}<br>C_{out} &amp;&#x3D; AB \overline{C_{in}} + \overline{A}BC_{in} + A \overline{B}C_{in} + ABC_{in} \\<br>&amp;&#x3D; AB + C_{in}(A \oplus B)<br>\end{aligned}<br>$$</p>
<p><strong>思考🤔</strong> ：为什么黑书给的是 $C_{out} &#x3D; AB + AC_{in} + BC_{in}$ ，这时候可以借助K-Map化简：如下图所示</p>
<div style="text-align: center;">
  <img src="/img/DC/fa1.svg" srcset="/img/loading.gif" lazyload alt="k-map" style="max-width: 100%; height: auto;" />
</div>


<p>根据K-Map化简，我们的全加器的画法会得出上图的电路，而如果根据真值表进行表达式化简，我们会得到下图的全加器。</p>
<img src="/img/DC/fa2.svg" srcset="/img/loading.gif" lazyload alt="Full Adder" style="max-width: 100%; height: auto;" />  

<p>我们可以用2个半加器和一个或门封装成一个全加器,具体的计算过程就不赘述了，这是修考重点！</p>
<img src="/img/DC/fa3.svg" srcset="/img/loading.gif" lazyload alt="全加器封装" style="max-width: 100%; height: auto;" />  

<h4 id="2-4-3-Ripple-Carry-Adder"><a href="#2-4-3-Ripple-Carry-Adder" class="headerlink" title="2.4.3 Ripple-Carry Adder"></a>2.4.3 Ripple-Carry Adder</h4><p><strong>Ripple-Carry Adder</strong> （行波进位加法器）是一种用于二进制数加法的简单组合逻辑电路，由多个一位全加器（Full Adder）级联而成，每个全加器负责处理输入位和进位。</p>
<ol>
<li><p><strong>组成结构</strong>  </p>
<ul>
<li>Ripple-Carry Adder 包括 $n$ 个全加器，用于计算 $n$ 位二进制数的加法。  </li>
<li>每个全加器接收两个输入位 $A[i]$ 和 $B[i]$，以及前一位的进位 $C[i]$。  </li>
<li>输出为和 $S[i]$ 和进位 $C[i+1]$。</li>
</ul>
</li>
<li><p><strong>进位传播</strong>  </p>
<ul>
<li>第一个全加器处理最低有效位 $A[0]$ 和 $B[0]$ 以及初始进位（通常为 0），产生和 $S[0]$ 和进位 $C[1]$。  </li>
<li>进位 $C[1]$ 传递到下一个全加器，依次类推，直到最高有效位。</li>
</ul>
</li>
<li><p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点</strong>  </p>
<ul>
<li>设计简单，硬件实现容易。</li>
</ul>
</li>
<li><p><strong>缺点</strong>  </p>
<ul>
<li><strong>进位传播延迟</strong>：每个全加器必须等待前一级的进位信号，导致延迟随位数线性增长，影响运算速度。</li>
</ul>
</li>
</ul>
<p>Ripple-Carry Adder 适用于简单、低速应用；但无法满足更高速的加法需求。</p>
</li>
</ol>
<img src="/img/DC/ripple.svg" srcset="/img/loading.gif" lazyload alt="4bit行波进位加法器" style="max-width: 100%; height: auto;" />  


<h4 id="2-4-4-Carry-Lookahead-Adder-CLA"><a href="#2-4-4-Carry-Lookahead-Adder-CLA" class="headerlink" title="2.4.4 Carry-Lookahead Adder (CLA)"></a>2.4.4 Carry-Lookahead Adder (CLA)</h4><p><strong>Carry-Lookahead Adder (CLA)</strong> ，即先行进位加法器，是一种改进的加法器，用于快速执行二进制加法，解决 Ripple-Carry Adder 中进位传播延迟的问题。</p>
<p>Carry-Lookahead Adder 通过并行计算进位信号，而不依赖逐级传播，从而显著提高速度。其核心思想是利用生成信号和传播信号：</p>
<ol>
<li><p><strong>生成信号 (Generate)</strong>  ：表示某一位的加法会直接产生一个进位：<br>$G_i &#x3D; A_i \cdot B_i$</p>
</li>
<li><p><strong>传播信号 (Propagate)</strong>  ：表示某一位的加法会将来自上一位的进位传递下去：<br>$P_i &#x3D; A_i + B_i$</p>
</li>
<li><p><strong>进位计算公式</strong>  ：根据生成和传播信号，计算每一位的进位：<br>$C_{i+1} &#x3D; G_i + P_i \cdot C_i$   其中，$C_0$ 是初始进位。</p>
</li>
</ol>
<p><strong>推导证明：</strong><br>根据前面全加器的结论，我们有：</p>
<ol>
<li><p><strong>初始公式</strong><br>$$C_{i + 1} &#x3D; A_{i} \cdot B_{i} + (A_{i} + B_{i}) \cdot C_{i}$$</p>
</li>
<li><p><strong>引入生成信号和传播信号</strong>(都是已知信号)<br>$$G_{i} &#x3D; A_{i} \cdot B_{i}$$<br>$$P_{i} &#x3D; A_{i} + B_{i}$$</p>
</li>
<li><p><strong>公式代换</strong><br>$$C_{i + 1} &#x3D; G_{i} + P_{i} \cdot C_{i} \quad \text{(用 $P_{i}$ 代换 $(A_{i} + B_{i})$)}$$</p>
</li>
</ol>
<p>那么我就可以用已知的输入 $A_{0}$  ~  $A_{n-1}$ 和 $B_{0}$  ~  $B_{n-1}$ 以及 $C_{0}$ 来确定进位是什么了。比如：</p>
<p>$$C_{1} &#x3D; G_{0} + P_{0} \cdot C_{0}$$</p>
<p>$$C_{2} &#x3D; G_{1} + P_{1} \cdot C_{1} &#x3D; G_{1} + P_{1} G_{0} + P_{1}P_{0}C_{0}$$<br>不断迭代我们可以得出 $C_{3}$ 和 $C_{4}$ ，甚至到 $C_{n-1}$ ，但是！考虑到电路的复杂程度和电路成本的情况下，我们可以稍微妥协一下，采用分块的策略，比如实现一个32bit的加法器，我们可以将四个全加器分成一个块使用上面推导出来的门电路封装成一个块打包好。然后我们就可以迅速确定当前块的进位，减少等待进位的时间。<em>在不考虑其他门延迟的情况下</em></p>
<ul>
<li>不分块的情况下：需要等32次进位的传递</li>
<li>4个为一块的情况下：只需要等$32&#x2F;4 &#x3D; 8$次进位传递</li>
</ul>
<img src="/img/DC/lookahead.jpeg" srcset="/img/loading.gif" lazyload alt="黑书: 32bit超前进位加法器" style="max-width: 100%; height: auto;" />  

<p><strong>优点</strong></p>
<ul>
<li><strong>减少延迟</strong>：进位计算是并行完成的，速度显著快于 Ripple-Carry Adder。</li>
<li><strong>高效的硬件实现</strong>：适合多位二进制数加法的高速场景。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>硬件复杂度增加</strong>：需要额外的逻辑电路来计算生成和传播信号，随着位数增加，复杂性迅速提高。</li>
<li><strong>功耗较高</strong>：更多逻辑门导致功耗增加。</li>
</ul>
<p>Carry-Lookahead Adder 是一种高效的加法器设计，常用于高速处理器中。相比 Ripple-Carry Adder，它通过并行化进位计算显著提高了运算速度，但也牺牲了一定的硬件简单性。</p>
<h4 id="2-4-5-Half-Subtractor"><a href="#2-4-5-Half-Subtractor" class="headerlink" title="2.4.5 Half Subtractor"></a>2.4.5 Half Subtractor</h4><p>半减法器（Half Subtractor）可以对两个单个位的二进制数进行减法运算。它有两个输入：被减数$A$和减数$B$，输出包括差值（Difference, $D$）和借位（Borrow, $B_{0}$）。</p>
<ul>
<li><p>差值 $D &#x3D; A \oplus B$</p>
</li>
<li><p>借位$B_{0} &#x3D; \overline{A}B$</p>
</li>
</ul>
<div style="text-align: center;">
<img src="/img/DC/half.svg" srcset="/img/loading.gif" lazyload alt="半减法器" style="max-width: 100%; height: auto;" />  
</div>


<h4 id="2-4-6-Full-Subtractor"><a href="#2-4-6-Full-Subtractor" class="headerlink" title="2.4.6 Full Subtractor"></a>2.4.6 Full Subtractor</h4><p>全减法器（Full Subtractor）可以对两个单个位的二进制数以及一个借位输入进行减法运算。它有三个输入：被减数$X$，减数$Y$，来自低位借位输入（Borrow_in, $B_{in}$），输出包括差值（Difference, $D$）和向高位的借位输出（Borrow_out, $B_{out}$）。</p>
<p>差值$D &#x3D; X ⊕ Y ⊕ B_{in}$</p>
<p>借位输出$<br>B_{out}&#x3D; \overline{X}B_{in} + \overline{X}Y + YB_{in}<br>$</p>
<blockquote>
<p>上述公式可以通过真值表和K-map得出，这里就省略了</p>
</blockquote>
<div style="text-align: center;">
<img src="/img/DC/sub2.svg" srcset="/img/loading.gif" lazyload alt="半减法器" style="max-width: 100%; height: auto;" />  
</div>

<p>Q：<em>如何用N-bit全加器实现全减器？</em></p>
<p>计算机中的加减运算都是通过补码进行的，根据补码运算有$A - B$ 实现的时候可以转化为$A + (-B)$, 我们又有 $\overline{B} + 1 &#x3D; -B$，所以$Y &#x3D; A - B &#x3D; A + \overline{B} + 1$</p>
<div style="text-align: center;">
<img src="/img/DC/sub3.svg" srcset="/img/loading.gif" lazyload alt="N-bit减法器" style="max-width: 100%; height: auto;" />  
</div>

<h4 id="2-4-7-Multiplexer"><a href="#2-4-7-Multiplexer" class="headerlink" title="2.4.7 Multiplexer"></a>2.4.7 Multiplexer</h4><p>复用器(Multiplexer)是一种数字电路元件，它的主要功能是将多个输入信号中的一个传递到输出端。复用器可以被视为一个多路选择开关，通过控制选择信号选择特定的输入线路。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><strong>输入信号</strong>：有 $2^n$ 个输入信号线，每条线路可传递一个信号。</li>
<li><strong>选择信号</strong>：通过 $n$ 条选择线决定选取哪一个输入信号。</li>
<li><strong>输出信号</strong>：仅有一个输出，输出选定的输入信号。</li>
</ul>
<p>复用器的输出可表示为：<br>$$<br>Y &#x3D; I_i \quad (i \text{由选择信号确定})<br>$$<br>其中 $I_i$ 是第 $i$ 个输入。下图是一个用门电路设计2:1 MUX并封装的过程</p>
<img src="/img/DC/mux.svg" srcset="/img/loading.gif" lazyload alt="2:1 MUX" style="max-width: 100%; height: auto;" />  

<p><strong>基本结构：</strong></p>
<ul>
<li><strong>数据输入端（Data Inputs）</strong>：多路信号的输入端口。</li>
<li><strong>选择端（Select Lines）</strong>：控制信号，决定选用哪个输入。</li>
<li><strong>输出端（Output Line）</strong>：传递选定信号的端口。</li>
</ul>
<p>例如：<br>对于一个 <strong>4路复用器（4-to-1 MUX）</strong>：</p>
<ul>
<li>有 4 个输入线：$I_0, I_1, I_2, I_3$。</li>
<li>有 2 个选择线：$S_1, S_0$。</li>
<li>有 1 个输出线：$Y$。</li>
</ul>
<p>输出由选择信号 $S_1$ 和 $S_0$ 确定：</p>
<p>$$<br>Y &#x3D;<br>\begin{cases}<br>I_0, &amp; \text{if } S_1S_0 &#x3D; 00 \\<br>I_1, &amp; \text{if } S_1S_0 &#x3D; 01 \\<br>I_2, &amp; \text{if } S_1S_0 &#x3D; 10 \\<br>I_3, &amp; \text{if } S_1S_0 &#x3D; 11<br>\end{cases}<br>$$</p>
<p>通过增加选择信号线数，复用器可以扩展为更大的多路选择器（如 8-to-1、16-to-1）。</p>
<img src="/img/DC/mux2.svg" srcset="/img/loading.gif" lazyload alt="MUX" style="max-width: 100%; height: auto;" />  

<h4 id="2-4-8-Decoder"><a href="#2-4-8-Decoder" class="headerlink" title="2.4.8 Decoder"></a>2.4.8 Decoder</h4><p>译码器是一种<strong>组合逻辑电路</strong>，其主要功能是将输入的<strong>二进制代码</strong>转换为<strong>独热码（one-hot code）</strong>，即在输出中只有一条线路为高电平，其余为低电平。</p>
<div class="note note-success">
            <p>独热码工作原理:如果有 $n$ 个类别，则需要一个长度为 $n$ 的二进制向量。对应某个类别的位置为1，其余位置为0。例如，对于3个类别：A, B, C：</p><ul><li>类别 A 编码为：$[1, 0, 0]$</li><li>类别 B 编码为：$[0, 1, 0]$</li><li>类别 C 编码为：$[0, 0, 1]$</li></ul>
          </div>

<p><strong>译码器工作原理</strong></p>
<ul>
<li><strong>输入信号</strong>：有 $n$ 条输入信号线，用于表示二进制编码。</li>
<li><strong>输出信号</strong>：有 $2^n$ 条输出信号线，每个输出对应一种输入组合。</li>
<li><strong>控制信号（可选）</strong>：部分译码器可能需要使能信号（Enable），用于控制译码器的工作状态。</li>
</ul>
<p>译码器根据输入信号的值，激活唯一对应的输出线。例如：</p>
<ul>
<li>输入：$00, 01, 10, 11$</li>
<li>输出：$Y_0, Y_1, Y_2, Y_3$ 依次被激活。</li>
</ul>
<p><strong>译码器基本结构</strong></p>
<p>对于一个 $n$ 位输入的译码器：</p>
<ul>
<li>有 $2^n$ 个输出信号线。</li>
<li>每个输出信号线对应一个输入组合。</li>
</ul>
<p>例如，一个 <strong>2-to-4 译码器</strong>（2位输入，4个输出）：</p>
<ul>
<li>输入：$A_1, A_0$。</li>
<li>输出：$Y_0, Y_1, Y_2, Y_3$。</li>
<li>输出逻辑：<br>$$<br>Y_0 &#x3D; \overline{A_1} \cdot \overline{A_0}, \quad<br>Y_1 &#x3D; \overline{A_1} \cdot A_0, \quad<br>Y_2 &#x3D; A_1 \cdot \overline{A_0}, \quad<br>Y_3 &#x3D; A_1 \cdot A_0<br>$$</li>
</ul>
<p>译码器是数字电路中重要的基础模块，用于信号的<strong>解码与路由</strong>。</p>
<img src="/img/DC/decoder.svg" srcset="/img/loading.gif" lazyload alt="译码器" style="max-width: 100%; height: auto;" />  

<h3 id="2-5-传播延迟和最小延迟"><a href="#2-5-传播延迟和最小延迟" class="headerlink" title="2.5 传播延迟和最小延迟"></a>2.5 传播延迟和最小延迟</h3><p><strong>传播延迟（Propagation Delay, $t_{pd}$）</strong></p>
<ul>
<li>定义：信号从输入端变化到输出端<strong>完全稳定</strong>所需的时间。对于组合电路来说就是关键路径上面每一个元件的传播延迟之和</li>
<li>影响因素：<ul>
<li>器件特性：如晶体管的开关速度、驱动能力。</li>
<li>负载电容：较大的负载电容会增加传播延迟。</li>
<li>电路拓扑：更复杂的路径结构会增加延迟。</li>
</ul>
</li>
<li>意义：传播延迟决定了电路的速度性能，即最大运行频率。</li>
</ul>
<p><strong>最小延迟（Contamination Delay, $t_{cd}$）</strong></p>
<ul>
<li>定义：信号在电路中传输所需的<strong>最短时间</strong>，反映信号可能在某些路径上过快到达输出端的时间。对于组合电路来说是最短路径上面每个元件的最小延迟之和。</li>
<li>影响因素：<ul>
<li>布线长度和材料特性。</li>
<li>逻辑门数量与优化设计。</li>
</ul>
</li>
<li>意义：<ul>
<li>保持时间（Hold Time）违规：最小延迟可能导致竞争冒险或保持时间问题。</li>
<li>必须确保最小延迟不会破坏电路的时序完整性。</li>
</ul>
</li>
</ul>
<img src="/img/DC/pd.svg" srcset="/img/loading.gif" lazyload alt="传播延迟和最小延迟" style="max-width: 100%; height: auto;" />  

<div class="note note-success">
            <p>Note: 每个门的传播延迟和最小延迟要看参数表,而且传播延迟和最小延迟这个问题非常艰深…</p>
          </div>

<h3 id="2-6-Glitch"><a href="#2-6-Glitch" class="headerlink" title="2.6 Glitch"></a>2.6 Glitch</h3><p><strong>毛刺（Glitch）</strong> 是数字电路中由于信号传播延迟或竞争冒险导致的短暂错误信号脉冲，通常表现为在信号稳定之前出现的意外高电平或低电平跳变。</p>
<p><strong>产生原因：</strong></p>
<ul>
<li>竞争冒险（Hazards）：当多条信号路径的传播延迟不一致时，可能导致某一时刻输出信号短暂错误。</li>
<li>门延迟： 逻辑门的延迟导致信号在不同路径上到达输出端的时间不同。</li>
<li>不完全同步：异步信号未正确对齐，导致输出出现瞬时错误信号。</li>
</ul>
<img src="/img/DC/glitch.svg" srcset="/img/loading.gif" lazyload alt="毛刺时序图" style="max-width: 100%; height: auto;" />  

<p>为了消除毛刺，可以通过添加冗余项优化逻辑表达式，确保信号在所有可能的变化路径中保持稳定。</p>
<p><strong>步骤：</strong></p>
<ul>
<li>构造卡诺图：根据真值表将逻辑表达式填入卡诺图。</li>
<li>标记相邻格子：将输出为“1”的相邻单元块分组，覆盖现有的逻辑区域。<br>检查是否有相邻的“1”之间存在空隙（可能导致冒险）。</li>
<li>添加冗余项：对于无法完全覆盖的相邻“1”之间的空隙，添加额外的逻辑项来补充。<br>确保每一个相邻的“1”都连通，避免由于输入信号变化导致逻辑的不连续。</li>
<li>生成优化后的逻辑表达式：将包含冗余项的逻辑表达式写出并实现。</li>
</ul>
<p>通过使用卡诺图消除毛刺的关键是：</p>
<ol>
<li>识别相邻逻辑之间的不连续性。</li>
<li>添加冗余项确保逻辑表达式的稳定性。</li>
<li>优化后可减少信号跳变，避免毛刺的产生。</li>
</ol>
<img src="/img/DC/glitch2.svg" srcset="/img/loading.gif" lazyload alt="毛刺消除" style="max-width: 100%; height: auto;" />  

<h2 id="3-Sequential-Logic-Circuit"><a href="#3-Sequential-Logic-Circuit" class="headerlink" title="3. Sequential Logic Circuit"></a>3. Sequential Logic Circuit</h2><p><strong>时序逻辑电路（Sequential Logic Circuit）</strong> 是一类输出<u>不仅取决于当前输入，还与电路的历史状态相关的电路。</u>它通过存储元件（如触发器、锁存器等）记录状态，具有<em>记忆功能</em>。</p>
<p><strong>时序逻辑电路特点:</strong></p>
<ul>
<li>记忆功能：与组合逻辑电路不同，时序逻辑电路可以存储数据。</li>
<li>状态变化：状态的变化通常由时钟信号控制，随着时钟信号的边沿（上升沿或下降沿）进行更新。</li>
<li>输出依赖性：输出依赖于当前输入和之前的状态。</li>
</ul>
<h3 id="3-1-Latch"><a href="#3-1-Latch" class="headerlink" title="3.1 Latch"></a>3.1 Latch</h3><p><strong>锁存器（Latch）</strong>是一种<strong>基本的存储元件</strong>，用于存储一个<strong>单个位的二进制信息</strong>。它的输出状态会随输入信号的变化而更新，具体取决于使能信号（通常称为<strong>控制信号</strong>或<strong>使能信号</strong>）。</p>
<p>工作方式为<strong>电平触发</strong>：  锁存器根据控制信号的电平（高电平或低电平）决定是否更新输出。  </p>
<ul>
<li>当使能信号为有效电平时，输出跟随输入变化。</li>
<li>当使能信号为无效电平时，锁存器保持当前状态（记忆功能）。</li>
</ul>
<p><strong>1. 锁存器类型：</strong></p>
<ul>
<li><p><strong>SR锁存器（Set-Reset Latch）</strong>：</p>
<ul>
<li>基于两个交叉耦合的与非门（NAND）或或非门（NOR）构成。</li>
<li>通过 $S$（置位）和 $R$（复位）信号控制状态。</li>
<li>存在不允许 $S &#x3D; R &#x3D; 1$ 的<strong>无效状态</strong>（对于NOR实现）。</li>
</ul>
</li>
<li><p><strong>D锁存器（Data Latch）</strong>：</p>
<ul>
<li>又称为<strong>数据锁存器</strong>。</li>
<li>有效控制信号时，输出 $Q$ 跟随输入 $D$；无效时，输出保持不变。</li>
</ul>
</li>
<li><p><strong>JK锁存器</strong>：</p>
<ul>
<li>改进了SR锁存器的无效状态问题，能够实现翻转（Toggle）功能。</li>
</ul>
</li>
</ul>
<p><strong>2. 锁存器特点：</strong></p>
<ul>
<li><strong>电平敏感</strong>：锁存器会在控制信号有效的整个时间内更新状态，而不是像触发器那样在时钟边沿更新。</li>
<li><strong>记忆功能</strong>：能够存储当前状态，直到输入或控制信号改变。</li>
</ul>
<p><strong>3. 锁存器应用</strong></p>
<ul>
<li><strong>数据暂存</strong>：存储单个位的信息。</li>
<li><strong>寄存器的构成</strong>：多个锁存器组合可以组成寄存器，用于数据存储和处理。</li>
<li><strong>时序电路</strong>：如简单的状态存储元件。</li>
</ul>
<p>锁存器是电平触发的基本存储元件，可以根据输入和使能信号存储信息或保持状态。其在数字电路中的作用类似“开关”，用以暂存和传递数据。</p>
<h4 id="3-1-1-SR锁存器（Set-Reset-Latch）"><a href="#3-1-1-SR锁存器（Set-Reset-Latch）" class="headerlink" title="3.1.1 SR锁存器（Set-Reset Latch）"></a>3.1.1 SR锁存器（Set-Reset Latch）</h4><p>SR锁存器是一种<strong>基本的锁存器类型</strong>，用于通过置位信号（Set）和复位信号（Reset）控制输出状态。它是由两个交叉耦合的逻辑门（通常是 NAND 或 NOR 门）构成的。</p>
<p><strong>SR Latch工作方式：</strong></p>
<ul>
<li><strong>输入信号</strong>：  <ul>
<li>$S$（Set）：置位信号，用于将输出 $Q$ 设置为高电平（1）。</li>
<li>$R$（Reset）：复位信号，用于将输出 $Q$ 设置为低电平（0）。</li>
</ul>
</li>
<li><strong>输出信号</strong>：<ul>
<li>$Q$：当前状态输出。</li>
<li>$\overline{Q}$：$Q$ 的反相输出，满足 $Q \cdot \overline{Q} &#x3D; 0$。</li>
</ul>
</li>
</ul>
<p>SR 锁存器的状态随 $S$ 和 $R$ 的变化而更新，具体规则如下：</p>
<table>
<thead>
<tr>
<th>$S$</th>
<th>$R$</th>
<th>$Q$</th>
<th>$\overline{Q}$</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>保持</td>
<td>保持</td>
<td>保持当前状态</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>复位（Reset）</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>置位（Set）</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>无效</td>
<td>无效</td>
<td>无效状态（禁止）</td>
</tr>
</tbody></table>
<p><strong>SR Latch特点：</strong></p>
<ul>
<li><strong>电平敏感</strong>：<br>SR锁存器根据 $S$ 和 $R$ 的电平信号控制输出状态。</li>
<li><strong>无效状态</strong>：<br>当 $S &#x3D; 1$ 且 $R &#x3D; 1$ 时，$Q$ 和 $\overline{Q}$ 都为 0，这种状态被定义为无效状态，通常在设计中需要避免。</li>
</ul>
<p><strong>SR Latch实现：</strong> SR锁存器可以通过以下两种逻辑门实现：</p>
<ul>
<li><strong>NOR门实现：</strong>：<ul>
<li>当 $S &#x3D; 1$ 时，置位 $Q &#x3D; 1$；当 $R &#x3D; 1$ 时，复位 $Q &#x3D; 0$。</li>
</ul>
</li>
<li><strong>NAND门实现：</strong>：<ul>
<li>信号逻辑与 NOR 门相反，通常 $S$ 和 $R$ 信号需要取反。</li>
</ul>
</li>
</ul>
<p><strong>SR Latch应用：</strong></p>
<ul>
<li><strong>状态存储</strong>：  记录电路中的状态信号。</li>
<li><strong>控制电路</strong>：  用于实现简单的时序控制功能。</li>
<li><strong>锁存电路</strong>：  用作更复杂存储元件（如触发器）的基础单元。</li>
</ul>
<p>SR锁存器是最基本的锁存器，通过置位和复位信号控制输出状态，但需要避免无效状态。它在简单存储和状态保持电路中有广泛应用。</p>
<img src="/img/DC/sr.svg" srcset="/img/loading.gif" lazyload alt="NOR门SR锁存器" style="max-width: 100%; height: auto;" />  

<p>还有一种是由NAND门构成的SR锁存器，注意真值表和由NOR门构成的SR锁存器的区别</p>
<table>
<thead>
<tr>
<th>$S$</th>
<th>$R$</th>
<th>$Q$</th>
<th>$\overline{Q}$</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td><strong>无效状态</strong>（禁止）</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>复位（Reset）</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>置位（Set）</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>保持</td>
<td>保持</td>
<td>保持当前状态</td>
</tr>
</tbody></table>
<img src="/img/DC/sr2.svg" srcset="/img/loading.gif" lazyload alt="NAND门SR锁存器" style="max-width: 100%; height: auto;" />  

<h4 id="3-1-2-D锁存器（Data-Latch）"><a href="#3-1-2-D锁存器（Data-Latch）" class="headerlink" title="3.1.2 D锁存器（Data Latch）"></a>3.1.2 D锁存器（Data Latch）</h4><p>D锁存器是一种基本的时序逻辑电路，用于存储1位二进制数据。它根据时钟信号的状态决定是否允许数据输入被存储。</p>
<ol>
<li><p><strong>输入和输出：</strong></p>
<ul>
<li><strong>D（Data）输入</strong>：需要存储的数据。</li>
<li><strong>使能信号（Enable&#x2F;Clock，通常用<code>E</code>或<code>EN</code>表示）</strong>：控制数据存储的信号。</li>
<li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li>
</ul>
</li>
<li><p><strong>工作原理：</strong></p>
<ul>
<li>当 <strong>使能信号为高</strong>（<code>E = 1</code>）：锁存器“打开”，D输入的值直接通过电路输出到 Q。</li>
<li>当 <strong>使能信号为低</strong>（<code>E = 0</code>）：锁存器“锁住”，Q 保持之前存储的值，不受 D 输入变化的影响。</li>
</ul>
</li>
<li><p><strong>特性：</strong></p>
<ul>
<li>数据在 <strong>使能信号有效期间</strong> 会被更新。</li>
<li>D锁存器消除了竞争（Race）条件，因为它只有一个数据输入（D），避免了像 SR 锁存器中的非法状态（S&#x3D;R&#x3D;1）。</li>
</ul>
</li>
<li><p><strong>应用：</strong></p>
</li>
</ol>
<ul>
<li><strong>数据存储单元</strong>：用作基本的位存储器。</li>
<li><strong>数据保持电路</strong>：维持信号的稳定性。</li>
<li><strong>边沿触发寄存器</strong>（如 D 触发器）的基本构造单元。</li>
</ul>
<table>
<thead>
<tr>
<th>Enable (E)</th>
<th>Data (D)</th>
<th>Output (Q)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>X (任意)</td>
<td>保持原值</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>D锁存器逻辑门组成：</p>
<ul>
<li>两个<strong>与非门（NAND）或与门（AND）</strong>用来生成控制信号。</li>
<li>两个交叉耦合的 NAND 门（或 NOR 门）构成一个基本的锁存器（SR 锁存器）。</li>
</ul>
<img src="/img/DC/dlatch.svg" srcset="/img/loading.gif" lazyload alt="D锁存器" style="max-width: 100%; height: auto;" />  


<h4 id="3-1-3-JK锁存器（JK-Latch）"><a href="#3-1-3-JK锁存器（JK-Latch）" class="headerlink" title="3.1.3 JK锁存器（JK Latch）"></a>3.1.3 JK锁存器（JK Latch）</h4><p>JK锁存器是一种增强型的时序逻辑电路，是对 SR 锁存器的改进，避免了 SR 锁存器中 <code>S=1</code> 和 <code>R=1</code> 时的非法状态问题。它被广泛用于时序电路中，能够实现多种功能，如保持、置位、复位和翻转。</p>
<ol>
<li><p><strong>输入和输出：</strong></p>
<ul>
<li><strong>J（Set）</strong>：对应置位功能。</li>
<li><strong>K（Reset）</strong>：对应复位功能。</li>
<li><strong>使能信号（Enable 或 Clock）</strong>：控制锁存器工作状态。</li>
<li><strong>Q（输出）和 Q̅（反输出）</strong>：锁存器的输出和反输出。</li>
</ul>
</li>
<li><p><strong>功能定义：</strong></p>
<ul>
<li><strong>J&#x3D;0, K&#x3D;0</strong>：保持状态（Q 保持不变）。</li>
<li><strong>J&#x3D;0, K&#x3D;1</strong>：复位（Q&#x3D;0）。</li>
<li><strong>J&#x3D;1, K&#x3D;0</strong>：置位（Q&#x3D;1）。</li>
<li><strong>J&#x3D;1, K&#x3D;1</strong>：翻转状态（Q 从 0 变为 1，或从 1 变为 0）。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>Enable (E)</th>
<th>J</th>
<th>K</th>
<th>Q (Next State)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>X</td>
<td>X</td>
<td>保持原值</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>保持原值</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Q̅（翻转）</td>
</tr>
</tbody></table>
<ol start="3">
<li><strong>JK锁存器应用:</strong></li>
</ol>
<ul>
<li><strong>寄存器设计</strong>：作为存储单元使用。</li>
<li><strong>计数器</strong>：通过翻转功能实现二进制计数器。</li>
<li><strong>时序电路</strong>：作为基本的控制逻辑单元。</li>
</ul>
<img src="/img/DC/jklatch.svg" srcset="/img/loading.gif" lazyload alt="JK锁存器" style="max-width: 100%; height: auto;" />  

<h3 id="3-2-Flip-FLop"><a href="#3-2-Flip-FLop" class="headerlink" title="3.2 Flip-FLop"></a>3.2 Flip-FLop</h3><p>触发器是数字电路中的一种基本<strong>时序逻辑电路</strong>，用于存储一个二进制位的信息。它具有<strong>存储能力</strong>和<strong>同步性</strong>，是寄存器、计数器等时序电路的基础组件。</p>
<p><strong>触发器的特点：</strong></p>
<ol>
<li><strong>存储能力</strong>：可以存储1位二进制数据（0或1）。</li>
<li><strong>同步性</strong>：大多数触发器通过<strong>时钟信号（Clock）</strong>控制状态的改变。</li>
<li><strong>状态保持</strong>：在没有输入信号变化时，触发器会保持当前状态。</li>
</ol>
<p><strong>常见触发器类型：</strong></p>
<p><strong>SR触发器：</strong></p>
<ul>
<li>基本类型，具有两个输入：<strong>Set（置1）</strong> 和 <strong>Reset（清0）</strong>。</li>
<li>特点：<ul>
<li>S&#x3D;1, R&#x3D;0：输出为1。</li>
<li>S&#x3D;0, R&#x3D;1：输出为0。</li>
<li>S&#x3D;0, R&#x3D;0：保持状态。</li>
<li><strong>S&#x3D;1, R&#x3D;1</strong>：不稳定状态（无效）。</li>
</ul>
</li>
</ul>
<p><strong>D触发器（数据触发器）：</strong></p>
<ul>
<li>具有一个数据输入端（D）和一个时钟输入端（CLK）。</li>
<li>特点：<ul>
<li>在时钟信号的有效边沿（上升沿或下降沿）到来时，将输入D的值传递到输出Q。</li>
</ul>
</li>
<li>应用：<ul>
<li>常用于数据同步和寄存器设计。</li>
</ul>
</li>
</ul>
<p><strong>JK触发器：</strong></p>
<ul>
<li>是RS触发器的改进型，消除了<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态。</li>
<li>输入为J和K：<ul>
<li>J&#x3D;1, K&#x3D;0：置1。</li>
<li>J&#x3D;0, K&#x3D;1：清0。</li>
<li>J&#x3D;K&#x3D;1：状态翻转。</li>
</ul>
</li>
<li>应用：<ul>
<li>广泛用于计数器和状态机设计。</li>
</ul>
</li>
</ul>
<p><strong>T触发器（触发翻转器）：</strong></p>
<ul>
<li>只有一个输入（T）。</li>
<li>特点：<ul>
<li>T&#x3D;1：状态翻转。</li>
<li>T&#x3D;0：状态保持。</li>
</ul>
</li>
<li>应用：<ul>
<li>常用于计数器电路。</li>
</ul>
</li>
</ul>
<p>触发器是数字电路中<strong>存储单元的核心</strong>，用来实现数据存储和同步控制。不同类型的触发器适用于不同的功能需求：</p>
<ul>
<li>SR触发器用于简单存储；</li>
<li>D触发器用于数据锁存；</li>
<li>JK触发器适合复杂逻辑控制；</li>
<li>T触发器常用于计数和分频。</li>
</ul>
<h4 id="3-2-1-SR-Flip-Flop"><a href="#3-2-1-SR-Flip-Flop" class="headerlink" title="3.2.1 SR Flip-Flop"></a>3.2.1 SR Flip-Flop</h4><p><strong>SR触发器</strong>是一种基本的双稳态存储单元，用于存储1位二进制信息。SR触发器由 <strong>Set（S）</strong> 和 <strong>Reset（R）</strong> 两个输入控制输出状态，常用于简单的存储和逻辑控制。</p>
<p><strong>工作原理</strong></p>
<ul>
<li><strong>S（Set）</strong>：设置触发器的输出为1（Q&#x3D;1）。</li>
<li><strong>R（Reset）</strong>：重置触发器的输出为0（Q&#x3D;0）。</li>
<li>$Q$ 和 $\overline{Q}$：为触发器的输出和其反向输出。</li>
</ul>
<p><strong>逻辑功能表</strong></p>
<table>
<thead>
<tr>
<th>S</th>
<th>R</th>
<th>Q（输出）</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>保持</td>
<td>保持上次状态</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>清零</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>置1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>无效</td>
<td>不允许状态</td>
</tr>
</tbody></table>
<p> <strong>状态说明</strong></p>
<ol>
<li><strong>S&#x3D;0, R&#x3D;0</strong>：触发器保持当前状态，不发生变化。</li>
<li><strong>S&#x3D;1, R&#x3D;0</strong>：输出Q被置为1（Set）。</li>
<li><strong>S&#x3D;0, R&#x3D;1</strong>：输出Q被重置为0（Reset）。</li>
<li><strong>S&#x3D;1, R&#x3D;1</strong>：为无效状态，因Q和Q’会同时为1，违背Q和Q’互补的逻辑。</li>
</ol>
<p> <strong>应用场景</strong></p>
<ul>
<li><strong>存储单元</strong>：用于存储1位数据。</li>
<li><strong>逻辑控制</strong>：作为简单的状态保持和切换电路。</li>
<li><strong>锁存器</strong>：用于构成其他类型的触发器（如D触发器和JK触发器）。</li>
</ul>
<p>SR触发器是最基本的触发器类型，但存在<strong>S&#x3D;1, R&#x3D;1</strong>的不允许状态，限制了它在复杂电路中的使用。改进型触发器（如JK触发器）解决了这一问题。</p>
<p>SR触发器状态转移公式：<br>$$<br>\begin{cases}<br>Q_{n+1}  &#x3D; S + \overline{R}Q_{n} \\<br>S \cdot R &#x3D; 0  (约束条件)<br>\end{cases}<br>$$</p>
<img src="/img/DC/srff.svg" srcset="/img/loading.gif" lazyload alt="SR触发器" style="max-width: 100%; height: auto;" />  

<h4 id="3-2-2-D-Flip-Flop"><a href="#3-2-2-D-Flip-Flop" class="headerlink" title="3.2.2 D Flip-Flop"></a>3.2.2 D Flip-Flop</h4><p><strong>D触发器</strong>（Data Flip-Flop, DFF）是数字电路中一种基本的时序逻辑电路，用于存储1位二进制数据。它通过 <strong>数据输入端（D）</strong> 和 <strong>时钟信号（CLK）</strong> 实现同步数据存储。D触发器也经常称为主从触发器（master-slave flip-flop），边沿触发器（edge-triggered flip-flop）或者正边沿触发器（positive edge-triggered flip-flop）。</p>
<p> <strong>工作原理:</strong></p>
<ul>
<li><strong>D输入</strong>：决定触发器的输出值。</li>
<li><strong>CLK输入</strong>：控制触发器的状态更新，确保输出只有在特定时钟条件下（如上升沿或下降沿）才更新。</li>
<li>当时钟信号有效时，<strong>D的值会传递到输出Q</strong>，同时Q’为Q的反相。</li>
</ul>
<p> <strong>逻辑功能表:</strong></p>
<table>
<thead>
<tr>
<th>CLK（时钟）</th>
<th>D（数据）</th>
<th>Q（输出）</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>上升沿</td>
<td>0</td>
<td>0</td>
<td>输出清零</td>
</tr>
<tr>
<td>上升沿</td>
<td>1</td>
<td>1</td>
<td>输出置1</td>
</tr>
<tr>
<td>其他</td>
<td>-</td>
<td>保持</td>
<td>状态不变</td>
</tr>
</tbody></table>
<p> <strong>DFF特点:</strong></p>
<ol>
<li><strong>同步性</strong>：依赖时钟信号控制，输出只在时钟有效时更新。</li>
<li><strong>无争议状态</strong>：相比SR触发器，D触发器没有无效状态。</li>
<li><strong>锁存功能</strong>：在时钟无效时，输出保持上一次的状态。</li>
</ol>
<p> <strong>DFF应用场景:</strong></p>
<ol>
<li><strong>寄存器</strong>：用于存储和传输数据。</li>
<li><strong>移位寄存器</strong>：通过多级D触发器实现数据位移。</li>
<li><strong>计数器</strong>：作为计数器电路的基础单元。</li>
<li><strong>同步电路</strong>：用于数据同步或信号稳定。</li>
</ol>
<p>D触发器是一种<strong>简单高效的存储单元</strong>，它通过时钟信号的控制实现数据的同步存储，广泛应用于各种数字电路中。一个D触发器可以由反相时钟控制的2个背靠背的D锁存器构成。</p>
<img src="/img/DC/dff.svg" srcset="/img/loading.gif" lazyload alt="D触发器" style="max-width: 100%; height: auto;" />  

<p><em>对于上升沿触发的DFF的时序图：</em></p>
<div style="text-align: center;">
<img src="/img/DC/dff2.svg" srcset="/img/loading.gif" lazyload alt="DFF" style="max-width: 100%; height: auto;" />  
</div>

<div class="note note-success">
            <p>至于为什么是上升沿触发，可以画一下主锁存器的值和从锁存器的值的时序图，此处省略</p>
          </div>

<p><em>当然还有下降沿触发的DFF的时序图：</em></p>
<img src="/img/DC/dff3.svg" srcset="/img/loading.gif" lazyload alt="下降沿DFF" style="max-width: 100%; height: auto;" />  

<p>D触发器状态转移公式：<br>$$Q_{n+1} &#x3D; D$$</p>
<h4 id="3-2-3-JK-Flip-Flop"><a href="#3-2-3-JK-Flip-Flop" class="headerlink" title="3.2.3 JK Flip-Flop"></a>3.2.3 JK Flip-Flop</h4><p><strong>JK触发器</strong>是一种改进型的双稳态触发器，是对<strong>SR触发器</strong>的增强，解决了SR触发器中<strong>S&#x3D;1, R&#x3D;1</strong>的无效状态问题。它通过输入信号J和K以及时钟信号CLK实现状态控制，具有更强的功能和更广的应用。</p>
<p> <strong>JKFF工作原理：</strong></p>
<ul>
<li><strong>J（Set）</strong>：与SR触发器的S功能类似，用于设置输出Q&#x3D;1。</li>
<li><strong>K（Reset）</strong>：与SR触发器的R功能类似，用于清零输出Q&#x3D;0。</li>
<li><strong>CLK（时钟信号）</strong>：用于同步控制，触发器的状态仅在时钟信号的有效边沿发生变化。</li>
</ul>
<p><strong>JKFF逻辑功能表：</strong></p>
<table>
<thead>
<tr>
<th>J</th>
<th>K</th>
<th>$Q_{n}$（输出）</th>
<th>$Q_{n+1}$（下一状态）</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>Q</td>
<td>保持</td>
<td>状态保持</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>清零</td>
<td>Reset</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>置1</td>
<td>Set</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Q’（反相）</td>
<td>翻转</td>
<td>Toggle（翻转）</td>
</tr>
</tbody></table>
<p> <strong>JKFF特点：</strong></p>
<ol>
<li><strong>无无效状态</strong>：J&#x3D;1, K&#x3D;1 时，触发器的输出状态翻转，解决了SR触发器的争议状态问题。</li>
<li><strong>同步性</strong>：在时钟信号控制下工作，确保状态变化的同步。</li>
<li><strong>功能多样</strong>：可以通过J和K的输入实现保持、置1、清零、翻转等功能。</li>
</ol>
<p> <strong>JKFF结构组成：</strong></p>
<ul>
<li>由SR触发器扩展而来，增加了逻辑门以控制输入S和R，确保J&#x3D;1, K&#x3D;1 时实现输出翻转。</li>
<li>常采用 <strong>边沿触发（Edge-triggered）</strong> 的设计，使其适用于复杂的时序电路。</li>
</ul>
<p> <strong>JKFF应用场景：</strong></p>
<ol>
<li><strong>计数器</strong>：JK触发器在计数器电路中广泛应用，用于实现递增或递减计数。</li>
<li><strong>状态机</strong>：设计复杂的同步时序电路。</li>
<li><strong>分频器</strong>：利用J&#x3D;1, K&#x3D;1的翻转特性实现时钟信号分频。</li>
</ol>
<p>JK触发器的实现可以通过主从结构，由两个SR触发器级联完成。</p>
<img src="/img/DC/jkff.svg" srcset="/img/loading.gif" lazyload alt="JKFF" style="max-width: 100%; height: auto;" />  

<p>下面是<em>下降沿触发</em>的JKFF的时序图:</p>
<img src="/img/DC/jkff2.svg" srcset="/img/loading.gif" lazyload alt="JKFF时序图" style="max-width: 100%; height: auto;" />  

<p>我们可以得出JKFF的状态转移公式：</p>
<p>$$Q_{n+1} &#x3D; J\overline{Q_{n}} + \overline{k}Q_{n}$$</p>
<div class="note note-success">
            <p>JKFF时序图口诀：00不变，11翻转，10置1，01置0</p>
          </div>

<h4 id="3-2-4-T-Flip-Flop"><a href="#3-2-4-T-Flip-Flop" class="headerlink" title="3.2.4 T Flip-Flop"></a>3.2.4 T Flip-Flop</h4><p><strong>T触发器</strong>（Toggle Flip-Flop）是一种基本的时序逻辑电路，用于实现<strong>状态翻转</strong>或<strong>分频功能</strong>。</p>
<p><strong>TFF工作原理：</strong></p>
<ul>
<li><strong>T输入（Toggle）</strong>：用于控制触发器的翻转功能。<ul>
<li>T&#x3D;0：保持当前状态</li>
<li>T&#x3D;1：状态翻转</li>
</ul>
</li>
<li><strong>CLK（时钟信号）</strong>：控制T触发器的状态更新，输出仅在时钟信号的有效边沿发生变化。</li>
</ul>
<p><strong>TFF逻辑功能表：</strong></p>
<table>
<thead>
<tr>
<th>CLK（时钟）</th>
<th>T（输入）</th>
<th>$Q_{n}$（输出）</th>
<th>$Q_{n+1}$（下一状态）</th>
<th>状态描述</th>
</tr>
</thead>
<tbody><tr>
<td>上升沿</td>
<td>0</td>
<td>Q</td>
<td>保持</td>
<td>状态保持</td>
</tr>
<tr>
<td>上升沿</td>
<td>1</td>
<td>Q’</td>
<td>翻转</td>
<td>Toggle（翻转）</td>
</tr>
<tr>
<td>其他</td>
<td>-</td>
<td>保持</td>
<td>保持</td>
<td>状态不变</td>
</tr>
</tbody></table>
<p><strong>TFF特点：</strong></p>
<ol>
<li><strong>状态翻转</strong>：当T&#x3D;1时，输出状态在每个时钟边沿发生翻转。</li>
<li><strong>分频功能</strong>：每次翻转需要一个时钟信号，因此输出频率为输入时钟频率的一半。</li>
<li><strong>简化结构</strong>：通过将JK触发器的J和K输入连接为同一信号T，简化了设计。</li>
</ol>
<p><strong>TFF实现方式：</strong></p>
<ol>
<li><strong>由JK触发器实现</strong>：将J&#x3D;K&#x3D;T，形成T触发器的逻辑。</li>
<li><strong>直接实现</strong>：通过逻辑门电路设计，实现T输入控制翻转功能。</li>
</ol>
<p><strong>TFF应用场景：</strong></p>
<ol>
<li><strong>计数器</strong>：用于实现二进制计数器的单个计数位。</li>
<li><strong>分频器</strong>：将时钟信号的频率降低一半，用于时钟分频。</li>
<li><strong>状态机</strong>：在简单状态转换电路中用作基本单元。</li>
</ol>
<p>TFF的一种实现如下图：<br><img src="/img/DC/tff.svg" srcset="/img/loading.gif" lazyload alt="TFF" style="max-width: 100%; height: auto;" />  </p>
<p>TFF的时序图如下：<br><img src="/img/DC/tff2.svg" srcset="/img/loading.gif" lazyload alt="TFF Time Diagram" style="max-width: 100%; height: auto;" />  </p>
<p>我们可以得出TFF的状态转移方程式为：</p>
<p>$$Q_{n+1} &#x3D; T \oplus Q_{n}$$</p>
<h3 id="3-3-Synchronous-Sequential-Logic"><a href="#3-3-Synchronous-Sequential-Logic" class="headerlink" title="3.3 Synchronous Sequential Logic"></a>3.3 Synchronous Sequential Logic</h3><p>Synchronous Sequential Logic（同步时序逻辑）是一类数字逻辑电路，其输出不仅取决于当前的输入，还取决于电路的状态（通常存储在触发器中）。这种电路的状态变化由一个<u>全局时钟信号</u>同步控制。</p>
<p>同步时序电路可以设计为两种类型：</p>
<ul>
<li>Mealy电路：输出依赖于当前状态和输入（对应有限自动机中的 Mealy 机）。</li>
<li>Moore电路：输出<strong>仅依赖于</strong>当前状态（对应有限自动机中的 Moore 机）。</li>
</ul>
<div class="note note-success">
            <p>记忆：摩尔庄园–&gt;摩尔当前–&gt;摩尔电路只依赖于当前状态</p>
          </div>

<img src="/img/DC/fsm.svg" srcset="/img/loading.gif" lazyload alt="FSM" style="max-width: 100%; height: auto;" />  

<p>根据上图可以再深入理解一下两种有限状态机（Finite State Machine, FSM），举个例子，判断输出1是如何得到的：</p>
<ul>
<li>Mealy型需要同时给出 <strong>当前状态</strong> 和 <strong>输入</strong> 才能确认，因为在状态B且输入1的情况下才会输出1</li>
<li>Moore型状态只需要当前状态是C就可以输出1</li>
</ul>
<h3 id="3-4-Asynchronous-Sequential-Logic"><a href="#3-4-Asynchronous-Sequential-Logic" class="headerlink" title="3.4 Asynchronous Sequential Logic"></a>3.4 Asynchronous Sequential Logic</h3>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%A7%91%E7%9B%AE%E7%AC%94%E8%AE%B0/" class="category-chain-item">专业科目笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%BF%AE%E8%80%83/" class="print-no-link">#修考</a>
      
        <a href="/tags/Digital-Circuit/" class="print-no-link">#Digital Circuit</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Digital Circuit</div>
      <div>http://toutou.zeabur.app/2024/11/04/Digital-Circuit/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>toutou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>November 4, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/21/Computer-Architecture/" title="Computer Architecture">
                        <span class="hidden-mobile">Computer Architecture</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://www.instagram.com/hanni_rio/" target="_blank" rel="nofollow noopener"><span>Hanni Rio</span></a> <i class="iconfont icon-copyright"></i> <a href="https://toutou.zeabur.app" target="_blank" rel="nofollow noopener"><span>toutou</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
