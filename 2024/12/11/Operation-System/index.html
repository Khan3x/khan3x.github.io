

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="toutou">
  <meta name="keywords" content="">
  
    <meta name="description" content="Operating SystemThis is for test takers to quickly review Operation System. Credit to 《Operating System, 9th Edition》。操作系统的知识看起来非常得杂乱无章，需要重点关注任务调度算法，内存管理分配算法，以及地址变换机制。              催更｜辅导｜私塾兼职｜联系偷偷：Lif">
<meta property="og:type" content="article">
<meta property="og:title" content="Operating System">
<meta property="og:url" content="http://toutou.zeabur.app/2024/12/11/Operation-System/index.html">
<meta property="og:site_name" content="偷偷星球">
<meta property="og:description" content="Operating SystemThis is for test takers to quickly review Operation System. Credit to 《Operating System, 9th Edition》。操作系统的知识看起来非常得杂乱无章，需要重点关注任务调度算法，内存管理分配算法，以及地址变换机制。              催更｜辅导｜私塾兼职｜联系偷偷：Lif">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/system_call.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/process_diagram.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/threading_models.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/fcfs.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/sjf.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/priority.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/rr.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/multive_queue.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/pipe.svg">
<meta property="og:image" content="http://toutou.zeabur.app/img/OS/message.svg">
<meta property="article:published_time" content="2024-12-11T04:18:51.000Z">
<meta property="article:modified_time" content="2024-12-20T05:02:18.289Z">
<meta property="article:author" content="toutou">
<meta property="article:tag" content="修考">
<meta property="article:tag" content="Computer Architecture">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://toutou.zeabur.app/img/OS/system_call.svg">
  
  
  
  <title>Operating System - 偷偷星球</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"toutou.zeabur.app","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>偷偷星球</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/wall.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Operating System"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-11 12:18" pubdate>
          December 11, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          124 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Operating System</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><p>This is for test takers to quickly review Operation System. Credit to 《Operating System, 9th Edition》。操作系统的知识看起来非常得杂乱无章，需要重点关注任务调度算法，内存管理分配算法，以及地址变换机制。</p>
<div class="note note-success">
            <p>催更｜辅导｜私塾兼职｜联系偷偷：LifeGoesOn_Rio</p>
          </div>

<h2 id="1-Introduction-to-Operating-System"><a href="#1-Introduction-to-Operating-System" class="headerlink" title="1. Introduction to Operating System"></a>1. Introduction to Operating System</h2><p>计算机系统可以划分为<strong>4个</strong>主要组件：</p>
<ol>
<li><p>硬件(hardware)：指的是物理设备，包括计算机的处理器、内存、硬盘、输入输出设备等。硬件如中央处理单元(CPU)、内存(memory)、输入输出设备(I&#x2F;O device)为系统提供基本的计算资源。</p>
</li>
<li><p>操作系统(Operating System)：软件层次上管理硬件资源并提供基本服务的平台，例如 Windows、Linux 等。</p>
</li>
<li><p>应用程序(application)：运行在操作系统之上的软件，提供具体的功能和服务，如浏览器、文字处理软件等。</p>
</li>
<li><p>用户(user)：使用计算机系统进行操作和执行任务的人员。</p>
</li>
</ol>
<hr>
<p><strong>单处理器系统（Single-Processor System）</strong> 是指只有一个中央处理单元（CPU）的计算机系统。其特点如下：  </p>
<ol>
<li><strong>核心数量</strong>：只有一个处理器核心，用于执行所有的指令和任务。  </li>
<li><strong>任务调度</strong>：通过时间分片等方法实现多任务操作，但实际上每个时刻只能执行一个任务。  </li>
<li><strong>适用场景</strong>：适合资源需求较低的应用场景，如传统的个人计算机和嵌入式系统。  </li>
<li><strong>优点</strong>：结构简单，成本较低，软件开发难度小。  </li>
<li><strong>缺点</strong>：处理能力有限，无法充分利用多核架构的优势。</li>
</ol>
<p><strong>多处理系统（multiprocessing system）(也称为并行系统（parallel system）)</strong> 是指拥有多个处理器（或多个核心）的计算机系统，允许多个任务同时运行。其特点如下：  </p>
<ol>
<li><strong>核心数量</strong>：包含两个或更多处理器（或多核），每个核心可以独立执行任务。  </li>
<li><strong>任务并行</strong>：支持真正的并行计算，显著提高计算速度和效率。  </li>
<li><strong>架构类型</strong>：分为<strong>对称多处理（Symmetric MultiProcessing, SMP）</strong>和<strong>非对称多处理（Asymmetric MultiProcessing, AMP）</strong>：  <ul>
<li>SMP：所有处理器平等共享内存和任务。  </li>
<li>AMP：不同处理器有专门的任务分工。</li>
</ul>
</li>
<li><strong>适用场景</strong>：高性能计算、服务器、多任务处理（如图像处理、机器学习等）。</li>
</ol>
<p><strong>多处理器系统的主要优点有：</strong></p>
<ol>
<li><p><strong>增加吞吐量</strong>  </p>
<ul>
<li>多处理器系统通过并行处理任务显著提高了整体计算吞吐量。  </li>
<li>多个处理器可以同时执行不同的任务，减少任务队列的等待时间，提高系统的运行效率。  </li>
<li>特别适用于计算密集型任务，如科学计算、数据处理和复杂的仿真。</li>
<li>采用N个处理器的加速比不是N，而是小于N（考虑资源共享竞争）</li>
</ul>
</li>
<li><p><strong>规模经济</strong>  </p>
<ul>
<li>多处理器系统通过共享内存、I&#x2F;O设备等资源，降低了每个处理器独立配备资源的成本。  </li>
<li>随着处理器数量增加，系统性能可以线性甚至超线性提升，使整体成本效益更高。  </li>
<li>常见于需要扩展性强的大型系统，如云计算和服务器集群。</li>
</ul>
</li>
<li><p><strong>增加可靠性</strong>  </p>
<ul>
<li>多处理器系统具备更高的容错能力，当一个处理器发生故障时，其他处理器可以接管任务，保证系统的连续运行。  </li>
<li>提供了冗余机制，使关键任务系统（如航空、医疗设备）在出现硬件问题时仍能保持稳定。比如10个处理器中的1个出了故障，剩下的9个会分担器故障处理器的那部分工作。</li>
<li>通过任务分配策略，还可有效防止单点故障的影响。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>操作系统</strong>（Operating System，OS）是计算机系统中最基础且最重要的<strong>软件</strong>，它负责管理硬件资源并为用户和应用程序提供接口。其主要功能和定义如下：</p>
<ol>
<li><p><strong>资源管理者</strong>  : 操作系统负责管理和分配计算机的硬件资源，包括CPU、内存、存储设备和外部设备，以确保各类任务高效运行。</p>
</li>
<li><p><strong>用户与硬件之间的桥梁</strong>  : 操作系统提供用户与硬件交互的接口，使用户可以通过简单的命令或图形界面与计算机进行操作，而无需直接了解硬件的底层细节。</p>
</li>
<li><p><strong>程序执行的控制中心</strong>  : 操作系统负责调度和协调应用程序的运行，提供多任务处理和资源分配功能，保证系统的稳定性和性能。</p>
</li>
<li><p><strong>服务提供者</strong>  : 它为应用程序提供基本的服务，如文件管理、内存管理、进程调度和网络通信，简化了软件开发。</p>
</li>
</ol>
<p>操作系统是计算机系统的核心，它连接硬件和用户，为软件运行提供支持，同时确保系统的高效性和可靠性。</p>
<hr>
<p><strong>中断机制</strong>是操作系统中一个关键的功能，用于处理异步事件和高效管理硬件资源。它使得计算机可以响应各种外部或内部事件，如硬件故障、输入输出操作的完成、定时器到期等。下面详细介绍中断机制的各个方面：</p>
<p>1.<strong>中断的基本概念：</strong> 中断（Interrupt）是指计算机在执行程序的过程中，由于某些突发事件（如硬件设备请求、异常情况等），使得CPU暂时中止当前正在执行的程序，转而去处理这些事件的过程。当中断事件处理完毕后，CPU再回到中断前的程序继续执行。</p>
<p>2.<strong>中断的分类：</strong></p>
<ol>
<li><strong>硬件中断（Hardware Interrupt）</strong>：由外部硬件设备触发，如键盘按键、鼠标点击、网络数据包到达等。</li>
<li><strong>软件中断（Software Interrupt）</strong>：由软件触发的中断，如系统调用、程序异常等。</li>
<li><strong>定时器中断（Timer Interrupt）</strong>：由系统定时器触发，用于时间片轮转调度等操作。</li>
</ol>
<p>3.<strong>中断处理过程：</strong> 中断处理过程一般包括以下几个步骤：</p>
<ol>
<li><strong>中断请求</strong>：外部设备或软件发出中断请求信号。</li>
<li><strong>中断响应</strong>：CPU检查中断信号，并保存当前执行的上下文（如程序计数器、寄存器等）。</li>
<li><strong>中断向量</strong>：根据中断类型，CPU查找中断向量表以获取相应的中断服务程序（Interrupt Service Routine，ISR）的入口地址。</li>
<li><strong>执行中断服务程序</strong>：CPU跳转到ISR，执行相应的中断处理逻辑。</li>
<li><strong>恢复上下文</strong>：中断处理完成后，CPU恢复先前保存的上下文，继续执行被中断的程序。</li>
</ol>
<p>4.<strong>中断优先级：</strong><br>在多种中断同时发生时，需要确定哪个中断优先处理。中断优先级机制用于决定中断处理的顺序。一般来说，硬件中断优先级较高，而软件中断优先级较低。中断控制器（Interrupt Controller）用于管理中断优先级。</p>
<p>5.<strong>中断屏蔽：</strong> 中断屏蔽是指在某些关键操作期间，暂时禁止某些中断的发生，以防止中断打断正在进行的重要操作。通常使用中断屏蔽寄存器来实现。屏蔽中断可以避免在执行关键代码段时被中断打断，但也需要注意不能长时间屏蔽，以免丢失重要的中断信号。</p>
<p>6.<strong>中断的优点:</strong></p>
<ol>
<li><strong>响应及时</strong>：中断机制可以在事件发生时立即响应，提高系统的实时性。</li>
<li><strong>资源高效利用</strong>：通过中断机制，可以在硬件设备准备好时才进行处理，而不需要轮询，节省CPU资源。</li>
<li><strong>多任务处理</strong>：中断机制支持多任务并发处理，增强系统的灵活性和效率。</li>
</ol>
<p>7.<strong>中断的缺点:</strong></p>
<ol>
<li><strong>中断延迟</strong>：如果中断处理程序过多或过长，可能会导致系统响应延迟。</li>
<li><strong>复杂性增加</strong>：中断机制需要维护中断向量表和中断控制器，增加了系统的复杂性。</li>
<li><strong>上下文切换开销</strong>：每次中断处理都涉及上下文切换，带来一定的性能开销。</li>
</ol>
<p>以下是一个简单的中断处理流程示例：假设这是一个简单的汇编代码，演示中断处理</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">ORG 100H
MOV AX, 0          ; 初始化AX寄存器

INTERRUPT_HANDLER:
PUSH AX            ; 保存AX寄存器
MOV AX, 1234H      ; 中断处理逻辑
POP AX             ; 恢复AX寄存器
IRET               ; 返回中断前的程序

MAIN:
MOV AX, 1
INT 0              ; 触发中断
MOV AX, 2
HLT                ; 停止程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>在这个示例中，当执行到 INT 0 指令时，会触发中断并调用 INTERRUPT_HANDLER 来处理中断。在中断处理程序中，保存了AX寄存器的值，并进行了简单的处理后恢复AX寄存器，然后返回到中断前的程序继续执行。通过中断机制，计算机系统可以高效处理各种异步事件，保证系统的稳定性和响应性。</p>
<hr>
<p><strong>轮询（Polling）</strong> 是一种通过主动检查设备或资源状态来判断是否需要处理某个事件的机制。操作系统或程序会周期性地访问设备或资源，以确定是否需要执行相关操作。</p>
<p><strong>轮询的特点：</strong></p>
<ol>
<li><p><strong>主动查询</strong>  : 系统不断循环检查设备或资源的状态，而不是等待设备主动通知。</p>
</li>
<li><p><strong>简单易实现</strong>  : 轮询机制实现起来比较简单，通常只需要循环读取设备的状态寄存器即可。</p>
</li>
<li><p><strong>低效</strong>  : 如果设备状态没有发生变化，CPU可能会浪费大量时间在无意义的查询上，无法高效利用资源。</p>
</li>
</ol>
<p><strong>轮询的工作流程：</strong></p>
<ol>
<li>系统通过读取设备状态寄存器获取设备当前状态。  </li>
<li>如果发现设备准备好（例如I&#x2F;O操作完成），则进行相应的处理。  </li>
<li>如果设备未准备好，则继续轮询，直到设备状态发生变化。</li>
</ol>
<p><strong>轮询的缺点：</strong></p>
<ul>
<li><strong>资源浪费</strong>：占用CPU时间，即使设备未准备好也会不断查询。  </li>
<li><strong>实时性差</strong>：对于需要快速响应的事件，轮询可能无法及时处理。  </li>
<li><strong>不适合频繁事件</strong>：当事件发生较多时，轮询会影响系统整体性能。</li>
</ul>
<p><strong>轮询的优点：</strong></p>
<ul>
<li><strong>简单性</strong>：实现简单，不需要复杂的硬件支持。  </li>
<li><strong>适用性</strong>：适合事件发生频率较低或硬件复杂度较低的场景。</li>
</ul>
<p><strong>轮询对比中断机制：</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>轮询</strong></th>
<th><strong>中断</strong></th>
</tr>
</thead>
<tbody><tr>
<td>响应方式</td>
<td>主动查询设备状态</td>
<td>被动响应设备的中断信号</td>
</tr>
<tr>
<td>资源利用效率</td>
<td>较低，可能浪费CPU资源</td>
<td>高效，只在事件发生时占用资源</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>简单，不需要硬件支持</td>
<td>复杂，需要硬件和软件配合</td>
</tr>
<tr>
<td>实时性</td>
<td>较差</td>
<td>较强</td>
</tr>
</tbody></table>
<p>轮询虽然简单，但在现代操作系统中已逐渐被更高效的<strong>中断机制</strong>取代。</p>
<hr>
<p>在操作系统中，<strong>“异常(exception)”</strong> 指的是一种特殊的事件或情况，它们会导致当前正在执行的程序或系统行为发生中断。这些异常可能来自于硬件或软件，通常需要操作系统进行处理，以确保系统的稳定性和安全性。</p>
<p><strong>异常的分类：</strong></p>
<ol>
<li><strong>硬件异常</strong>：由于硬件故障或特殊硬件条件引起，例如内存访问违规、除零错误等。</li>
<li><strong>软件异常</strong>：由于软件执行过程中出现的非法操作或异常情况引起，例如非法指令、系统调用错误等。</li>
</ol>
<p><strong>异常处理过程：</strong></p>
<ol>
<li><strong>检测异常</strong>：当异常发生时，硬件或操作系统检测到异常情况。</li>
<li><strong>保存状态</strong>：当前处理器状态（例如寄存器值、程序计数器）被保存，以便后续恢复。</li>
<li><strong>调用异常处理程序</strong>：操作系统根据异常类型，调用相应的异常处理程序（Exception Handler）。</li>
<li><strong>处理异常</strong>：异常处理程序执行特定的操作，以处理或缓解异常情况。</li>
<li><strong>恢复状态</strong>：异常处理完成后，恢复处理器状态并继续执行被中断的程序。</li>
</ol>
<p><strong>常见的异常类型：</strong></p>
<ul>
<li><strong>访问违例</strong>：试图访问未授权的内存区域。</li>
<li><strong>非法指令</strong>：执行了无效或未定义的指令。</li>
<li><strong>除零错误</strong>：在计算过程中出现除数为零的情况。</li>
<li><strong>系统调用</strong>：用户程序请求操作系统提供服务时产生的异常。</li>
</ul>
<p><strong>异常处理的优点：</strong></p>
<ul>
<li><strong>提高系统稳定性</strong>：通过有效的异常处理机制，操作系统可以检测并处理各种错误，避免系统崩溃。</li>
<li><strong>增强安全性</strong>：异常处理可以防止非法操作，保护系统和用户数据的安全。</li>
</ul>
<p>异常处理是操作系统中的一个关键机制，用于管理和处理各种意外事件和错误情况。通过异常处理，操作系统能够保持系统的稳定性和安全性，确保用户和应用程序的正常运行。</p>
<hr>
<p>在操作系统中，<strong>中断（Interrupt）和异常（Exception）</strong> 是两种重要的事件，它们都会导致CPU暂停当前的任务，转而去处理这些事件。再总结一下就是：</p>
<ul>
<li>中断（Interrupt）：中断是由<u>硬件设备（如键盘，鼠标，网络接口卡等）发出的信号，</u>通知操作系统有一些重要的事件发生，需要立即处理。例如，当你按下键盘上的一个键时，键盘会向CPU发送一个中断信号，CPU会暂停当前的任务，转而去处理这个按键事件。处理完这个事件后，CPU会返回到被中断的任务，继续执行。</li>
<li>异常（Exception）：异常是由<u>CPU在执行指令过程中发现的问题，</u>如除以零，访问无效的内存地址等。当发生异常时，CPU会暂停当前的任务，转而去执行一个特殊的异常处理程序。处理完这个异常后，CPU可能会返回到被中断的任务，也可能会终止这个任务，这取决于异常的类型和严重性。</li>
</ul>
<p>总体来说，中断和异常都是操作系统用来响应和处理重要事件的机制。它们都会导致CPU暂停当前的任务，但来源和处理方式有所不同。<strong>中断通常由外部硬件或定时器触发，表示系统需要对外部事件进行响应，而异常则由程序内部的特殊或错误行为引发，表示需要操作系统介入进行修复或处理</strong>。发生中断或异常时，操作系统都会介入并展开管理工作；<strong>用户态和内核态的切换是通过中断或异常实现的，而中断是实现这种切换的唯一途径，通过修改程序状态字（PSW）来完成状态转换</strong>。</p>
<hr>
<p><strong>内存管理</strong> 是操作系统的一项重要功能，负责管理计算机的主存储器，并为应用程序分配和释放内存。内存管理的主要目标是提高内存的使用效率，保证系统的稳定性和安全性。以下是内存管理的一些关键概念和机制：</p>
<p><strong>内存管理的主要任务:</strong></p>
<ol>
<li><strong>内存分配</strong>：为进程分配所需的内存资源，包括动态分配和静态分配。</li>
<li><strong>内存保护</strong>：确保进程只能访问自己合法的内存区域，防止进程之间相互干扰。</li>
<li><strong>内存回收</strong>：回收不再使用的内存，以便分配给其他进程。</li>
</ol>
<p><strong>内存管理机制:</strong></p>
<p><strong>1.分段和分页:</strong></p>
<ul>
<li><strong>分页</strong>：内存被划分成大小相同的页，每个进程的地址空间也被划分成相同大小的页。通过页表（Page Table）映射进程页和物理内存页，实现内存的管理。</li>
<li><strong>分段</strong>：内存被划分成不同大小的段，每个段包含一段逻辑地址空间。通过段表（Segment Table）管理和映射各段地址。</li>
</ul>
<p><strong>2.虚拟内存:</strong></p>
<p>虚拟内存技术允许操作系统将实际物理内存与进程的逻辑内存分离，使得进程可以使用比实际物理内存更大的地址空间。虚拟内存通过页表和交换空间（Swap Space）管理，将不常用的页临时存储在磁盘上，需要时再调入内存。</p>
<p><strong>3.内存保护:</strong></p>
<ul>
<li><strong>基址寄存器和界限寄存器</strong>：通过设置每个进程的基址和界限，确保进程只能访问自己的内存区域，防止越界访问。</li>
<li><strong>页面保护</strong>：通过页表中的保护位控制每个页的访问权限（读、写、执行），保证进程的内存访问安全。</li>
</ul>
<p><strong>4. 内存回收:</strong></p>
<ul>
<li><strong>垃圾回收</strong>：通过自动检测和回收不再使用的内存，释放资源供其他进程使用。</li>
<li><strong>内存压缩</strong>：通过内存整理和压缩，减少内存碎片，提高内存利用率。</li>
</ul>
<p><strong>内存管理的重要性:</strong></p>
<ol>
<li><strong>提高系统性能</strong>：通过有效的内存分配和回收机制，保证进程的高效运行。</li>
<li><strong>增强系统稳定性</strong>：通过内存保护机制，防止进程之间的相互干扰，保证系统的稳定运行。</li>
<li><strong>优化资源利用</strong>：通过虚拟内存和分页技术，最大化内存资源的利用率，使得系统能够同时运行更多的进程。</li>
</ol>
<p>内存管理是操作系统的一项核心功能，涉及内存的分配、保护和回收等多个方面。通过有效的内存管理，操作系统能够提高系统性能、增强稳定性，并优化资源利用，为应用程序提供稳定可靠的运行环境。</p>
<hr>
<p>操作系统的<strong>进程管理</strong>是指对系统中所有进程的创建、调度、执行、和终止进行管理和协调的过程。它是操作系统的核心功能之一，负责保证多个任务能够高效、公平地共享CPU和其他资源。</p>
<p><strong>进程管理的主要功能：</strong></p>
<ol>
<li><p><strong>进程创建与终止</strong>  </p>
<ul>
<li>创建新进程：为程序分配必要的资源（如内存、文件句柄）并初始化进程控制块（PCB）。  </li>
<li>终止进程：释放进程所占用的资源并清理PCB。</li>
</ul>
</li>
<li><p><strong>进程调度</strong>  </p>
<ul>
<li>负责决定哪一个进程可以使用CPU。  </li>
<li>常用的调度算法包括：  <ul>
<li>先来先服务（FCFS）  </li>
<li>最短作业优先（SJF）  </li>
<li>时间片轮转（RR）  </li>
<li>多级队列调度等。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程同步</strong>  </p>
<ul>
<li>保证多个进程在访问共享资源时不会产生冲突。  </li>
<li>使用机制：信号量（Semaphore）、互斥锁（Mutex）、条件变量等。</li>
</ul>
</li>
<li><p><strong>进程通信</strong>  </p>
<ul>
<li>提供进程之间交换数据的手段。  </li>
<li>常用方式：管道（Pipe）、消息队列（Message Queue）、共享内存（Shared Memory）、信号（Signal）等。</li>
</ul>
</li>
<li><p><strong>进程状态管理</strong>  </p>
<ul>
<li>维护进程的状态：  <ul>
<li>新建（New）  </li>
<li>就绪（Ready）  </li>
<li>运行（Running）  </li>
<li>阻塞（Blocked）  </li>
<li>终止（Terminated）</li>
</ul>
</li>
<li>根据状态变化完成任务切换。</li>
</ul>
</li>
<li><p><strong>多线程支持</strong>  </p>
<ul>
<li>管理线程的创建、调度和同步，支持多线程模型（如用户线程和内核线程）。</li>
</ul>
</li>
</ol>
<p><strong>进程与线程的区别</strong></p>
<ul>
<li><strong>进程(Process)</strong> 是资源分配的最小单位，每个进程有独立的地址空间。进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。  </li>
<li><strong>线程(Thread)</strong> 是CPU调度的最小单位，线程共享进程的地址空间。线程是进程中的一条执行路径，是进程的一个实体，可作为系统独立调度和分派的基本单位。</li>
</ul>
<p>进程：就像一家物业管理公司，它独立运营，有自己的一套管理系统（相当于进程的独立地址空间）。这个公司可以接多个任务，但所有任务最终都需要公司的资源来完成。</p>
<p>单线程：假设你是这家公司的唯一员工。初期，业务量很小，每个任务都需要你亲自去完成。比如，给老张家修完暖气管道，然后再去老李家换电灯泡。这个过程类似于单线程执行——每次只能处理一个任务，必须按顺序进行。</p>
<ul>
<li>示例：修暖气管道 -&gt; 换电灯泡</li>
</ul>
<p>多线程：随着业务的发展，你雇佣了多个工人。这时，你的公司可以同时为多户人家提供服务。每个工人就是一个线程，他们可以独立处理自己的任务，但仍然共享公司的资源（如工具、交通工具等）。</p>
<ul>
<li>示例：工人A修暖气管道，工人B换电灯泡，工人C修水管</li>
</ul>
<p>主线程：你作为公司的老板和主线程，负责分配任务、协调工作，确保所有工人（线程）能顺利开展工作。如果某个工人遇到问题（冲突或需要协同），你可以及时介入解决，保持公司的正常运行。</p>
<p>通过这个类比，进程就像是一个独立的公司，每个线程就像是公司的员工，他们共享公司的资源，并共同完成任务。多线程能提高效率，但需要有效的管理和协调，确保资源的合理使用和任务的顺利完成。</p>
<p>进程管理是操作系统的核心功能之一，它通过对进程的调度和控制，实现了多任务并发，保证系统资源的高效利用和任务的公平执行。</p>
<hr>
<p><strong>API（Application Programming Interface, 应用程序编程接口）</strong> 是一种允许不同软件系统之间进行通信的接口。API 定义了一组函数、方法、协议或工具，使开发者可以利用这些接口来访问另一种软件的功能或数据，而无需了解其内部实现细节。</p>
<p><strong>API重要特点：</strong></p>
<ul>
<li><strong>抽象层（Abstraction Layer）</strong>：API 提供了对底层复杂操作的简化抽象，开发者不需要了解底层实现细节。</li>
<li><strong>功能封装（Function Encapsulation）</strong>：API 将常用功能封装为可复用的接口，方便开发者调用。</li>
<li><strong>互操作性（Interoperability）</strong>：不同的软件系统可以通过 API 进行互操作，提高系统的兼容性和可扩展性。</li>
</ul>
<p><strong>系统调用（System Call）</strong> 是操作系统内核提供的接口，允许应用程序请求操作系统提供服务。系统调用是程序与操作系统之间的桥梁，使应用程序可以执行底层硬件操作，如文件操作、进程管理和网络通信等。系统调用可以被看作是<strong>操作系统API的一部分</strong>。当你在编程时使用API，你可能会间接地使用系统调用。例如，当你使用C++的文件流对象（如std::fstream）来读写文件时，这些对象内部可能会使用到操作系统的系统调用来进行实际的文件操作。</p>
<p><strong>系统调用重要特点：</strong></p>
<ul>
<li><strong>内核模式（Kernel Mode）</strong>：系统调用将程序从用户模式切换到内核模式，以便执行特权操作。</li>
<li><strong>服务访问（Service Access）</strong>：通过系统调用，应用程序可以访问操作系统内核提供的服务。</li>
<li><strong>安全和稳定（Security and Stability）</strong>：系统调用由操作系统内核管理，确保了系统的安全性和稳定性。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong>API（应用程序编程接口）</strong> 是软件之间进行通信的接口，通过提供预定义的函数和方法，使开发者能够利用现有功能来构建应用程序。</li>
<li><strong>系统调用（System Call）</strong> 是操作系统提供的接口，使应用程序可以请求操作系统执行底层硬件操作和特权任务。</li>
</ul>
<p>API 是一种更高层次的抽象，而系统调用是更底层的接口，两者都在不同层次上为软件开发提供了便利和功能。总的来说，API和系统调用都是使程序员能够更容易地编写代码和交互系统的工具。API提供了更高级别的抽象，而系统调用则提供了对操作系统服务的直接访问。</p>
<hr>
<p>操作系统的<strong>四个重要特征</strong>包括：</p>
<p><strong>1.并发（Concurrency）</strong> 并发是指两个或多个事件在同一时间间隔内发生。在操作系统中，并发可以通过多线程或多进程实现，线程或进程可以在一个处理器上交替执行，或者在多个处理器上同时执行。</p>
<ul>
<li><strong>并发（Concurrency）</strong> 是指多个任务在同一时间段内交替进行，给人的感觉是同时发生，但实际上每个任务并不是同时进行的。</li>
<li><strong>并行（Parallelism）</strong> 与并发不同，并行是指两个或多个事件在同一时刻同时发生。例如：多线程下载文件，多个进程同时处理不同任务。</li>
</ul>
<p><strong>2.共享（Sharing）</strong> 共享是指系统中的资源可以被多个并发进程共同使用。共享的方式有两种：同时访问（同时共享）和在一段时间内交替访问（互斥共享）。</p>
<ul>
<li><strong>同时共享（Concurrent Sharing）</strong>：多个进程同时访问同一资源。</li>
<li><strong>互斥共享（Mutual Exclusion Sharing）</strong>：多个进程轮流访问同一资源，以避免冲突。例如：多个进程共享打印机资源，互斥访问临界区。</li>
</ul>
<p><strong>3.虚拟化（Virtualization）</strong> 虚拟化是指把一个物理资源（如处理器、内存或磁盘）抽象为多个逻辑资源，或把多个物理资源抽象为一个逻辑资源。虚拟化使得用户感觉有更多的资源可用，或使得资源使用更加高效。</p>
<ul>
<li><strong>空分复用（Space Division Multiplexing）</strong>：如虚拟存储器，使4GB内存的计算机能够运行需要超过4GB内存的程序。</li>
<li><strong>时分复用（Time Division Multiplexing）</strong>：时分复用通过将时间划分为多个时间片，每个时间片分配给不同的任务执行。通过CPU时间片轮转技术实现多任务并行，使得每个任务在短时间内轮流占用CPU资源，给人一种同时执行多个任务的感觉。如虚拟处理器和多任务操作系统，通过CPU时间片轮转技术实现多任务并行。</li>
</ul>
<p><strong>4.异步性（Asynchronism）</strong> 异步性是指由于进程间的并发性，使得进程交替执行，进程的执行不是一贯的，也不是在固定的时间间隔内发生。这意味着进程可能走走停停，取决于系统资源的可用性和调度策略。</p>
<ul>
<li><strong>示例</strong>：异步I&#x2F;O操作，操作系统在等待I&#x2F;O操作完成时可以执行其他任务。</li>
</ul>
<p>这些特征共同作用，使操作系统能够有效地管理计算机资源，提供稳定和高效的运行环境。</p>
<div class="note note-success">
            <p>以上就是操作系统主要关注的内容，后续章节就是扩展讲解上述内容中重要的技术细节和实现思想</p>
          </div>

<h2 id="2-Process-Management"><a href="#2-Process-Management" class="headerlink" title="2. Process Management"></a>2. Process Management</h2><p>本章主要讲解操作系统里面的进程管理部分。理解进程和线程，掌握进程调度相关的各种策略算法，并且熟悉信号量的互斥机制是非常重要的。</p>
<h3 id="2-1-操作系统的用户交互"><a href="#2-1-操作系统的用户交互" class="headerlink" title="2.1 操作系统的用户交互"></a>2.1 操作系统的用户交互</h3><p>操作系统的用户交互主要分为两种类型：</p>
<h4 id="2-1-1-命令解释程序（Command-Interpreter）"><a href="#2-1-1-命令解释程序（Command-Interpreter）" class="headerlink" title="2.1.1 命令解释程序（Command Interpreter）"></a>2.1.1 命令解释程序（Command Interpreter）</h4><ul>
<li>又称为 <strong>命令行界面（CLI，Command Line Interface）</strong>。</li>
<li>用户通过输入文本命令与操作系统进行交互。</li>
<li>常见的命令解释程序包括 Unix&#x2F;Linux 系统的 Bash、Windows 的 CMD 和 PowerShell。</li>
<li><strong>优点</strong>：灵活性高，适合自动化脚本和高级用户。</li>
<li><strong>缺点</strong>：需要记住大量命令和语法，不直观。</li>
</ul>
<p>以下是一个简单的 shell 指令示例：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># 创建一个新的目录
mkdir my_new_directory

# 进入新创建的目录
cd my_new_directory

# 创建一个新的空文件
touch new_file.txt

# 将一段文本写入文件中
echo &quot;Hello, World!&quot; &gt; new_file.txt

# 显示文件内容
cat new_file.txt

# 复制文件并重命名
cp new_file.txt copy_of_new_file.txt

# 显示当前目录中的文件和子目录列表
ls -l

# 删除复制的文件
rm copy_of_new_file.txt

# 返回上一级目录
cd ..

# 删除新创建的目录及其内容
rm -r my_new_directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h4 id="2-1-2-图形用户界面（GUI，Graphical-User-Interface）"><a href="#2-1-2-图形用户界面（GUI，Graphical-User-Interface）" class="headerlink" title="2.1.2 图形用户界面（GUI，Graphical User Interface）"></a>2.1.2 图形用户界面（GUI，Graphical User Interface）</h4><ul>
<li>用户通过图形化元素（如窗口、图标、按钮）与操作系统进行交互。</li>
<li>常见的图形用户界面包括 Windows 的资源管理器（Windows Explorer）、macOS 的 Finder 以及 GNOME 和 KDE 等 Linux 桌面环境。</li>
<li><strong>优点</strong>：直观易用，适合初学者和普通用户。</li>
<li><strong>缺点</strong>：灵活性相对较低，复杂操作可能效率不高。</li>
</ul>
<p>这两种交互方式各有优缺点，通常操作系统会同时提供这两种方式，以满足不同用户的需求和使用场景。通过结合命令行界面和图形用户界面，用户可以在不同情况下选择最合适的交互方式，提高工作效率和使用体验。</p>
<hr>
<h3 id="2-2-操作系统中的系统调用"><a href="#2-2-操作系统中的系统调用" class="headerlink" title="2.2 操作系统中的系统调用"></a>2.2 操作系统中的系统调用</h3><p><strong>系统调用（System Call）</strong> 是操作系统提供的一组接口，允许应用程序与操作系统内核交互，以请求内核执行特权操作。系统调用是程序与操作系统之间的桥梁，使应用程序可以执行低级别的系统功能，如文件操作、进程管理和网络通信等。</p>
<p><strong>系统调用主要功能:</strong></p>
<ul>
<li><strong>文件操作</strong>：创建、打开、读取、写入和关闭文件。</li>
<li><strong>进程管理</strong>：创建、终止进程，分配资源，进程间通信等。</li>
<li><strong>内存管理</strong>：分配和释放内存，内存映射等。</li>
<li><strong>设备管理</strong>：访问和控制硬件设备，如磁盘、网络接口等。</li>
<li><strong>网络通信</strong>：发送和接收网络数据，设置网络连接等。</li>
</ul>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>用户模式到内核模式切换</strong>：当应用程序发出系统调用时，CPU将从用户模式切换到内核模式。</li>
<li><strong>内核执行请求</strong>：操作系统内核接收系统调用请求，并执行相应的特权操作。</li>
<li><strong>返回结果</strong>：操作系统内核完成操作后，将结果返回给应用程序，并切换回用户模式。</li>
</ol>
<p><strong>系统调用示例:</strong></p>
<ul>
<li><code>open</code>：打开文件的系统调用。</li>
<li><code>read</code>：读取文件内容的系统调用。</li>
<li><code>write</code>：写入文件内容的系统调用。</li>
<li><code>fork</code>：创建新进程的系统调用。</li>
<li><code>exec</code>：执行新程序的系统调用。</li>
</ul>
<p>通过系统调用，应用程序可以安全、高效地访问操作系统提供的底层资源和服务，实现丰富的功能。</p>
<img src="/img/OS/system_call.svg" srcset="/img/loading.gif" lazyload alt="系统调用" style="max-width: 100%; height: auto;" />

<p>在后台，<strong>API 函数(Application Programming Interface, API<br>)</strong> 通常为应用程序开发人员提供了调用实际系统调用的函数。API 函数为开发人员提供了一个更高层次的抽象，使他们能够以更简单和统一的方式访问底层操作系统的功能，而不需要了解系统调用的具体实现细节。</p>
<p>通过调用 API 函数，开发人员可以间接地进行文件操作、进程管理、内存管理、设备控制等操作，这些 API 函数在后台会触发相应的系统调用来完成实际的操作。例如：</p>
<ul>
<li><strong>文件操作</strong>：<code>fopen</code> API 函数会调用 <code>open</code> 系统调用。</li>
<li><strong>进程管理</strong>：<code>fork</code> API 函数直接对应 <code>fork</code> 系统调用。</li>
<li><strong>内存管理</strong>：<code>malloc</code> API 函数可能会调用 <code>brk</code> 或 <code>mmap</code> 系统调用。</li>
</ul>
<p>总之，API 提供了一种方便的方式，使开发人员能够利用操作系统的功能，而不必处理系统调用的复杂性和底层细节。</p>
<blockquote>
<p>在后台，API函数通常为应用程序员调用实际的系统调用</p>
</blockquote>
<h3 id="2-3-进程的概念"><a href="#2-3-进程的概念" class="headerlink" title="2.3 进程的概念"></a>2.3 进程的概念</h3><p><strong>进程</strong>是计算机中一个正在运行的程序的实例。它不仅包括可执行程序的代码，还包含了该程序的运行状态信息，包括程序计数器、寄存器和变量的值。</p>
<p><strong>进程的主要特点:</strong></p>
<ol>
<li><strong>独立性</strong>：每个进程在其自己的内存空间中运行，独立于其他进程。</li>
<li><strong>资源拥有</strong>：进程拥有自己的系统资源，如文件句柄和内存段。</li>
<li><strong>并发性</strong>：操作系统可以在同一时间段内允许多个进程并发执行（即使在单个处理器系统中，通过时间分片实现）。</li>
<li><strong>状态</strong>：进程有多种状态，包括新建、就绪、运行、等待和终止。</li>
</ol>
<p><strong>进程的组成部分:</strong></p>
<ul>
<li><strong>可执行代码</strong>：实际的程序代码。</li>
<li><strong>进程控制块（PCB）</strong>：存储进程的状态信息，如程序计数器、寄存器、内存分配等。</li>
<li><strong>堆栈</strong>：存储临时数据（函数参数、返回地址、局部变量）。</li>
<li><strong>堆</strong>：动态分配的内存，用于存储运行时需要的数据。</li>
<li><strong>数据段</strong>：全局变量和静态变量。</li>
</ul>
<p><strong>进程状态切换：</strong></p>
<ol>
<li><p><strong>新建（New）</strong>：进程正在被创建。</p>
<ul>
<li>当一个程序被启动时，操作系统会为其创建一个新进程。此时进程处于新建状态。</li>
</ul>
</li>
<li><p><strong>就绪（Ready）</strong>：进程已经创建完毕，等待被调度执行。</p>
<ul>
<li>进程创建完成后，进入就绪队列，等待调度器将其调度到 CPU 上执行。</li>
<li><strong>切换方式</strong>：从新建状态切换到就绪状态。</li>
</ul>
</li>
<li><p><strong>运行（Running）</strong>：进程正在执行。</p>
<ul>
<li>当调度器选择一个就绪状态的进程并将其分配给 CPU 时，该进程进入运行状态，开始执行。</li>
<li><strong>切换方式</strong>：<ul>
<li>从就绪状态切换到运行状态。</li>
<li>当等待的事件完成后，进程返回就绪状态，待调度器再次分配 CPU。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>等待（Waiting）</strong>：进程在等待某些事件（如I&#x2F;O操作）完成。</p>
<ul>
<li>如果进程在执行过程中需要等待某些事件（如 I&#x2F;O 操作、资源可用等），它会进入等待状态。</li>
<li><strong>切换方式</strong>：从运行状态切换到等待状态（当进程请求的 I&#x2F;O 操作开始执行时）。</li>
</ul>
</li>
<li><p><strong>终止（Terminated）</strong>：进程已经完成执行或被强制终止。</p>
<ul>
<li>当进程完成其全部工作或被强制终止时，进入终止状态，等待操作系统回收资源。</li>
<li><strong>切换方式</strong>：从运行状态切换到终止状态（当进程正常完成或遇到无法恢复的错误时）。</li>
</ul>
</li>
</ol>
<p><strong>示例流程:</strong></p>
<ol>
<li><strong>创建一个新进程</strong>：新进程从新建状态切换到就绪状态。</li>
<li><strong>调度器选择进程</strong>：调度器将一个就绪进程分配给 CPU，进程从就绪状态切换到运行状态。</li>
<li><strong>进程请求 I&#x2F;O 操作</strong>：进程在运行过程中请求 I&#x2F;O 操作，切换到等待状态。</li>
<li><strong>I&#x2F;O 操作完成</strong>：I&#x2F;O 操作完成，进程从等待状态返回就绪状态。</li>
<li><strong>进程重新获得 CPU</strong>：调度器再次选择该进程，进程切换到运行状态。</li>
<li><strong>进程完成执行</strong>：进程完成所有任务或被强制终止，进入终止状态。</li>
</ol>
<p>这种状态切换机制是多任务操作系统有效管理和调度进程的重要方式，确保系统资源的合理分配和使用。</p>
<img src="/img/OS/process_diagram.svg" srcset="/img/loading.gif" lazyload alt="进程状态图" style="max-width: 100%; height: auto;" />


<p>当一个程序被加载到内存并开始执行时，操作系统为其创建一个进程，并分配所需的系统资源。操作系统通过进程调度程序管理和调度进程的执行，确保每个进程可以合理地使用 CPU 时间和其他资源。</p>
<p>进程是多任务操作系统的基础，允许多个程序同时运行，提高系统的效率和资源利用率。</p>
<hr>
<p>PCB（<strong>Process Control Block</strong>）是操作系统中用于管理进程的一个数据结构。每个正在运行的进程都有一个对应的 PCB，用于存储进程的各种信息。<u>PCB是进程存在的唯一标志。</u>常见的 PCB 内容包括：</p>
<ol>
<li><strong>进程状态</strong>：记录进程当前的状态（如运行、就绪、阻塞等）。</li>
<li><strong>程序计数器</strong>：指向下一条将执行的指令地址。</li>
<li><strong>CPU寄存器</strong>：保存进程执行时的 CPU 寄存器内容，包括通用寄存器、程序计数器等。</li>
<li><strong>内存管理信息</strong>：如进程的内存分配、页表等。</li>
<li><strong>进程标识符</strong>：进程的唯一标识（PID）。</li>
<li><strong>调度信息</strong>：包括优先级、调度队列指针等。</li>
<li><strong>I&#x2F;O信息</strong>：包括进程使用的输入输出设备信息和相关状态。</li>
</ol>
<p>PCB 是操作系统调度和管理进程的重要工具，确保操作系统能够有效地保存和恢复进程的状态。</p>
<h4 id="2-3-1-线程的概念"><a href="#2-3-1-线程的概念" class="headerlink" title="2.3.1 线程的概念"></a>2.3.1 线程的概念</h4><p>线程(Thread) 是操作系统中的基本调度单位，是进程中的一个执行单元。一个进程可以包含多个线程，多个线程共享进程的资源（如内存空间、文件描述符等），但每个线程都有自己的程序计数器、寄存器和堆栈。线程被用来执行并发任务。</p>
<p><strong>线程的特点：</strong></p>
<ol>
<li><strong>轻量级</strong>：相比进程，线程的创建和销毁成本较低，切换速度较快。</li>
<li><strong>共享资源</strong>：同一进程内的多个线程共享进程的地址空间、全局变量等资源。</li>
<li><strong>独立执行</strong>：每个线程有自己的程序计数器、栈和局部变量，可以独立执行任务。</li>
<li><strong>并发执行</strong>：多个线程可以并发或并行地执行，适用于多核处理器和多任务环境。</li>
</ol>
<p><strong>线程与进程的区别：</strong></p>
<ul>
<li><strong>进程</strong>是资源分配的基本单位，每个进程都有独立的内存空间。</li>
<li><strong>线程</strong>是 CPU 调度的基本单位，同一进程内的多个线程共享内存资源，但有独立的执行路径。</li>
</ul>
<h4 id="2-3-2-操作系统中的多线程模型（Multithreading-Models）"><a href="#2-3-2-操作系统中的多线程模型（Multithreading-Models）" class="headerlink" title="2.3.2 操作系统中的多线程模型（Multithreading Models）"></a>2.3.2 操作系统中的多线程模型（Multithreading Models）</h4><p>操作系统中的多线程模型决定了用户线程与内核线程之间的映射关系。主要有以下几种模型：</p>
<p><strong>1. 一对一模型（One-to-One Model）</strong></p>
<ul>
<li>每个用户线程映射到一个内核线程。</li>
<li><strong>优点</strong>：可以充分利用多处理器的并行性，因为每个线程可以在不同的处理器上独立运行。</li>
<li><strong>缺点</strong>：每个线程需要一个内核线程，导致线程的创建和管理开销较大，可能影响性能。</li>
</ul>
<p><strong>2. 多对一模型（Many-to-One Model）</strong></p>
<ul>
<li>多个用户线程映射到一个内核线程。</li>
<li><strong>优点</strong>：线程的创建和管理开销较小，因为内核只需要管理一个内核线程。</li>
<li><strong>缺点</strong>：由于所有用户线程都在同一个内核线程上运行，无法利用多处理器的并行性。如果一个线程阻塞，整个进程都会被阻塞。</li>
</ul>
<p><strong>3. 多对多模型（Many-to-Many Model）</strong></p>
<ul>
<li>多个用户线程映射到多个内核线程。</li>
<li><strong>优点</strong>：结合了前两种模型的优点，既可以利用多处理器的并行性，又能控制线程的创建和管理开销。</li>
<li><strong>缺点</strong>：需要复杂的调度和管理机制来平衡用户线程与内核线程之间的映射关系。</li>
</ul>
<p><strong>4. 二级模型（Two-Level Model）</strong></p>
<ul>
<li>是多对多模型的变体，允许多个用户线程映射到同一个内核线程，也允许一个用户线程映射到多个内核线程。</li>
<li><strong>优点</strong>：允许更灵活的线程管理，结合了多对多模型和一对一模型的优点。</li>
<li><strong>缺点</strong>：需要更复杂的调度机制，增加了系统的实现复杂性。</li>
</ul>
<img src="/img/OS/threading_models.svg" srcset="/img/loading.gif" lazyload alt="多线程模型" style="max-width: 100%; height: auto;" />

<h3 id="2-4-进程控制"><a href="#2-4-进程控制" class="headerlink" title="2.4 进程控制"></a>2.4 进程控制</h3><p>进程控制是操作系统管理和调度进程的关键任务。它包括创建、调度、终止进程等操作，以确保系统中的进程能高效、按需执行。</p>
<p><strong>1. 进程的创建</strong></p>
<ul>
<li><strong>创建新进程</strong>：操作系统通过系统调用（如 <code>fork</code> 在 Unix 系统中）创建一个新进程。新进程通常是当前进程的副本，称为子进程。</li>
<li><strong>资源分配</strong>：当创建新进程时，操作系统为其分配必要的资源（如内存、文件句柄等），并初始化进程控制块（PCB）以存储进程信息。</li>
</ul>
<p><strong>2. 进程调度</strong></p>
<ul>
<li><strong>进程状态</strong>：进程在执行过程中会经历不同的状态（如就绪、运行、阻塞等）。操作系统调度器负责决定进程在何时进入哪种状态。</li>
<li><strong>调度算法</strong>：操作系统使用各种调度算法（如先来先服务 FCFS、时间片轮转 RR、最短作业优先 SJF 等）来决定哪个进程应该获得 CPU 时间。</li>
<li><strong>多任务处理</strong>：操作系统允许多个进程并发运行，通过上下文切换在多个进程间分配 CPU 时间。</li>
</ul>
<p><strong>3. 进程同步与通信</strong></p>
<ul>
<li><strong>进程同步</strong>：在并发执行的多个进程间，操作系统提供同步机制（如信号量、互斥锁、条件变量等）以确保共享资源的正确使用，避免数据竞争和死锁。</li>
<li><strong>进程通信</strong>：进程之间可以通过多种方式进行通信，如管道、消息队列、共享内存等。操作系统提供通信机制以允许进程间交换数据。</li>
</ul>
<p><strong>4. 进程终止</strong></p>
<ul>
<li><strong>进程终止</strong>：进程执行完毕或由于错误发生时，会通过系统调用（如 <code>exit</code>）终止。操作系统会回收进程所占用的资源，关闭文件、释放内存等。</li>
<li><strong>父子进程的终止</strong>：当子进程终止时，操作系统会向父进程发送信号（如 Unix 系统中的 <code>SIGCHLD</code>），父进程可选择等待子进程的终止并回收子进程资源。</li>
</ul>
<p><strong>5. 进程控制块（PCB）</strong></p>
<ul>
<li><strong>PCB（Process Control Block）</strong>：每个进程在操作系统中都有一个对应的 PCB，用于存储进程的状态、程序计数器、CPU 寄存器、内存信息等。</li>
<li><strong>进程调度</strong>：PCB 是进程调度和管理的核心数据结构，操作系统通过它来实现上下文切换和进程状态的转换。</li>
</ul>
<p>进程控制是操作系统的重要功能，涉及进程的创建、调度、同步、通信以及终止等方面。通过有效的进程控制，操作系统能够确保多任务环境下的进程按预期运行，资源得到合理分配。</p>
<h3 id="2-5-进程间调度"><a href="#2-5-进程间调度" class="headerlink" title="2.5 进程间调度"></a>2.5 进程间调度</h3><p>操作系统中的进程调度是管理CPU资源分配的一项重要功能。它决定了哪些进程何时运行，以及如何在多个进程间切换，以实现系统资源的高效利用和响应。</p>
<p><strong>常见的调度算法主要有：</strong></p>
<p><strong>1. 先到先服务（First-Come First-Served, FCFS）</strong></p>
<ul>
<li>简单且直观，进程按照到达顺序执行。</li>
<li><strong>优点</strong>：实现简单。</li>
<li><strong>缺点</strong>：容易导致长进程阻塞短进程（队头阻塞），可能增加平均等待时间。</li>
</ul>
<p><strong>2. 短作业优先（Shortest-Job-First, SJF）</strong></p>
<ul>
<li>优先执行预计运行时间最短的进程。</li>
<li><strong>优点</strong>：减少平均等待时间。</li>
<li><strong>缺点</strong>：需要准确预测进程运行时间，长作业可能会长期得不到调度（饥饿现象）。</li>
</ul>
<p><strong>3. 优先级调度算法（Priority Scheduling）</strong></p>
<ul>
<li>根据进程的优先级调度，优先级高的进程先执行。</li>
<li><strong>优点</strong>：灵活性高，可以根据需求调整优先级。</li>
<li><strong>缺点</strong>：低优先级进程可能会长期得不到调度（饥饿现象）。</li>
</ul>
<p><strong>4. 轮转调度（Round-Robin，RR）算法</strong></p>
<ul>
<li>每个进程分配一个固定的时间片，时间片到后切换到下一个进程。</li>
<li><strong>优点</strong>：公平，适用于时间共享系统。</li>
<li><strong>缺点</strong>：时间片过大或过小会影响系统性能。</li>
</ul>
<p><strong>5. 多级反馈队列调度算法（Multilevel Feedback Queue）</strong></p>
<ul>
<li>结合多个优先级队列和时间片调度。</li>
<li>进程根据其行为动态调整优先级和队列位置。</li>
<li><strong>优点</strong>：灵活性高，能够较好地平衡响应时间和系统吞吐量。</li>
</ul>
<p>通过这些调度算法，操作系统能够高效管理和分配CPU资源，保证系统的稳定性和用户体验。下面分别分析上述调度算法.</p>
<hr>
<h4 id="2-5-1-先到先服务（First-Come-First-Served-FCFS）"><a href="#2-5-1-先到先服务（First-Come-First-Served-FCFS）" class="headerlink" title="2.5.1 先到先服务（First-Come First-Served, FCFS）"></a>2.5.1 先到先服务（First-Come First-Served, FCFS）</h4><p><strong>先到先服务（First-Come, First-Served，FCFS）</strong> 是一种简单的进程调度算法，它的工作原理是：当进程到达系统时，它们被放入就绪队列。调度器选择队列中的第一个进程进行执行，直到该进程完成或发生阻塞事件，然后调度器选择下一个进程。</p>
<ul>
<li>优点：<ul>
<li>公平性（Fairness）：FCFS算法对所有进程都是公平的，因为它按照进程到达的顺序进行调度。</li>
<li>简单性（Simplicity）：FCFS算法非常简单和易于实现。</li>
</ul>
</li>
<li>缺点：<ul>
<li>无法充分利用CPU（Poor CPU Utilization）：如果当前正在运行的进程需要大量的I&#x2F;O操作，那么CPU可能会在等待I&#x2F;O操作完成时处于空闲状态。</li>
<li>平均等待时间可能较长（Long Average Waiting Time）：在FCFS算法中，短的进程可能会被长的进程阻塞，这种现象被称为“饥饿”（Starvation）或“拖尾效应”（Convoy Effect）。</li>
<li>无法支持优先级（Lack of Priority Support）：FCFS算法不支持优先级，因此无法保证重要的进程能够优先执行。</li>
</ul>
</li>
</ul>
<p>总的来说，虽然FCFS算法简单且公平，但由于其无法有效地利用CPU和支持优先级，所以在需要高效率或优先级调度的系统中，通常不会使用FCFS算法。</p>
<img src="/img/OS/fcfs.svg" srcset="/img/loading.gif" lazyload alt="先到先服务调度算法" style="max-width: 100%; height: auto;" />


<hr>
<p>在操作系统中，<strong>饥饿（Starvation）</strong> 是指某些进程长时间得不到所需资源，从而无法执行的情况。这通常发生在资源分配机制不公平或不完善的情况下。饥饿现象主要出现在以下几种情况下：</p>
<ul>
<li>优先级调度：在优先级调度算法中，如果某些低优先级的进程始终被高优先级进程抢占，低优先级进程可能会一直得不到执行机会，从而陷入饥饿状态。</li>
<li>资源竞争：当多个进程竞争有限的资源时，某些进程可能持续无法获得资源，导致无法继续执行。</li>
<li>长作业排队：在先到先服务（FCFS）或短作业优先（SJF）等调度算法中，长时间运行的进程可能会因其他短作业的持续到达而长期得不到调度。</li>
</ul>
<p>解决饥饿问题的一种常见方法是<strong>老化机制（Aging）</strong>，即逐渐提高长期未被调度进程的优先级，使其最终能够获得资源并执行。</p>
<hr>
<h4 id="2-5-2-短作业优先（Shortest-Job-First-SJF）"><a href="#2-5-2-短作业优先（Shortest-Job-First-SJF）" class="headerlink" title="2.5.2 短作业优先（Shortest-Job-First, SJF）"></a>2.5.2 短作业优先（Shortest-Job-First, SJF）</h4><p>在这种算法中，调度器选择就绪队列中预计运行时间最短的进程进行执行。预计运行时间可以是进程的CPU突发时间（CPU burst time）或者是进程的剩余执行时间。（这里就要看是非抢占式的还是抢占式的了，可以直观理解）</p>
<p>短作业优先调度算法的主要优点是它最小化了平均等待时间。因为短的进程总是优先于长的进程，所以它们的等待时间会更短，从而使得平均等待时间最小。</p>
<p>然而，这种算法也有一些缺点。首先，它需要知道进程的预计运行时间，但在实际的系统中，这通常是无法预知的。其次，这种算法可能会导致 <strong>“饥饿”（Starvation）</strong> 现象，即长的进程可能会被无限期地推迟，因为总是有短的进程到来。<br>总的来说，短作业优先调度算法在理论上是非常有效的，但在实际的系统中，由于需要预知进程的运行时间以及可能导致的饥饿问题，它的应用受到了一些限制。</p>
<img src="/img/OS/sjf.svg" srcset="/img/loading.gif" lazyload alt="短作业优先调度算法" style="max-width: 100%; height: auto;" />

<hr>
<h4 id="2-5-3-优先级调度算法（Priority-Scheduling）"><a href="#2-5-3-优先级调度算法（Priority-Scheduling）" class="headerlink" title="2.5.3 优先级调度算法（Priority-Scheduling）"></a>2.5.3 优先级调度算法（Priority-Scheduling）</h4><p>优先级调度算法是一种操作系统中的进程调度算法。在这种算法中，每个进程都有一个优先级，操作系统总是选择优先级最高的进程来运行。这种算法的主要特点如下：</p>
<ul>
<li>优先级：每个进程都有一个优先级，优先级高的进程优先执行。（抢占式，preemptive）</li>
<li>动态调整：系统可以根据需要动态调整进程的优先级。例如，为了防止低优先级的进程永远得不到执行，系统可能会随着时间的推移提高等待进程的优先级。</li>
<li>饿死问题：如果总是有新的高优先级进程出现，那么低优先级的进程可能永远得不到执行，这就是所谓的饿死问题。为了解决这个问题，系统可能会采取一些策略，比如老化（随着时间的推移提高等待进程的优先级）。</li>
</ul>
<p>这种算法在实时系统中特别有用，因为在这些系统中，有些任务（比如控制飞机的自动驾驶仪）比其他任务更重要，因此需要优先执行。但是，这种算法也有一些缺点，比如可能会导致低优先级的进程饿死。因此，设计一个好的优先级调度算法需要权衡各种因素。</p>
<img src="/img/OS/priority.svg" srcset="/img/loading.gif" lazyload alt="优先级调度算法" style="max-width: 100%; height: auto;" />

<hr>
<h4 id="2-5-4-轮转调度（Round-Robin，RR）算法"><a href="#2-5-4-轮转调度（Round-Robin，RR）算法" class="headerlink" title="2.5.4 轮转调度（Round-Robin，RR）算法"></a>2.5.4 轮转调度（Round-Robin，RR）算法</h4><p>轮转调度（Round-Robin，RR）算法是一种非常常见的操作系统进程调度算法。以下是对其的简要解释：</p>
<ul>
<li>时间片（Time Quantum）：在轮转调度算法中，每个进程被分配一个固定长度的时间片来执行。当一个进程的时间片用完时，它将被移出CPU，下一个进程将开始执行。</li>
<li>公平性（Fairness）：由于每个进程都有相同长度的时间片来执行，因此这种算法被认为是公平的。没有进程会因为优先级低而被饿死。<br>上下文切换（Context Switch）：当一个进程的时间片用完，操作系统需要进行上下文切换，将CPU从当前进程切换到下一个进程。这会产生一定的开销。</li>
<li>响应时间（Response Time）：轮转调度算法通常能提供良好的响应时间，因为每个进程都会定期得到CPU时间。</li>
</ul>
<p>这种算法适用于时间共享系统，但如果时间片设置得不合适，可能会导致过多的上下文切换，从而降低系统性能。因此，选择合适的时间片长度是实现轮转调度算法的关键。如果时间片过长，那么系统的响应时间可能会变差；如果时间片过短，那么上下文切换的开销可能会变大。</p>
<p>同一时刻两个进程 A 和 B, A 刚下处理机, B 刚进入队列, 默认 B 先轮转时间片。</p>
<ul>
<li>如果时间片太大, 退化为FCFS, 会增大进程响应时间</li>
<li>如果时间片太小, 进程切换频繁, 切换进程会花费大量时间</li>
</ul>
<p>一般来说, 设计时间片要让切换进程的开销占比不超过 1%</p>
<img src="/img/OS/rr.svg" srcset="/img/loading.gif" lazyload alt="轮转调度算法" style="max-width: 100%; height: auto;" />

<hr>
<h4 id="2-5-5-多级反馈队列调度算法（Multilevel-Feedback-Queue）"><a href="#2-5-5-多级反馈队列调度算法（Multilevel-Feedback-Queue）" class="headerlink" title="2.5.5 多级反馈队列调度算法（Multilevel Feedback Queue）"></a>2.5.5 多级反馈队列调度算法（Multilevel Feedback Queue）</h4><p>多级反馈队列调度算法（Multilevel Feedback Queue Scheduling）是一种操作系统中的进程调度算法。以下是对其的简要解释：</p>
<ul>
<li>多级队列（Multilevel Queues）：在这种算法中，存在多个队列，每个队列都有自己的优先级。优先级最高的队列中的进程首先得到执行。（也就是前一队列为空的时候，才能执行当前队列！！）</li>
<li>反馈（Feedback）：如果一个进程在其分配的时间片内没有完成，那么它将被移动到优先级较低的队列。这就是所谓的“反馈”机制。</li>
<li>公平性和灵活性（Fairness and Flexibility）：这种算法旨在结合优先级调度和轮转调度的优点，以实现公平性和灵活性。它可以确保高优先级的进程快速执行，同时也不会饿死低优先级的进程。</li>
<li>动态优先级（Dynamic Priorities）：进程的优先级不是固定的，而是可以根据其行为动态改变。例如，如果一个进程经常阻塞等待I&#x2F;O操作，那么它的优先级可能会提高，以便在I&#x2F;O操作完成后能够快速得到执行。</li>
</ul>
<p>这种算法在许多操作系统中都得到了应用，因为它既可以处理交互式进程（这些进程需要快速响应），也可以处理批处理进程（这些进程需要长时间运行）。然而，它的实现相对复杂，需要维护多个队列，并动态调整进程的优先级。此外，选择合适的队列数量和时间片长度也是一个挑战。如果设置不当，可能会导致某些进程得不到公平的CPU时间，或者系统的上下文切换开销过大。因此，实现这种算法需要权衡各种因素。</p>
<p>这个算法无明显缺点，但是会导致饥饿！考虑一种情况：长时间运行的进程一直被降级到低优先级队列，而新到达的高优先级进程源源不断地占用CPU资源，那么低优先级的进程可能会长期得不到调度，导致饥饿。</p>
<img src="/img/OS/multive_queue.svg" srcset="/img/loading.gif" lazyload alt="多级反馈队列调度算法" style="max-width: 100%; height: auto;" />

<h3 id="2-6-进程间通信"><a href="#2-6-进程间通信" class="headerlink" title="2.6 进程间通信"></a>2.6 进程间通信</h3><p>进程间通信（IPC，Inter-Process Communication）是操作系统中的一项重要机制，用于让不同进程之间交换数据或同步操作。操作系统提供了多种进程间通信方式，每种方式有其特点和适用场景。以下是几种常见的进程间通信方式的详细讲解：</p>
<h4 id="2-6-1-管道（Pipe）"><a href="#2-6-1-管道（Pipe）" class="headerlink" title="2.6.1 管道（Pipe）"></a>2.6.1 管道（Pipe）</h4><p>管道是一种最基本的进程间通信方式，允许数据在一个进程与另一个进程之间单向流动。它适用于父子进程之间的通信。</p>
<ul>
<li><strong>匿名管道（Anonymous Pipe）</strong>：不具备名字，一般用于有亲缘关系的进程（如父子进程）。匿名管道是半双工的，即数据只能单向流动。</li>
<li><strong>命名管道（Named Pipe）</strong>：有名字，可以在无亲缘关系的进程间使用，因此适用于不同进程间的通信。命名管道是全双工的，即可以双向传输数据。</li>
</ul>
<img src="/img/OS/pipe.svg" srcset="/img/loading.gif" lazyload alt="管道通信" style="max-width: 100%; height: auto;" />

<h4 id="2-6-2-消息队列（Message-Queue）"><a href="#2-6-2-消息队列（Message-Queue）" class="headerlink" title="2.6.2 消息队列（Message Queue）"></a>2.6.2 消息队列（Message Queue）</h4><p>消息队列是由内核维护的一种数据结构，用于在进程间传递消息。消息队列中的消息按照优先级或发送顺序排队，可以支持多个进程进行通信。</p>
<ul>
<li>消息队列是一种基于消息的通信机制，可以支持多对多的通信模式。</li>
<li>通过消息队列，进程可以通过发送消息和接收消息来进行数据交换。</li>
<li>它的优势是，进程间通信不需要共享内存，但也会有一定的性能开销。</li>
</ul>
<img src="/img/OS/message.svg" srcset="/img/loading.gif" lazyload alt="消息队列" style="max-width: 100%; height: auto;" />

<h4 id="2-6-3-共享内存（Shared-Memory）"><a href="#2-6-3-共享内存（Shared-Memory）" class="headerlink" title="2.6.3 共享内存（Shared Memory）"></a>2.6.3 共享内存（Shared Memory）</h4><p>共享内存是一种效率较高的进程间通信方式，多个进程可以直接访问同一块内存区域。一个进程创建并映射这块共享内存，其他进程可以直接访问该内存区域。</p>
<ul>
<li>共享内存允许多个进程共享数据，因此可以显著提高进程间的数据交换效率。</li>
<li>但由于多个进程可能同时读写共享内存，必须通过信号量等同步机制来保证数据一致性，避免竞争条件和冲突。</li>
</ul>
<h4 id="2-6-4-信号量（Semaphore）"><a href="#2-6-4-信号量（Semaphore）" class="headerlink" title="2.6.4 信号量（Semaphore）"></a>2.6.4 信号量（Semaphore）</h4><p>信号量是一种同步工具，通常用于控制多个进程对共享资源的访问。信号量内部包含一个计数器，该计数器控制访问共享资源的进程数目。</p>
<ul>
<li>信号量常用于控制对共享内存、文件等资源的访问，它可以防止资源竞争。</li>
<li>信号量有两种类型：<strong>计数信号量</strong>（控制资源的数量）和<strong>二值信号量</strong>（类似于锁，只允许一个进程访问资源）。</li>
<li>信号量通常与共享内存结合使用，用于保证对临界区的同步和互斥。</li>
</ul>
<h4 id="2-6-5-信号（Signal）"><a href="#2-6-5-信号（Signal）" class="headerlink" title="2.6.5 信号（Signal）"></a>2.6.5 信号（Signal）</h4><p>信号是一种异步通知机制，用于向进程发送通知，告知其某个事件已经发生。例如，操作系统可以向进程发送 <code>SIGINT</code> 信号来中断它，或者使用 <code>kill</code> 命令向一个进程发送信号。</p>
<ul>
<li>信号是一种非常轻量级的进程间通信方式，适用于通知进程发生了某种事件或请求处理。</li>
<li>信号通常不会携带大量数据，主要用于进程间的控制和通知。</li>
</ul>
<h4 id="2-6-6-套接字（Socket）"><a href="#2-6-6-套接字（Socket）" class="headerlink" title="2.6.6 套接字（Socket）"></a>2.6.6 套接字（Socket）</h4><p>套接字是一种广泛用于进程间通信的机制，尤其适用于不同主机之间的通信。通过网络协议，套接字允许不同机器上的进程进行通信。</p>
<ul>
<li>套接字不仅可以用于不同主机间的进程间通信，也可以用于本地主机上的进程间通信。</li>
<li>套接字可以是<strong>面向连接的</strong>（如 TCP 套接字）或<strong>无连接的</strong>（如 UDP 套接字），适用于不同的应用场景。</li>
<li>它是进程间通信中最为通用和灵活的一种方式，尤其在分布式系统中具有重要作用。</li>
</ul>
<hr>
<p>总的来说，这些通信方式有下面的应用场景。</p>
<ul>
<li><strong>管道</strong>适用于父子进程的单向通信。</li>
<li><strong>消息队列</strong>适合需要按消息传递数据的多进程场景。</li>
<li><strong>共享内存</strong>提供高效的跨进程数据共享，但需要同步机制来保证数据一致性。</li>
<li><strong>信号量</strong>用于控制对共享资源的访问，并且用于进程间的同步与互斥。</li>
<li><strong>信号</strong>是一种简单的异步通信机制，用于进程间的通知。</li>
<li><strong>套接字</strong>是最通用的进程间通信机制，尤其在网络编程中得到广泛应用。</li>
</ul>
<h3 id="2-7-进程间同步互斥"><a href="#2-7-进程间同步互斥" class="headerlink" title="2.7 进程间同步互斥"></a>2.7 进程间同步互斥</h3><p>标志检查算法，信号量机制，经典互斥问题。</p>
<h3 id="2-8-死锁"><a href="#2-8-死锁" class="headerlink" title="2.8 死锁"></a>2.8 死锁</h3><p>概念，银行家算法…</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%A7%91%E7%9B%AE%E7%AC%94%E8%AE%B0/" class="category-chain-item">专业科目笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%BF%AE%E8%80%83/" class="print-no-link">#修考</a>
      
        <a href="/tags/Computer-Architecture/" class="print-no-link">#Computer Architecture</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Operating System</div>
      <div>http://toutou.zeabur.app/2024/12/11/Operation-System/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>toutou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 11, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/10/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A62024%E5%B9%B4%E5%86%AC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90-%E6%83%85%E6%8A%A5%E7%94%9F%E5%91%BD/" title="东北大学2024年冬计算机组成_问题5">
                        <span class="hidden-mobile">东北大学2024年冬计算机组成_问题5</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://www.instagram.com/hanni_rio/" target="_blank" rel="nofollow noopener"><span>Hanni Rio</span></a> <i class="iconfont icon-copyright"></i> <a href="https://toutou.zeabur.app" target="_blank" rel="nofollow noopener"><span>toutou</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
